{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/123.png","path":"123.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/1926.png","path":"1926.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gallery.css","path":"css/gallery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/cursor.js","path":"js/cursor.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/gallery-encrypt.js","path":"js/gallery-encrypt.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/snow.js","path":"js/snow.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/2.png","path":"medias/2.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","path":"medias/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"source/galleries/2020/0.jpg","path":"galleries/2020/0.jpg","modified":0,"renderable":0},{"_id":"source/galleries/test/0.jpg","path":"galleries/test/0.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"source/galleries/serect/images/lock.jpg","path":"galleries/serect/images/lock.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/16.jpg","path":"galleries/2020/images/16.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/22.jpg","path":"galleries/2020/images/22.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/21.jpg","path":"galleries/2020/images/21.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/2.jpg","path":"galleries/2020/images/2.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/23.jpg","path":"galleries/2020/images/23.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/3.jpg","path":"galleries/2020/images/3.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/5.jpg","path":"galleries/2020/images/5.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/7.jpg","path":"galleries/2020/images/7.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/8.jpg","path":"galleries/2020/images/8.jpg","modified":0,"renderable":0},{"_id":"source/galleries/test/images/13.jpg","path":"galleries/test/images/13.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/jquery.fancybox.css","path":"libs/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.css","path":"libs/justifiedGallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.js","path":"libs/justifiedGallery/justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"source/galleries/2020/images/0.jpg","path":"galleries/2020/images/0.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/1.jpg","path":"galleries/2020/images/1.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/10.jpg","path":"galleries/2020/images/10.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/11.jpg","path":"galleries/2020/images/11.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/13.jpg","path":"galleries/2020/images/13.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/15.jpg","path":"galleries/2020/images/15.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/18.jpg","path":"galleries/2020/images/18.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/17.jpg","path":"galleries/2020/images/17.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/19.jpg","path":"galleries/2020/images/19.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/20.jpg","path":"galleries/2020/images/20.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/4.jpg","path":"galleries/2020/images/4.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/6.jpg","path":"galleries/2020/images/6.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/9.jpg","path":"galleries/2020/images/9.jpg","modified":0,"renderable":0},{"_id":"source/galleries/test/images/12.jpg","path":"galleries/test/images/12.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/js/crypto-js.js","path":"js/crypto-js.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/fancybox.js","path":"libs/fancybox/fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"source/galleries/serect/images/15.jpg","path":"galleries/serect/images/15.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/14.jpg","path":"galleries/2020/images/14.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/12.jpg","path":"galleries/2020/images/12.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/10.jpg","path":"medias/featureimages/原始图片/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/13.jpg","path":"medias/featureimages/原始图片/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/15.jpg","path":"medias/featureimages/原始图片/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/16.jpg","path":"medias/featureimages/原始图片/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/2.jpg","path":"medias/featureimages/原始图片/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/21.jpg","path":"medias/featureimages/原始图片/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/22.jpg","path":"medias/featureimages/原始图片/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/23.jpg","path":"medias/featureimages/原始图片/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/3.jpg","path":"medias/featureimages/原始图片/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/7.jpg","path":"medias/featureimages/原始图片/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/5.jpg","path":"medias/featureimages/原始图片/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/8.jpg","path":"medias/featureimages/原始图片/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"source/galleries/test/images/cover/13.jpg","path":"galleries/test/images/cover/13.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/my404/bodymovin.js","path":"libs/my404/bodymovin.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/0.jpg","path":"medias/featureimages/原始图片/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/11.jpg","path":"medias/featureimages/原始图片/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/20.jpg","path":"medias/featureimages/原始图片/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/18.jpg","path":"medias/featureimages/原始图片/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/17.jpg","path":"medias/featureimages/原始图片/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/19.jpg","path":"medias/featureimages/原始图片/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/4.jpg","path":"medias/featureimages/原始图片/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/6.jpg","path":"medias/featureimages/原始图片/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/9.jpg","path":"medias/featureimages/原始图片/9.jpg","modified":0,"renderable":1},{"_id":"source/galleries/test/images/cover/12.jpg","path":"galleries/test/images/cover/12.jpg","modified":0,"renderable":0},{"_id":"source/galleries/2020/images/cover/p0.jpg","path":"galleries/2020/images/cover/p0.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/1.jpg","path":"medias/featureimages/原始图片/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/12.jpg","path":"medias/featureimages/原始图片/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/my404/data.js","path":"libs/my404/data.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/14.jpg","path":"medias/featureimages/原始图片/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"0e8bb4c7cce552e079a6c857acc8aa8ae18636a8","modified":1628588941651},{"_id":"source/404.md","hash":"df93abe9e7a0ef09fbd4ab0d64a35653e5798de7","modified":1597282950000},{"_id":"themes/hexo-theme-matery/README.md","hash":"17bc69b0792b06a2eafde5174bd4f122917f690d","modified":1591088916000},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1591088916000},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"14bf70dade027765924cbc5db2f68366b7efe052","modified":1591088916000},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"5340c994462c7345373e075529f40e60c1952f00","modified":1591088916000},{"_id":"source/robots.txt","hash":"aa444ef5779825885f01306f8ff66819fb45739f","modified":1599890768000},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"1069142a4a98e221cfd3e3b24366f37a849418ee","modified":1619744992823},{"_id":"source/_posts/2012-941.md","hash":"20499d830ddde7337e641f05710fa9d830200bbd","modified":1602069224000},{"_id":"source/_posts/2013-941.md","hash":"7d09f630d800f69782a0447561311e00e6c8c23b","modified":1601189246000},{"_id":"source/_posts/.DS_Store","hash":"33742df06356e0f597ffdffd62f986f5088b165c","modified":1628244353555},{"_id":"source/_posts/2014-941.md","hash":"89e539b18c63f88c2cc2bd67ad7c576b40d919ce","modified":1601019088000},{"_id":"source/_posts/2015-941.md","hash":"f2fafa685fdc66ce236b10ff85300f54e9909db0","modified":1600847536000},{"_id":"source/_posts/2016-941.md","hash":"22abce94027a0cd73b15940fc0645ee471936c3d","modified":1600777398000},{"_id":"source/about/index.md","hash":"c0c5e90b5ea1cc89e2ddb57bc0048e238f3df741","modified":1591092442000},{"_id":"source/_posts/2017-941.md","hash":"530982809a156abfcb547f46af9ca5cdbada1b8d","modified":1600525914000},{"_id":"source/_posts/2020吉林大学心理学拟录取名单.md","hash":"44569e76d6b214f8438c21fe585d516453f98f1f","modified":1597045876000},{"_id":"source/_posts/2018-941.md","hash":"68b1ca347844fc0b78413478ac3f8f614dcb020c","modified":1602069386000},{"_id":"source/_posts/7月份学习计划.md","hash":"6d7a49e8f146f4ecd7ec9b46dedaf5a9269bd45f","modified":1597054696000},{"_id":"source/_posts/2018-979.md","hash":"08046dd4115f171a3571f59fa5e47d46661a8b5e","modified":1619427943249},{"_id":"source/_posts/9月8号计划.md","hash":"948893a82daaab4633007f62b0dac46bfe3f36e4","modified":1599479668000},{"_id":"source/_posts/5-7-5-16学习记录.md","hash":"8c7c9e4b4f15fc08cb043fa5beb4af93eb73bf04","modified":1621228812035},{"_id":"source/_posts/8-17学习记录.md","hash":"f59eff63db47248d688cf96259016d5a30571e46","modified":1629258369000},{"_id":"source/_posts/SimCSE（一）.md","hash":"d02d8754a638690ab856686f41a59ca3b4978667","modified":1619593007049},{"_id":"source/_posts/SimCSE完成情况.md","hash":"e6218fae150cca64f46650af89f1ba4a825dff71","modified":1621228828500},{"_id":"source/_posts/SimCSE（七）.md","hash":"0deaabc5d6580be5dd4a6067158a301e88fea8f6","modified":1620113667090},{"_id":"source/_posts/SimCSE（三）.md","hash":"c84f9d09fe9b0434fd8242c5e4550b0a4f3fabc0","modified":1619592795825},{"_id":"source/_posts/SimCSE（九）.md","hash":"b37de9fa247ba87347615fc23c440a4e5c2e17d8","modified":1620200657385},{"_id":"source/_posts/SimCSE（二）.md","hash":"f6327fea9d207ebe3ff0f99c5cc5f0cd3dd368ee","modified":1619593040723},{"_id":"source/_posts/SimCSE（五）.md","hash":"9e7fb2bc992cf0775026f0bb02461ed7472c70b4","modified":1619681948077},{"_id":"source/_posts/SimCSE（十）.md","hash":"7fa2e30bb3a4b9e9b0cc3feeab25d824ede99f45","modified":1620305370803},{"_id":"source/_posts/SimCSE（八）.md","hash":"22efd52a964d13bfa964d82224535b3d95c40b86","modified":1620113811277},{"_id":"source/_posts/SimCSE（六）.md","hash":"351597ca131729d78ab0c66aef343c8129b870ff","modified":1619763182000},{"_id":"source/_posts/SimCSE（四）.md","hash":"1b1eaa61ffef78dfa5f0ffe2c7a59a0c6482a876","modified":1619592373335},{"_id":"source/_posts/八月份学习计划.md","hash":"baf00afa13e252742220abcfb8ea253e2761017c","modified":1600522510000},{"_id":"source/_posts/tensorflow（一）.md","hash":"f18c9f124523d7f13ad46ed28dde4eab10bcd47b","modified":1620389211109},{"_id":"source/_posts/前端设计原稿.md","hash":"8c70f4bf8c99d9c0cfb41f55f185a2d677f3aed2","modified":1621238702656},{"_id":"source/_posts/吉林大学招生简章.md","hash":"51b3b34312f1fe91de9260eed9ded7f6564f01e5","modified":1597045876000},{"_id":"source/_posts/后台部署.md","hash":"e3481aa83bba6c921185ec8d9994f9a78a73cd83","modified":1621228738920},{"_id":"source/_posts/图相关代码.md","hash":"4b8fbffd16ea73fbaa718501152552bb73d59796","modified":1602069176000},{"_id":"source/_posts/基础通信.md","hash":"29d2631a5dadf059a8e2ba8bd76e98b74cff9df2","modified":1597045876000},{"_id":"source/_posts/学习计划.md","hash":"94c8635b464a60177cbd7129ea28f380d0abc42e","modified":1597062882000},{"_id":"source/_posts/强化-计网第三章-数据链路层.md","hash":"8958e2eda72de07fe75abdc4b8be3586ef00cb1f","modified":1601044446000},{"_id":"source/_posts/强化-计网第二章-物理层.md","hash":"2eec0e90b17b0352dd0384c80b47426b3c8167b9","modified":1600688562000},{"_id":"source/_posts/每日一题7-27.md","hash":"bbce9c1294cb84363475fff6f02f6064e236578a","modified":1597045876000},{"_id":"source/_posts/强化计网第一章-概述.md","hash":"ec4eb7acd813396f12b00c37d1916019d4266d66","modified":1600168746000},{"_id":"source/_posts/微博爬虫功能.md","hash":"7104cbe6fc8b3ffe9a3fefb7e15c682f96dbbd76","modified":1621229622223},{"_id":"source/_posts/排序算法.md","hash":"119b26a81cafc336e71187b4e3fd01aaab5931ec","modified":1600422262000},{"_id":"source/_posts/树相关代码.md","hash":"ea4bcfdc5744bfb70dac1d963c0f2fb451e91aef","modified":1599889468000},{"_id":"source/_posts/每日一题7-28.md","hash":"9dc575ea947aa1c5049d91b38e57e0c8c34974fd","modified":1597045876000},{"_id":"source/_posts/每日一题7-29.md","hash":"80120dfd399ca6656e985105c7f5ab99b7239c86","modified":1597045876000},{"_id":"source/_posts/物理层.md","hash":"f7487a453b601d1b164be06f588a328d4da125fb","modified":1597045876000},{"_id":"source/_posts/每日一题8-3.md","hash":"6e37156046574df1ceb0e09875613a71090ede6d","modified":1597054878000},{"_id":"source/_posts/笔迹识别（二）.md","hash":"f72ee4c568a5cbb4eea5757e2332d020c69f8901","modified":1629345925187},{"_id":"source/_posts/第一次测试.md","hash":"02ad6e97b6e9b4f8a6043020b0c3142933a635ce","modified":1597045876000},{"_id":"source/_posts/线性表代码.md","hash":"9fe20169710bb879883dc54c967a8046e1af943f","modified":1598347528000},{"_id":"source/_posts/艾宾浩斯背单词.md","hash":"69c339ba950e6a83676759c3af48f62c6e7b15b8","modified":1597045876000},{"_id":"source/_posts/菁菁学习计划.md","hash":"39c5d720d5c720e822bb5f0a3a2f84ff476a194c","modified":1597062886000},{"_id":"source/_posts/爬虫数据库bug.md","hash":"e0006522e86ed13772ea15e0b54fcfd6f594ca12","modified":1621229993591},{"_id":"source/_posts/爬虫部署.md","hash":"38864ba4d264a959a0cdd82b8c642aaac1836be3","modified":1621228746879},{"_id":"source/_posts/计网第一章-概述.md","hash":"0b55d5afee9794e6d40fda9be9c7b7ecca3ad1cc","modified":1597045876000},{"_id":"source/_posts/计网第七章-局域网和广域网技术.md","hash":"83f6e6d93f5844da1239d5f11df7e07c4063ded5","modified":1597991076000},{"_id":"source/_posts/计网第五章-网络层.md","hash":"df9ff13e216b2911d0ff7c84b1c4ea6ccd0b864b","modified":1597061960000},{"_id":"source/_posts/计网第八章-TCP-IP协议.md","hash":"e68e83f62c79b32ededc966cabef0d64a51c4824","modified":1598361014000},{"_id":"source/_posts/计网第六章-传输层.md","hash":"9510ffbba5eef85b8f219521d09ad43b52fc1bfa","modified":1599552690000},{"_id":"source/_posts/计网第四章-数据链路层.md","hash":"0cb22230cb3d78a04e23b4ed55680ff28d34ca3d","modified":1597045876000},{"_id":"source/_posts/链表代码.md","hash":"40ceb97fa6eb668c0f4117c71e20cd301ccd1d83","modified":1598795218000},{"_id":"source/categories/index.md","hash":"27751321f880c08de5562b5a84d7a8f980def63b","modified":1591092378000},{"_id":"source/_posts/高数第一讲总结.md","hash":"08fa222dcf4e05f7b6f3fdb8543f7a4156e90bb7","modified":1597045876000},{"_id":"source/contact/index.md","hash":"543e39afa39588a1c4cec1a9060dcf19fb8f2c2d","modified":1591092478000},{"_id":"source/friends/index.md","hash":"2be114a59665f3f4e39e39e1db1173e98d7b84c4","modified":1591092506000},{"_id":"source/_data/galleries.json","hash":"735f5f8a8a26c12c517ce73c4ac04bcb42a189ac","modified":1591168376000},{"_id":"source/_data/friends.json","hash":"8b454e8017b9fe5f257c8c75c5a39666198bf99d","modified":1591092568000},{"_id":"source/galleries/index.md","hash":"e6826b7a7674a9ecb0eabe6a773361930bd48848","modified":1591167164000},{"_id":"source/tags/index.md","hash":"0eca48c8f4b4f84e1a964d10d5269e043a8751ac","modified":1591092406000},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"9baf9370d0d7494e8575934e4bd0fa6d24484052","modified":1591088916000},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"13ce732a54ce08b0ca01f14fd09cbe8fc418de21","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/404.ejs","hash":"aa3f930ce4c475664df9eb283ca76974e3e4c276","modified":1597301998000},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"88e23163aae5dff7a2e7050f55c3754f0e76ae68","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"57733d52d17361e735fcc95f875e0b1b9ebdcbd8","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"4ac716d15d84e7c37f07308a5ec008a2ac090c9b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"e9716a948172e6ad46c18cc7e78770cdc46f1857","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"3cabb8e3680858c1412277def37bdef73981be0f","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/contact.ejs","hash":"72fb5af3fc2f8955e2eb10926bbe4532a04ccd1b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"3783bb4d7807e3a3701d67499a878c69a0a872d6","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"058eb27ff10f5314d8b9e334c54419b9a6572315","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/galleries.ejs","hash":"a3c2f9935092344eaa09f6039f4a77c38a914aac","modified":1591189024000},{"_id":"themes/hexo-theme-matery/source/123.png","hash":"bc8b87f6cca89ad6e4948f126cda3ad0118602e0","modified":1598164468000},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"597cc049c9669b081b5ba8c67c084016dbc3e1f6","modified":1594699998000},{"_id":"themes/hexo-theme-matery/source/1926.png","hash":"7fe3f65c530251ca1302a7082ad592491d9d5ac6","modified":1598164696000},{"_id":"themes/hexo-theme-matery/layout/gallery.ejs","hash":"b171427b81b1463eedd95c6977c7e79abc3b5ef7","modified":1591166328000},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1591088918000},{"_id":"source/_posts/SimCSE（一）/拟合对比.png","hash":"ade4e63775a1475dbbc8576577ae658e44aea985","modified":1619490090686},{"_id":"source/_posts/SimCSE（一）/拟合图片.jpeg","hash":"350914236a057a25bf4b38cfb7dc76b1b913a531","modified":1619488114380},{"_id":"source/_posts/SimCSE（三）/对比表示学习.webp","hash":"32f4d8e690c48e9a85225d6a80647d7739f54e64","modified":1619576860189},{"_id":"source/_posts/SimCSE（六）/Table 3.png","hash":"9b1b72884ae7040b59126e8aa3e72bf9c9bcee18","modified":1619750421903},{"_id":"source/_posts/SimCSE（六）/Table 4.png","hash":"84e62bea77dcb9bae68c22cfd8921613e215dc94","modified":1619750643271},{"_id":"source/_posts/SimCSE（四）/.DS_Store","hash":"56f308098f360f1f57d6db49d5d037c7e930cff5","modified":1619591098066},{"_id":"source/_posts/SimCSE（四）/001-surprise.png","hash":"df1017e79115d555acb6c20e92dedb943725d3e1","modified":1619579243386},{"_id":"source/_posts/SimCSE（十）/拟合对比.png","hash":"ade4e63775a1475dbbc8576577ae658e44aea985","modified":1619490090686},{"_id":"source/_posts/tensorflow（一）/下载1.png","hash":"ebb490ea5075c9d2635fae75321de407a0484a6d","modified":1620385036518},{"_id":"source/_posts/tensorflow（一）/.DS_Store","hash":"45a2384eeb70e224ab82e7a4bb8af4a78ffa79c7","modified":1620389235692},{"_id":"source/_posts/tensorflow（一）/下载2.png","hash":"96b38facb940591ef365e1d99fb0129510d4e61e","modified":1620385043972},{"_id":"source/_posts/吉林大学招生简章/学硕.png","hash":"cd78beb919d1f0890805ef1b72be62e07e13478f","modified":1591190956000},{"_id":"source/_posts/吉林大学招生简章/专硕.png","hash":"3f6cc9638d1008fdc17fdaf7a9ac21fbb33d3bec","modified":1591190970000},{"_id":"source/_posts/吉林大学招生简章/计算机专硕.png","hash":"1853a4b13e59f1ec2bb8b478f78f3cbb457882b4","modified":1591191580000},{"_id":"source/_posts/吉林大学招生简章/计算机学硕2.png","hash":"06fa26541b12b7f2183a75db465d6297c0b65c6b","modified":1591191564000},{"_id":"source/_posts/强化-计网第二章-物理层/FSK.png","hash":"ac413c0abe1af8b4bddb0349460cd718adc92def","modified":1600427838000},{"_id":"source/_posts/强化-计网第二章-物理层/PSK.png","hash":"486e4edfcd32d452203563c7e8a38717f3a3ae0f","modified":1600427864000},{"_id":"source/_posts/强化-计网第二章-物理层/单极性编码.png","hash":"3e1fc255c87b089e7215ad9c47e8661a37c2c510","modified":1600427194000},{"_id":"source/_posts/强化-计网第二章-物理层/ASK.png","hash":"9064448e487e8e86a72c826398410d7f3cb1ac30","modified":1600427822000},{"_id":"source/_posts/强化-计网第二章-物理层/QAM.png","hash":"a37b4f7c9209baa4659b6e7085b1a2a3dfed217b","modified":1600427908000},{"_id":"source/_posts/强化-计网第二章-物理层/非归零编码.png","hash":"bc6c4a1125794f5e901ab88a6aeb0c152e15c134","modified":1600427154000},{"_id":"source/_posts/计网第七章-局域网和广域网技术/img2.png","hash":"6f0da5a3255d4fcd96798a975420cc9d0e468984","modified":1597240196000},{"_id":"source/_posts/计网第七章-局域网和广域网技术/img.png","hash":"1ed58176ace712ebcb350cd4f38cde8d07345fe1","modified":1597238116000},{"_id":"source/_posts/计网第八章-TCP-IP协议/B类子网编码.png","hash":"e7cbc020d5dcfde2afc669a6b80b3418358a6ca5","modified":1598356256000},{"_id":"source/_posts/计网第八章-TCP-IP协议/IP地址范围.png","hash":"bc822cfc18f0dab6fd6d216605078f78a6153abb","modified":1598350656000},{"_id":"source/_posts/计网第八章-TCP-IP协议/ip地址分类.png","hash":"3e979cba0042bf99d365c98f62797252760483e2","modified":1598097724000},{"_id":"source/_posts/计网第八章-TCP-IP协议/IP报文格式.png","hash":"d7f64bcf781a9cceb7c382b976640ad02c25ed86","modified":1598351580000},{"_id":"source/galleries/2020/index.md","hash":"fe9db3134f89a453f5c348d6d72943927573a2f6","modified":1591167848000},{"_id":"source/galleries/个人生活/index.md","hash":"3ebcc1f41ade8da966854f1415c339a264221b03","modified":1591168406000},{"_id":"source/galleries/test/index.md","hash":"10cce90efad69fab7e0a794342e2e7607af44f9d","modified":1591167984000},{"_id":"source/galleries/serect/index.md","hash":"238f66e78d3c498d6a981d5d2cdcc8904a7f5f72","modified":1591168394000},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"be527741c39c9dc4a13ad712b49fe8db0147fe1e","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"4b01030b7136192bdbd704e29a0fe12f92767551","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2841870e0c625787de348221e5ddb7bbe99ec5a2","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"58a7a07f8ab81ecc19a78d897955ca1ad73defb3","modified":1591194254000},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"1b392f2160f962f62f3ddf5e1155c7f2f4888e1d","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"27764936791ce36b527bea63689435346bbfb425","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"90888c945384aa1ee4650bd43bd7ea670f25828c","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"4bcdbd27273dd1b7098d4cfa6479b5d6b138cd12","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"6dc2522bc03b65d0b421a643b21a78a59c8213c1","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/minivaline.ejs","hash":"68085770dc09d71c14d323dff940fe6c1826ba76","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"8ce2974b19765e1f05d935a4f18abf7c84a980da","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"5a2179a9a3de6f56b0aaa154a11919b8f34fcbf9","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"d8773abab5d0b672b70a9df20a8f9f7f6b0a2dae","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"7f583c935253e2bf6421791715ee9de4989add6e","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"868ba6e0107b57000637b4f87881dbfacdf54fd1","modified":1597281988000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"8ad8a7ec3f6438af496c51fd6bef1684e158a9ef","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"de0d5763ddd64463f43135678b64c044884b8406","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"908ddab5b5d5662c50b46ada0e03e06fe0a6c310","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"ae24615ac88719139b57a4709b096c81e1a64d5a","modified":1597053466000},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"f67bc52bc5a2464ebe30f42c65c0ee38eeec2fda","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"1afa71b003c16fe1f17389ef9a84c7044b7ac362","modified":1597051622000},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"f1d9d245932fde9cb5365acec8fbf8e76b93e215","modified":1597061238000},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"90c2ab31492f8226454537d6b987e9399119047d","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"c5f1a2de30363f370c8c37994140d6ef4fd0c4b7","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"e50fae64b6cfdbed18861eb49eca5018a920c7a4","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"f640583d45179abc1ef57951e7f61fb9e10f44c9","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"3ef458166041a8a12e493cc5963a5af5d98c1dfc","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"131e2eabf6b216210efd0746300889adfee357be","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"d6692f8c81013191fce59f47df1b6171649181ca","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"8fc0e6172abbed7084b06e3ed637ad37e2752c48","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"f5259f18a906f2862fe72b90c28125b5f6b7d0b1","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"141f19a8aa41b7a21436f23ce114bd5fda932512","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"9edbeb1ec6212762d597ae7a05b5a219f72c8f98","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"fb5ee7674070956d134ddca6890a9bd3f398cc0f","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"20f0b6155eee348276dd91790f6a52b1005a0518","modified":1591088916000},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"416f2f47f34df031fe4eef050fc21a2de06fdb83","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"d32898104477acef56c33d00a68b48db15dcf2e6","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"db62ecc8bfa16222b8080b5f624b856e6267554d","modified":1599893640000},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"03dcd0a7a9fdbcc2bc38a99a8fad96ae17a340fa","modified":1591088918000},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"6eaab5fccff9ad69d1d877a0f0585e2fcb89ba52","modified":1591088918000},{"_id":"themes/hexo-theme-matery/scripts/helpers/encrypt.js","hash":"7d0ff9a889846fb55b4e3730187e4b6fc07a4bf1","modified":1591165996000},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/css/gallery.css","hash":"47a7ceb6cce120cc632201383d0f122128f6b2a7","modified":1591107790000},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"8f173e67b23205a3baf468f1f2d7713c7579f800","modified":1591170144000},{"_id":"themes/hexo-theme-matery/source/js/cursor.js","hash":"d22c22398f5dd0d273a98031515821587c32fdcf","modified":1591168622000},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"ddfef10e80a09b8efb48c52ede773e71d5890c78","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/js/gallery-encrypt.js","hash":"4ba874f9507602a571dfd38367a69e6154faf935","modified":1591169846000},{"_id":"themes/hexo-theme-matery/source/js/snow.js","hash":"711b6fe8bca5c8a45732901dff7fae0082e9f812","modified":1591098084000},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/2.png","hash":"342759d8f8bc25491d6ba5e865de2bcd02a4a985","modified":1591095466000},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1591088918000},{"_id":"source/_posts/SimCSE（六）/Figure 2.png","hash":"1fbf82c0bb59931035d6c1807cf34d5db58f819b","modified":1619751039932},{"_id":"source/_posts/SimCSE（六）/Table 2.png","hash":"b073cfe77432bcb540a9943782b56a17f1db6af0","modified":1619750037148},{"_id":"source/_posts/SimCSE（六）/Table 5.png","hash":"7ca1b25e1749f59db183527ac6f44f68347bf5f6","modified":1619756323253},{"_id":"source/_posts/SimCSE（四）/Unsupervised SimCSE.png","hash":"d9a3d0c1014ea23cc2aec9c9130bf81c34292083","modified":1619587071381},{"_id":"source/_posts/吉林大学招生简章/计算机学硕1.png","hash":"47be7240a692215f98d87c4a49fe8b49a6f96b01","modified":1591191528000},{"_id":"source/_posts/强化-计网第二章-物理层/曼彻斯特.png","hash":"9fc2f5c9639235a866c4b99de45a83f4f4e855a7","modified":1600427248000},{"_id":"source/_posts/菁菁学习计划/2.png","hash":"7958ba1aa02ecc910f2b16447aacf3ae52bec2a2","modified":1591597000000},{"_id":"source/_posts/菁菁学习计划/1.png","hash":"e3bd9199976b029443e186fc6a491406ea424b07","modified":1591596984000},{"_id":"source/galleries/2020/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1591088918000},{"_id":"source/galleries/test/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"97c06820a14aa7ec9ad201fd81ec88aeb5b9c95f","modified":1619763599000},{"_id":"source/_posts/SimCSE（一）/dropout.jpeg","hash":"f1349c4e39b7980b1acb7823daa73126c67dbc81","modified":1619491216977},{"_id":"source/_posts/SimCSE（十）/dropout.jpeg","hash":"f1349c4e39b7980b1acb7823daa73126c67dbc81","modified":1619491216977},{"_id":"source/_posts/tensorflow（一）/模型情况.png","hash":"b43ec15731e5ecf6e95e93c784dd709c250a3561","modified":1620386246707},{"_id":"source/galleries/serect/images/lock.jpg","hash":"4fbda18ce7047d6ba74316ff8ed27446d7bdb9ed","modified":1591167050000},{"_id":"source/galleries/2020/images/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1591088918000},{"_id":"source/galleries/2020/images/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1591088918000},{"_id":"source/galleries/2020/images/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1591088918000},{"_id":"source/galleries/2020/images/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1591088918000},{"_id":"source/galleries/2020/images/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1591088918000},{"_id":"source/galleries/2020/images/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1591088918000},{"_id":"source/galleries/2020/images/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1591088918000},{"_id":"source/galleries/2020/images/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1591088918000},{"_id":"source/galleries/2020/images/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1591088918000},{"_id":"source/galleries/test/images/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"d2569ef80127ed2f4af7ef4d9f82b037794eec69","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"8f53dbd5f9a40c377664bf8ca0d5d5ed75b91757","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"a8133367d48199e7505c2d831ca848b4202b9ba6","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6ab7871d36cab438bbd4d781bc1fe7618b46b6e7","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"066d2c89ad429e44f6467b9267da782ccaad57de","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"3edbe498f7bb9e7daa77f9db30e1b5eeab40e067","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"9c0bacfbd4519d3859e3bbb06128ba241804d8b1","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"043eba3c85c2e2009a9fabf3c4fc55537852fd86","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/jquery.fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1591096194000},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.css","hash":"b9323091d50785ad6c617d7cae76a41a89eb44b3","modified":1591096270000},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.js","hash":"6f5433cc9f19ce2403e903e5d01a4c7b38f0969b","modified":1591096482000},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"ed9da4adea9bcd618fdf25acab2daf9b9cdd341e","modified":1619745989196},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"9783581bec83e6bd6cd279f0af23a2862f46a587","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1591088918000},{"_id":"source/_posts/SimCSE（四）/Supervised SimCSE.png","hash":"b6770e01537295e8c83f691ca0af33d99a1d6c71","modified":1619591060988},{"_id":"source/galleries/2020/images/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1591088918000},{"_id":"source/galleries/2020/images/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1591088918000},{"_id":"source/galleries/2020/images/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1591088918000},{"_id":"source/galleries/2020/images/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1591088918000},{"_id":"source/galleries/2020/images/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1591088918000},{"_id":"source/galleries/2020/images/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1591088918000},{"_id":"source/galleries/2020/images/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1591088918000},{"_id":"source/galleries/2020/images/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1591088918000},{"_id":"source/galleries/2020/images/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1591088918000},{"_id":"source/galleries/2020/images/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1591088918000},{"_id":"source/galleries/2020/images/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1591088918000},{"_id":"source/galleries/2020/images/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1591088918000},{"_id":"source/galleries/2020/images/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1591088918000},{"_id":"source/galleries/test/images/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/js/crypto-js.js","hash":"ddacd177f23f65ff97b93b0417048f51928ee17e","modified":1591106602000},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","hash":"a8927ac2830b2fdd4a729eb0eb7f80923539ceb9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/fancybox.js","hash":"eef46b6fb2e460838cd7328a6e13ecda0cb1e194","modified":1591096444000},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"2c8e19f4e3cdd6a31233ef216b51b6c750a5867b","modified":1591241642000},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"ed0ddcbb0d101f961eb6cb21773bb35b6f6fdfcd","modified":1591241686000},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"09202ead78dc3cd57e674b30d0b16270bbf2db0f","modified":1597053580000},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"ae95fc1feedfa7794471c075db395dbb42cf7bca","modified":1591241620000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"ed0ddcbb0d101f961eb6cb21773bb35b6f6fdfcd","modified":1591241686000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"09202ead78dc3cd57e674b30d0b16270bbf2db0f","modified":1597053580000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"5d473138e8aaf6bc4d98728a6caff2cd9bdf2fbc","modified":1597053590000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"5d473138e8aaf6bc4d98728a6caff2cd9bdf2fbc","modified":1597053590000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"09202ead78dc3cd57e674b30d0b16270bbf2db0f","modified":1597053580000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"ae95fc1feedfa7794471c075db395dbb42cf7bca","modified":1591241620000},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"71ad4fae25d5dd74eab05a7934afeceb1046e5b2","modified":1591194060000},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","hash":"351b0d9f6e9c3a6bbbdf61f40108288b42632b19","modified":1591194086000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"2c8e19f4e3cdd6a31233ef216b51b6c750a5867b","modified":1591241642000},{"_id":"source/galleries/serect/images/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1591088918000},{"_id":"source/galleries/2020/images/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1591088918000},{"_id":"source/galleries/2020/images/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"7a3534269fd922d722a76c3affefc68e21246898","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"67d261ac428761389c895e1da73664e633e14a72","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"de34668d902ec082d17ddb6dd7ad24255fb547c5","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"ba635a17a9d9d132369f9fe4b1fbcaf001ea6ac9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"97894a96ce2c87a3141139553f2b41776fa131b6","modified":1619428909684},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"9cb4babc20eb8fb5a86c4b0cc894fdb0f3cd9534","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"8bb636f3a08da1a38d79956373758bb12e30107f","modified":1591241570000},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"379848eb0bf64c4bd0a94ea67d81b56f048fb2d6","modified":1591241652000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"8bb636f3a08da1a38d79956373758bb12e30107f","modified":1591241584000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"379848eb0bf64c4bd0a94ea67d81b56f048fb2d6","modified":1591241652000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"2c8e19f4e3cdd6a31233ef216b51b6c750a5867b","modified":1591241642000},{"_id":"source/galleries/test/images/cover/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/my404/bodymovin.js","hash":"0101a4545f219753bb617e9f1794444694b3e7d0","modified":1499821912000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1591193360000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1591088918000},{"_id":"source/galleries/test/images/cover/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1591088918000},{"_id":"source/galleries/2020/images/cover/p0.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1591147632000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"6390d0a6e6211ebbd68b49759b4dec8b2a9f04c9","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/my404/data.js","hash":"a9ba4005f96055774d3ff6977bd420d46da42da7","modified":1499821914000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/原始图片/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"224e516f87193797355c00f8e32769d5eda50897","modified":1591241676000},{"_id":"source/_posts/计网第八章-TCP-IP协议/四次挥手过程.gif","hash":"4c9b15582bff89ea47b39b7f4ad4e97ebb38b8d7","modified":1598360206000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"6bd90963ff62eb70aa0eadaa067c4215073525f2","modified":1591241660000},{"_id":"source/_posts/SimCSE（九）/训练结果.png","hash":"c4d483b5314ba47a17f1b9de38347acaa3a628dd","modified":1620177812207},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"224e516f87193797355c00f8e32769d5eda50897","modified":1591241676000},{"_id":"source/_posts/前端设计原稿/数据表格2.png","hash":"3429ea518d321096101c05480709bac74c7248a4","modified":1621238383043},{"_id":"source/_posts/计网第八章-TCP-IP协议/三次挥手.gif","hash":"13e16c6955cd6261a95520df3e828c769b80ade1","modified":1598359940000},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1591192416000},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1591088918000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1591088918000},{"_id":"source/_posts/前端设计原稿/爬取设置.pdf","hash":"66f38eb186d4bec27639fe0241e227acb74c886f","modified":1621237839000},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1591088918000},{"_id":"source/_posts/计网第八章-TCP-IP协议/四次挥手.gif","hash":"0e19db0df5a10a28d0be9201319f137d47515a3f","modified":1598359986000},{"_id":"source/_posts/前端设计原稿/数据表格展示.pdf","hash":"426023922170eb34eb056cd7fa698cd974b89e12","modified":1621237857000},{"_id":"source/_posts/计网第八章-TCP-IP协议/三次握手建立过程.gif","hash":"b4538e2a6273431516a40d67772817887eb62833","modified":1598360184000},{"_id":"source/_posts/前端设计原稿/数据表格1.png","hash":"7494e96bd3aa3e918b5ae58bc84684ea87ef78c3","modified":1621238377585},{"_id":"source/_posts/SimCSE（三）/ICML2020.pdf","hash":"7b029c48a62a3c07464f3a6a78d8575edc2f9b94","modified":1619574964365},{"_id":"source/_posts/前端设计原稿/爬取设置.png","hash":"1e03f3163cba6cd1022953f1c8ec3093515ad505","modified":1621238358734},{"_id":"public/baidu_urls.txt","hash":"7f642a7a7de4536bbb3708f20518c779e1a5ffed","modified":1629345545985},{"_id":"public/baidusitemap.xml","hash":"9eeb89be44bd32ab34f19c85155ec7b9de704dd1","modified":1629345545985},{"_id":"public/search.xml","hash":"a3ee15621f0a6eb8867090c61897059d82e6ddfd","modified":1629345975501},{"_id":"public/sitemap.xml","hash":"30f53ce9dc749b38dc8eb3b17478cdc92f1432c2","modified":1629345545985},{"_id":"public/404.html","hash":"117ea96eb13d05022718236d5796e1735148b961","modified":1629345545985},{"_id":"public/about/index.html","hash":"7b8d81960a09dba41c6519b682784f20ff02de48","modified":1629345545985},{"_id":"public/friends/index.html","hash":"5bdafa35914d43e5bedd9b0a3ee58bf021aaf45e","modified":1629345545985},{"_id":"public/galleries/index.html","hash":"5c1d7fa197f516eab1e25a5f9110c8d0db78d1a4","modified":1629345545985},{"_id":"public/contact/index.html","hash":"17c777c0bf2601b2154edc9d46cf84c91f6f2402","modified":1629345545985},{"_id":"public/categories/index.html","hash":"6a51eeb4e78d9d8f6fc81911a8e650a5bfffb647","modified":1629345545985},{"_id":"public/tags/index.html","hash":"adf8ad4871cdc14ebd54b88524674e8f5e2fa6f5","modified":1629345545985},{"_id":"public/galleries/test/index.html","hash":"2caee117eabb405bdc5d6cce008dcb4e562bef98","modified":1629345975501},{"_id":"public/galleries/serect/index.html","hash":"dce320702aaeda49ef5cbb4a28758b7610e1a94b","modified":1629345975501},{"_id":"public/galleries/个人生活/index.html","hash":"dc29e1a53522989828cd09c851b8ebb8f13d2b85","modified":1629345975501},{"_id":"public/posts/1276.html/index.html","hash":"9056025f7b2b7f0c8a919f5fcef42e1eed201aeb","modified":1629345975501},{"_id":"public/galleries/2020/index.html","hash":"bf869b380a0611ac08407accd70a309deff60ed9","modified":1629345975501},{"_id":"public/posts/820c.html/index.html","hash":"f525c925aacf4968a69e61147914c73420bd7948","modified":1629345545985},{"_id":"public/posts/51d4.html/index.html","hash":"97eafdfd992e26f364288bd551c6cf8a3e5f1f7b","modified":1629345545985},{"_id":"public/posts/5fd7.html/index.html","hash":"048b71cfcf1b390369714cedbece81373ec9052a","modified":1629345545985},{"_id":"public/posts/c728.html/index.html","hash":"15e2a9dd025848f709e5961f6196b542e4b4fb20","modified":1629345545985},{"_id":"public/posts/b77d.html/index.html","hash":"ca858f4e06f85cc876fdcf2f4130d943678a1f00","modified":1629345545985},{"_id":"public/posts/5774.html/index.html","hash":"0fc314e1bc94c12d8a13c9a3b02997f8248d3c40","modified":1629345545985},{"_id":"public/posts/19e3.html/index.html","hash":"2cef8787139764832d24ee2caf24807a859b3530","modified":1629345545985},{"_id":"public/posts/bd21.html/index.html","hash":"350e64b5d9f779d67db5adf1be1736ae58c532f1","modified":1629345545985},{"_id":"public/posts/9be8.html/index.html","hash":"5ea6a0459ab668e5646957c6182f38c7fce55d44","modified":1629345545985},{"_id":"public/posts/1e5f.html/index.html","hash":"d0dd4f926bf1475634990d731b39402f4f8c14fc","modified":1629345545985},{"_id":"public/posts/4201.html/index.html","hash":"ac65b1121465e48884261796900d93b38b67dd1f","modified":1629345545985},{"_id":"public/posts/f664.html/index.html","hash":"056631e980cd317e5317aa4d8e822349a7064267","modified":1629345545985},{"_id":"public/posts/ca01.html/index.html","hash":"e359cc43859b7708542c101894d42ce70ceb7ce3","modified":1629345545985},{"_id":"public/posts/8218.html/index.html","hash":"58b1f8e6506a43685f89fef4b56dde218d1d7fa4","modified":1629345545985},{"_id":"public/posts/40a6.html/index.html","hash":"e6fc63b47a729db798777b755a2967a3d63c93f9","modified":1629345545985},{"_id":"public/posts/3b4c.html/index.html","hash":"dd2ce2d8d166d4926ce16cd258fdc9c261c8033b","modified":1629345545985},{"_id":"public/posts/221e.html/index.html","hash":"d78eed724746ef1e83a3c6b725eee6a95808e32b","modified":1629345545985},{"_id":"public/posts/939d.html/index.html","hash":"03da93123239e1ded8f67a90a36092758b6e5b5a","modified":1629345545985},{"_id":"public/posts/6918.html/index.html","hash":"95a31c0f9272189c598047527e825468879e25d0","modified":1629345545985},{"_id":"public/posts/9ebc.html/index.html","hash":"aa55afb9672de1b8863a8d357da10aff4e13697b","modified":1629345545985},{"_id":"public/posts/5e09.html/index.html","hash":"fba4b018fecd707b132f5432f94c443fec529d1b","modified":1629345545985},{"_id":"public/posts/5c43.html/index.html","hash":"bdf80013d1f1a54943edb7207f12fbf2eeca0be5","modified":1629345545985},{"_id":"public/posts/5e81.html/index.html","hash":"f37ae58bd5f8590204c0112df852df37a6dbeed6","modified":1629345545985},{"_id":"public/posts/9e34.html/index.html","hash":"199940a585e0b7eaaf3a770f2a77b5b16e78bd3d","modified":1629345545985},{"_id":"public/posts/9e70.html/index.html","hash":"5c31a82e9f725716eba309803f084d3d507d656a","modified":1629345545985},{"_id":"public/posts/2fcb.html/index.html","hash":"4bfa82f4bf51dc1f1b1939fb6083d246fcd34177","modified":1629345545985},{"_id":"public/posts/5e4d.html/index.html","hash":"41626dd242cc2c269a712f9e420343a2f3ea18ad","modified":1629345545985},{"_id":"public/posts/5f19.html/index.html","hash":"8ac25f7805c3610825864b66449195b0850623c0","modified":1629345545985},{"_id":"public/posts/f655.html/index.html","hash":"50308a93c3c9ba6d4ac7497a62f00ed3ddac39d8","modified":1629345545985},{"_id":"public/posts/232f.html/index.html","hash":"6a2ea922c6118c261c5e125b0a8ac68f6226e6bc","modified":1629345545985},{"_id":"public/posts/ad5b.html/index.html","hash":"33eb37b7a0618dde35247087fa2b01d598b72d2b","modified":1629345545985},{"_id":"public/posts/51cd.html/index.html","hash":"a3fb8a1b4e8f03d100ab6618112fd1d7182c2e94","modified":1629345545985},{"_id":"public/posts/3849.html/index.html","hash":"b8dd23da5b5245fb00ee828886e8a63a74f1d229","modified":1629345545985},{"_id":"public/posts/3689.html/index.html","hash":"9844be877ae154592942edc724fe7f2ad0fcc75a","modified":1629345545985},{"_id":"public/posts/d09f.html/index.html","hash":"9decc0f57c7009113fa40cb29c512398ee992f75","modified":1629345545985},{"_id":"public/posts/156a.html/index.html","hash":"cf8aae3f4fccd2f2665e95708ff2f644f53fcdee","modified":1629345545985},{"_id":"public/posts/93d0.html/index.html","hash":"1992e75eae936aea1ef17f10d40517ae43cdbb76","modified":1629345545985},{"_id":"public/posts/f4b7.html/index.html","hash":"4b24afd239f01fa3f14ba6bc83ed6c48242f1f37","modified":1629345545985},{"_id":"public/posts/b074.html/index.html","hash":"419f7e68916a4ab335deed84170e560105d76002","modified":1629345545985},{"_id":"public/posts/dde7.html/index.html","hash":"30bf95b68583b931d8640066f4085facf8a04538","modified":1629345545985},{"_id":"public/posts/7624.html/index.html","hash":"30650c780c4d682ed59fe338e694315280191598","modified":1629345545985},{"_id":"public/posts/8cfd.html/index.html","hash":"9540aa0af425707d8f8e6634c8c83108e3395224","modified":1629345545985},{"_id":"public/posts/6f31.html/index.html","hash":"447a4b94a7a2c2f4bb0fff06399643d98ab52f59","modified":1629345545985},{"_id":"public/posts/b23c.html/index.html","hash":"dbb629e8de67b880e12e9780157cdcbdfe414a6a","modified":1629345545985},{"_id":"public/posts/2693.html/index.html","hash":"13f3390621bf652249dd0c15bac7620b09ae1adc","modified":1629345545985},{"_id":"public/posts/2140.html/index.html","hash":"c26a04db13776a70a7f1b2de531a36d2ee0fba81","modified":1629345545985},{"_id":"public/posts/506b.html/index.html","hash":"02ecc2354baca3ba10248b74decaa4f0d76b3f63","modified":1629345545985},{"_id":"public/posts/6b05.html/index.html","hash":"87ffebcc6bc648ab767a196e99e9232c823a72d0","modified":1629345545985},{"_id":"public/posts/6c68.html/index.html","hash":"9641e516f70f6888568f3d47c9721ed40ffab021","modified":1629345545985},{"_id":"public/posts/4cfa.html/index.html","hash":"59dd6607c14a0cacfcb3ebbda4f3017a6f7c7e4f","modified":1629345545985},{"_id":"public/posts/6214.html/index.html","hash":"d74ac3582348dbc905b2e1a4c33a87570faaaa38","modified":1629345545985},{"_id":"public/posts/7930.html/index.html","hash":"e375a265b0d0362a1bc0ede0a12b0b75bb38769b","modified":1629345545985},{"_id":"public/posts/9eeb.html/index.html","hash":"c6511cb6c26753f9e9b4650a47c1d1e8988b9a8f","modified":1629345545985},{"_id":"public/posts/b0c7.html/index.html","hash":"88412326f1dbc00e1a62a86554ed9ae56d01f8a4","modified":1629345545985},{"_id":"public/posts/2e9c.html/index.html","hash":"21d3e67018165dd25c1d3a5798d117607df58992","modified":1629345545985},{"_id":"public/posts/a3e2.html/index.html","hash":"d5243668579584be7d515cf3a7f8882e16fe87ca","modified":1629345545985},{"_id":"public/posts/e047.html/index.html","hash":"fb02026b86578b67a25c2cbc62e60471a8a939c4","modified":1629345545985},{"_id":"public/archives/index.html","hash":"5b1aa28cdfa70d9ea86995c4b433e47b817be0f0","modified":1629345545985},{"_id":"public/archives/page/3/index.html","hash":"804fc5ac498a6fbb19eca12f076d809b36d0edd6","modified":1629345545985},{"_id":"public/archives/page/4/index.html","hash":"bc62b77cbe933c6635613b3e02c01d20e1c35f79","modified":1629345545985},{"_id":"public/archives/2020/index.html","hash":"1f00fca773968eb0b9a7c0e67ce1574d7ed044a0","modified":1629345545985},{"_id":"public/archives/2020/page/2/index.html","hash":"9be169a417f2e6fb743656ab7cf46af7ca86f7ea","modified":1629345545985},{"_id":"public/archives/2020/page/3/index.html","hash":"ccd6a2663c369bfe796079d448e1f63990fcd847","modified":1629345545985},{"_id":"public/archives/page/5/index.html","hash":"a888f7de3a16b6d15252839348d27cbca1d83883","modified":1629345545985},{"_id":"public/archives/page/2/index.html","hash":"0e4c7080f7304562871003e6f3d8441f9473e356","modified":1629345545985},{"_id":"public/archives/2020/page/4/index.html","hash":"eac2cb510547d9dbf5389bfd5b1123081e6776e2","modified":1629345545985},{"_id":"public/archives/2020/06/index.html","hash":"ae688ecf9224dfa053ea834b7ecb9b103e4c02f9","modified":1629345545985},{"_id":"public/archives/2020/05/index.html","hash":"71984a51e6dd5be90e8c4497da91c654c178bee7","modified":1629345545985},{"_id":"public/archives/2020/07/index.html","hash":"935611472073ae0d4b52b0f0b93fce05200d67a4","modified":1629345545985},{"_id":"public/archives/2020/09/index.html","hash":"718c5b487f05849adf445591857401e3e07f8bee","modified":1629345545985},{"_id":"public/archives/2020/08/index.html","hash":"6862bf1d74413d8240b9bef3d3b3eb700686e469","modified":1629345545985},{"_id":"public/archives/2021/index.html","hash":"1c3bae4ceaf940371cb087c2b4107676f632e3dc","modified":1629345545985},{"_id":"public/archives/2021/page/2/index.html","hash":"ef04f9148c84218903e92950f606fec83a1576c0","modified":1629345545985},{"_id":"public/archives/2021/04/index.html","hash":"7d056020e46789152447cab23503b2e386aa5c54","modified":1629345545985},{"_id":"public/archives/2020/10/index.html","hash":"30fe5c2751ed8fe86a3c323f75023c496b456031","modified":1629345545985},{"_id":"public/archives/2021/05/index.html","hash":"d2ccfa0624623393a3dee470479afe1aac3ad914","modified":1629345545985},{"_id":"public/archives/2021/08/index.html","hash":"8a7c72275934c93d6811ebaa788de76e7135c641","modified":1629345545985},{"_id":"public/categories/代码/index.html","hash":"bad718af0dda990c036e809f4b79426f6cc0a75a","modified":1629345545985},{"_id":"public/categories/代码/page/2/index.html","hash":"576dec27cc90947ee42a9e0d97532b298e0652ab","modified":1629345545985},{"_id":"public/categories/菁菁/index.html","hash":"2ac0a64cd0041c98aa0bd133bf55cebbac674178","modified":1629345545985},{"_id":"public/categories/男男/index.html","hash":"7acb8e180fdd8b1fb14dcf56b94634c9f62bfe7c","modified":1629345545985},{"_id":"public/categories/计划/index.html","hash":"7cc353940c8ee7e27979d619769c78f0415491f6","modified":1629345545985},{"_id":"public/categories/tensorflow/index.html","hash":"e3e84b89cb84e7242102e2b7a000a4dd29df83dd","modified":1629345545985},{"_id":"public/categories/论文/index.html","hash":"c2aa04302b939ad3713222eaea39cd9fe1a4f3bf","modified":1629345545985},{"_id":"public/categories/计网/index.html","hash":"a557e17b65954522f451f04af1abe925d1f4356e","modified":1629345545985},{"_id":"public/categories/吉林大学/index.html","hash":"18faf85672d1c5244a8ad81144c9ec671fb5963c","modified":1629345545985},{"_id":"public/categories/项目/index.html","hash":"2158ebe054673f47b9fa125d0b666e2ffd3c2acc","modified":1629345545985},{"_id":"public/categories/每日一题/index.html","hash":"d3940741630f8112ebb848b7e59ef029a5460f62","modified":1629345545985},{"_id":"public/categories/first/index.html","hash":"7d4509a0f69312abf922a5fbd54cde4b1eec27df","modified":1629345545985},{"_id":"public/categories/考研/index.html","hash":"6533e8d9e8a118bee58ce23781a3f09b3f1c520a","modified":1629345545985},{"_id":"public/categories/bug/index.html","hash":"b9bb8de8a9599d74118393f4e8e369d1fbe44428","modified":1629345545985},{"_id":"public/categories/数学/index.html","hash":"9698ac01f2bb3dd6f838f86919bde6ebd2648f02","modified":1629345545985},{"_id":"public/index.html","hash":"c52290c934393a4e4b93f86731c8d6d9c3cdfbb3","modified":1629345545985},{"_id":"public/page/4/index.html","hash":"4c439f2a13d1a7a0ef32a5651e56d073900cd522","modified":1629345545985},{"_id":"public/page/3/index.html","hash":"a240ca01cdacffb2c053ef95cfb0eabf06d28438","modified":1629345545985},{"_id":"public/page/2/index.html","hash":"c021c86d61c01ceea9a0121f2b390886c4f2fa4e","modified":1629345545985},{"_id":"public/tags/代码/index.html","hash":"c3581570840e651de4f4f477698f765dbd80f4d4","modified":1629345545985},{"_id":"public/page/5/index.html","hash":"dc3bd04bb2ff1634f10e32c8d07ff18a0479cd7c","modified":1629345545985},{"_id":"public/tags/代码/page/2/index.html","hash":"82581428ad993ae245f24deebea090aa888034bb","modified":1629345545985},{"_id":"public/tags/考研/index.html","hash":"7179424093efbb4c966335b8a7b3325cc131c819","modified":1629345545985},{"_id":"public/tags/考研/page/2/index.html","hash":"82a1b6631d81e82950c977e7b9b6d461a86757d7","modified":1629345545985},{"_id":"public/tags/考研/page/3/index.html","hash":"bce4ece18e94853060df06b1e52856433ea5b061","modified":1629345545985},{"_id":"public/tags/考研/page/4/index.html","hash":"b02b766aa3ef174d5e32a9de03a9f267112e739f","modified":1629345545985},{"_id":"public/tags/心理学/index.html","hash":"e9330496847252b560f2896c9085ede619b973ef","modified":1629345545985},{"_id":"public/tags/计划/index.html","hash":"db173f90bca589270c7f7c06e798e2868ffdd918","modified":1629345545985},{"_id":"public/tags/论文/index.html","hash":"15d6af554c57588e90e2d128c016c07bcb8255f0","modified":1629345545985},{"_id":"public/tags/论文/page/2/index.html","hash":"26ffda857c61a69624a2026df98171d9577c565b","modified":1629345545985},{"_id":"public/tags/研究生/index.html","hash":"318c14497dcdf214106c6e764ff4dc5acdbdb846","modified":1629345545985},{"_id":"public/tags/研究生/page/2/index.html","hash":"8bf147f527fda4f3621513d7b4110c468185c2e4","modified":1629345545985},{"_id":"public/tags/笔迹鉴定/index.html","hash":"07ce4b48ca910eb7120767e34d9a390949eceddd","modified":1629345545985},{"_id":"public/tags/知识图谱/index.html","hash":"740fcac8b9dea2633e3fcf25d927ec1dac294ea5","modified":1629345545985},{"_id":"public/tags/SimCSE/index.html","hash":"2a2288eb26e6d335cb6ada2dd4f9ffcafa61e253","modified":1629345545985},{"_id":"public/tags/tensorflow/index.html","hash":"216a0c60cf0f8c382c118612f39c4c28da857d7b","modified":1629345545985},{"_id":"public/tags/NLP/index.html","hash":"789073349360f92a24eeaa241c449e48631e2bdd","modified":1629345545985},{"_id":"public/tags/神经网络/index.html","hash":"9970960c2ca0af012892d9fb1f9a05c6b41baab4","modified":1629345545985},{"_id":"public/tags/前端/index.html","hash":"83753edd374ca3635128bec8a0cf9ab0cd9383c6","modified":1629345545985},{"_id":"public/tags/Vue/index.html","hash":"4396e31577bb2d6f865bda10918b854676c6474e","modified":1629345545985},{"_id":"public/tags/项目/index.html","hash":"b3202ee9fe1ef5585daa202260698f497abd2497","modified":1629345545985},{"_id":"public/tags/计算机/index.html","hash":"7e7bf929df0c722d4406a9018ad963462436fd2e","modified":1629345545985},{"_id":"public/tags/NodeJS/index.html","hash":"93b9c3480527c47d32f153a9922bc913e4b244d5","modified":1629345545985},{"_id":"public/tags/API/index.html","hash":"760c3ca472a334bec5c1d380c3f7fa8f57771f3b","modified":1629345545985},{"_id":"public/tags/部署/index.html","hash":"488585bd3a2287a7f8e1c6068ea44660488929a5","modified":1629345545985},{"_id":"public/tags/图/index.html","hash":"87987dc071c3cce3f5e9dfde124c98aa696da16b","modified":1629345545985},{"_id":"public/tags/计网/index.html","hash":"bd0a5f6ced68f2c4d43ac8ef650acfd9385bbcaa","modified":1629345545985},{"_id":"public/tags/总结/index.html","hash":"e250bfad94f7e8f140ed400702c3cb3e6b55751e","modified":1629345545985},{"_id":"public/tags/数据链路层/index.html","hash":"6069c054b732e560231de16057dac64efadc866a","modified":1629345545985},{"_id":"public/tags/男男/index.html","hash":"5141158b0210d6bbc2a8521a9dc3e334e6b98c61","modified":1629345545985},{"_id":"public/tags/强化/index.html","hash":"dc237624ed6d59efeeb88b3abc710d5e0e905a87","modified":1629345545985},{"_id":"public/tags/scrapy/index.html","hash":"4c7da58ed65dfc35e72d1eaf282260a97ce754a5","modified":1629345545985},{"_id":"public/tags/每日一题/index.html","hash":"85ceecbc5033a675158e7b1bfb1f656b5f4233ed","modified":1629345545985},{"_id":"public/tags/微博/index.html","hash":"9a873da6c16dab107e71c3996936a9c4ffc0eb43","modified":1629345545985},{"_id":"public/tags/爬虫/index.html","hash":"72761d180022351a8c4776176fbac8b457dc7075","modified":1629345545985},{"_id":"public/tags/排序/index.html","hash":"d8bbd65997f507e0cff16e7fa29363a4dab6b03b","modified":1629345545985},{"_id":"public/tags/树/index.html","hash":"82df288a112d3e792fd2f6623429a70dbfd8920f","modified":1629345545985},{"_id":"public/tags/Typora/index.html","hash":"45d24e750c10a52e5145199fc965c105c1dfb67a","modified":1629345545985},{"_id":"public/tags/Markdown/index.html","hash":"1ab5b5cf1e41fee50708fba6b511cea3e5c4ad72","modified":1629345545985},{"_id":"public/tags/线性表/index.html","hash":"62a1cee8b29fe4c41f251663765e2f7b30011cb1","modified":1629345545985},{"_id":"public/tags/bug/index.html","hash":"a54ba04ab8779c1b6995a1fa95eec55516242949","modified":1629345545985},{"_id":"public/tags/菁菁/index.html","hash":"0d2b390379f7e32e67b7f0363d431e10bf802aaf","modified":1629345545985},{"_id":"public/tags/scrapyd/index.html","hash":"5c3d30a65b931c11dda057da4f1dc618c40bb232","modified":1629345545985},{"_id":"public/tags/链表/index.html","hash":"7896f1b47c5399368156cbefa7f18d0b207c11c3","modified":1629345545985},{"_id":"public/tags/高数/index.html","hash":"159cd4b76b3d95ab956c84cead9df1cbe4f8059f","modified":1629345545985},{"_id":"public/robots.txt","hash":"aa444ef5779825885f01306f8ff66819fb45739f","modified":1629345545985},{"_id":"public/1926.png","hash":"7fe3f65c530251ca1302a7082ad592491d9d5ac6","modified":1629345545985},{"_id":"public/123.png","hash":"bc8b87f6cca89ad6e4948f126cda3ad0118602e0","modified":1629345545985},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1629345545985},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1629345545985},{"_id":"public/medias/2.png","hash":"342759d8f8bc25491d6ba5e865de2bcd02a4a985","modified":1629345545985},{"_id":"public/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1629345545985},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1629345545985},{"_id":"public/galleries/serect/images/lock.jpg","hash":"4fbda18ce7047d6ba74316ff8ed27446d7bdb9ed","modified":1629345545985},{"_id":"public/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1629345545985},{"_id":"public/galleries/2020/images/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1629345545985},{"_id":"public/galleries/2020/images/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1629345545985},{"_id":"public/galleries/2020/images/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1629345545985},{"_id":"public/galleries/2020/images/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1629345545985},{"_id":"public/galleries/2020/images/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1629345545985},{"_id":"public/galleries/2020/images/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1629345545985},{"_id":"public/galleries/2020/images/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1629345545985},{"_id":"public/galleries/2020/images/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1629345545985},{"_id":"public/galleries/test/images/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1629345545985},{"_id":"public/galleries/2020/images/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1629345545985},{"_id":"public/galleries/2020/images/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1629345545985},{"_id":"public/galleries/2020/images/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1629345545985},{"_id":"public/galleries/2020/images/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1629345545985},{"_id":"public/galleries/serect/images/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1629345545985},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"67d261ac428761389c895e1da73664e633e14a72","modified":1629345545985},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1629345545985},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1629345545985},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1629345545985},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1629345545985},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1629345545985},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1629345545985},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1629345545985},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1629345545985},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1629345545985},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1629345545985},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1629345545985},{"_id":"public/galleries/test/images/cover/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1629345545985},{"_id":"public/posts/3b4c.html/对比表示学习.webp","hash":"32f4d8e690c48e9a85225d6a80647d7739f54e64","modified":1629345545985},{"_id":"public/posts/9be8.html/拟合对比.png","hash":"ade4e63775a1475dbbc8576577ae658e44aea985","modified":1629345545985},{"_id":"public/posts/93d0.html/img.png","hash":"1ed58176ace712ebcb350cd4f38cde8d07345fe1","modified":1629345545985},{"_id":"public/posts/93d0.html/img2.png","hash":"6f0da5a3255d4fcd96798a975420cc9d0e468984","modified":1629345545985},{"_id":"public/posts/7930.html/2.png","hash":"7958ba1aa02ecc910f2b16447aacf3ae52bec2a2","modified":1629345545985},{"_id":"public/posts/40a6.html/001-surprise.png","hash":"df1017e79115d555acb6c20e92dedb943725d3e1","modified":1629345545985},{"_id":"public/posts/5c43.html/拟合图片.jpeg","hash":"350914236a057a25bf4b38cfb7dc76b1b913a531","modified":1629345545985},{"_id":"public/posts/bd21.html/下载1.png","hash":"ebb490ea5075c9d2635fae75321de407a0484a6d","modified":1629345545985},{"_id":"public/posts/bd21.html/下载2.png","hash":"96b38facb940591ef365e1d99fb0129510d4e61e","modified":1629345545985},{"_id":"public/posts/5c43.html/拟合对比.png","hash":"ade4e63775a1475dbbc8576577ae658e44aea985","modified":1629345545985},{"_id":"public/posts/ca01.html/Table 4.png","hash":"84e62bea77dcb9bae68c22cfd8921613e215dc94","modified":1629345545985},{"_id":"public/posts/ca01.html/Table 3.png","hash":"9b1b72884ae7040b59126e8aa3e72bf9c9bcee18","modified":1629345545985},{"_id":"public/posts/2e9c.html/专硕.png","hash":"3f6cc9638d1008fdc17fdaf7a9ac21fbb33d3bec","modified":1629345545985},{"_id":"public/posts/2e9c.html/计算机专硕.png","hash":"1853a4b13e59f1ec2bb8b478f78f3cbb457882b4","modified":1629345545985},{"_id":"public/posts/2e9c.html/计算机学硕2.png","hash":"06fa26541b12b7f2183a75db465d6297c0b65c6b","modified":1629345545985},{"_id":"public/posts/2e9c.html/学硕.png","hash":"cd78beb919d1f0890805ef1b72be62e07e13478f","modified":1629345545985},{"_id":"public/posts/f655.html/ASK.png","hash":"9064448e487e8e86a72c826398410d7f3cb1ac30","modified":1629345545985},{"_id":"public/posts/f655.html/QAM.png","hash":"a37b4f7c9209baa4659b6e7085b1a2a3dfed217b","modified":1629345545985},{"_id":"public/posts/f655.html/PSK.png","hash":"486e4edfcd32d452203563c7e8a38717f3a3ae0f","modified":1629345545985},{"_id":"public/posts/f655.html/FSK.png","hash":"ac413c0abe1af8b4bddb0349460cd718adc92def","modified":1629345545985},{"_id":"public/posts/156a.html/B类子网编码.png","hash":"e7cbc020d5dcfde2afc669a6b80b3418358a6ca5","modified":1629345545985},{"_id":"public/posts/f655.html/单极性编码.png","hash":"3e1fc255c87b089e7215ad9c47e8661a37c2c510","modified":1629345545985},{"_id":"public/posts/f655.html/非归零编码.png","hash":"bc6c4a1125794f5e901ab88a6aeb0c152e15c134","modified":1629345545985},{"_id":"public/posts/156a.html/IP地址范围.png","hash":"bc822cfc18f0dab6fd6d216605078f78a6153abb","modified":1629345545985},{"_id":"public/posts/156a.html/ip地址分类.png","hash":"3e979cba0042bf99d365c98f62797252760483e2","modified":1629345545985},{"_id":"public/posts/156a.html/IP报文格式.png","hash":"d7f64bcf781a9cceb7c382b976640ad02c25ed86","modified":1629345545985},{"_id":"public/css/prism-coy.css","hash":"e95a1fca67112e71cd43ab1e5332a9f798d0da3e","modified":1629345545985},{"_id":"public/css/prism-line-numbers.css","hash":"e0db113a99e4a09d2161a539b1652d96e4a22fac","modified":1629345545985},{"_id":"public/lib/blog-encrypt.js","hash":"91fda12d550323056762c5408623eb8a1d201ecc","modified":1629345545985},{"_id":"public/css/blog-encrypt.css","hash":"22e25b0d16ea053d25eb971e038c817a4c9cb584","modified":1629345545985},{"_id":"public/galleries/2020/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1629345545985},{"_id":"public/galleries/test/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1629345545985},{"_id":"public/galleries/2020/images/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1629345545985},{"_id":"public/galleries/2020/images/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1629345545985},{"_id":"public/galleries/2020/images/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1629345545985},{"_id":"public/galleries/2020/images/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1629345545985},{"_id":"public/galleries/2020/images/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1629345545985},{"_id":"public/galleries/2020/images/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1629345545985},{"_id":"public/galleries/2020/images/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1629345545985},{"_id":"public/galleries/test/images/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1629345545985},{"_id":"public/galleries/2020/images/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1629345545985},{"_id":"public/galleries/2020/images/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1629345545985},{"_id":"public/medias/banner/3.jpg","hash":"09202ead78dc3cd57e674b30d0b16270bbf2db0f","modified":1629345545985},{"_id":"public/galleries/2020/images/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1629345545985},{"_id":"public/medias/banner/1.jpg","hash":"ed0ddcbb0d101f961eb6cb21773bb35b6f6fdfcd","modified":1629345545985},{"_id":"public/medias/featureimages/0.jpg","hash":"ed0ddcbb0d101f961eb6cb21773bb35b6f6fdfcd","modified":1629345545985},{"_id":"public/medias/featureimages/11.jpg","hash":"09202ead78dc3cd57e674b30d0b16270bbf2db0f","modified":1629345545985},{"_id":"public/medias/banner/0.jpg","hash":"2c8e19f4e3cdd6a31233ef216b51b6c750a5867b","modified":1629345545985},{"_id":"public/medias/featureimages/12.jpg","hash":"5d473138e8aaf6bc4d98728a6caff2cd9bdf2fbc","modified":1629345545985},{"_id":"public/medias/featureimages/3.jpg","hash":"09202ead78dc3cd57e674b30d0b16270bbf2db0f","modified":1629345545985},{"_id":"public/medias/featureimages/6.jpg","hash":"5d473138e8aaf6bc4d98728a6caff2cd9bdf2fbc","modified":1629345545985},{"_id":"public/medias/featureimages/5.jpg","hash":"ae95fc1feedfa7794471c075db395dbb42cf7bca","modified":1629345545985},{"_id":"public/medias/banner/5.jpg","hash":"ae95fc1feedfa7794471c075db395dbb42cf7bca","modified":1629345545985},{"_id":"public/medias/reward/alipay.jpg","hash":"71ad4fae25d5dd74eab05a7934afeceb1046e5b2","modified":1629345545985},{"_id":"public/galleries/2020/images/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1629345545985},{"_id":"public/medias/featureimages/9.jpg","hash":"2c8e19f4e3cdd6a31233ef216b51b6c750a5867b","modified":1629345545985},{"_id":"public/medias/reward/wechat.png","hash":"351b0d9f6e9c3a6bbbdf61f40108288b42632b19","modified":1629345545985},{"_id":"public/galleries/2020/images/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1629345545985},{"_id":"public/medias/featureimages/7.jpg","hash":"2c8e19f4e3cdd6a31233ef216b51b6c750a5867b","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1629345545985},{"_id":"public/galleries/test/images/cover/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1629345545985},{"_id":"public/medias/featureimages/原始图片/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1629345545985},{"_id":"public/posts/7930.html/1.png","hash":"e3bd9199976b029443e186fc6a491406ea424b07","modified":1629345545985},{"_id":"public/posts/ca01.html/Figure 2.png","hash":"1fbf82c0bb59931035d6c1807cf34d5db58f819b","modified":1629345545985},{"_id":"public/posts/40a6.html/Unsupervised SimCSE.png","hash":"d9a3d0c1014ea23cc2aec9c9130bf81c34292083","modified":1629345545985},{"_id":"public/posts/ca01.html/Table 2.png","hash":"b073cfe77432bcb540a9943782b56a17f1db6af0","modified":1629345545985},{"_id":"public/posts/ca01.html/Table 5.png","hash":"7ca1b25e1749f59db183527ac6f44f68347bf5f6","modified":1629345545985},{"_id":"public/posts/2e9c.html/计算机学硕1.png","hash":"47be7240a692215f98d87c4a49fe8b49a6f96b01","modified":1629345545985},{"_id":"public/posts/f655.html/曼彻斯特.png","hash":"9fc2f5c9639235a866c4b99de45a83f4f4e855a7","modified":1629345545985},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1629345545985},{"_id":"public/js/cursor.js","hash":"c94c446e154071062519a8846cdad8401b02d5f0","modified":1629345545985},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1629345545985},{"_id":"public/css/my.css","hash":"9cd162b6abcbb6b3ea8448d1b809a1f42358ee9e","modified":1629345545985},{"_id":"public/js/snow.js","hash":"264295c67eaae8057380af993fc9f578c340afbd","modified":1629345545985},{"_id":"public/css/gallery.css","hash":"43063994d9813c813620c7b204a3dd4b03dff0bc","modified":1629345545985},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1629345545985},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1629345545985},{"_id":"public/js/gallery-encrypt.js","hash":"ff41bf0660399b074e26722d7ccc4dc1034f8a24","modified":1629345545985},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1629345545985},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1629345545985},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1629345545985},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1629345545985},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1629345545985},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1629345545985},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1629345545985},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1629345545985},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1629345545985},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1629345545985},{"_id":"public/libs/fancybox/jquery.fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1629345545985},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1629345545985},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1629345545985},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"ed9da4adea9bcd618fdf25acab2daf9b9cdd341e","modified":1629345545985},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1629345545985},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1629345545985},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1629345545985},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1629345545985},{"_id":"public/libs/justifiedGallery/justifiedGallery.min.css","hash":"89fb099880771c23dce3005a87db36053c8c491c","modified":1629345545985},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1629345545985},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1629345545985},{"_id":"public/css/matery.css","hash":"2af3a49e1d82c62f8ec2cbeb5c0bb59f9342a751","modified":1629345545985},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1629345545985},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1629345545985},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1629345545985},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1629345545985},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1629345545985},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1629345545985},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1629345545985},{"_id":"public/libs/justifiedGallery/justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1629345545985},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1629345545985},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1629345545985},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1629345545985},{"_id":"public/libs/fancybox/fancybox.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1629345545985},{"_id":"public/js/crypto-js.js","hash":"3dd73b6f13dc818a3a9c5c7424c1c4a9649b00a2","modified":1629345545985},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1629345545985},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1629345545985},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1629345545985},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1629345545985},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1629345545985},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1629345545985},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1629345545985},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1629345545985},{"_id":"public/libs/valine/Valine.min.js","hash":"97894a96ce2c87a3141139553f2b41776fa131b6","modified":1629345545985},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1629345545985},{"_id":"public/libs/my404/bodymovin.js","hash":"0101a4545f219753bb617e9f1794444694b3e7d0","modified":1629345545985},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1629345545985},{"_id":"public/libs/my404/data.js","hash":"a9ba4005f96055774d3ff6977bd420d46da42da7","modified":1629345545985},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1629345545985},{"_id":"public/medias/banner/4.jpg","hash":"8bb636f3a08da1a38d79956373758bb12e30107f","modified":1629345545985},{"_id":"public/medias/banner/6.jpg","hash":"379848eb0bf64c4bd0a94ea67d81b56f048fb2d6","modified":1629345545985},{"_id":"public/medias/featureimages/4.jpg","hash":"8bb636f3a08da1a38d79956373758bb12e30107f","modified":1629345545985},{"_id":"public/medias/featureimages/8.jpg","hash":"379848eb0bf64c4bd0a94ea67d81b56f048fb2d6","modified":1629345545985},{"_id":"public/galleries/2020/images/cover/p0.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1629345545985},{"_id":"public/posts/9be8.html/dropout.jpeg","hash":"f1349c4e39b7980b1acb7823daa73126c67dbc81","modified":1629345545985},{"_id":"public/posts/5c43.html/dropout.jpeg","hash":"f1349c4e39b7980b1acb7823daa73126c67dbc81","modified":1629345545985},{"_id":"public/posts/bd21.html/模型情况.png","hash":"b43ec15731e5ecf6e95e93c784dd709c250a3561","modified":1629345545985},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1629345545985},{"_id":"public/posts/40a6.html/Supervised SimCSE.png","hash":"b6770e01537295e8c83f691ca0af33d99a1d6c71","modified":1629345545985},{"_id":"public/medias/featureimages/2.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1629345545985},{"_id":"public/posts/156a.html/四次挥手过程.gif","hash":"4c9b15582bff89ea47b39b7f4ad4e97ebb38b8d7","modified":1629345545985},{"_id":"public/medias/featureimages/10.jpg","hash":"224e516f87193797355c00f8e32769d5eda50897","modified":1629345545985},{"_id":"public/medias/featureimages/13.jpg","hash":"6bd90963ff62eb70aa0eadaa067c4215073525f2","modified":1629345545985},{"_id":"public/medias/banner/2.jpg","hash":"224e516f87193797355c00f8e32769d5eda50897","modified":1629345545985},{"_id":"public/posts/1e5f.html/训练结果.png","hash":"c4d483b5314ba47a17f1b9de38347acaa3a628dd","modified":1629345545985},{"_id":"public/medias/featureimages/1.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1629345545985},{"_id":"public/posts/156a.html/三次挥手.gif","hash":"13e16c6955cd6261a95520df3e828c769b80ade1","modified":1629345545985},{"_id":"public/posts/51d4.html/数据表格2.png","hash":"3429ea518d321096101c05480709bac74c7248a4","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1629345545985},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1629345545985},{"_id":"public/posts/51d4.html/爬取设置.pdf","hash":"66f38eb186d4bec27639fe0241e227acb74c886f","modified":1629345545985},{"_id":"public/posts/156a.html/四次挥手.gif","hash":"0e19db0df5a10a28d0be9201319f137d47515a3f","modified":1629345545985},{"_id":"public/posts/51d4.html/数据表格展示.pdf","hash":"426023922170eb34eb056cd7fa698cd974b89e12","modified":1629345545985},{"_id":"public/posts/156a.html/三次握手建立过程.gif","hash":"b4538e2a6273431516a40d67772817887eb62833","modified":1629345545985},{"_id":"public/posts/51d4.html/数据表格1.png","hash":"7494e96bd3aa3e918b5ae58bc84684ea87ef78c3","modified":1629345545985},{"_id":"public/posts/3b4c.html/ICML2020.pdf","hash":"7b029c48a62a3c07464f3a6a78d8575edc2f9b94","modified":1629345545985},{"_id":"public/posts/51d4.html/爬取设置.png","hash":"1e03f3163cba6cd1022953f1c8ec3093515ad505","modified":1629345545985}],"Category":[{"name":"代码","_id":"cksie9q580005a09k930h2acr"},{"name":"菁菁","_id":"cksie9q5j000qa09kcdv55r96"},{"name":"男男","_id":"cksie9q5k000ya09khzywhh3n"},{"name":"计划","_id":"cksie9q5o001fa09kero1dbtf"},{"name":"论文","_id":"cksie9q5p001oa09kbhax8mal"},{"name":"tensorflow","_id":"cksie9q5w002ya09khu903ai1"},{"name":"项目","_id":"cksie9q5x0035a09k0lbc1wda"},{"name":"吉林大学","_id":"cksie9q5y003ea09k5pon3ksr"},{"name":"计网","_id":"cksie9q61003ta09k0g3k2qeq"},{"name":"每日一题","_id":"cksie9q64004ga09kb2aj6s0i"},{"name":"first","_id":"cksie9q6b005ia09kdyfe423q"},{"name":"考研","_id":"cksie9q6d005qa09k2tfxf3a1"},{"name":"bug","_id":"cksie9q6e005ya09kgefidxv5"},{"name":"数学","_id":"cksie9q6e0062a09k6n9cd8q5"}],"Data":[{"_id":"galleries","data":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}]},{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}],"Page":[{"title":"404","date":"2020-08-13T01:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2020-08-13 09:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---","updated":"2020-08-13T01:42:30.000Z","path":"404.html","comments":1,"_id":"cksie9q3v0000a09kh81tad9i","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"about","date":"2020-06-02T10:06:55.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-06-02 18:06:55\ntype: \"about\"\nlayout: \"about\"\n---","updated":"2020-06-02T10:07:22.000Z","path":"about/index.html","comments":1,"_id":"cksie9q570002a09kg2539hkx","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-06-02T10:05:52.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-06-02 18:05:52\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2020-06-02T10:06:18.000Z","path":"categories/index.html","comments":1,"_id":"cksie9q570004a09kf5g88hrn","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2018-09-30 17:25:30\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2020-06-02T10:07:58.000Z","path":"contact/index.html","comments":1,"_id":"cksie9q590008a09k30xobxfl","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2018-12-12 21:25:30\ntype: \"friends\"\nlayout: \"friends\"\n---","updated":"2020-06-02T10:08:26.000Z","path":"friends/index.html","comments":1,"_id":"cksie9q5a000aa09kdc5sbmrd","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"相册","date":"2020-06-02T11:02:29.000Z","type":"galleries","layout":"galleries","_content":"","source":"galleries/index.md","raw":"---\ntitle: 相册\ndate: 2020-06-02 19:02:29\ntype: \"galleries\"\nlayout: \"galleries\"\n---\n","updated":"2020-06-03T06:52:44.000Z","path":"galleries/index.html","comments":1,"_id":"cksie9q5c000ea09k3owg29i4","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-06-02T10:06:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-06-02 18:06:27\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-06-02T10:06:46.000Z","path":"tags/index.html","comments":1,"_id":"cksie9q7b00cna09kctgm8phn","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"个人生活","date":"2020-06-03T07:11:29.000Z","type":"gallery","layout":"gallery","password":"shenghuo","_content":"","source":"galleries/个人生活/index.md","raw":"---\ntitle: 个人生活\ndate: 2020-06-03 15:11:29\ntype: \"gallery\"\nlayout: \"gallery\"\npassword: shenghuo \n---\n","updated":"2020-06-03T07:13:26.000Z","path":"galleries/个人生活/index.html","comments":1,"_id":"cksie9q7t00coa09key4p2rx7","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">Hey, password is required here.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"a049597181244d1f43122cf2d0dcdd54786255159a6330f2c916b38ff98c4936\">69cb69b134b8ae0378e39748c29440f49eae4a5ec2568e877c97c611e48011fcb0e191fbbddaecf3b452ff604874fda79020da843a6405e9d5615dd29da605d3147db1460153d66d7ab6ee98104386bb53135bd8de06d2bb9af6bb628ea7b9d49a7872f0825f032d24219561b3d46c13007d0ab1a1f917a151d556ee65dcc83c2d240268c4ca059435af37112793ed91863d16d26cc98fc386aa08344a6a2a1aa83e1c8a04df78abd4d5b6efc3b5f6d3986f72e5afa5bc23d2372db9fa988b99e35b549e48fbc55927f1bc2c470ebc921de59b4caa668dd9fa34aa6f49b2735ac0cd4ccf6be0513760bed8842fd71286299ee1d0d60c92cbaf52b4b13f2d0293fe582b87aafd5a99e8362226a540045a3664e9606d88f8edaef2bbd4007ce503c7433c00955e2fb61e42a35f1a24d38cdcc47686feddd724adbf5411eaddee24a02e373d2622179b07b565f5068bfcec88f7aa38a14c0e7d291e7fe4ea023ecbc28cb91e35666b1d971361097069ae7b5c9fce15120cb3a2961efa7a1f3fba81e8266f3032807e01821948a272902abb7759b95abd13ca0e66df80cfbb40300cc2654ca2e1585d0caa107818c546bb58178ebb45b1129bc2c68a9bf04965e4e8b448f0b3dc061f1534aca4cae0ed51867e325dadede58cacd57e77ca9ddc7713b3ff30784c9ee81752ff4a8954e1bc61134b5ee0c01f9048c7ab229422ef1256db0e2f984611b815b84f59e565a9d9c4bb9042bcb17af5a2887eb95658dd1b29c040fa3b6e53a175b6885efadb6aa1381887b07ba928b82b92054347df451738adb3537823655820a86c822f445b9ac8fe8f20acbfc901b877a8d4e86755812f41705f0dce5b5b9ea91b21c120c74da31e58ca5ca47a23cbed432379649ff442bd183a8d2ac8f0702bc3df3686c9f7f55fa818961187aac859f88bb53947509c8c661bfa0ef3974d21b34f6e2c0f041d</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","encrypt":true},{"title":"2020","date":"2020-05-19T02:51:50.000Z","type":"gallery","layout":"gallery","password":"lgn970722","_content":"","source":"galleries/2020/index.md","raw":"---\ntitle: 2020\ndate: 2020-05-19 10:51:50\ntype: \"gallery\"\nlayout: \"gallery\"\npassword: lgn970722\n---","updated":"2020-06-03T07:04:08.000Z","path":"galleries/2020/index.html","comments":1,"_id":"cksie9q7t00cpa09k11yt01kn","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">Hey, password is required here.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"2958fa0556bfad5d0cc555521580adcf7743a9528760c82bc4c91fc1d0587f8f\">8567f00c865c7b7900a73b68f55362fcdff9531a62cee3bfa3d884880643639f177dddc72e00808ad5b95c2c6ab197a9cc63bfd66ebfbaab96bde6e6386ebb93c2aee1875f0fea819377dc2654acb6da18476d4d6e6d84da9d3a648a1c647845415075f3ace6d54a380986d64fce7fb0e0697890d34e9332326743120b47987baac95f16c5df3b1efbd1665357fbcd675b80baba03e1fe5f4a8d693cecc7c47e716f03e4f18b07463c3307ce43914306f2a3c626e9345c8a0bd5f012e23c27b028ed18eee88aaf0f26a3b88ca72b59a88916fcc12661d7ab3256ff511394c6a12106cc71ade9819efeb562fd83ee55f9c2e94dce49fc2fd99ef90732cfdb3d479ea974534671bc8fced2a83d7f8a414a67d2050a6c605afab7cdee51a503961305f88328a284f4c17ba5959441fa40a9d1a9db631e326153bce862076178670fc1069259173e9b4df09a14655239b91d2514acc566545e1b327b7619e05ea876c172660438178493577e858154bb4715331db1133f13223daf8b52f41bf11e6a458aefeb297a047548efbf37bc92795e1489d60d31540b36eb707c3e8bfa90f3a4f055194ff53864edd73824681bf134678c10e0ee4583084a6542ce89ea08dedbf53a1822d7b6c358571f57024a8e5f1e2eaa9a80f2c8f6b8eb7916ff3ec8e0ea4cda408e266db638dd63640f447b6adc9fa4cf7abcf312f5f9b1280ad227f35d060ddcea1f9eccde171ed1c1bcfdda36c0f235b5ac6b47346aa2c4c9f02bac5fa103bae46b6d1fcf20370f4bf08d18f42ba8af3a7b18b1c69b9290a9affb8e196e4e32a71cfc56be7aeace5b5d4a7a201821a7969a032498db457b97dfcd097d40e7ccd69c059ac9868a8de7c031b9d84455b36c8abafd38fa367ce51149bd66bbb58d5a5d6e4de997e245d136c4ef221edb6c52ef6185d63a95d31736ad803beefa18c2ff543555e7183d12035cca</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","encrypt":true},{"title":"test","date":"2020-06-01T04:02:29.000Z","type":"gallery","layout":"gallery","password":"test","_content":"","source":"galleries/test/index.md","raw":"---\ntitle: test\ndate: 2020-06-01 12:02:29\ntype: \"gallery\"\nlayout: \"gallery\"\npassword: test\n---\n","updated":"2020-06-03T07:06:24.000Z","path":"galleries/test/index.html","comments":1,"_id":"cksie9q7u00cqa09khgel475p","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">Hey, password is required here.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"e963f58974547040a5d1086db3d611a24059ecb1dc7ae3df37066a729583ca00\">5f1ae1018b93439759966a504f76a6425751408c3953a755653773d327bcc06d75f4ecaf693fba9d1225cb53e1788e71f4dfbf441f06df463f52e6cea64e81061cbba0010e8ccb1180d6e47b37678d51e0f57096153cfc0631dbc7e24957240bf395610c3c47dbee5152928aed5545a30839208b0204ca7e9b022e2404a2c1a59b75a783fd7ab50b8f979bee1b3f9052957be524c85cf9d85b8fd27e2ae4b11c28d092628ac2e1352091f9415d45f6ee2c362f62cc0527c3d700b186a612b7782bdaae409496b6b890cc001fad228df50abc5802acbcd01f30655555c991e1996447280c245dc496b87d0031252d995194a55a529fce6e9c338d02596496e14df9ef984cf7984b2f8e8ba97a54ce5dab91c4d2e9300d4c3ae10df7cf9f3c34f8634c914805355683fd14d200315ce11e33e530c3af5d3c14f84b6c73c0a97ac1ede921fdbb2d8f1962aefe7d471d370d1c602c6adb93d277a7e3da188783735feaceb93c7b74beafe5853ac25deb8b98c31e423091d3451b57711dbb90d1fb7d46cfd1e8b2158fee8fd4729e98564e61e91df903548331588738a79ab525758d4a84cf514aa3461181d806d60aed86bfc46cd3ca1d2df36f21e4fa946059a513f11ceba11a38a72f0a4ff1f2c7eb1ceca3e37b41c944ec4721cba49505f587ccfaa10ffe3f3bba5b77266cc17848a9fe2cb9ecc7a26046e091fce25ab2083f05e3f729fd9be224cf93a7dba19778a1bc5886d8dd6b21e513a6879c1b2eaa87c953e83a2e66cbc6d129a9bbe0d208ee51aebb4c76944974c33471e74ae5611081e594978823d9317fb9a8bcbfefc2b8399808f7d53b172a130803271694057bf970443093e85b7ff7b211d6700917e60d82b84278bacd0d39f0b265692296bdafaa3dd83dabe02ad5afa02077072962f1cd34fa4ce72d879b14ca952561ae4ea5d190298b082bc4513f4be1efe1f9380e</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","encrypt":true},{"title":"serect","date":"2020-06-03T07:02:29.000Z","type":"gallery","layout":"gallery","password":"serect","_content":"","source":"galleries/serect/index.md","raw":"---\ntitle: serect\ndate: 2020-06-03 15:02:29\ntype: \"gallery\"\nlayout: \"gallery\"\npassword: serect\n---\n","updated":"2020-06-03T07:13:14.000Z","path":"galleries/serect/index.html","comments":1,"_id":"cksie9q7u00cra09kecdj27hw","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">Hey, password is required here.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"3dce5d5511e4429cfece19f890d3004495b8d3f2a918e8b0b2e07d13f6c5d7a5\">6f52fb18315f92792099c76cb33cf964cbc9e8a52e01661f1ef370c8a59969f5592793e5735b22224c3fb93cc355ed6c319e98afda77bd575dd700761dc382efa9c2be3adb007130305e53114f061faf005b9c99d4687730c44b4ea9a2542fc6b3d0b692a1a2418a8d998688443456ddc7157d1974081be362a44462a8275f4695839e4440f3af41e9aa4420813ed82a7fc0ef7dd270d29a4bf4a331403d0a40003349b7ba15367b2d5e59cb30a8e2d08625107721575b8cd538d51c8f080a4cd9a68fde94465e3b9566deeeec7cddb74fd0dfc3c788bea9920c0c2f7209c28c99eedc218a9130a1ed07cc171b018581055d176c271e208113f1a1a074ee309da631b651ac9ce199a06ac33a079c30dcacbd821b7f4685c08ec9e65bf6396a2fa150fa75061506ab45d64ac284cdc250b7c194bcb5d04e2c53277b3ffa38e8cd75ae7c2fb46d849e495a741f95f96c08b8ebdf40bf899b089ac01240435998617a83e7d065b2c784668ed118cd03957bee5e87804af6cb9ed8c10cc6c60754db81de5ca380e1234170f5fd49364767e98bcb7ed5f1bb3c3f8f8dff91781adf39bbf80db94a7a08188f78fb85540bda08f6ca2d1e809818357e9d688721986a1bf7602650f69ffa7def992a762a8ef5331c0e2964b931e2c0138393e033c50c627cec582f98a02bcc319dfca4d8bbf81bdd7476a608068330a97caffcff70c4d2a29356c3c8106596d413cbc231134c044ae8ff36b7320d2022556dc1faeb307fa72077714509e45ecd7fe0d8b1f1ec1039a02328eaa6e4c2758691b24a4de545fd89b9a0ee2dbbad94b0d41a95ef44e65a8c21713f4cac1ea5b8555dc11f1f260df38b05aab689a19b8d8b4832662cb1dd971ca2d4c738637118aaad0be65964cd3da5957a5efe89d5432e850b1034fdf26198be44fc6cf9c821490286673b9bf21b2f05e9ee57c9ca1eb7d3f2987eb1</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","encrypt":true}],"Post":[{"title":"2012-941","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2012-941学硕代码题","description":"2012-941学硕代码题","summary":"2012-941学硕代码题","abbrlink":"5e81","date":"2020-10-07T11:12:22.000Z","password":null,"_content":"## 2012-941\n\n#### 1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\n\n- <font color=\"red\">复习，理解，重点</font>\n\n```c\ntypedef struct VNode{                      //顶点表结点\n    int len0;//距离初始顶点v0的距离\n    int v;//顶点编号\n}Node;//邻接表的顶点类型\nvoid bfsPrintNode(ALGraph *g,int v[],int k){\n    Node Queue[MaxSize];//定义一个顶点类型的队列\n    int front = 0;//队头\n    int rear = 0;//队尾\n    int flag[v0] = 1;//访问后则将其置为1\n    Queue[rear++] = {0,v0};//初始顶点v0入队\n    while(!isEmpty(Q)){\n        Node node = Queue[front++];//v接收出队元素\n        for(ArcNode *p = g.vexset[node.v].firstarc;p != NULL;p = p -> nextarc){\n            if(flag[p -> nextarc == 0]){\n                visit(p -> adjvex);//若p对应的邻接顶点没被访问，则访问它\n                flag[p -> adjvex] = 1;\n                Queue[rear++] = {node.len0 + 1,p -> adjvex};//邻接顶点入队\n            }\n        }\n    }\n    for(int i = 0;i < rear;++i){\n        if(Queue[i].len0 == k){//打印出距离初始顶点距离为k的所有顶点\n            printf(\"%d\",Queue[i].v);\n        }\n    }\n}\n```\n\n","source":"_posts/2012-941.md","raw":"---\ntitle: 2012-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2012-941学硕代码题\ndescription: 2012-941学硕代码题\nsummary: 2012-941学硕代码题\nabbrlink: '5e81'\ndate: 2020-10-07 19:12:22\npassword:\n---\n## 2012-941\n\n#### 1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\n\n- <font color=\"red\">复习，理解，重点</font>\n\n```c\ntypedef struct VNode{                      //顶点表结点\n    int len0;//距离初始顶点v0的距离\n    int v;//顶点编号\n}Node;//邻接表的顶点类型\nvoid bfsPrintNode(ALGraph *g,int v[],int k){\n    Node Queue[MaxSize];//定义一个顶点类型的队列\n    int front = 0;//队头\n    int rear = 0;//队尾\n    int flag[v0] = 1;//访问后则将其置为1\n    Queue[rear++] = {0,v0};//初始顶点v0入队\n    while(!isEmpty(Q)){\n        Node node = Queue[front++];//v接收出队元素\n        for(ArcNode *p = g.vexset[node.v].firstarc;p != NULL;p = p -> nextarc){\n            if(flag[p -> nextarc == 0]){\n                visit(p -> adjvex);//若p对应的邻接顶点没被访问，则访问它\n                flag[p -> adjvex] = 1;\n                Queue[rear++] = {node.len0 + 1,p -> adjvex};//邻接顶点入队\n            }\n        }\n    }\n    for(int i = 0;i < rear;++i){\n        if(Queue[i].len0 == k){//打印出距离初始顶点距离为k的所有顶点\n            printf(\"%d\",Queue[i].v);\n        }\n    }\n}\n```\n\n","slug":"2012-941","published":1,"updated":"2020-10-07T11:13:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q550001a09k3u3zcriz","content":"<h2 id=\"2012-941\"><a href=\"#2012-941\" class=\"headerlink\" title=\"2012-941\"></a>2012-941</h2><h4 id=\"1-求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\"><a href=\"#1-求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\" class=\"headerlink\" title=\"1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\"></a>1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算</h4><ul>\n<li><font color=\"red\">复习，理解，重点</font>\n\n</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">typedef struct VNode{                      //顶点表结点\n    int len0;//距离初始顶点v0的距离\n    int v;//顶点编号\n}Node;//邻接表的顶点类型\nvoid bfsPrintNode(ALGraph *g,int v[],int k){\n    Node Queue[MaxSize];//定义一个顶点类型的队列\n    int front = 0;//队头\n    int rear = 0;//队尾\n    int flag[v0] = 1;//访问后则将其置为1\n    Queue[rear++] = {0,v0};//初始顶点v0入队\n    while(!isEmpty(Q)){\n        Node node = Queue[front++];//v接收出队元素\n        for(ArcNode *p = g.vexset[node.v].firstarc;p != NULL;p = p -> nextarc){\n            if(flag[p -> nextarc == 0]){\n                visit(p -> adjvex);//若p对应的邻接顶点没被访问，则访问它\n                flag[p -> adjvex] = 1;\n                Queue[rear++] = {node.len0 + 1,p -> adjvex};//邻接顶点入队\n            }\n        }\n    }\n    for(int i = 0;i < rear;++i){\n        if(Queue[i].len0 == k){//打印出距离初始顶点距离为k的所有顶点\n            printf(\"%d\",Queue[i].v);\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2012-941\"><a href=\"#2012-941\" class=\"headerlink\" title=\"2012-941\"></a>2012-941</h2><h4 id=\"1-求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\"><a href=\"#1-求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\" class=\"headerlink\" title=\"1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算\"></a>1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算</h4><ul>\n<li><font color=\"red\">复习，理解，重点</font>\n\n</li>\n</ul>\n<pre><code class=\"lang-c\">typedef struct VNode{                      //顶点表结点\n    int len0;//距离初始顶点v0的距离\n    int v;//顶点编号\n}Node;//邻接表的顶点类型\nvoid bfsPrintNode(ALGraph *g,int v[],int k){\n    Node Queue[MaxSize];//定义一个顶点类型的队列\n    int front = 0;//队头\n    int rear = 0;//队尾\n    int flag[v0] = 1;//访问后则将其置为1\n    Queue[rear++] = {0,v0};//初始顶点v0入队\n    while(!isEmpty(Q)){\n        Node node = Queue[front++];//v接收出队元素\n        for(ArcNode *p = g.vexset[node.v].firstarc;p != NULL;p = p -&gt; nextarc){\n            if(flag[p -&gt; nextarc == 0]){\n                visit(p -&gt; adjvex);//若p对应的邻接顶点没被访问，则访问它\n                flag[p -&gt; adjvex] = 1;\n                Queue[rear++] = {node.len0 + 1,p -&gt; adjvex};//邻接顶点入队\n            }\n        }\n    }\n    for(int i = 0;i &lt; rear;++i){\n        if(Queue[i].len0 == k){//打印出距离初始顶点距离为k的所有顶点\n            printf(&quot;%d&quot;,Queue[i].v);\n        }\n    }\n}\n</code></pre>\n"},{"title":"2013-941","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2013-941学硕代码题","description":"2013-941学硕代码题","summary":"2013-941学硕代码题","abbrlink":"9ebc","date":"2020-09-27T06:46:29.000Z","password":null,"_content":"## 2013-941\n\n#### (1).找出二叉树先根序列的最后一个结点\n\n- 二叉查找树由3个域构成\n- key：给出结点数据项的值，为正整数\n- left：结点的左子结点地址\n- right：结点的右子结点地址\n- 根结点地址为root\n- 不能使用递归\n- 不能使用栈\n\n```c\nvoid last(BiTree root){\n    BiTree *p = root;\n    while(p -> right != NULL || p -> left != NULL){\n       if(p -> right){\n           while(p -> right != NULL){\n               p = p -> right;\n           }\n       }else{\n           p = p -> left;\n       }\n    }\n    return p;\n}\n```\n\n#### (2)将key域的值大于等于给定x的值的结点全部删除\n\n```c\nvoid Del(BiTree T){//递归删除树算法\n    if(T != NULL){\n        Del(T -> left);\n        Del(T -> right);\n        free(T);\n    }\n}\nvoid DeleteX(BiTree root,int x){\n    BiTree Queue[MaxSize];\n    int rear = -1,front = -1;\n    BiTree *p = root;\n    BiTree *pre = NULL;\n    while(p -> right != NULL && p -> key <= x){\n        pre = p;\n        p = p -> right;\n    }\n    if(p -> key <= x){\n            return;\n    }\n    Queue[++rear] = p;\n    while(rear != front){\n        p = Queue[++front];\n        if(p -> key > x){\n            Queue[++rear] = p -> left;\n            pre -> right = p -> left;\n            p -> left = NULL;\n            Del(p);\n        }else{\n            Queue[++rear] = p -> right;\n        }\n    }\n}\n```\n","source":"_posts/2013-941.md","raw":"---\ntitle: 2013-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2013-941学硕代码题\ndescription: 2013-941学硕代码题\nsummary: 2013-941学硕代码题\nabbrlink: 9ebc\ndate: 2020-09-27 14:46:29\npassword:\n---\n## 2013-941\n\n#### (1).找出二叉树先根序列的最后一个结点\n\n- 二叉查找树由3个域构成\n- key：给出结点数据项的值，为正整数\n- left：结点的左子结点地址\n- right：结点的右子结点地址\n- 根结点地址为root\n- 不能使用递归\n- 不能使用栈\n\n```c\nvoid last(BiTree root){\n    BiTree *p = root;\n    while(p -> right != NULL || p -> left != NULL){\n       if(p -> right){\n           while(p -> right != NULL){\n               p = p -> right;\n           }\n       }else{\n           p = p -> left;\n       }\n    }\n    return p;\n}\n```\n\n#### (2)将key域的值大于等于给定x的值的结点全部删除\n\n```c\nvoid Del(BiTree T){//递归删除树算法\n    if(T != NULL){\n        Del(T -> left);\n        Del(T -> right);\n        free(T);\n    }\n}\nvoid DeleteX(BiTree root,int x){\n    BiTree Queue[MaxSize];\n    int rear = -1,front = -1;\n    BiTree *p = root;\n    BiTree *pre = NULL;\n    while(p -> right != NULL && p -> key <= x){\n        pre = p;\n        p = p -> right;\n    }\n    if(p -> key <= x){\n            return;\n    }\n    Queue[++rear] = p;\n    while(rear != front){\n        p = Queue[++front];\n        if(p -> key > x){\n            Queue[++rear] = p -> left;\n            pre -> right = p -> left;\n            p -> left = NULL;\n            Del(p);\n        }else{\n            Queue[++rear] = p -> right;\n        }\n    }\n}\n```\n","slug":"2013-941","published":1,"updated":"2020-09-27T06:47:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q570003a09kbn3fd2er","content":"<h2 id=\"2013-941\"><a href=\"#2013-941\" class=\"headerlink\" title=\"2013-941\"></a>2013-941</h2><h4 id=\"1-找出二叉树先根序列的最后一个结点\"><a href=\"#1-找出二叉树先根序列的最后一个结点\" class=\"headerlink\" title=\"(1).找出二叉树先根序列的最后一个结点\"></a>(1).找出二叉树先根序列的最后一个结点</h4><ul>\n<li>二叉查找树由3个域构成</li>\n<li>key：给出结点数据项的值，为正整数</li>\n<li>left：结点的左子结点地址</li>\n<li>right：结点的右子结点地址</li>\n<li>根结点地址为root</li>\n<li>不能使用递归</li>\n<li>不能使用栈</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void last(BiTree root){\n    BiTree *p = root;\n    while(p -> right != NULL || p -> left != NULL){\n       if(p -> right){\n           while(p -> right != NULL){\n               p = p -> right;\n           }\n       }else{\n           p = p -> left;\n       }\n    }\n    return p;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-将key域的值大于等于给定x的值的结点全部删除\"><a href=\"#2-将key域的值大于等于给定x的值的结点全部删除\" class=\"headerlink\" title=\"(2)将key域的值大于等于给定x的值的结点全部删除\"></a>(2)将key域的值大于等于给定x的值的结点全部删除</h4><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void Del(BiTree T){//递归删除树算法\n    if(T != NULL){\n        Del(T -> left);\n        Del(T -> right);\n        free(T);\n    }\n}\nvoid DeleteX(BiTree root,int x){\n    BiTree Queue[MaxSize];\n    int rear = -1,front = -1;\n    BiTree *p = root;\n    BiTree *pre = NULL;\n    while(p -> right != NULL && p -> key <= x){\n        pre = p;\n        p = p -> right;\n    }\n    if(p -> key <= x){\n            return;\n    }\n    Queue[++rear] = p;\n    while(rear != front){\n        p = Queue[++front];\n        if(p -> key > x){\n            Queue[++rear] = p -> left;\n            pre -> right = p -> left;\n            p -> left = NULL;\n            Del(p);\n        }else{\n            Queue[++rear] = p -> right;\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2013-941\"><a href=\"#2013-941\" class=\"headerlink\" title=\"2013-941\"></a>2013-941</h2><h4 id=\"1-找出二叉树先根序列的最后一个结点\"><a href=\"#1-找出二叉树先根序列的最后一个结点\" class=\"headerlink\" title=\"(1).找出二叉树先根序列的最后一个结点\"></a>(1).找出二叉树先根序列的最后一个结点</h4><ul>\n<li>二叉查找树由3个域构成</li>\n<li>key：给出结点数据项的值，为正整数</li>\n<li>left：结点的左子结点地址</li>\n<li>right：结点的右子结点地址</li>\n<li>根结点地址为root</li>\n<li>不能使用递归</li>\n<li>不能使用栈</li>\n</ul>\n<pre><code class=\"lang-c\">void last(BiTree root){\n    BiTree *p = root;\n    while(p -&gt; right != NULL || p -&gt; left != NULL){\n       if(p -&gt; right){\n           while(p -&gt; right != NULL){\n               p = p -&gt; right;\n           }\n       }else{\n           p = p -&gt; left;\n       }\n    }\n    return p;\n}\n</code></pre>\n<h4 id=\"2-将key域的值大于等于给定x的值的结点全部删除\"><a href=\"#2-将key域的值大于等于给定x的值的结点全部删除\" class=\"headerlink\" title=\"(2)将key域的值大于等于给定x的值的结点全部删除\"></a>(2)将key域的值大于等于给定x的值的结点全部删除</h4><pre><code class=\"lang-c\">void Del(BiTree T){//递归删除树算法\n    if(T != NULL){\n        Del(T -&gt; left);\n        Del(T -&gt; right);\n        free(T);\n    }\n}\nvoid DeleteX(BiTree root,int x){\n    BiTree Queue[MaxSize];\n    int rear = -1,front = -1;\n    BiTree *p = root;\n    BiTree *pre = NULL;\n    while(p -&gt; right != NULL &amp;&amp; p -&gt; key &lt;= x){\n        pre = p;\n        p = p -&gt; right;\n    }\n    if(p -&gt; key &lt;= x){\n            return;\n    }\n    Queue[++rear] = p;\n    while(rear != front){\n        p = Queue[++front];\n        if(p -&gt; key &gt; x){\n            Queue[++rear] = p -&gt; left;\n            pre -&gt; right = p -&gt; left;\n            p -&gt; left = NULL;\n            Del(p);\n        }else{\n            Queue[++rear] = p -&gt; right;\n        }\n    }\n}\n</code></pre>\n"},{"title":"2015-941","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2015-941学硕代码题","description":"2015-941学硕代码题","summary":"2015-941学硕代码题","abbrlink":"9e34","date":"2020-09-22T12:36:24.000Z","password":null,"_content":"## 2015-941\n\n#### 1.判断两个单链表是否相交\n\n- 两个单链表的头指针分别为head1和head2\n- 如果相交则返回第一个交点\n- 要求算法的时间复杂度为$O(length1+length2)$\n\n（1）算法思想\n\n- 先创建一个子函数求出链表长度\n- 主函数：\n- 因为两个链表如果相交，则两个链表中从某一结点开始往后一定全一样\n- 所以长链表比锻炼表前面多出的部分不可能存在交点\n- 利用链表的长度差值n，长链表从第n+1个结点，短链表从第一个结点开始，同时开始遍历\n\n```c\nint len(LinkList L){\n    int i = 0;\n    LNode *p = L;\n    while(p != NULL){\n        i++;\n        p = p -> next;\n    }\n    return i;\n}\nLNode Search(LinkList head1,LinkList head2){\n    int length1 = len(head1);\n    int length2 = len(head2);\n    int n;\n    LNode *q = head1;\n    LNode *s = head2;\n    if(length1 > length2){\n        n = length1 - length2;\n        for(int j = 0; j < n; j++){\n            q = q -> next;\n        }\n    }\n    if(length1 < length2){\n        n = length2 - length1;\n        for(int j = 0; j < n; j++){\n            s = s -> next;\n        }\n    }\n    while(q != NULL && q -> data != s -> data){\n        q = q -> next;\n        s = s -> next;\n    }\n    return q;\n}\n```\n\n#### 2.二叉树各层独生叶结点的数目\n\n- 独生叶结点（既是叶结点又无兄弟结点）\n- root指向二叉树根结点的指针\n- 输出各层独生叶结点的数目\n\n```c\nint shumu(BiTree root){\n    BiTree p = root;\n    int front = -1, rear = -1;\n    int level = 1;//层数\n    int last = 0;\n    int Queue[];\n    if(p = NULL){\n        return 0;\n    }\n    Queue[++rear] = p ;\n    while(front != rear){\n        int num = 0;\n        p = Queue[++front];\n        if(p -> lchild && p -> rchild){   \n            Queue[++rear] = p -> lchild;\n            Queue[++rear] = p -> rchild;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(\"%d\",level);\n                printf(\"%d\",num);\n            }\n        }\n        if(p -> lchild && p -> rchild = NULL){\n            Queue[++rear] = p -> lchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n            }\n        }\n        if(p -> rchild && p -> lchild = NULL){\n            Queue[++rear] = p -> rchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(\"%d\",level);\n                printf(\"%d\",num);\n            }\n        }\n    }\n}\n```","source":"_posts/2015-941.md","raw":"---\ntitle: 2015-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2015-941学硕代码题\ndescription: 2015-941学硕代码题\nsummary: 2015-941学硕代码题\nabbrlink: '9e34'\ndate: 2020-09-22 20:36:24\npassword:\n---\n## 2015-941\n\n#### 1.判断两个单链表是否相交\n\n- 两个单链表的头指针分别为head1和head2\n- 如果相交则返回第一个交点\n- 要求算法的时间复杂度为$O(length1+length2)$\n\n（1）算法思想\n\n- 先创建一个子函数求出链表长度\n- 主函数：\n- 因为两个链表如果相交，则两个链表中从某一结点开始往后一定全一样\n- 所以长链表比锻炼表前面多出的部分不可能存在交点\n- 利用链表的长度差值n，长链表从第n+1个结点，短链表从第一个结点开始，同时开始遍历\n\n```c\nint len(LinkList L){\n    int i = 0;\n    LNode *p = L;\n    while(p != NULL){\n        i++;\n        p = p -> next;\n    }\n    return i;\n}\nLNode Search(LinkList head1,LinkList head2){\n    int length1 = len(head1);\n    int length2 = len(head2);\n    int n;\n    LNode *q = head1;\n    LNode *s = head2;\n    if(length1 > length2){\n        n = length1 - length2;\n        for(int j = 0; j < n; j++){\n            q = q -> next;\n        }\n    }\n    if(length1 < length2){\n        n = length2 - length1;\n        for(int j = 0; j < n; j++){\n            s = s -> next;\n        }\n    }\n    while(q != NULL && q -> data != s -> data){\n        q = q -> next;\n        s = s -> next;\n    }\n    return q;\n}\n```\n\n#### 2.二叉树各层独生叶结点的数目\n\n- 独生叶结点（既是叶结点又无兄弟结点）\n- root指向二叉树根结点的指针\n- 输出各层独生叶结点的数目\n\n```c\nint shumu(BiTree root){\n    BiTree p = root;\n    int front = -1, rear = -1;\n    int level = 1;//层数\n    int last = 0;\n    int Queue[];\n    if(p = NULL){\n        return 0;\n    }\n    Queue[++rear] = p ;\n    while(front != rear){\n        int num = 0;\n        p = Queue[++front];\n        if(p -> lchild && p -> rchild){   \n            Queue[++rear] = p -> lchild;\n            Queue[++rear] = p -> rchild;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(\"%d\",level);\n                printf(\"%d\",num);\n            }\n        }\n        if(p -> lchild && p -> rchild = NULL){\n            Queue[++rear] = p -> lchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n            }\n        }\n        if(p -> rchild && p -> lchild = NULL){\n            Queue[++rear] = p -> rchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(\"%d\",level);\n                printf(\"%d\",num);\n            }\n        }\n    }\n}\n```","slug":"2015-941","published":1,"updated":"2020-09-23T07:52:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q590007a09khcob65lm","content":"<h2 id=\"2015-941\"><a href=\"#2015-941\" class=\"headerlink\" title=\"2015-941\"></a>2015-941</h2><h4 id=\"1-判断两个单链表是否相交\"><a href=\"#1-判断两个单链表是否相交\" class=\"headerlink\" title=\"1.判断两个单链表是否相交\"></a>1.判断两个单链表是否相交</h4><ul>\n<li>两个单链表的头指针分别为head1和head2</li>\n<li>如果相交则返回第一个交点</li>\n<li>要求算法的时间复杂度为$O(length1+length2)$</li>\n</ul>\n<p>（1）算法思想</p>\n<ul>\n<li>先创建一个子函数求出链表长度</li>\n<li>主函数：</li>\n<li>因为两个链表如果相交，则两个链表中从某一结点开始往后一定全一样</li>\n<li>所以长链表比锻炼表前面多出的部分不可能存在交点</li>\n<li>利用链表的长度差值n，长链表从第n+1个结点，短链表从第一个结点开始，同时开始遍历</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int len(LinkList L){\n    int i = 0;\n    LNode *p = L;\n    while(p != NULL){\n        i++;\n        p = p -> next;\n    }\n    return i;\n}\nLNode Search(LinkList head1,LinkList head2){\n    int length1 = len(head1);\n    int length2 = len(head2);\n    int n;\n    LNode *q = head1;\n    LNode *s = head2;\n    if(length1 > length2){\n        n = length1 - length2;\n        for(int j = 0; j < n; j++){\n            q = q -> next;\n        }\n    }\n    if(length1 < length2){\n        n = length2 - length1;\n        for(int j = 0; j < n; j++){\n            s = s -> next;\n        }\n    }\n    while(q != NULL && q -> data != s -> data){\n        q = q -> next;\n        s = s -> next;\n    }\n    return q;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-二叉树各层独生叶结点的数目\"><a href=\"#2-二叉树各层独生叶结点的数目\" class=\"headerlink\" title=\"2.二叉树各层独生叶结点的数目\"></a>2.二叉树各层独生叶结点的数目</h4><ul>\n<li>独生叶结点（既是叶结点又无兄弟结点）</li>\n<li>root指向二叉树根结点的指针</li>\n<li>输出各层独生叶结点的数目</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int shumu(BiTree root){\n    BiTree p = root;\n    int front = -1, rear = -1;\n    int level = 1;//层数\n    int last = 0;\n    int Queue[];\n    if(p = NULL){\n        return 0;\n    }\n    Queue[++rear] = p ;\n    while(front != rear){\n        int num = 0;\n        p = Queue[++front];\n        if(p -> lchild && p -> rchild){   \n            Queue[++rear] = p -> lchild;\n            Queue[++rear] = p -> rchild;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(\"%d\",level);\n                printf(\"%d\",num);\n            }\n        }\n        if(p -> lchild && p -> rchild = NULL){\n            Queue[++rear] = p -> lchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n            }\n        }\n        if(p -> rchild && p -> lchild = NULL){\n            Queue[++rear] = p -> rchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(\"%d\",level);\n                printf(\"%d\",num);\n            }\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2015-941\"><a href=\"#2015-941\" class=\"headerlink\" title=\"2015-941\"></a>2015-941</h2><h4 id=\"1-判断两个单链表是否相交\"><a href=\"#1-判断两个单链表是否相交\" class=\"headerlink\" title=\"1.判断两个单链表是否相交\"></a>1.判断两个单链表是否相交</h4><ul>\n<li>两个单链表的头指针分别为head1和head2</li>\n<li>如果相交则返回第一个交点</li>\n<li>要求算法的时间复杂度为$O(length1+length2)$</li>\n</ul>\n<p>（1）算法思想</p>\n<ul>\n<li>先创建一个子函数求出链表长度</li>\n<li>主函数：</li>\n<li>因为两个链表如果相交，则两个链表中从某一结点开始往后一定全一样</li>\n<li>所以长链表比锻炼表前面多出的部分不可能存在交点</li>\n<li>利用链表的长度差值n，长链表从第n+1个结点，短链表从第一个结点开始，同时开始遍历</li>\n</ul>\n<pre><code class=\"lang-c\">int len(LinkList L){\n    int i = 0;\n    LNode *p = L;\n    while(p != NULL){\n        i++;\n        p = p -&gt; next;\n    }\n    return i;\n}\nLNode Search(LinkList head1,LinkList head2){\n    int length1 = len(head1);\n    int length2 = len(head2);\n    int n;\n    LNode *q = head1;\n    LNode *s = head2;\n    if(length1 &gt; length2){\n        n = length1 - length2;\n        for(int j = 0; j &lt; n; j++){\n            q = q -&gt; next;\n        }\n    }\n    if(length1 &lt; length2){\n        n = length2 - length1;\n        for(int j = 0; j &lt; n; j++){\n            s = s -&gt; next;\n        }\n    }\n    while(q != NULL &amp;&amp; q -&gt; data != s -&gt; data){\n        q = q -&gt; next;\n        s = s -&gt; next;\n    }\n    return q;\n}\n</code></pre>\n<h4 id=\"2-二叉树各层独生叶结点的数目\"><a href=\"#2-二叉树各层独生叶结点的数目\" class=\"headerlink\" title=\"2.二叉树各层独生叶结点的数目\"></a>2.二叉树各层独生叶结点的数目</h4><ul>\n<li>独生叶结点（既是叶结点又无兄弟结点）</li>\n<li>root指向二叉树根结点的指针</li>\n<li>输出各层独生叶结点的数目</li>\n</ul>\n<pre><code class=\"lang-c\">int shumu(BiTree root){\n    BiTree p = root;\n    int front = -1, rear = -1;\n    int level = 1;//层数\n    int last = 0;\n    int Queue[];\n    if(p = NULL){\n        return 0;\n    }\n    Queue[++rear] = p ;\n    while(front != rear){\n        int num = 0;\n        p = Queue[++front];\n        if(p -&gt; lchild &amp;&amp; p -&gt; rchild){   \n            Queue[++rear] = p -&gt; lchild;\n            Queue[++rear] = p -&gt; rchild;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(&quot;%d&quot;,level);\n                printf(&quot;%d&quot;,num);\n            }\n        }\n        if(p -&gt; lchild &amp;&amp; p -&gt; rchild = NULL){\n            Queue[++rear] = p -&gt; lchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n            }\n        }\n        if(p -&gt; rchild &amp;&amp; p -&gt; lchild = NULL){\n            Queue[++rear] = p -&gt; rchild;\n            num = num + 1;\n            if(front == last){\n                level++;\n                last = rear;\n                printf(&quot;%d&quot;,level);\n                printf(&quot;%d&quot;,num);\n            }\n        }\n    }\n}\n</code></pre>\n"},{"title":"2014-941","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2014-941学硕代码题","description":"2014-941学硕代码题","summary":"2014-941学硕代码题","abbrlink":"5e09","date":"2020-09-25T07:27:49.000Z","password":null,"_content":"## 2014-941\n\n#### 1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度\n\n```c\nint swap(int a,int b){\n    int temp = b;\n    b = a;\n    a = temp;\n}\nint shuzu(int A[]){\n    int i,j = 0;\n    while(A[i] != NULL){\n        if(A[i] % 2 != 0){//奇数\n        \ti++;\n        }\n        if(A[i] % 2 = 0){//偶数\n            swap(A[i],A[j]);\n            i++；\n            j++;\n        }\n    }\n    return A;\n}\n```\n\n#### 2.按递减次序打印所有左子树非空，右子树为空的结点的关键字\n\n- **<font color=\"red\">重要</font>**\n\n- 二叉查找树采用链式存储\n- 各个结点的关键词均不相同\n- 非递归算法\n\n------\n\n- 利用栈，先一路走到最右边，然后判断该结点是否符合题意\n- 若不符合转向左子树，继续在左子树的右子树里依次寻找\n\n------\n\n\n```c\nint guanjianzi(BiTree T){\n    BiTree *p = T;\n    int Stack[];\n    int top = -1;\n    while(p || top > -1){\n        while(p){\n            Stack[++top] = p;\n            p = p -> rchild;//右分支向下\n        }\n        if(top > -1){\n            p = Stack[top--];\n            if(p -> lchild != NULL && p -> rchild == NULL){\n                printf(p -> data);\n            }\n            p = p -> lchild;//左分支\n        }//if\n    }//while\n}\n```\n","source":"_posts/2014-941.md","raw":"---\ntitle: 2014-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2014-941学硕代码题\ndescription: 2014-941学硕代码题\nsummary: 2014-941学硕代码题\nabbrlink: '5e09'\ndate: 2020-09-25 15:27:49\npassword:\n---\n## 2014-941\n\n#### 1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度\n\n```c\nint swap(int a,int b){\n    int temp = b;\n    b = a;\n    a = temp;\n}\nint shuzu(int A[]){\n    int i,j = 0;\n    while(A[i] != NULL){\n        if(A[i] % 2 != 0){//奇数\n        \ti++;\n        }\n        if(A[i] % 2 = 0){//偶数\n            swap(A[i],A[j]);\n            i++；\n            j++;\n        }\n    }\n    return A;\n}\n```\n\n#### 2.按递减次序打印所有左子树非空，右子树为空的结点的关键字\n\n- **<font color=\"red\">重要</font>**\n\n- 二叉查找树采用链式存储\n- 各个结点的关键词均不相同\n- 非递归算法\n\n------\n\n- 利用栈，先一路走到最右边，然后判断该结点是否符合题意\n- 若不符合转向左子树，继续在左子树的右子树里依次寻找\n\n------\n\n\n```c\nint guanjianzi(BiTree T){\n    BiTree *p = T;\n    int Stack[];\n    int top = -1;\n    while(p || top > -1){\n        while(p){\n            Stack[++top] = p;\n            p = p -> rchild;//右分支向下\n        }\n        if(top > -1){\n            p = Stack[top--];\n            if(p -> lchild != NULL && p -> rchild == NULL){\n                printf(p -> data);\n            }\n            p = p -> lchild;//左分支\n        }//if\n    }//while\n}\n```\n","slug":"2014-941","published":1,"updated":"2020-09-25T07:31:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5a0009a09kah7x9pia","content":"<h2 id=\"2014-941\"><a href=\"#2014-941\" class=\"headerlink\" title=\"2014-941\"></a>2014-941</h2><h4 id=\"1-将整数数组-1…n-中所有的偶数放到所有奇数之前，并求时间复杂度\"><a href=\"#1-将整数数组-1…n-中所有的偶数放到所有奇数之前，并求时间复杂度\" class=\"headerlink\" title=\"1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度\"></a>1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度</h4><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int swap(int a,int b){\n    int temp = b;\n    b = a;\n    a = temp;\n}\nint shuzu(int A[]){\n    int i,j = 0;\n    while(A[i] != NULL){\n        if(A[i] % 2 != 0){//奇数\n            i++;\n        }\n        if(A[i] % 2 = 0){//偶数\n            swap(A[i],A[j]);\n            i++；\n            j++;\n        }\n    }\n    return A;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-按递减次序打印所有左子树非空，右子树为空的结点的关键字\"><a href=\"#2-按递减次序打印所有左子树非空，右子树为空的结点的关键字\" class=\"headerlink\" title=\"2.按递减次序打印所有左子树非空，右子树为空的结点的关键字\"></a>2.按递减次序打印所有左子树非空，右子树为空的结点的关键字</h4><ul>\n<li><p><strong><font color=\"red\">重要</font></strong></p>\n</li>\n<li><p>二叉查找树采用链式存储</p>\n</li>\n<li>各个结点的关键词均不相同</li>\n<li>非递归算法</li>\n</ul>\n<hr>\n<ul>\n<li>利用栈，先一路走到最右边，然后判断该结点是否符合题意</li>\n<li>若不符合转向左子树，继续在左子树的右子树里依次寻找</li>\n</ul>\n<hr>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int guanjianzi(BiTree T){\n    BiTree *p = T;\n    int Stack[];\n    int top = -1;\n    while(p || top > -1){\n        while(p){\n            Stack[++top] = p;\n            p = p -> rchild;//右分支向下\n        }\n        if(top > -1){\n            p = Stack[top--];\n            if(p -> lchild != NULL && p -> rchild == NULL){\n                printf(p -> data);\n            }\n            p = p -> lchild;//左分支\n        }//if\n    }//while\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2014-941\"><a href=\"#2014-941\" class=\"headerlink\" title=\"2014-941\"></a>2014-941</h2><h4 id=\"1-将整数数组-1…n-中所有的偶数放到所有奇数之前，并求时间复杂度\"><a href=\"#1-将整数数组-1…n-中所有的偶数放到所有奇数之前，并求时间复杂度\" class=\"headerlink\" title=\"1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度\"></a>1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度</h4><pre><code class=\"lang-c\">int swap(int a,int b){\n    int temp = b;\n    b = a;\n    a = temp;\n}\nint shuzu(int A[]){\n    int i,j = 0;\n    while(A[i] != NULL){\n        if(A[i] % 2 != 0){//奇数\n            i++;\n        }\n        if(A[i] % 2 = 0){//偶数\n            swap(A[i],A[j]);\n            i++；\n            j++;\n        }\n    }\n    return A;\n}\n</code></pre>\n<h4 id=\"2-按递减次序打印所有左子树非空，右子树为空的结点的关键字\"><a href=\"#2-按递减次序打印所有左子树非空，右子树为空的结点的关键字\" class=\"headerlink\" title=\"2.按递减次序打印所有左子树非空，右子树为空的结点的关键字\"></a>2.按递减次序打印所有左子树非空，右子树为空的结点的关键字</h4><ul>\n<li><p><strong><font color=\"red\">重要</font></strong></p>\n</li>\n<li><p>二叉查找树采用链式存储</p>\n</li>\n<li>各个结点的关键词均不相同</li>\n<li>非递归算法</li>\n</ul>\n<hr>\n<ul>\n<li>利用栈，先一路走到最右边，然后判断该结点是否符合题意</li>\n<li>若不符合转向左子树，继续在左子树的右子树里依次寻找</li>\n</ul>\n<hr>\n<pre><code class=\"lang-c\">int guanjianzi(BiTree T){\n    BiTree *p = T;\n    int Stack[];\n    int top = -1;\n    while(p || top &gt; -1){\n        while(p){\n            Stack[++top] = p;\n            p = p -&gt; rchild;//右分支向下\n        }\n        if(top &gt; -1){\n            p = Stack[top--];\n            if(p -&gt; lchild != NULL &amp;&amp; p -&gt; rchild == NULL){\n                printf(p -&gt; data);\n            }\n            p = p -&gt; lchild;//左分支\n        }//if\n    }//while\n}\n</code></pre>\n"},{"title":"2016-941","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2016-941学硕代码题","description":"2016-941学硕代码题","summary":"2016-941学硕代码题","abbrlink":"9e70","date":"2020-09-20T10:56:04.000Z","password":null,"_content":"## 2016-941\n\n#### 1.查找倒数第k个值\n\n- 一个带有表头结点的**单链表**，结点结构为（data，link）\n- 链表只给出了头指针list\n- 在不改变链表的前提下，查找出链表中倒数第k个位置上的结点\n- 若查找成功，输出该结点的data域的值，并返回1；否则，只返回0\n\n（1）描述算法基本思想\n\n- 先求出链表的长度\n- 再用链表长度减去倒数第k个，就为倒数第k个的正向下标\n- 例如：链表长度为6，求倒数第2个值，即正数6-2=4下标\n- 在正向循环得出即可\n\n（2）写出代码\n\n（3）分析时间复杂性\n\n```c\ntypedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *link;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\nint DaoshuK(LinkList list，int k){\n    int len = 0;\n    int i = -1;//\n    LNode *p = list, *q = list;   //p用来求链表长度,q开始查找倒数第k个值的下标\n    while(p != NULL){             //求链表长度\n        len++;\n        p = p -> link;\n    }\n    while(q->link){\n        i++;\n        if(i == len-k){           //找倒数第k个值\n            int data = q->data;\n            return data,1；\n        }\n        q = q -> link;\n    }\n    return 0;    \n}\n```\n\n#### 2.输出二叉树序列S\n\n- 输出二叉树序列，以r为树根\n- 给出二叉树序列，输出二叉树\n\n（1）算法思想\n\n- 引入一个辅助栈，以树的先序非递归遍历思想为基础，根据所给序列正向建树。\n- 若当前p指向结点非空，对应序号为0，则他的左右孩子赋值为空；\n- 对应序号为1，则创建一个结点，其左指针指向新创建的结点；\n- 若对应序号为2，则创建两个结点，其左右指针分别指向两个结点\n\n（2）代码\n\n```c\nBiTree CreateTree(BiTree &r,int A[],int len){\n    //该算法根据数组A中序建树，序列长度就是数组长度len\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    int i = 0;//计数值，判断序列结束\n    BiTree p = r, bt = NULL;//p用来遍历，bt用来辅助创造结点\n    while(p != NULL || top != -1 && i < len){\n        if(p != MULL){\n            if(A[i] == 0){\n                p -> lchild = NULL;\n                P -> rchild = NULL;\n                Stack[++top] = p;\n            }\n            if(A[i] == 1){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -> lchild = bt;\n                P -> rchild = NULL;\n                Stack[++top] = NULL;\n            }\n            if(A[i] == 2){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -> lchild = bt;\n                bt = (BiTree)malloc(sizeof(BiTree));\n                P -> rchild = bt;\n                Stack[++top] = p;\n            }\n            i++;\n            p = p -> lchild\n        }else{\n            p = Stack[top--];\n            p = p -> rchild;\n        }\n    }\n    return r;\n}\n```","source":"_posts/2016-941.md","raw":"---\ntitle: 2016-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2016-941学硕代码题\ndescription: 2016-941学硕代码题\nsummary: 2016-941学硕代码题\nabbrlink: '9e70'\ndate: 2020-09-20 18:56:04\npassword:\n---\n## 2016-941\n\n#### 1.查找倒数第k个值\n\n- 一个带有表头结点的**单链表**，结点结构为（data，link）\n- 链表只给出了头指针list\n- 在不改变链表的前提下，查找出链表中倒数第k个位置上的结点\n- 若查找成功，输出该结点的data域的值，并返回1；否则，只返回0\n\n（1）描述算法基本思想\n\n- 先求出链表的长度\n- 再用链表长度减去倒数第k个，就为倒数第k个的正向下标\n- 例如：链表长度为6，求倒数第2个值，即正数6-2=4下标\n- 在正向循环得出即可\n\n（2）写出代码\n\n（3）分析时间复杂性\n\n```c\ntypedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *link;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\nint DaoshuK(LinkList list，int k){\n    int len = 0;\n    int i = -1;//\n    LNode *p = list, *q = list;   //p用来求链表长度,q开始查找倒数第k个值的下标\n    while(p != NULL){             //求链表长度\n        len++;\n        p = p -> link;\n    }\n    while(q->link){\n        i++;\n        if(i == len-k){           //找倒数第k个值\n            int data = q->data;\n            return data,1；\n        }\n        q = q -> link;\n    }\n    return 0;    \n}\n```\n\n#### 2.输出二叉树序列S\n\n- 输出二叉树序列，以r为树根\n- 给出二叉树序列，输出二叉树\n\n（1）算法思想\n\n- 引入一个辅助栈，以树的先序非递归遍历思想为基础，根据所给序列正向建树。\n- 若当前p指向结点非空，对应序号为0，则他的左右孩子赋值为空；\n- 对应序号为1，则创建一个结点，其左指针指向新创建的结点；\n- 若对应序号为2，则创建两个结点，其左右指针分别指向两个结点\n\n（2）代码\n\n```c\nBiTree CreateTree(BiTree &r,int A[],int len){\n    //该算法根据数组A中序建树，序列长度就是数组长度len\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    int i = 0;//计数值，判断序列结束\n    BiTree p = r, bt = NULL;//p用来遍历，bt用来辅助创造结点\n    while(p != NULL || top != -1 && i < len){\n        if(p != MULL){\n            if(A[i] == 0){\n                p -> lchild = NULL;\n                P -> rchild = NULL;\n                Stack[++top] = p;\n            }\n            if(A[i] == 1){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -> lchild = bt;\n                P -> rchild = NULL;\n                Stack[++top] = NULL;\n            }\n            if(A[i] == 2){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -> lchild = bt;\n                bt = (BiTree)malloc(sizeof(BiTree));\n                P -> rchild = bt;\n                Stack[++top] = p;\n            }\n            i++;\n            p = p -> lchild\n        }else{\n            p = Stack[top--];\n            p = p -> rchild;\n        }\n    }\n    return r;\n}\n```","slug":"2016-941","published":1,"updated":"2020-09-22T12:23:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5b000ba09k9fafcny7","content":"<h2 id=\"2016-941\"><a href=\"#2016-941\" class=\"headerlink\" title=\"2016-941\"></a>2016-941</h2><h4 id=\"1-查找倒数第k个值\"><a href=\"#1-查找倒数第k个值\" class=\"headerlink\" title=\"1.查找倒数第k个值\"></a>1.查找倒数第k个值</h4><ul>\n<li>一个带有表头结点的<strong>单链表</strong>，结点结构为（data，link）</li>\n<li>链表只给出了头指针list</li>\n<li>在不改变链表的前提下，查找出链表中倒数第k个位置上的结点</li>\n<li>若查找成功，输出该结点的data域的值，并返回1；否则，只返回0</li>\n</ul>\n<p>（1）描述算法基本思想</p>\n<ul>\n<li>先求出链表的长度</li>\n<li>再用链表长度减去倒数第k个，就为倒数第k个的正向下标</li>\n<li>例如：链表长度为6，求倒数第2个值，即正数6-2=4下标</li>\n<li>在正向循环得出即可</li>\n</ul>\n<p>（2）写出代码</p>\n<p>（3）分析时间复杂性</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">typedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *link;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\nint DaoshuK(LinkList list，int k){\n    int len = 0;\n    int i = -1;//\n    LNode *p = list, *q = list;   //p用来求链表长度,q开始查找倒数第k个值的下标\n    while(p != NULL){             //求链表长度\n        len++;\n        p = p -> link;\n    }\n    while(q->link){\n        i++;\n        if(i == len-k){           //找倒数第k个值\n            int data = q->data;\n            return data,1；\n        }\n        q = q -> link;\n    }\n    return 0;    \n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-输出二叉树序列S\"><a href=\"#2-输出二叉树序列S\" class=\"headerlink\" title=\"2.输出二叉树序列S\"></a>2.输出二叉树序列S</h4><ul>\n<li>输出二叉树序列，以r为树根</li>\n<li>给出二叉树序列，输出二叉树</li>\n</ul>\n<p>（1）算法思想</p>\n<ul>\n<li>引入一个辅助栈，以树的先序非递归遍历思想为基础，根据所给序列正向建树。</li>\n<li>若当前p指向结点非空，对应序号为0，则他的左右孩子赋值为空；</li>\n<li>对应序号为1，则创建一个结点，其左指针指向新创建的结点；</li>\n<li>若对应序号为2，则创建两个结点，其左右指针分别指向两个结点</li>\n</ul>\n<p>（2）代码</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">BiTree CreateTree(BiTree &r,int A[],int len){\n    //该算法根据数组A中序建树，序列长度就是数组长度len\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    int i = 0;//计数值，判断序列结束\n    BiTree p = r, bt = NULL;//p用来遍历，bt用来辅助创造结点\n    while(p != NULL || top != -1 && i < len){\n        if(p != MULL){\n            if(A[i] == 0){\n                p -> lchild = NULL;\n                P -> rchild = NULL;\n                Stack[++top] = p;\n            }\n            if(A[i] == 1){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -> lchild = bt;\n                P -> rchild = NULL;\n                Stack[++top] = NULL;\n            }\n            if(A[i] == 2){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -> lchild = bt;\n                bt = (BiTree)malloc(sizeof(BiTree));\n                P -> rchild = bt;\n                Stack[++top] = p;\n            }\n            i++;\n            p = p -> lchild\n        }else{\n            p = Stack[top--];\n            p = p -> rchild;\n        }\n    }\n    return r;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2016-941\"><a href=\"#2016-941\" class=\"headerlink\" title=\"2016-941\"></a>2016-941</h2><h4 id=\"1-查找倒数第k个值\"><a href=\"#1-查找倒数第k个值\" class=\"headerlink\" title=\"1.查找倒数第k个值\"></a>1.查找倒数第k个值</h4><ul>\n<li>一个带有表头结点的<strong>单链表</strong>，结点结构为（data，link）</li>\n<li>链表只给出了头指针list</li>\n<li>在不改变链表的前提下，查找出链表中倒数第k个位置上的结点</li>\n<li>若查找成功，输出该结点的data域的值，并返回1；否则，只返回0</li>\n</ul>\n<p>（1）描述算法基本思想</p>\n<ul>\n<li>先求出链表的长度</li>\n<li>再用链表长度减去倒数第k个，就为倒数第k个的正向下标</li>\n<li>例如：链表长度为6，求倒数第2个值，即正数6-2=4下标</li>\n<li>在正向循环得出即可</li>\n</ul>\n<p>（2）写出代码</p>\n<p>（3）分析时间复杂性</p>\n<pre><code class=\"lang-c\">typedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *link;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\nint DaoshuK(LinkList list，int k){\n    int len = 0;\n    int i = -1;//\n    LNode *p = list, *q = list;   //p用来求链表长度,q开始查找倒数第k个值的下标\n    while(p != NULL){             //求链表长度\n        len++;\n        p = p -&gt; link;\n    }\n    while(q-&gt;link){\n        i++;\n        if(i == len-k){           //找倒数第k个值\n            int data = q-&gt;data;\n            return data,1；\n        }\n        q = q -&gt; link;\n    }\n    return 0;    \n}\n</code></pre>\n<h4 id=\"2-输出二叉树序列S\"><a href=\"#2-输出二叉树序列S\" class=\"headerlink\" title=\"2.输出二叉树序列S\"></a>2.输出二叉树序列S</h4><ul>\n<li>输出二叉树序列，以r为树根</li>\n<li>给出二叉树序列，输出二叉树</li>\n</ul>\n<p>（1）算法思想</p>\n<ul>\n<li>引入一个辅助栈，以树的先序非递归遍历思想为基础，根据所给序列正向建树。</li>\n<li>若当前p指向结点非空，对应序号为0，则他的左右孩子赋值为空；</li>\n<li>对应序号为1，则创建一个结点，其左指针指向新创建的结点；</li>\n<li>若对应序号为2，则创建两个结点，其左右指针分别指向两个结点</li>\n</ul>\n<p>（2）代码</p>\n<pre><code class=\"lang-c\">BiTree CreateTree(BiTree &amp;r,int A[],int len){\n    //该算法根据数组A中序建树，序列长度就是数组长度len\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    int i = 0;//计数值，判断序列结束\n    BiTree p = r, bt = NULL;//p用来遍历，bt用来辅助创造结点\n    while(p != NULL || top != -1 &amp;&amp; i &lt; len){\n        if(p != MULL){\n            if(A[i] == 0){\n                p -&gt; lchild = NULL;\n                P -&gt; rchild = NULL;\n                Stack[++top] = p;\n            }\n            if(A[i] == 1){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -&gt; lchild = bt;\n                P -&gt; rchild = NULL;\n                Stack[++top] = NULL;\n            }\n            if(A[i] == 2){\n                bt = (BiTree)malloc(sizeof(BiTree));\n                p -&gt; lchild = bt;\n                bt = (BiTree)malloc(sizeof(BiTree));\n                P -&gt; rchild = bt;\n                Stack[++top] = p;\n            }\n            i++;\n            p = p -&gt; lchild\n        }else{\n            p = Stack[top--];\n            p = p -&gt; rchild;\n        }\n    }\n    return r;\n}\n</code></pre>\n"},{"title":"2017-941","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"5e4d","date":"2020-09-18T09:44:34.000Z","password":null,"keywords":"2017-941学硕代码题","description":"2017-941学硕代码题","summary":"2017-941学硕代码题","_content":"## 2017-941\n\n#### 1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\n\n- 要求1：数组C中的每一个元素$C[i] = ||  \\{ A[j]|A[j]≤B[i],1≤j≤n\\}||$，其中$||S||$表示集合S中的元素个数。例如：下表给出了长度为4的两个数组A和B，以及满足要求的数组C\n- 要求2：所设计算法的时间复杂性低于$O(n^2)$\n\n| i    | 1    | 2    | 3    | 4    |\n| ---- | ---- | ---- | ---- | ---- |\n| A[i] | 6    | 17   | 9    | 10   |\n| B[i] | 8    | 2    | 17   | 13   |\n| C[i] | 1    | 0    | 4    | 3    |\n\n（1）描述算法的基本设计思想（3分）；\n\nC[1]的意思就是，A数组中小于等于B[1]的个数；C[2]就是，A数组中小于等于B[2]的个数。以此类推\n\n先将A利用快速排序排好顺序，再用b进行折半查找\n\n（2）用算法描述语言描述算法（8分）；\n\n```c\n//折半查找来确定有序序列A中有多少元素不大于x\nint binarySearch(int A[],int n,int x){\n    int l = 0,r = n-1,m = (l+r)/2;\n    while(l <= r){\n        if(A[m] > x){\n            r = m - 1;\n        }else{\n            l = m + 1;\n        }\n        m = (l+r)/2;\n    }\n    return l;//最后l为小于等于x元素的个数\n}\n//先采用快速排序排列A数组，时间复杂度（nlogn），要求不能超过n方\nint Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low<high){\n        low++;\n        while(A[low]<=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]>pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low<high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n        \tA[low] = A[high];                //用临时变量w储存值，交换两个数\n        \tA[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &A[],int low,int high){   //开始快排\n    if(low<high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n\nvoid getArrayC(int A[],int B[],int C[],int n){\n    Partition(A,0,n);//快排排序\n    for(int i = 0; i < n; ++i){\n        C[i] = binarySearch(A, n, B[i]);//查找\n    }\n}\n```\n\n（3）给出算法的时间复杂性分析（4分）。\n\n- 排序时间$O(nlogn)+$查找时间$O(logn)$，符合要求\n\n#### 2.（10分）写出求二叉树宽度的非递归算法\n\n- **二叉树的宽度定义为具有结点数最多的那一层上的结点总数。如下图所示，以a为根的二叉树宽度为3。假设二叉树以链接结构存储，指针T指向二叉树的根，树中结点的结构为（left，data，right）**\n\n（1）描述算法的基本设计思想（3分）；\n\n- 利用主要层次遍历\n\n- 再加上last指针：指向当前层数最右结点\n\n（2）用算法描述语言描述算法（7分）；\n\n```c\nint MaxBreadth(BiTree T){\n    int front = -1,rear = -1;//队头尾指针\n    int level =1,last = 0;//last指向当前层数最右结点，level为当前层数\n    int width[];//储存每层最大宽度的数组\n    BiTree p = T;//用p遍历二叉树\n    Queue[++rear] = p;//根结点入队\n    if(p == NULL){\n        return 0;\n    }\n    width[level] = 1;//第一层一个结点\n    while(rear > front){ //队列不为空\n        p = Queue[++front];//层次遍历，出队元素\n        if(p->lchild != NULL){\n            Queue[++rear] = p->lchild; //左子树不为空，则左子树根结点入队 \n        } \n        if(p->rchild != NULL){ \n            Queue[++rear] = p->rchild; //右子树不为空，则右子树根节点入队 \n        }\n        if(front == last){//出队元素和last所指向的最右结点相同时\n            width[++level] = rear - last;//该层元素个数等于此时队列的尾指针减去上一层最右结点的位置\n            last = rear;\n        } \n    }\n    //最后得到的层数会多一层 \n    int max=0;\n    for(int i=1;i<=level;i++){\n        if(width[i]>max){\n            max=width[i];\n        }\n    } \n    return max; \n}\n```","source":"_posts/2017-941.md","raw":"---\ntitle: 2017-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nabbrlink: 5e4d\ndate: 2020-09-18 17:44:34\npassword:\nkeywords: 2017-941学硕代码题\ndescription: 2017-941学硕代码题\nsummary: 2017-941学硕代码题\n---\n## 2017-941\n\n#### 1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\n\n- 要求1：数组C中的每一个元素$C[i] = ||  \\{ A[j]|A[j]≤B[i],1≤j≤n\\}||$，其中$||S||$表示集合S中的元素个数。例如：下表给出了长度为4的两个数组A和B，以及满足要求的数组C\n- 要求2：所设计算法的时间复杂性低于$O(n^2)$\n\n| i    | 1    | 2    | 3    | 4    |\n| ---- | ---- | ---- | ---- | ---- |\n| A[i] | 6    | 17   | 9    | 10   |\n| B[i] | 8    | 2    | 17   | 13   |\n| C[i] | 1    | 0    | 4    | 3    |\n\n（1）描述算法的基本设计思想（3分）；\n\nC[1]的意思就是，A数组中小于等于B[1]的个数；C[2]就是，A数组中小于等于B[2]的个数。以此类推\n\n先将A利用快速排序排好顺序，再用b进行折半查找\n\n（2）用算法描述语言描述算法（8分）；\n\n```c\n//折半查找来确定有序序列A中有多少元素不大于x\nint binarySearch(int A[],int n,int x){\n    int l = 0,r = n-1,m = (l+r)/2;\n    while(l <= r){\n        if(A[m] > x){\n            r = m - 1;\n        }else{\n            l = m + 1;\n        }\n        m = (l+r)/2;\n    }\n    return l;//最后l为小于等于x元素的个数\n}\n//先采用快速排序排列A数组，时间复杂度（nlogn），要求不能超过n方\nint Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low<high){\n        low++;\n        while(A[low]<=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]>pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low<high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n        \tA[low] = A[high];                //用临时变量w储存值，交换两个数\n        \tA[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &A[],int low,int high){   //开始快排\n    if(low<high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n\nvoid getArrayC(int A[],int B[],int C[],int n){\n    Partition(A,0,n);//快排排序\n    for(int i = 0; i < n; ++i){\n        C[i] = binarySearch(A, n, B[i]);//查找\n    }\n}\n```\n\n（3）给出算法的时间复杂性分析（4分）。\n\n- 排序时间$O(nlogn)+$查找时间$O(logn)$，符合要求\n\n#### 2.（10分）写出求二叉树宽度的非递归算法\n\n- **二叉树的宽度定义为具有结点数最多的那一层上的结点总数。如下图所示，以a为根的二叉树宽度为3。假设二叉树以链接结构存储，指针T指向二叉树的根，树中结点的结构为（left，data，right）**\n\n（1）描述算法的基本设计思想（3分）；\n\n- 利用主要层次遍历\n\n- 再加上last指针：指向当前层数最右结点\n\n（2）用算法描述语言描述算法（7分）；\n\n```c\nint MaxBreadth(BiTree T){\n    int front = -1,rear = -1;//队头尾指针\n    int level =1,last = 0;//last指向当前层数最右结点，level为当前层数\n    int width[];//储存每层最大宽度的数组\n    BiTree p = T;//用p遍历二叉树\n    Queue[++rear] = p;//根结点入队\n    if(p == NULL){\n        return 0;\n    }\n    width[level] = 1;//第一层一个结点\n    while(rear > front){ //队列不为空\n        p = Queue[++front];//层次遍历，出队元素\n        if(p->lchild != NULL){\n            Queue[++rear] = p->lchild; //左子树不为空，则左子树根结点入队 \n        } \n        if(p->rchild != NULL){ \n            Queue[++rear] = p->rchild; //右子树不为空，则右子树根节点入队 \n        }\n        if(front == last){//出队元素和last所指向的最右结点相同时\n            width[++level] = rear - last;//该层元素个数等于此时队列的尾指针减去上一层最右结点的位置\n            last = rear;\n        } \n    }\n    //最后得到的层数会多一层 \n    int max=0;\n    for(int i=1;i<=level;i++){\n        if(width[i]>max){\n            max=width[i];\n        }\n    } \n    return max; \n}\n```","slug":"2017-941","published":1,"updated":"2020-09-19T14:31:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5d000fa09kdu32frth","content":"<h2 id=\"2017-941\"><a href=\"#2017-941\" class=\"headerlink\" title=\"2017-941\"></a>2017-941</h2><h4 id=\"1-（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\"><a href=\"#1-（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\" class=\"headerlink\" title=\"1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\"></a>1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。</h4><ul>\n<li>要求1：数组C中的每一个元素$C[i] = ||  \\{ A[j]|A[j]≤B[i],1≤j≤n\\}||$，其中$||S||$表示集合S中的元素个数。例如：下表给出了长度为4的两个数组A和B，以及满足要求的数组C</li>\n<li>要求2：所设计算法的时间复杂性低于$O(n^2)$</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>i</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A[i]</td>\n<td>6</td>\n<td>17</td>\n<td>9</td>\n<td>10</td>\n</tr>\n<tr>\n<td>B[i]</td>\n<td>8</td>\n<td>2</td>\n<td>17</td>\n<td>13</td>\n</tr>\n<tr>\n<td>C[i]</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>（1）描述算法的基本设计思想（3分）；</p>\n<p>C[1]的意思就是，A数组中小于等于B[1]的个数；C[2]就是，A数组中小于等于B[2]的个数。以此类推</p>\n<p>先将A利用快速排序排好顺序，再用b进行折半查找</p>\n<p>（2）用算法描述语言描述算法（8分）；</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">//折半查找来确定有序序列A中有多少元素不大于x\nint binarySearch(int A[],int n,int x){\n    int l = 0,r = n-1,m = (l+r)/2;\n    while(l <= r){\n        if(A[m] > x){\n            r = m - 1;\n        }else{\n            l = m + 1;\n        }\n        m = (l+r)/2;\n    }\n    return l;//最后l为小于等于x元素的个数\n}\n//先采用快速排序排列A数组，时间复杂度（nlogn），要求不能超过n方\nint Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low<high){\n        low++;\n        while(A[low]<=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]>pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low<high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n            A[low] = A[high];                //用临时变量w储存值，交换两个数\n            A[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &A[],int low,int high){   //开始快排\n    if(low<high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n\nvoid getArrayC(int A[],int B[],int C[],int n){\n    Partition(A,0,n);//快排排序\n    for(int i = 0; i < n; ++i){\n        C[i] = binarySearch(A, n, B[i]);//查找\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>（3）给出算法的时间复杂性分析（4分）。</p>\n<ul>\n<li>排序时间$O(nlogn)+$查找时间$O(logn)$，符合要求</li>\n</ul>\n<h4 id=\"2-（10分）写出求二叉树宽度的非递归算法\"><a href=\"#2-（10分）写出求二叉树宽度的非递归算法\" class=\"headerlink\" title=\"2.（10分）写出求二叉树宽度的非递归算法\"></a>2.（10分）写出求二叉树宽度的非递归算法</h4><ul>\n<li><strong>二叉树的宽度定义为具有结点数最多的那一层上的结点总数。如下图所示，以a为根的二叉树宽度为3。假设二叉树以链接结构存储，指针T指向二叉树的根，树中结点的结构为（left，data，right）</strong></li>\n</ul>\n<p>（1）描述算法的基本设计思想（3分）；</p>\n<ul>\n<li><p>利用主要层次遍历</p>\n</li>\n<li><p>再加上last指针：指向当前层数最右结点</p>\n</li>\n</ul>\n<p>（2）用算法描述语言描述算法（7分）；</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int MaxBreadth(BiTree T){\n    int front = -1,rear = -1;//队头尾指针\n    int level =1,last = 0;//last指向当前层数最右结点，level为当前层数\n    int width[];//储存每层最大宽度的数组\n    BiTree p = T;//用p遍历二叉树\n    Queue[++rear] = p;//根结点入队\n    if(p == NULL){\n        return 0;\n    }\n    width[level] = 1;//第一层一个结点\n    while(rear > front){ //队列不为空\n        p = Queue[++front];//层次遍历，出队元素\n        if(p->lchild != NULL){\n            Queue[++rear] = p->lchild; //左子树不为空，则左子树根结点入队 \n        } \n        if(p->rchild != NULL){ \n            Queue[++rear] = p->rchild; //右子树不为空，则右子树根节点入队 \n        }\n        if(front == last){//出队元素和last所指向的最右结点相同时\n            width[++level] = rear - last;//该层元素个数等于此时队列的尾指针减去上一层最右结点的位置\n            last = rear;\n        } \n    }\n    //最后得到的层数会多一层 \n    int max=0;\n    for(int i=1;i<=level;i++){\n        if(width[i]>max){\n            max=width[i];\n        }\n    } \n    return max; \n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2017-941\"><a href=\"#2017-941\" class=\"headerlink\" title=\"2017-941\"></a>2017-941</h2><h4 id=\"1-（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\"><a href=\"#1-（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\" class=\"headerlink\" title=\"1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。\"></a>1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。</h4><ul>\n<li>要求1：数组C中的每一个元素$C[i] = ||  \\{ A[j]|A[j]≤B[i],1≤j≤n\\}||$，其中$||S||$表示集合S中的元素个数。例如：下表给出了长度为4的两个数组A和B，以及满足要求的数组C</li>\n<li>要求2：所设计算法的时间复杂性低于$O(n^2)$</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>i</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A[i]</td>\n<td>6</td>\n<td>17</td>\n<td>9</td>\n<td>10</td>\n</tr>\n<tr>\n<td>B[i]</td>\n<td>8</td>\n<td>2</td>\n<td>17</td>\n<td>13</td>\n</tr>\n<tr>\n<td>C[i]</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>（1）描述算法的基本设计思想（3分）；</p>\n<p>C[1]的意思就是，A数组中小于等于B[1]的个数；C[2]就是，A数组中小于等于B[2]的个数。以此类推</p>\n<p>先将A利用快速排序排好顺序，再用b进行折半查找</p>\n<p>（2）用算法描述语言描述算法（8分）；</p>\n<pre><code class=\"lang-c\">//折半查找来确定有序序列A中有多少元素不大于x\nint binarySearch(int A[],int n,int x){\n    int l = 0,r = n-1,m = (l+r)/2;\n    while(l &lt;= r){\n        if(A[m] &gt; x){\n            r = m - 1;\n        }else{\n            l = m + 1;\n        }\n        m = (l+r)/2;\n    }\n    return l;//最后l为小于等于x元素的个数\n}\n//先采用快速排序排列A数组，时间复杂度（nlogn），要求不能超过n方\nint Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low&lt;high){\n        low++;\n        while(A[low]&lt;=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]&gt;pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low&lt;high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n            A[low] = A[high];                //用临时变量w储存值，交换两个数\n            A[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &amp;A[],int low,int high){   //开始快排\n    if(low&lt;high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n\nvoid getArrayC(int A[],int B[],int C[],int n){\n    Partition(A,0,n);//快排排序\n    for(int i = 0; i &lt; n; ++i){\n        C[i] = binarySearch(A, n, B[i]);//查找\n    }\n}\n</code></pre>\n<p>（3）给出算法的时间复杂性分析（4分）。</p>\n<ul>\n<li>排序时间$O(nlogn)+$查找时间$O(logn)$，符合要求</li>\n</ul>\n<h4 id=\"2-（10分）写出求二叉树宽度的非递归算法\"><a href=\"#2-（10分）写出求二叉树宽度的非递归算法\" class=\"headerlink\" title=\"2.（10分）写出求二叉树宽度的非递归算法\"></a>2.（10分）写出求二叉树宽度的非递归算法</h4><ul>\n<li><strong>二叉树的宽度定义为具有结点数最多的那一层上的结点总数。如下图所示，以a为根的二叉树宽度为3。假设二叉树以链接结构存储，指针T指向二叉树的根，树中结点的结构为（left，data，right）</strong></li>\n</ul>\n<p>（1）描述算法的基本设计思想（3分）；</p>\n<ul>\n<li><p>利用主要层次遍历</p>\n</li>\n<li><p>再加上last指针：指向当前层数最右结点</p>\n</li>\n</ul>\n<p>（2）用算法描述语言描述算法（7分）；</p>\n<pre><code class=\"lang-c\">int MaxBreadth(BiTree T){\n    int front = -1,rear = -1;//队头尾指针\n    int level =1,last = 0;//last指向当前层数最右结点，level为当前层数\n    int width[];//储存每层最大宽度的数组\n    BiTree p = T;//用p遍历二叉树\n    Queue[++rear] = p;//根结点入队\n    if(p == NULL){\n        return 0;\n    }\n    width[level] = 1;//第一层一个结点\n    while(rear &gt; front){ //队列不为空\n        p = Queue[++front];//层次遍历，出队元素\n        if(p-&gt;lchild != NULL){\n            Queue[++rear] = p-&gt;lchild; //左子树不为空，则左子树根结点入队 \n        } \n        if(p-&gt;rchild != NULL){ \n            Queue[++rear] = p-&gt;rchild; //右子树不为空，则右子树根节点入队 \n        }\n        if(front == last){//出队元素和last所指向的最右结点相同时\n            width[++level] = rear - last;//该层元素个数等于此时队列的尾指针减去上一层最右结点的位置\n            last = rear;\n        } \n    }\n    //最后得到的层数会多一层 \n    int max=0;\n    for(int i=1;i&lt;=level;i++){\n        if(width[i]&gt;max){\n            max=width[i];\n        }\n    } \n    return max; \n}\n</code></pre>\n"},{"title":"2020吉林大学心理学拟录取名单","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"2020心理学录取名单","abbrlink":"a3e2","date":"2020-06-03T12:56:45.000Z","password":null,"_content":"## -2020吉林大学心理学拟录取名单-\n* * *\n| 姓名 | 初试总分 | 报考专业 | 复试成绩 | 总成绩 | 备注           |\n| ------ | -------- | ---------- | -------- | ------ | ---------------- |\n| 王曼玉 | 376      | 基础心理学 | 285      | 81.14  | 　              |\n| 王青 | 371      | 基础心理学 | 286      | 80.54  | 　              |\n| 陈楚浩 | 404      | 应用心理学 | 285      | 85.06  | 　              |\n| 董洁 | 398      | 应用心理学 | 282      | 83.92  | 　              |\n| 杨杭 | 379      | 应用心理学 | 278      | 80.86  | 　              |\n| 任志颖 | 377      | 应用心理学 | 276      | 80.38  | 　              |\n| 张晗 | 364      | 应用心理学 | 278      | 78.76  | 　              |\n| 贾玉洁 | 417      | 应用心理 | 282      | 86.58  | 　              |\n| 卢梦歌 | 415      | 应用心理 | 281      | 86.2   | 　              |\n| 刘云欢 | 397      | 应用心理 | 283      | 83.88  | 　              |\n| 罗光霞 | 391      | 应用心理 | 282      | 82.94  | 　              |\n| 鲍守頔 | 399      | 应用心理 | 270      | 82.86  | 　              |\n| 徐帅 | 385      | 应用心理 | 288      | 82.7   | 　              |\n| 刘力萌 | 389      | 应用心理 | 279      | 82.36  | 　              |\n| 王玉倩 | 387      | 应用心理 | 278      | 81.98  | 　              |\n| 唐紫薇 | 385      | 应用心理 | 277      | 81.6   | 　              |\n| 王贝 | 383      | 应用心理 | 276      | 81.22  | 　              |\n| 吴峰 | 382      | 应用心理 | 277      | 81.18  | 　              |\n| 董维 | 379      | 应用心理 | 275      | 80.56  | 　              |\n| 田飞霜 | 378      | 应用心理 | 275      | 80.42  | 　              |\n| 张彦琪 | 335      | 应用心理 | 273      | 74.2   | 退役大学生计划 |\n| 马莹 | 292      | 应用心理 | 276      | 68.48  | 少数民族骨干计划 |","source":"_posts/2020吉林大学心理学拟录取名单.md","raw":"---\ntitle: 2020吉林大学心理学拟录取名单\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 2020心理学录取名单\ntags:\n  - 考研\n  - 心理学\ncategories:\n  - 菁菁\nabbrlink: a3e2\ndate: 2020-06-03 20:56:45\npassword:\n---\n## -2020吉林大学心理学拟录取名单-\n* * *\n| 姓名 | 初试总分 | 报考专业 | 复试成绩 | 总成绩 | 备注           |\n| ------ | -------- | ---------- | -------- | ------ | ---------------- |\n| 王曼玉 | 376      | 基础心理学 | 285      | 81.14  | 　              |\n| 王青 | 371      | 基础心理学 | 286      | 80.54  | 　              |\n| 陈楚浩 | 404      | 应用心理学 | 285      | 85.06  | 　              |\n| 董洁 | 398      | 应用心理学 | 282      | 83.92  | 　              |\n| 杨杭 | 379      | 应用心理学 | 278      | 80.86  | 　              |\n| 任志颖 | 377      | 应用心理学 | 276      | 80.38  | 　              |\n| 张晗 | 364      | 应用心理学 | 278      | 78.76  | 　              |\n| 贾玉洁 | 417      | 应用心理 | 282      | 86.58  | 　              |\n| 卢梦歌 | 415      | 应用心理 | 281      | 86.2   | 　              |\n| 刘云欢 | 397      | 应用心理 | 283      | 83.88  | 　              |\n| 罗光霞 | 391      | 应用心理 | 282      | 82.94  | 　              |\n| 鲍守頔 | 399      | 应用心理 | 270      | 82.86  | 　              |\n| 徐帅 | 385      | 应用心理 | 288      | 82.7   | 　              |\n| 刘力萌 | 389      | 应用心理 | 279      | 82.36  | 　              |\n| 王玉倩 | 387      | 应用心理 | 278      | 81.98  | 　              |\n| 唐紫薇 | 385      | 应用心理 | 277      | 81.6   | 　              |\n| 王贝 | 383      | 应用心理 | 276      | 81.22  | 　              |\n| 吴峰 | 382      | 应用心理 | 277      | 81.18  | 　              |\n| 董维 | 379      | 应用心理 | 275      | 80.56  | 　              |\n| 田飞霜 | 378      | 应用心理 | 275      | 80.42  | 　              |\n| 张彦琪 | 335      | 应用心理 | 273      | 74.2   | 退役大学生计划 |\n| 马莹 | 292      | 应用心理 | 276      | 68.48  | 少数民族骨干计划 |","slug":"2020吉林大学心理学拟录取名单","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5e000ga09ke0mdcpvn","content":"<h2 id=\"2020吉林大学心理学拟录取名单\"><a href=\"#2020吉林大学心理学拟录取名单\" class=\"headerlink\" title=\"-2020吉林大学心理学拟录取名单-\"></a>-2020吉林大学心理学拟录取名单-</h2><hr>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>初试总分</th>\n<th>报考专业</th>\n<th>复试成绩</th>\n<th>总成绩</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>王曼玉</td>\n<td>376</td>\n<td>基础心理学</td>\n<td>285</td>\n<td>81.14</td>\n<td>　</td>\n</tr>\n<tr>\n<td>王青</td>\n<td>371</td>\n<td>基础心理学</td>\n<td>286</td>\n<td>80.54</td>\n<td>　</td>\n</tr>\n<tr>\n<td>陈楚浩</td>\n<td>404</td>\n<td>应用心理学</td>\n<td>285</td>\n<td>85.06</td>\n<td>　</td>\n</tr>\n<tr>\n<td>董洁</td>\n<td>398</td>\n<td>应用心理学</td>\n<td>282</td>\n<td>83.92</td>\n<td>　</td>\n</tr>\n<tr>\n<td>杨杭</td>\n<td>379</td>\n<td>应用心理学</td>\n<td>278</td>\n<td>80.86</td>\n<td>　</td>\n</tr>\n<tr>\n<td>任志颖</td>\n<td>377</td>\n<td>应用心理学</td>\n<td>276</td>\n<td>80.38</td>\n<td>　</td>\n</tr>\n<tr>\n<td>张晗</td>\n<td>364</td>\n<td>应用心理学</td>\n<td>278</td>\n<td>78.76</td>\n<td>　</td>\n</tr>\n<tr>\n<td>贾玉洁</td>\n<td>417</td>\n<td>应用心理</td>\n<td>282</td>\n<td>86.58</td>\n<td>　</td>\n</tr>\n<tr>\n<td>卢梦歌</td>\n<td>415</td>\n<td>应用心理</td>\n<td>281</td>\n<td>86.2</td>\n<td>　</td>\n</tr>\n<tr>\n<td>刘云欢</td>\n<td>397</td>\n<td>应用心理</td>\n<td>283</td>\n<td>83.88</td>\n<td>　</td>\n</tr>\n<tr>\n<td>罗光霞</td>\n<td>391</td>\n<td>应用心理</td>\n<td>282</td>\n<td>82.94</td>\n<td>　</td>\n</tr>\n<tr>\n<td>鲍守頔</td>\n<td>399</td>\n<td>应用心理</td>\n<td>270</td>\n<td>82.86</td>\n<td>　</td>\n</tr>\n<tr>\n<td>徐帅</td>\n<td>385</td>\n<td>应用心理</td>\n<td>288</td>\n<td>82.7</td>\n<td>　</td>\n</tr>\n<tr>\n<td>刘力萌</td>\n<td>389</td>\n<td>应用心理</td>\n<td>279</td>\n<td>82.36</td>\n<td>　</td>\n</tr>\n<tr>\n<td>王玉倩</td>\n<td>387</td>\n<td>应用心理</td>\n<td>278</td>\n<td>81.98</td>\n<td>　</td>\n</tr>\n<tr>\n<td>唐紫薇</td>\n<td>385</td>\n<td>应用心理</td>\n<td>277</td>\n<td>81.6</td>\n<td>　</td>\n</tr>\n<tr>\n<td>王贝</td>\n<td>383</td>\n<td>应用心理</td>\n<td>276</td>\n<td>81.22</td>\n<td>　</td>\n</tr>\n<tr>\n<td>吴峰</td>\n<td>382</td>\n<td>应用心理</td>\n<td>277</td>\n<td>81.18</td>\n<td>　</td>\n</tr>\n<tr>\n<td>董维</td>\n<td>379</td>\n<td>应用心理</td>\n<td>275</td>\n<td>80.56</td>\n<td>　</td>\n</tr>\n<tr>\n<td>田飞霜</td>\n<td>378</td>\n<td>应用心理</td>\n<td>275</td>\n<td>80.42</td>\n<td>　</td>\n</tr>\n<tr>\n<td>张彦琪</td>\n<td>335</td>\n<td>应用心理</td>\n<td>273</td>\n<td>74.2</td>\n<td>退役大学生计划</td>\n</tr>\n<tr>\n<td>马莹</td>\n<td>292</td>\n<td>应用心理</td>\n<td>276</td>\n<td>68.48</td>\n<td>少数民族骨干计划</td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2020吉林大学心理学拟录取名单\"><a href=\"#2020吉林大学心理学拟录取名单\" class=\"headerlink\" title=\"-2020吉林大学心理学拟录取名单-\"></a>-2020吉林大学心理学拟录取名单-</h2><hr>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>初试总分</th>\n<th>报考专业</th>\n<th>复试成绩</th>\n<th>总成绩</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>王曼玉</td>\n<td>376</td>\n<td>基础心理学</td>\n<td>285</td>\n<td>81.14</td>\n<td>　</td>\n</tr>\n<tr>\n<td>王青</td>\n<td>371</td>\n<td>基础心理学</td>\n<td>286</td>\n<td>80.54</td>\n<td>　</td>\n</tr>\n<tr>\n<td>陈楚浩</td>\n<td>404</td>\n<td>应用心理学</td>\n<td>285</td>\n<td>85.06</td>\n<td>　</td>\n</tr>\n<tr>\n<td>董洁</td>\n<td>398</td>\n<td>应用心理学</td>\n<td>282</td>\n<td>83.92</td>\n<td>　</td>\n</tr>\n<tr>\n<td>杨杭</td>\n<td>379</td>\n<td>应用心理学</td>\n<td>278</td>\n<td>80.86</td>\n<td>　</td>\n</tr>\n<tr>\n<td>任志颖</td>\n<td>377</td>\n<td>应用心理学</td>\n<td>276</td>\n<td>80.38</td>\n<td>　</td>\n</tr>\n<tr>\n<td>张晗</td>\n<td>364</td>\n<td>应用心理学</td>\n<td>278</td>\n<td>78.76</td>\n<td>　</td>\n</tr>\n<tr>\n<td>贾玉洁</td>\n<td>417</td>\n<td>应用心理</td>\n<td>282</td>\n<td>86.58</td>\n<td>　</td>\n</tr>\n<tr>\n<td>卢梦歌</td>\n<td>415</td>\n<td>应用心理</td>\n<td>281</td>\n<td>86.2</td>\n<td>　</td>\n</tr>\n<tr>\n<td>刘云欢</td>\n<td>397</td>\n<td>应用心理</td>\n<td>283</td>\n<td>83.88</td>\n<td>　</td>\n</tr>\n<tr>\n<td>罗光霞</td>\n<td>391</td>\n<td>应用心理</td>\n<td>282</td>\n<td>82.94</td>\n<td>　</td>\n</tr>\n<tr>\n<td>鲍守頔</td>\n<td>399</td>\n<td>应用心理</td>\n<td>270</td>\n<td>82.86</td>\n<td>　</td>\n</tr>\n<tr>\n<td>徐帅</td>\n<td>385</td>\n<td>应用心理</td>\n<td>288</td>\n<td>82.7</td>\n<td>　</td>\n</tr>\n<tr>\n<td>刘力萌</td>\n<td>389</td>\n<td>应用心理</td>\n<td>279</td>\n<td>82.36</td>\n<td>　</td>\n</tr>\n<tr>\n<td>王玉倩</td>\n<td>387</td>\n<td>应用心理</td>\n<td>278</td>\n<td>81.98</td>\n<td>　</td>\n</tr>\n<tr>\n<td>唐紫薇</td>\n<td>385</td>\n<td>应用心理</td>\n<td>277</td>\n<td>81.6</td>\n<td>　</td>\n</tr>\n<tr>\n<td>王贝</td>\n<td>383</td>\n<td>应用心理</td>\n<td>276</td>\n<td>81.22</td>\n<td>　</td>\n</tr>\n<tr>\n<td>吴峰</td>\n<td>382</td>\n<td>应用心理</td>\n<td>277</td>\n<td>81.18</td>\n<td>　</td>\n</tr>\n<tr>\n<td>董维</td>\n<td>379</td>\n<td>应用心理</td>\n<td>275</td>\n<td>80.56</td>\n<td>　</td>\n</tr>\n<tr>\n<td>田飞霜</td>\n<td>378</td>\n<td>应用心理</td>\n<td>275</td>\n<td>80.42</td>\n<td>　</td>\n</tr>\n<tr>\n<td>张彦琪</td>\n<td>335</td>\n<td>应用心理</td>\n<td>273</td>\n<td>74.2</td>\n<td>退役大学生计划</td>\n</tr>\n<tr>\n<td>马莹</td>\n<td>292</td>\n<td>应用心理</td>\n<td>276</td>\n<td>68.48</td>\n<td>少数民族骨干计划</td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"2018-941","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2018-941学硕代码题","description":"2018-941学硕代码题","summary":"2018-941学硕代码题","abbrlink":"5f19","date":"2020-09-17T13:17:06.000Z","password":null,"_content":"## 2018-941-学硕-其他-数组\n\n#### 1.已知k阶斐波那契数列的定义为：\n\n​\t$f_0=0,f_1=0,…f_{k-2}=0,f_{k-1}=1,$\n\n​\t$f_n=f_{n-1}+f_{n-2}+…+f_{n-k},n=k,k+1,…$\n\n（1）试编写求$k$阶斐波那契序列的第$m$项值的非递归函数$F(k,m)$\n\n（2）计算$F(5,8)$的值\n\n- 算法思想：$k$阶斐波那契数列从第$0$项到$k-2$项全为$0$，$k-1$项为$1$，从第$k$项开始每项为前$2$项之和\n\n```c\nint F(int k,int m){\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if(m ≤ (k-2)){//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for(int j = k-1;j < m;j++){\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    return f;\n}\n```\n\n- C语言可执行代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m <= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j < m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(\"%d\", f);\n    return f;\n}\n\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(\"%s\",\"没有\");\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else{\n\n            //return printf(\"%s\",\"没有\");\n            return false;\n        }\n    }\n}\n\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(\"Fibonacci: %d\\n\",Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    printf(\"是否为子孙: %d\",status);\n    return 0;\n}\n```\n\n#### 2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙\n\n```c\n//递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n   int flag = 0;\n   if(!v){\n       return false;\n   }else{\n       if(L[v] == u || R[v] ==  u){\n           return true;\n       }else if(Dencendant(L,R,n,u,L[v]) || Dencendant(L,R,n,u,R[v])){\n           return true;\n       }else{\n           return false;\n       }\n   }\n}\n\n//非递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n    int Queue[MaxSize];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 && u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 && u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\n```\n\n- C语言可执行代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m <= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j < m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(\"%d\", f);\n    return f;\n}\n//递归\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(\"%s\",\"没有\");\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else{\n\n            //return printf(\"%s\",\"没有\");\n            return false;\n        }\n    }\n}\n//非递归\nbool IsDescendant1(int L[],int R[],int n,int u,int v){\n    int Queue[50];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 && u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 && u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(\"Fibonacci: %d\\n\",Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    bool status1 = IsDescendant1(A,B,n,u,v);\n    printf(\"（非递归）是否为子孙: %d\",status);\n    printf(\"（递归）是否为子孙: %d\",status1);\n    return 0;\n}\n\n```\n","source":"_posts/2018-941.md","raw":"---\ntitle: 2018-941\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2018-941学硕代码题\ndescription: 2018-941学硕代码题\nsummary: 2018-941学硕代码题\nabbrlink: 5f19\ndate: 2020-09-17 21:17:06\npassword:\n---\n## 2018-941-学硕-其他-数组\n\n#### 1.已知k阶斐波那契数列的定义为：\n\n​\t$f_0=0,f_1=0,…f_{k-2}=0,f_{k-1}=1,$\n\n​\t$f_n=f_{n-1}+f_{n-2}+…+f_{n-k},n=k,k+1,…$\n\n（1）试编写求$k$阶斐波那契序列的第$m$项值的非递归函数$F(k,m)$\n\n（2）计算$F(5,8)$的值\n\n- 算法思想：$k$阶斐波那契数列从第$0$项到$k-2$项全为$0$，$k-1$项为$1$，从第$k$项开始每项为前$2$项之和\n\n```c\nint F(int k,int m){\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if(m ≤ (k-2)){//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for(int j = k-1;j < m;j++){\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    return f;\n}\n```\n\n- C语言可执行代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m <= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j < m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(\"%d\", f);\n    return f;\n}\n\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(\"%s\",\"没有\");\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else{\n\n            //return printf(\"%s\",\"没有\");\n            return false;\n        }\n    }\n}\n\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(\"Fibonacci: %d\\n\",Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    printf(\"是否为子孙: %d\",status);\n    return 0;\n}\n```\n\n#### 2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙\n\n```c\n//递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n   int flag = 0;\n   if(!v){\n       return false;\n   }else{\n       if(L[v] == u || R[v] ==  u){\n           return true;\n       }else if(Dencendant(L,R,n,u,L[v]) || Dencendant(L,R,n,u,R[v])){\n           return true;\n       }else{\n           return false;\n       }\n   }\n}\n\n//非递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n    int Queue[MaxSize];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 && u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 && u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\n```\n\n- C语言可执行代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m <= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j < m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(\"%d\", f);\n    return f;\n}\n//递归\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(\"%s\",\"没有\");\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else{\n\n            //return printf(\"%s\",\"没有\");\n            return false;\n        }\n    }\n}\n//非递归\nbool IsDescendant1(int L[],int R[],int n,int u,int v){\n    int Queue[50];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 && u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 && u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(\"Fibonacci: %d\\n\",Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    bool status1 = IsDescendant1(A,B,n,u,v);\n    printf(\"（非递归）是否为子孙: %d\",status);\n    printf(\"（递归）是否为子孙: %d\",status1);\n    return 0;\n}\n\n```\n","slug":"2018-941","published":1,"updated":"2020-10-07T11:16:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5f000la09k7zhrhrnm","content":"<h2 id=\"2018-941-学硕-其他-数组\"><a href=\"#2018-941-学硕-其他-数组\" class=\"headerlink\" title=\"2018-941-学硕-其他-数组\"></a>2018-941-学硕-其他-数组</h2><h4 id=\"1-已知k阶斐波那契数列的定义为：\"><a href=\"#1-已知k阶斐波那契数列的定义为：\" class=\"headerlink\" title=\"1.已知k阶斐波那契数列的定义为：\"></a>1.已知k阶斐波那契数列的定义为：</h4><p>​    $f_0=0,f_1=0,…f_{k-2}=0,f_{k-1}=1,$</p>\n<p>​    $f_n=f_{n-1}+f_{n-2}+…+f_{n-k},n=k,k+1,…$</p>\n<p>（1）试编写求$k$阶斐波那契序列的第$m$项值的非递归函数$F(k,m)$</p>\n<p>（2）计算$F(5,8)$的值</p>\n<ul>\n<li>算法思想：$k$阶斐波那契数列从第$0$项到$k-2$项全为$0$，$k-1$项为$1$，从第$k$项开始每项为前$2$项之和</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int F(int k,int m){\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if(m ≤ (k-2)){//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for(int j = k-1;j < m;j++){\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    return f;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>C语言可执行代码</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m <= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j < m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(\"%d\", f);\n    return f;\n}\n\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(\"%s\",\"没有\");\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else{\n\n            //return printf(\"%s\",\"没有\");\n            return false;\n        }\n    }\n}\n\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(\"Fibonacci: %d\\n\",Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    printf(\"是否为子孙: %d\",status);\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-假定用两个一维数组-L-1-n-和-R-1-n-作为有-n-个结点二叉树的存储结构，-L-i-和-R-i-分别指示结点-i-的左儿子和右儿子，-0-表示空。试写一个算法判断结点u是否为结点-v-的子孙\"><a href=\"#2-假定用两个一维数组-L-1-n-和-R-1-n-作为有-n-个结点二叉树的存储结构，-L-i-和-R-i-分别指示结点-i-的左儿子和右儿子，-0-表示空。试写一个算法判断结点u是否为结点-v-的子孙\" class=\"headerlink\" title=\"2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙\"></a>2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙</h4><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">//递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n   int flag = 0;\n   if(!v){\n       return false;\n   }else{\n       if(L[v] == u || R[v] ==  u){\n           return true;\n       }else if(Dencendant(L,R,n,u,L[v]) || Dencendant(L,R,n,u,R[v])){\n           return true;\n       }else{\n           return false;\n       }\n   }\n}\n\n//非递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n    int Queue[MaxSize];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 && u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 && u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>C语言可执行代码</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m <= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j < m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(\"%d\", f);\n    return f;\n}\n//递归\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(\"%s\",\"没有\");\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(\"%s\",\"有\");\n            return true;\n        }else{\n\n            //return printf(\"%s\",\"没有\");\n            return false;\n        }\n    }\n}\n//非递归\nbool IsDescendant1(int L[],int R[],int n,int u,int v){\n    int Queue[50];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 && u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 && u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(\"Fibonacci: %d\\n\",Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    bool status1 = IsDescendant1(A,B,n,u,v);\n    printf(\"（非递归）是否为子孙: %d\",status);\n    printf(\"（递归）是否为子孙: %d\",status1);\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2018-941-学硕-其他-数组\"><a href=\"#2018-941-学硕-其他-数组\" class=\"headerlink\" title=\"2018-941-学硕-其他-数组\"></a>2018-941-学硕-其他-数组</h2><h4 id=\"1-已知k阶斐波那契数列的定义为：\"><a href=\"#1-已知k阶斐波那契数列的定义为：\" class=\"headerlink\" title=\"1.已知k阶斐波那契数列的定义为：\"></a>1.已知k阶斐波那契数列的定义为：</h4><p>​    $f_0=0,f_1=0,…f_{k-2}=0,f_{k-1}=1,$</p>\n<p>​    $f_n=f_{n-1}+f_{n-2}+…+f_{n-k},n=k,k+1,…$</p>\n<p>（1）试编写求$k$阶斐波那契序列的第$m$项值的非递归函数$F(k,m)$</p>\n<p>（2）计算$F(5,8)$的值</p>\n<ul>\n<li>算法思想：$k$阶斐波那契数列从第$0$项到$k-2$项全为$0$，$k-1$项为$1$，从第$k$项开始每项为前$2$项之和</li>\n</ul>\n<pre><code class=\"lang-c\">int F(int k,int m){\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if(m ≤ (k-2)){//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for(int j = k-1;j &lt; m;j++){\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    return f;\n}\n</code></pre>\n<ul>\n<li>C语言可执行代码</li>\n</ul>\n<pre><code class=\"lang-c\">#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m &lt;= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j &lt; m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(&quot;%d&quot;, f);\n    return f;\n}\n\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(&quot;%s&quot;,&quot;没有&quot;);\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(&quot;%s&quot;,&quot;有&quot;);\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(&quot;%s&quot;,&quot;有&quot;);\n            return true;\n        }else{\n\n            //return printf(&quot;%s&quot;,&quot;没有&quot;);\n            return false;\n        }\n    }\n}\n\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(&quot;Fibonacci: %d\\n&quot;,Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    printf(&quot;是否为子孙: %d&quot;,status);\n    return 0;\n}\n</code></pre>\n<h4 id=\"2-假定用两个一维数组-L-1-n-和-R-1-n-作为有-n-个结点二叉树的存储结构，-L-i-和-R-i-分别指示结点-i-的左儿子和右儿子，-0-表示空。试写一个算法判断结点u是否为结点-v-的子孙\"><a href=\"#2-假定用两个一维数组-L-1-n-和-R-1-n-作为有-n-个结点二叉树的存储结构，-L-i-和-R-i-分别指示结点-i-的左儿子和右儿子，-0-表示空。试写一个算法判断结点u是否为结点-v-的子孙\" class=\"headerlink\" title=\"2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙\"></a>2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙</h4><pre><code class=\"lang-c\">//递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n   int flag = 0;\n   if(!v){\n       return false;\n   }else{\n       if(L[v] == u || R[v] ==  u){\n           return true;\n       }else if(Dencendant(L,R,n,u,L[v]) || Dencendant(L,R,n,u,R[v])){\n           return true;\n       }else{\n           return false;\n       }\n   }\n}\n\n//非递归方法\nbool IsDescendant(int L[],int R[],int n,int u,int v){\n    int Queue[MaxSize];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 &amp;&amp; u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 &amp;&amp; u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\n</code></pre>\n<ul>\n<li>C语言可执行代码</li>\n</ul>\n<pre><code class=\"lang-c\">#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n\nint F(int k, int m) {\n    int f = 1, a = 0, b = 0;//a为第一项f0=1\n    if (m &lt;= (k - 2)) {//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2\n        return 0;\n    }\n    for (int j = k - 1; j &lt; m; j++) {\n        b = f;\n        f = f + a;\n        a = b;\n    }\n    //printf(&quot;%d&quot;, f);\n    return f;\n}\n//递归\nbool IsDescendant(int L[], int R[], int n, int u, int v) {\n    if(!v){\n        //return printf(&quot;%s&quot;,&quot;没有&quot;);\n        return false;\n    }\n    else{\n        if(L[v] == u || R[v] == u){\n            //return printf(&quot;%s&quot;,&quot;有&quot;);\n            return true;\n        }else if(IsDescendant(L, R, n, u, L[v]) || IsDescendant(L, R, n, u, R[v])){\n            //return printf(&quot;%s&quot;,&quot;有&quot;);\n            return true;\n        }else{\n\n            //return printf(&quot;%s&quot;,&quot;没有&quot;);\n            return false;\n        }\n    }\n}\n//非递归\nbool IsDescendant1(int L[],int R[],int n,int u,int v){\n    int Queue[50];\n    int rear = -1,front = -1,p;\n    if(L[v] != 0 &amp;&amp; u != v){\n        Queue[++rear] = L[v];//v的左孩子入队\n    }\n    if(R[v] != 0 &amp;&amp; u != v){\n        Queue[++rear] = R[v];//v的右孩子入队\n    }\n    while(front != rear){//队不为空时\n        p = Queue[++front];\n        if(p == u){\n            return true;\n        }else{\n            if(L[p] != 0){\n                Queue[++rear] = L[p];\n            }\n            if(R[p] != 0){\n                Queue[++rear] = R[p];\n            }\n        }\n    }\n    return false;\n}\nint main() {\n    int Fibonacci = F(1, 4);\n    printf(&quot;Fibonacci: %d\\n&quot;,Fibonacci);\n    int n =6,u=4,v=2;\n    int A[] = {0,2,4,0,0,0};\n    int B[] = {0,3,5,0,0,0};\n    bool status = IsDescendant(A,B,n,u,v);\n    bool status1 = IsDescendant1(A,B,n,u,v);\n    printf(&quot;（非递归）是否为子孙: %d&quot;,status);\n    printf(&quot;（递归）是否为子孙: %d&quot;,status1);\n    return 0;\n}\n</code></pre>\n"},{"title":"7月份学习计划","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"学习计划","abbrlink":"4cfa","date":"2020-07-01T12:06:05.000Z","password":null,"_content":"<center> <h2>7月份学习计划<h2></center>\n\n| <center>7月份</center> | <center>数学</center>                                        | <center>专业课</center>                                      | <center>英语</center>                                        | <center>政治</center>                       | <center>完成度</center>          |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------- | -------------------------------- |\n| 7.1                    | 1.1000题高数第16讲BC <br>2.看第7章BC组讲解                   | 1.2018年计专数据结构基础题                                   | 1.整理句子<br> 2.背单词                                      | 对立统一                                    | <center>:sun_with_face:</center> |\n| 7.2                    | 1.1000题高数第17讲BC <br>2.看第8章BC组讲解                   | 1.2017年计专数据结构基础题 <br>2.2018计算机学硕两道代码 <br>3.对照常青藤与课本复习计算机网络其余部分 | 1.恋恋有词Unit6 Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词 | 质量互变定律                                | <center>:sun_with_face:</center> |\n| 7.3                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.4                    | 1.1000题高数第18讲25道题<br>2.看第9章BC组讲解                | 1.2016年计专数据结构基础题 <br>2.2017计算机学硕两道代码 <br>3.冲刺讲义数据结构看完4.2和代码讲义链表代码 <br>4.2018学硕计网真题 | 1.恋恋有词Unit7 Lesson1 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词 | 否定之否定定律                              | <center>:frowning:</center>      |\n| 7.5                    | 1.1000题高数第18讲剩余题目<br>2.看第10章BC组讲解             | 1.2015年计专数据结构基础题 <br>2.2018学硕计网真题            | 1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词 | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.6                    | 1.1000题线代第1、2讲BC <br>2.看第11、12章BC组讲解            | 1.2014年计专数据结构基础题 <br>2.冲刺讲义数据结构看完4.2 <br>3.2017学硕计网真题 | 1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词 | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.7                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.8                    | 1.1000题线代第3-1讲 <br>2.看第13章讲解                       | 1.2013年计专数据结构基础题 <br>2.学习2017学硕计网选择题知识点 <br>3.冲刺讲义数据结构看4.3 | 1.做真题2010.3并看李旭相应视频 <br>2.背所学课程单词          | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.9                    | 1.1000题线代第3-2讲 <br>2.看第14章讲解                       | 1.2012年计专数据结构基础题 <br>2.2016学硕计网 <br>3.冲刺讲义数据结构看4.4 | 1.做真题2010.4并看李旭相应视频 <br>2.背所学课程单词          | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.10                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.11                   | 烧烤BBQ                                                      | 烧烤BBQ                                                      | 烧烤BBQ                                                      | 烧烤BBQ                                     | <center>:relaxed:</center>       |\n| 7.12                   | 1.1000题线代第4讲 <br>2.看第15章讲解                         | 1.2011年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5 | 1.做真题2011.1并看李旭相应视频 <br>2.背所学课程单词          | 认识论                                      | <center>:sun_with_face:</center> |\n| 7.13                   | 1.1000题线代第5-1讲 <br>2.看第16章B组讲解                    | 1.2010年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5 | 1.做真题2011.2并看李旭相应视频 <br>2.背所学课程单词          | 认识的本质                                  | <center>:sun_with_face:</center> |\n| 7.14                   | 1.1000题线代第5-2讲 <br>2.看第16章C组讲解                    | 1.2018年软专数据结构基础题 <br>2.2012学硕计网 <br>3.冲刺讲义数据结构看4.5 | 1.做真题2011.3并看李旭相应视频 <br>2.背所学课程单词          | 认识的本质                                  | <center>:sun_with_face:</center> |\n| 7.15                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.16                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.17                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.18                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.19                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.20                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.21                   | 1.1000题线代第6讲 <br>2.看第17章讲解 <br>3.看18讲第一章并blog总结相关知识点 | 1.2017年软专数据结构基础题 <br>2.2010学硕计网 <br>3.冲刺讲义数据结构看4.1 <br>4.冲刺讲义计网基础全部看完 | 1.做真题2011.4并看李旭相应视频 <br>２.背所学课程单词         | 认识的本质                                  | <center>:sun_with_face:</center> |\n| 7.22                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.23                   | 1.1000题线代第7-1讲 <br>2.看第18章讲解 <br>3.看18讲第二章    | 1.2015年软专数据结构基础题 <br>2.整理计网基础第二章blog <br>3.冲刺讲义数据结构看4.2 | 1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词         | 1.徐涛真理与价值 <br>2.做1000题第一、二章题 | <center>:sun_with_face:</center> |\n| 7.24                   | 1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章    | 1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 | 1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词         | 社会基本矛盾                                | <center>:sun_with_face:</center> |\n| 7.25                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.26                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.27                   | 1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章    | 1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 <br>4.每日一题 栈 | 1.做真题2014.4并看李旭相应视频 <br>２.背所学课程单词         | 1.社会形态                                  | <center>:sun_with_face:</center> |\n| 7.28                   | 1.1000题线代第8讲 <br>2.看线代第3章讲解 <br>3.看18讲第二章 <br>4.闭关修炼第一章 | 1.2013年软专数据结构基础题 <br>2.整理计网基础第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈 | 1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词         | 1.社会形态 <br>2.做1000剩余第二章单选       | <center>:sun_with_face:</center> |\n| 7.29                   | 1.看线代第3章讲解 <br>2.闭关修炼第一章                       | 1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈 | 1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词         | 1.社会形态 <br>2.做1000剩余第二章单选       |                                  |\n| 7.30                   | 1.1000题线概率第2讲                                          | 1.2011年软专数据结构基础题                                   | 1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词         | 商品的两因素                                |                                  |\n| 7.31                   | 1.1000题线概率第3讲                                          | 1.2010年软专数据结构基础题                                   |                                                              | 价值规律                                    |                                  |\n|                        | 1.1000题线概率第4讲                                          |                                                              |                                                              | 剩余价值生产                                |                                  |\n|                        | 1.1000题线概率第5讲                                          |                                                              |                                                              | 剩余价值流转                                |                                  |\n|                        | 1.1000题线概率第6-1讲                                        |                                                              |                                                              | 垄断资本主义                                |                                  |\n|                        | 1.1000题线概率第6-2讲                                        |                                                              |                                                              | 社会主义                                    |                                  |\n|                        | 1.1000题线概率第6-3讲                                        |                                                              |                                                              | 人生的青春                                  |                                  |\n|                        | 1.1000题线概率第7讲                                          |                                                              |                                                              | 人生理想                                    |                                  |\n|                        | 1.1000题线概率第8讲                                          |                                                              |                                                              |                                             |                                  |\n|                        | 1.1000题线概率第9-1讲                                        |                                                              |                                                              |                                             |                                  |\n|                        | 1.1000题线概率第9-2讲                                        |                                                              |                                                              |                                             |                                  |","source":"_posts/7月份学习计划.md","raw":"---\ntitle: 7月份学习计划\ntop: false\ncover: false\ntoc: false\nmathjax: true\nsummary: 学习计划\ntags:\n  - 考研\n  - 计划\ncategories:\n  - 男男\nabbrlink: 4cfa\ndate: 2020-07-01 20:06:05\npassword:\n---\n<center> <h2>7月份学习计划<h2></center>\n\n| <center>7月份</center> | <center>数学</center>                                        | <center>专业课</center>                                      | <center>英语</center>                                        | <center>政治</center>                       | <center>完成度</center>          |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------- | -------------------------------- |\n| 7.1                    | 1.1000题高数第16讲BC <br>2.看第7章BC组讲解                   | 1.2018年计专数据结构基础题                                   | 1.整理句子<br> 2.背单词                                      | 对立统一                                    | <center>:sun_with_face:</center> |\n| 7.2                    | 1.1000题高数第17讲BC <br>2.看第8章BC组讲解                   | 1.2017年计专数据结构基础题 <br>2.2018计算机学硕两道代码 <br>3.对照常青藤与课本复习计算机网络其余部分 | 1.恋恋有词Unit6 Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词 | 质量互变定律                                | <center>:sun_with_face:</center> |\n| 7.3                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.4                    | 1.1000题高数第18讲25道题<br>2.看第9章BC组讲解                | 1.2016年计专数据结构基础题 <br>2.2017计算机学硕两道代码 <br>3.冲刺讲义数据结构看完4.2和代码讲义链表代码 <br>4.2018学硕计网真题 | 1.恋恋有词Unit7 Lesson1 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词 | 否定之否定定律                              | <center>:frowning:</center>      |\n| 7.5                    | 1.1000题高数第18讲剩余题目<br>2.看第10章BC组讲解             | 1.2015年计专数据结构基础题 <br>2.2018学硕计网真题            | 1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词 | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.6                    | 1.1000题线代第1、2讲BC <br>2.看第11、12章BC组讲解            | 1.2014年计专数据结构基础题 <br>2.冲刺讲义数据结构看完4.2 <br>3.2017学硕计网真题 | 1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词 | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.7                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.8                    | 1.1000题线代第3-1讲 <br>2.看第13章讲解                       | 1.2013年计专数据结构基础题 <br>2.学习2017学硕计网选择题知识点 <br>3.冲刺讲义数据结构看4.3 | 1.做真题2010.3并看李旭相应视频 <br>2.背所学课程单词          | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.9                    | 1.1000题线代第3-2讲 <br>2.看第14章讲解                       | 1.2012年计专数据结构基础题 <br>2.2016学硕计网 <br>3.冲刺讲义数据结构看4.4 | 1.做真题2010.4并看李旭相应视频 <br>2.背所学课程单词          | 否定之否定定律                              | <center>:sun_with_face:</center> |\n| 7.10                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.11                   | 烧烤BBQ                                                      | 烧烤BBQ                                                      | 烧烤BBQ                                                      | 烧烤BBQ                                     | <center>:relaxed:</center>       |\n| 7.12                   | 1.1000题线代第4讲 <br>2.看第15章讲解                         | 1.2011年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5 | 1.做真题2011.1并看李旭相应视频 <br>2.背所学课程单词          | 认识论                                      | <center>:sun_with_face:</center> |\n| 7.13                   | 1.1000题线代第5-1讲 <br>2.看第16章B组讲解                    | 1.2010年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5 | 1.做真题2011.2并看李旭相应视频 <br>2.背所学课程单词          | 认识的本质                                  | <center>:sun_with_face:</center> |\n| 7.14                   | 1.1000题线代第5-2讲 <br>2.看第16章C组讲解                    | 1.2018年软专数据结构基础题 <br>2.2012学硕计网 <br>3.冲刺讲义数据结构看4.5 | 1.做真题2011.3并看李旭相应视频 <br>2.背所学课程单词          | 认识的本质                                  | <center>:sun_with_face:</center> |\n| 7.15                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.16                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.17                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.18                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.19                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.20                   | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                                         | 学习deepin-linux系统                        | <center>:relaxed:</center>       |\n| 7.21                   | 1.1000题线代第6讲 <br>2.看第17章讲解 <br>3.看18讲第一章并blog总结相关知识点 | 1.2017年软专数据结构基础题 <br>2.2010学硕计网 <br>3.冲刺讲义数据结构看4.1 <br>4.冲刺讲义计网基础全部看完 | 1.做真题2011.4并看李旭相应视频 <br>２.背所学课程单词         | 认识的本质                                  | <center>:sun_with_face:</center> |\n| 7.22                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.23                   | 1.1000题线代第7-1讲 <br>2.看第18章讲解 <br>3.看18讲第二章    | 1.2015年软专数据结构基础题 <br>2.整理计网基础第二章blog <br>3.冲刺讲义数据结构看4.2 | 1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词         | 1.徐涛真理与价值 <br>2.做1000题第一、二章题 | <center>:sun_with_face:</center> |\n| 7.24                   | 1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章    | 1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 | 1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词         | 社会基本矛盾                                | <center>:sun_with_face:</center> |\n| 7.25                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.26                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                                     | 休息一天                                    | <center>:relaxed:</center>       |\n| 7.27                   | 1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章    | 1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 <br>4.每日一题 栈 | 1.做真题2014.4并看李旭相应视频 <br>２.背所学课程单词         | 1.社会形态                                  | <center>:sun_with_face:</center> |\n| 7.28                   | 1.1000题线代第8讲 <br>2.看线代第3章讲解 <br>3.看18讲第二章 <br>4.闭关修炼第一章 | 1.2013年软专数据结构基础题 <br>2.整理计网基础第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈 | 1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词         | 1.社会形态 <br>2.做1000剩余第二章单选       | <center>:sun_with_face:</center> |\n| 7.29                   | 1.看线代第3章讲解 <br>2.闭关修炼第一章                       | 1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈 | 1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词         | 1.社会形态 <br>2.做1000剩余第二章单选       |                                  |\n| 7.30                   | 1.1000题线概率第2讲                                          | 1.2011年软专数据结构基础题                                   | 1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词         | 商品的两因素                                |                                  |\n| 7.31                   | 1.1000题线概率第3讲                                          | 1.2010年软专数据结构基础题                                   |                                                              | 价值规律                                    |                                  |\n|                        | 1.1000题线概率第4讲                                          |                                                              |                                                              | 剩余价值生产                                |                                  |\n|                        | 1.1000题线概率第5讲                                          |                                                              |                                                              | 剩余价值流转                                |                                  |\n|                        | 1.1000题线概率第6-1讲                                        |                                                              |                                                              | 垄断资本主义                                |                                  |\n|                        | 1.1000题线概率第6-2讲                                        |                                                              |                                                              | 社会主义                                    |                                  |\n|                        | 1.1000题线概率第6-3讲                                        |                                                              |                                                              | 人生的青春                                  |                                  |\n|                        | 1.1000题线概率第7讲                                          |                                                              |                                                              | 人生理想                                    |                                  |\n|                        | 1.1000题线概率第8讲                                          |                                                              |                                                              |                                             |                                  |\n|                        | 1.1000题线概率第9-1讲                                        |                                                              |                                                              |                                             |                                  |\n|                        | 1.1000题线概率第9-2讲                                        |                                                              |                                                              |                                             |                                  |","slug":"7月份学习计划","published":1,"updated":"2020-08-10T10:18:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5i000oa09kbosg5d5x","content":"<center> <h2>7月份学习计划</h2><h2></h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>7月份</center></th>\n<th><center>数学</center></th>\n<th><center>专业课</center></th>\n<th><center>英语</center></th>\n<th><center>政治</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7.1</td>\n<td>1.1000题高数第16讲BC <br>2.看第7章BC组讲解</td>\n<td>1.2018年计专数据结构基础题</td>\n<td>1.整理句子<br> 2.背单词</td>\n<td>对立统一</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.2</td>\n<td>1.1000题高数第17讲BC <br>2.看第8章BC组讲解</td>\n<td>1.2017年计专数据结构基础题 <br>2.2018计算机学硕两道代码 <br>3.对照常青藤与课本复习计算机网络其余部分</td>\n<td>1.恋恋有词Unit6 Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词</td>\n<td>质量互变定律</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.3</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.4</td>\n<td>1.1000题高数第18讲25道题<br>2.看第9章BC组讲解</td>\n<td>1.2016年计专数据结构基础题 <br>2.2017计算机学硕两道代码 <br>3.冲刺讲义数据结构看完4.2和代码讲义链表代码 <br>4.2018学硕计网真题</td>\n<td>1.恋恋有词Unit7 Lesson1 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span></center></td>\n</tr>\n<tr>\n<td>7.5</td>\n<td>1.1000题高数第18讲剩余题目<br>2.看第10章BC组讲解</td>\n<td>1.2015年计专数据结构基础题 <br>2.2018学硕计网真题</td>\n<td>1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.6</td>\n<td>1.1000题线代第1、2讲BC <br>2.看第11、12章BC组讲解</td>\n<td>1.2014年计专数据结构基础题 <br>2.冲刺讲义数据结构看完4.2 <br>3.2017学硕计网真题</td>\n<td>1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.7</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.8</td>\n<td>1.1000题线代第3-1讲 <br>2.看第13章讲解</td>\n<td>1.2013年计专数据结构基础题 <br>2.学习2017学硕计网选择题知识点 <br>3.冲刺讲义数据结构看4.3</td>\n<td>1.做真题2010.3并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.9</td>\n<td>1.1000题线代第3-2讲 <br>2.看第14章讲解</td>\n<td>1.2012年计专数据结构基础题 <br>2.2016学硕计网 <br>3.冲刺讲义数据结构看4.4</td>\n<td>1.做真题2010.4并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.10</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.11</td>\n<td>烧烤BBQ</td>\n<td>烧烤BBQ</td>\n<td>烧烤BBQ</td>\n<td>烧烤BBQ</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.12</td>\n<td>1.1000题线代第4讲 <br>2.看第15章讲解</td>\n<td>1.2011年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5</td>\n<td>1.做真题2011.1并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>认识论</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.13</td>\n<td>1.1000题线代第5-1讲 <br>2.看第16章B组讲解</td>\n<td>1.2010年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5</td>\n<td>1.做真题2011.2并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>认识的本质</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.14</td>\n<td>1.1000题线代第5-2讲 <br>2.看第16章C组讲解</td>\n<td>1.2018年软专数据结构基础题 <br>2.2012学硕计网 <br>3.冲刺讲义数据结构看4.5</td>\n<td>1.做真题2011.3并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>认识的本质</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.15</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.16</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.17</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.18</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.19</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.20</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.21</td>\n<td>1.1000题线代第6讲 <br>2.看第17章讲解 <br>3.看18讲第一章并blog总结相关知识点</td>\n<td>1.2017年软专数据结构基础题 <br>2.2010学硕计网 <br>3.冲刺讲义数据结构看4.1 <br>4.冲刺讲义计网基础全部看完</td>\n<td>1.做真题2011.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>认识的本质</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.22</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.23</td>\n<td>1.1000题线代第7-1讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td>\n<td>1.2015年软专数据结构基础题 <br>2.整理计网基础第二章blog <br>3.冲刺讲义数据结构看4.2</td>\n<td>1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.徐涛真理与价值 <br>2.做1000题第一、二章题</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.24</td>\n<td>1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td>\n<td>1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3</td>\n<td>1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>社会基本矛盾</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.25</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.26</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>7.27</td>\n<td>1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td>\n<td>1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 <br>4.每日一题 栈</td>\n<td>1.做真题2014.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.28</td>\n<td>1.1000题线代第8讲 <br>2.看线代第3章讲解 <br>3.看18讲第二章 <br>4.闭关修炼第一章</td>\n<td>1.2013年软专数据结构基础题 <br>2.整理计网基础第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td>\n<td>1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态 <br>2.做1000剩余第二章单选</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>7.29</td>\n<td>1.看线代第3章讲解 <br>2.闭关修炼第一章</td>\n<td>1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td>\n<td>1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态 <br>2.做1000剩余第二章单选</td>\n<td></td>\n</tr>\n<tr>\n<td>7.30</td>\n<td>1.1000题线概率第2讲</td>\n<td>1.2011年软专数据结构基础题</td>\n<td>1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>商品的两因素</td>\n<td></td>\n</tr>\n<tr>\n<td>7.31</td>\n<td>1.1000题线概率第3讲</td>\n<td>1.2010年软专数据结构基础题</td>\n<td></td>\n<td>价值规律</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第4讲</td>\n<td></td>\n<td></td>\n<td>剩余价值生产</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第5讲</td>\n<td></td>\n<td></td>\n<td>剩余价值流转</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第6-1讲</td>\n<td></td>\n<td></td>\n<td>垄断资本主义</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第6-2讲</td>\n<td></td>\n<td></td>\n<td>社会主义</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第6-3讲</td>\n<td></td>\n<td></td>\n<td>人生的青春</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第7讲</td>\n<td></td>\n<td></td>\n<td>人生理想</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第8讲</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第9-1讲</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第9-2讲</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<center> <h2>7月份学习计划<h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>7月份</center></th>\n<th><center>数学</center></th>\n<th><center>专业课</center></th>\n<th><center>英语</center></th>\n<th><center>政治</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7.1</td>\n<td>1.1000题高数第16讲BC <br>2.看第7章BC组讲解</td>\n<td>1.2018年计专数据结构基础题</td>\n<td>1.整理句子<br> 2.背单词</td>\n<td>对立统一</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.2</td>\n<td>1.1000题高数第17讲BC <br>2.看第8章BC组讲解</td>\n<td>1.2017年计专数据结构基础题 <br>2.2018计算机学硕两道代码 <br>3.对照常青藤与课本复习计算机网络其余部分</td>\n<td>1.恋恋有词Unit6 Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词</td>\n<td>质量互变定律</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.3</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.4</td>\n<td>1.1000题高数第18讲25道题<br>2.看第9章BC组讲解</td>\n<td>1.2016年计专数据结构基础题 <br>2.2017计算机学硕两道代码 <br>3.冲刺讲义数据结构看完4.2和代码讲义链表代码 <br>4.2018学硕计网真题</td>\n<td>1.恋恋有词Unit7 Lesson1 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center>:frowning:</center></td>\n</tr>\n<tr>\n<td>7.5</td>\n<td>1.1000题高数第18讲剩余题目<br>2.看第10章BC组讲解</td>\n<td>1.2015年计专数据结构基础题 <br>2.2018学硕计网真题</td>\n<td>1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.6</td>\n<td>1.1000题线代第1、2讲BC <br>2.看第11、12章BC组讲解</td>\n<td>1.2014年计专数据结构基础题 <br>2.冲刺讲义数据结构看完4.2 <br>3.2017学硕计网真题</td>\n<td>1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.7</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.8</td>\n<td>1.1000题线代第3-1讲 <br>2.看第13章讲解</td>\n<td>1.2013年计专数据结构基础题 <br>2.学习2017学硕计网选择题知识点 <br>3.冲刺讲义数据结构看4.3</td>\n<td>1.做真题2010.3并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.9</td>\n<td>1.1000题线代第3-2讲 <br>2.看第14章讲解</td>\n<td>1.2012年计专数据结构基础题 <br>2.2016学硕计网 <br>3.冲刺讲义数据结构看4.4</td>\n<td>1.做真题2010.4并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.10</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.11</td>\n<td>烧烤BBQ</td>\n<td>烧烤BBQ</td>\n<td>烧烤BBQ</td>\n<td>烧烤BBQ</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.12</td>\n<td>1.1000题线代第4讲 <br>2.看第15章讲解</td>\n<td>1.2011年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5</td>\n<td>1.做真题2011.1并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>认识论</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.13</td>\n<td>1.1000题线代第5-1讲 <br>2.看第16章B组讲解</td>\n<td>1.2010年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5</td>\n<td>1.做真题2011.2并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>认识的本质</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.14</td>\n<td>1.1000题线代第5-2讲 <br>2.看第16章C组讲解</td>\n<td>1.2018年软专数据结构基础题 <br>2.2012学硕计网 <br>3.冲刺讲义数据结构看4.5</td>\n<td>1.做真题2011.3并看李旭相应视频 <br>2.背所学课程单词</td>\n<td>认识的本质</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.15</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.16</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.17</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.18</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.19</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.20</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td>学习deepin-linux系统</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.21</td>\n<td>1.1000题线代第6讲 <br>2.看第17章讲解 <br>3.看18讲第一章并blog总结相关知识点</td>\n<td>1.2017年软专数据结构基础题 <br>2.2010学硕计网 <br>3.冲刺讲义数据结构看4.1 <br>4.冲刺讲义计网基础全部看完</td>\n<td>1.做真题2011.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>认识的本质</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.22</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.23</td>\n<td>1.1000题线代第7-1讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td>\n<td>1.2015年软专数据结构基础题 <br>2.整理计网基础第二章blog <br>3.冲刺讲义数据结构看4.2</td>\n<td>1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.徐涛真理与价值 <br>2.做1000题第一、二章题</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.24</td>\n<td>1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td>\n<td>1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3</td>\n<td>1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>社会基本矛盾</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.25</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.26</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>7.27</td>\n<td>1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td>\n<td>1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 <br>4.每日一题 栈</td>\n<td>1.做真题2014.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.28</td>\n<td>1.1000题线代第8讲 <br>2.看线代第3章讲解 <br>3.看18讲第二章 <br>4.闭关修炼第一章</td>\n<td>1.2013年软专数据结构基础题 <br>2.整理计网基础第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td>\n<td>1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态 <br>2.做1000剩余第二章单选</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>7.29</td>\n<td>1.看线代第3章讲解 <br>2.闭关修炼第一章</td>\n<td>1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td>\n<td>1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态 <br>2.做1000剩余第二章单选</td>\n<td></td>\n</tr>\n<tr>\n<td>7.30</td>\n<td>1.1000题线概率第2讲</td>\n<td>1.2011年软专数据结构基础题</td>\n<td>1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>商品的两因素</td>\n<td></td>\n</tr>\n<tr>\n<td>7.31</td>\n<td>1.1000题线概率第3讲</td>\n<td>1.2010年软专数据结构基础题</td>\n<td></td>\n<td>价值规律</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第4讲</td>\n<td></td>\n<td></td>\n<td>剩余价值生产</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第5讲</td>\n<td></td>\n<td></td>\n<td>剩余价值流转</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第6-1讲</td>\n<td></td>\n<td></td>\n<td>垄断资本主义</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第6-2讲</td>\n<td></td>\n<td></td>\n<td>社会主义</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第6-3讲</td>\n<td></td>\n<td></td>\n<td>人生的青春</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第7讲</td>\n<td></td>\n<td></td>\n<td>人生理想</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第8讲</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第9-1讲</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>1.1000题线概率第9-2讲</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"2018-979","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"2018-979软学代码题","description":"2018-979软学代码题","summary":"2018-979软学代码题","abbrlink":"6918","date":"2020-10-22T11:39:08.000Z","password":null,"_content":"## 2018-979-软学\n\n#### 1.第一题\n\n- 在Head为头指针的单链表中查找结点DATA域值为K的结点\n- 并将该结点与其前驱结点（如果存在）交换位置\n\n```c\nvoid jiaohuan(LinkList Head,int K){\n    LNode *pre = Head,*p = Head -> next;\n    if(p != NULL && p -> data == K){\n        //如果第一个就对\n        pre -> next = p -> next;\n        p -> next = pre;\n        return true;\n    }\n    p = p -> next;\n    if(p != NULL){\n        //之后的元素\n        if(p -> data == K){\n            pre -> next -> next = p -> next;\n            p -> next = pre -> next;\n            pre -> next = p;\n            return true;\n        }else{\n            p = p -> next;\n            pre = pre -> next;\n        }\n    }\n    return false;\n    \n}\n```\n\n#### 2.第二题\n\n- 给定二叉树的根指针为Root\n- 对二叉树自下而上、自左而右的层次遍历\n\n```c\ntypedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTNode *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\nvoid bianli(BiTree Root){\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    BiTree Queue[MaxSize];\n    int front,rear = -1;\n    BiTree p = Root;\n    if(p != NULL){\n        Stack[++top] = p;\n    }\n    while(p != NULL || top != -1){\n        \n        if(p -> lchild != NULL){\n            Stack[++top] = p -> lchild;\n        }\n        if(p -> rchild != NULL){\n            Stack[++top] = p -> rchild;\n        }else{\n            p = Stack[top--];\n            Queue[++rear] = p;\n        }\n        p = p -> lchild;\n    }\n    return Queue;\n}\n```\n\n### 3.第三题\n\n- 长度为n的数组A\n- 已知前$m(m<n)$个元素按升序有序排列，后$n-m$个元素按降序有序排列\n- 编写算法在$O(n)$时间内对数组A的元素按降序排序\n\n```c\nint* Sort(int A[]){\n    int C[];\n    int low = m-1,high = m,i = 0;\n    while(low >= 0 && high < n){\n        if(A[high].data >= A[low.data]){\n            C[i] = A[high];\n            high++;\n            i++;\n        }else{\n            C[i] = A[low];\n            low--;\n            i++;\n        }\n    }\n    while(high < n){\n        C[i] = A[high];\n        high++;\n        i++;\n    }\n    while(low >= 0){\n        C[i] = A[low];\n        low--;\n        i++;\n    }\n    return C;\n}\n```\n","source":"_posts/2018-979.md","raw":"---\ntitle: 2018-979\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\ncategories:\n  - 代码\nkeywords: 2018-979软学代码题\ndescription: 2018-979软学代码题\nsummary: 2018-979软学代码题\nabbrlink: '6918'\ndate: 2020-10-22 19:39:08\npassword:\n---\n## 2018-979-软学\n\n#### 1.第一题\n\n- 在Head为头指针的单链表中查找结点DATA域值为K的结点\n- 并将该结点与其前驱结点（如果存在）交换位置\n\n```c\nvoid jiaohuan(LinkList Head,int K){\n    LNode *pre = Head,*p = Head -> next;\n    if(p != NULL && p -> data == K){\n        //如果第一个就对\n        pre -> next = p -> next;\n        p -> next = pre;\n        return true;\n    }\n    p = p -> next;\n    if(p != NULL){\n        //之后的元素\n        if(p -> data == K){\n            pre -> next -> next = p -> next;\n            p -> next = pre -> next;\n            pre -> next = p;\n            return true;\n        }else{\n            p = p -> next;\n            pre = pre -> next;\n        }\n    }\n    return false;\n    \n}\n```\n\n#### 2.第二题\n\n- 给定二叉树的根指针为Root\n- 对二叉树自下而上、自左而右的层次遍历\n\n```c\ntypedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTNode *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\nvoid bianli(BiTree Root){\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    BiTree Queue[MaxSize];\n    int front,rear = -1;\n    BiTree p = Root;\n    if(p != NULL){\n        Stack[++top] = p;\n    }\n    while(p != NULL || top != -1){\n        \n        if(p -> lchild != NULL){\n            Stack[++top] = p -> lchild;\n        }\n        if(p -> rchild != NULL){\n            Stack[++top] = p -> rchild;\n        }else{\n            p = Stack[top--];\n            Queue[++rear] = p;\n        }\n        p = p -> lchild;\n    }\n    return Queue;\n}\n```\n\n### 3.第三题\n\n- 长度为n的数组A\n- 已知前$m(m<n)$个元素按升序有序排列，后$n-m$个元素按降序有序排列\n- 编写算法在$O(n)$时间内对数组A的元素按降序排序\n\n```c\nint* Sort(int A[]){\n    int C[];\n    int low = m-1,high = m,i = 0;\n    while(low >= 0 && high < n){\n        if(A[high].data >= A[low.data]){\n            C[i] = A[high];\n            high++;\n            i++;\n        }else{\n            C[i] = A[low];\n            low--;\n            i++;\n        }\n    }\n    while(high < n){\n        C[i] = A[high];\n        high++;\n        i++;\n    }\n    while(low >= 0){\n        C[i] = A[low];\n        low--;\n        i++;\n    }\n    return C;\n}\n```\n","slug":"2018-979","published":1,"updated":"2021-04-26T09:05:43.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5j000ta09kbj3ja7wy","content":"<h2 id=\"2018-979-软学\"><a href=\"#2018-979-软学\" class=\"headerlink\" title=\"2018-979-软学\"></a>2018-979-软学</h2><h4 id=\"1-第一题\"><a href=\"#1-第一题\" class=\"headerlink\" title=\"1.第一题\"></a>1.第一题</h4><ul>\n<li>在Head为头指针的单链表中查找结点DATA域值为K的结点</li>\n<li>并将该结点与其前驱结点（如果存在）交换位置</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void jiaohuan(LinkList Head,int K){\n    LNode *pre = Head,*p = Head -> next;\n    if(p != NULL && p -> data == K){\n        //如果第一个就对\n        pre -> next = p -> next;\n        p -> next = pre;\n        return true;\n    }\n    p = p -> next;\n    if(p != NULL){\n        //之后的元素\n        if(p -> data == K){\n            pre -> next -> next = p -> next;\n            p -> next = pre -> next;\n            pre -> next = p;\n            return true;\n        }else{\n            p = p -> next;\n            pre = pre -> next;\n        }\n    }\n    return false;\n\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-第二题\"><a href=\"#2-第二题\" class=\"headerlink\" title=\"2.第二题\"></a>2.第二题</h4><ul>\n<li>给定二叉树的根指针为Root</li>\n<li>对二叉树自下而上、自左而右的层次遍历</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">typedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTNode *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\nvoid bianli(BiTree Root){\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    BiTree Queue[MaxSize];\n    int front,rear = -1;\n    BiTree p = Root;\n    if(p != NULL){\n        Stack[++top] = p;\n    }\n    while(p != NULL || top != -1){\n\n        if(p -> lchild != NULL){\n            Stack[++top] = p -> lchild;\n        }\n        if(p -> rchild != NULL){\n            Stack[++top] = p -> rchild;\n        }else{\n            p = Stack[top--];\n            Queue[++rear] = p;\n        }\n        p = p -> lchild;\n    }\n    return Queue;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"3-第三题\"><a href=\"#3-第三题\" class=\"headerlink\" title=\"3.第三题\"></a>3.第三题</h3><ul>\n<li>长度为n的数组A</li>\n<li>已知前$m(m&lt;n)$个元素按升序有序排列，后$n-m$个元素按降序有序排列</li>\n<li>编写算法在$O(n)$时间内对数组A的元素按降序排序</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int* Sort(int A[]){\n    int C[];\n    int low = m-1,high = m,i = 0;\n    while(low >= 0 && high < n){\n        if(A[high].data >= A[low.data]){\n            C[i] = A[high];\n            high++;\n            i++;\n        }else{\n            C[i] = A[low];\n            low--;\n            i++;\n        }\n    }\n    while(high < n){\n        C[i] = A[high];\n        high++;\n        i++;\n    }\n    while(low >= 0){\n        C[i] = A[low];\n        low--;\n        i++;\n    }\n    return C;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"2018-979-软学\"><a href=\"#2018-979-软学\" class=\"headerlink\" title=\"2018-979-软学\"></a>2018-979-软学</h2><h4 id=\"1-第一题\"><a href=\"#1-第一题\" class=\"headerlink\" title=\"1.第一题\"></a>1.第一题</h4><ul>\n<li>在Head为头指针的单链表中查找结点DATA域值为K的结点</li>\n<li>并将该结点与其前驱结点（如果存在）交换位置</li>\n</ul>\n<pre><code class=\"lang-c\">void jiaohuan(LinkList Head,int K){\n    LNode *pre = Head,*p = Head -&gt; next;\n    if(p != NULL &amp;&amp; p -&gt; data == K){\n        //如果第一个就对\n        pre -&gt; next = p -&gt; next;\n        p -&gt; next = pre;\n        return true;\n    }\n    p = p -&gt; next;\n    if(p != NULL){\n        //之后的元素\n        if(p -&gt; data == K){\n            pre -&gt; next -&gt; next = p -&gt; next;\n            p -&gt; next = pre -&gt; next;\n            pre -&gt; next = p;\n            return true;\n        }else{\n            p = p -&gt; next;\n            pre = pre -&gt; next;\n        }\n    }\n    return false;\n\n}\n</code></pre>\n<h4 id=\"2-第二题\"><a href=\"#2-第二题\" class=\"headerlink\" title=\"2.第二题\"></a>2.第二题</h4><ul>\n<li>给定二叉树的根指针为Root</li>\n<li>对二叉树自下而上、自左而右的层次遍历</li>\n</ul>\n<pre><code class=\"lang-c\">typedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTNode *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\nvoid bianli(BiTree Root){\n    BiTree Stack[MaxSize];\n    int top = -1;//栈初始化\n    BiTree Queue[MaxSize];\n    int front,rear = -1;\n    BiTree p = Root;\n    if(p != NULL){\n        Stack[++top] = p;\n    }\n    while(p != NULL || top != -1){\n\n        if(p -&gt; lchild != NULL){\n            Stack[++top] = p -&gt; lchild;\n        }\n        if(p -&gt; rchild != NULL){\n            Stack[++top] = p -&gt; rchild;\n        }else{\n            p = Stack[top--];\n            Queue[++rear] = p;\n        }\n        p = p -&gt; lchild;\n    }\n    return Queue;\n}\n</code></pre>\n<h3 id=\"3-第三题\"><a href=\"#3-第三题\" class=\"headerlink\" title=\"3.第三题\"></a>3.第三题</h3><ul>\n<li>长度为n的数组A</li>\n<li>已知前$m(m&lt;n)$个元素按升序有序排列，后$n-m$个元素按降序有序排列</li>\n<li>编写算法在$O(n)$时间内对数组A的元素按降序排序</li>\n</ul>\n<pre><code class=\"lang-c\">int* Sort(int A[]){\n    int C[];\n    int low = m-1,high = m,i = 0;\n    while(low &gt;= 0 &amp;&amp; high &lt; n){\n        if(A[high].data &gt;= A[low.data]){\n            C[i] = A[high];\n            high++;\n            i++;\n        }else{\n            C[i] = A[low];\n            low--;\n            i++;\n        }\n    }\n    while(high &lt; n){\n        C[i] = A[high];\n        high++;\n        i++;\n    }\n    while(low &gt;= 0){\n        C[i] = A[low];\n        low--;\n        i++;\n    }\n    return C;\n}\n</code></pre>\n"},{"title":"9月8号计划","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"9.8计划","abbrlink":"51cd","date":"2020-09-07T11:51:15.000Z","password":null,"_content":"**1. 计网绪论强化知识点\n2. 图相关代码整理\n3. 政治两课\n4. 数学概率第一章\n5. 英语真题加单词**","source":"_posts/9月8号计划.md","raw":"---\ntitle: 9月8号计划\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 考研\n  - 计划\ncategories:\n  - 男男\nsummary: 9.8计划\nabbrlink: 51cd\ndate: 2020-09-07 19:51:15\npassword:\n---\n**1. 计网绪论强化知识点\n2. 图相关代码整理\n3. 政治两课\n4. 数学概率第一章\n5. 英语真题加单词**","slug":"9月8号计划","published":1,"updated":"2020-09-07T11:54:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5k000wa09kc5lpcg5j","content":"<p>**1. 计网绪论强化知识点</p>\n<ol>\n<li>图相关代码整理</li>\n<li>政治两课</li>\n<li>数学概率第一章</li>\n<li>英语真题加单词**</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<p>**1. 计网绪论强化知识点</p>\n<ol>\n<li>图相关代码整理</li>\n<li>政治两课</li>\n<li>数学概率第一章</li>\n<li>英语真题加单词**</li>\n</ol>\n"},{"title":"5.7-5.16学习记录","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"5.7-5.16学习情况","abbrlink":"19e3","date":"2021-05-07T11:33:41.000Z","password":null,"keywords":null,"description":null,"_content":"<center> <h2>5.7-5.16学习情况<h2></center>\n\nPS\n\n\n- :sun_with_face:为顺利完成\n\n- :relaxed:为休息一天\n\n- :frowning:为尚未完成\n\n| <center>日期</center> | <center>学习情况</center>                                    | <center>完成度</center>          |\n| --------------------- | ------------------------------------------------------------ | -------------------------------- |\n| 5/7                   | 1.学习了tensorflow库，初步掌握句子分词，构建模型，训练模型，以及预测简单流程。<br>     2.使用miniforge3安装python虚拟环境，适配M1芯片，并可以使用conda install -n py38  包名，进行快速安装，简单的一批。 | <center>:sun_with_face:</center> |\n| 5/8                   |                                                              |                                  |\n| 5/9                   |                                                              |                                  |\n| 5/10                  |                                                              |                                  |\n| 5/11                  |                                                              |                                  |\n| 5/12                  |                                                              |                                  |\n| 5/13                  |                                                              |                                  |\n| 5/14                  |                                                              |                                  |\n| 5/15                  |                                                              |                                  |\n| 5/16                  |                                                              |                                  |\n\n","source":"_posts/5-7-5-16学习记录.md","raw":"---\ntitle: 5.7-5.16学习记录\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 计划\ncategories:\n  - 计划\nsummary: 5.7-5.16学习情况\nabbrlink: '19e3'\ndate: 2021-05-07 19:33:41\npassword:\nkeywords:\ndescription:\n---\n<center> <h2>5.7-5.16学习情况<h2></center>\n\nPS\n\n\n- :sun_with_face:为顺利完成\n\n- :relaxed:为休息一天\n\n- :frowning:为尚未完成\n\n| <center>日期</center> | <center>学习情况</center>                                    | <center>完成度</center>          |\n| --------------------- | ------------------------------------------------------------ | -------------------------------- |\n| 5/7                   | 1.学习了tensorflow库，初步掌握句子分词，构建模型，训练模型，以及预测简单流程。<br>     2.使用miniforge3安装python虚拟环境，适配M1芯片，并可以使用conda install -n py38  包名，进行快速安装，简单的一批。 | <center>:sun_with_face:</center> |\n| 5/8                   |                                                              |                                  |\n| 5/9                   |                                                              |                                  |\n| 5/10                  |                                                              |                                  |\n| 5/11                  |                                                              |                                  |\n| 5/12                  |                                                              |                                  |\n| 5/13                  |                                                              |                                  |\n| 5/14                  |                                                              |                                  |\n| 5/15                  |                                                              |                                  |\n| 5/16                  |                                                              |                                  |\n\n","slug":"5-7-5-16学习记录","published":1,"updated":"2021-05-17T05:20:12.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5l0011a09kgd3f9zga","content":"<center> <h2>5.7-5.16学习情况</h2><h2></h2></center>\n\n<p>PS</p>\n<ul>\n<li><p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span>为顺利完成</p>\n</li>\n<li><p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span>为休息一天</p>\n</li>\n<li><p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span>为尚未完成</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>日期</center></th>\n<th><center>学习情况</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5/7</td>\n<td>1.学习了tensorflow库，初步掌握句子分词，构建模型，训练模型，以及预测简单流程。<br>     2.使用miniforge3安装python虚拟环境，适配M1芯片，并可以使用conda install -n py38  包名，进行快速安装，简单的一批。</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>5/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/16</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<center> <h2>5.7-5.16学习情况<h2></center>\n\n<p>PS</p>\n<ul>\n<li><p>:sun_with_face:为顺利完成</p>\n</li>\n<li><p>:relaxed:为休息一天</p>\n</li>\n<li><p>:frowning:为尚未完成</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>日期</center></th>\n<th><center>学习情况</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5/7</td>\n<td>1.学习了tensorflow库，初步掌握句子分词，构建模型，训练模型，以及预测简单流程。<br>     2.使用miniforge3安装python虚拟环境，适配M1芯片，并可以使用conda install -n py38  包名，进行快速安装，简单的一批。</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>5/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5/16</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"笔迹识别（一）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"笔迹鉴定论文（一）","abbrlink":"820c","date":"2021-08-17T11:01:35.000Z","password":null,"keywords":null,"description":null,"_content":"## 文本识别\n\n1. 特征提取：特征提取是手写体汉字识别最关键的环节。\n\n   1.1纹理特征：纹理是一种不依赖于颜色或亮度变化的反映图像中同质现象的视觉特征，刻画了图像像素邻域灰度空间分布的规律。它是所有物体表面都具有的内在特征，不同物体具有不同的纹理，如云彩，树木，砖，织物等都有各自的纹理特征。\n\n   - 根据每个人不同的书写习惯，会产生自己的书写纹理特征，通过纹理特征能够区分不同书写人的笔迹。\n\n   - 文本图像作为一种特殊的图像，其纹理具有很强的方向性和以行为周期的准准确性，基于空间/频率域联合分析的方法可以描述纹理表面灰度级的整体周期，适合于描述文本图像的纹理。频率域可以将纹理的局部特性和全局特性有机的结合起来。\n\n     - 频域特征：Gabor滤波器可以在频域上不同尺度、不同方向上提取相关特征，Gabor滤波器是一个用于边缘检测的线性滤波器，可以在频域的不同尺度，不同方向上提取相关特征。\n\n     - gabor算子由一个高斯函数和一个余弦函数调制而成。gabor算子由六个参数控制，其中三个与余弦函数有关，两个与高斯函数有关。\n\n     - `cv.getGaborKernel`函数可以定义内核，它接受内核大小、高斯标准差、波的方向、波长、空间比和相位等参数。\n\n     - 滤波公式：$g(x, y ; \\lambda, \\theta, \\psi, \\sigma, \\gamma)=\\exp \\left(-\\frac{x^{\\prime 2}+\\gamma^{2} y^{2}}{2 \\sigma^{2}}\\right) \\exp \\left(i\\left(2 \\pi \\frac{x^{\\prime}}{\\lambda}+\\psi\\right)\\right)$​\n\n     -  （1） *x*,*y*分别表示像素坐标位置； \n        （2） *λ*表示滤波的波长\n        （3） *θ*表示Gabor核函数图像的倾斜角度； \n        （4） *ψ*表示相位偏移量，取值范围是-180~180； \n        （5） *σ*表示高斯函数的标准差； \n        （6） *γ*表示长宽比，决定这Gabor核函数图像的椭圆率。\n\n     - | ksize        | Size of the filter returned. 滤波器的大小（图片尺寸）        |\n       | ------------ | ------------------------------------------------------------ |\n       | sigma(**σ**) | Standard deviation of the gaussian envelope. **高斯函数标准差** |\n       | theta(**θ**) | Orientation of the normal to the parallel stripes of a Gabor function. **高斯函数：垂直于Gabor函数平行条纹的方向。** |\n       | lambd(**λ**) | Wavelength of the sinusoidal factor. **正弦因子的波长**      |\n       | gamma(**γ**) | Spatial aspect ratio. **高斯函数宽高比**                     |\n       | psi(**ψ**)   | Phase offset. **相位偏差**                                   |\n       | ktype        | Type of filter coefficients. It can be CV_32F or CV_64F . **滤波器系数的类型** |\n\n       不同参数下测试，ksize：111，sigam：5，theta：90，lambd：10，gamma：1.2\n\n       <img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132433303.png\" style=\"zoom:50%;\" />\n\n       ksize：111，sigam：10，theta：90，lambd：10，gamma：1.2\n\n       <img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132709822.png\" style=\"zoom:50%;\" />\n\n       !![6张对比图](https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817134252871.png)\n\n     - 空间分布特征：\n\n       - 灰度协方差矩阵：用于匹配图像，匹配一个图像是否包含于另一个图像中。在文字识别中，可以用作找两份文字是否出于同一个人写的，或者某个偏旁部首是否与文字中的相似。\n\n2. 文献\n\n- Writer Identification and Verification，书写人识别与验证\n\n  - 手写体生物识别需要在多个观察层次上具有广泛的知识\n  - 良好的生物特征具备普遍性、独特性、永久性和可收集性\n  - 四个导致书写变异的因素：\n    - 仿射变换，是书写人自愿控制的。大小、平移、旋转和剪切的变换是笔迹识别中令人讨厌的问题。\n    - 神经生物学变异性，局部环境和生理状态决定了在书写时所花费的精力。\n    - 手写过程中的瞬时系统状态，也就是笔顺，笔顺会对图像产生明显的影响\n    - 异体字变异，特定于书写者的字符形状现象，也就是每个人对某个特定字会有自己独特的写法\n\n- 8: **Handwriting Identification: a Direction Review**，笔迹鉴定：一个方向的回看？\n\n  - 书写者识别是从一组书写者中识别作者的过程\n\n  - 而书写者验证是确定两个手写样本是由相同的书写者还是由不同的书写者书写的任务。\n\n  - 基于笔迹的书写者身份的证明基于三个传统步骤：数据采集和预处理、特征提取和分类\n\n    - 首先对手写文本进行预处理（如二值化、分段和规范化）\n\n      - 第一步，先将彩色图像转变灰度图像，\n\n        - 平均法：将同一个像素位置3个RGB值进行平均\n        - 最大最小平均：取同一个像素位置的RGB中亮度最大的和最小的进行平均。\n        - 加权平均：这是最流行的方法。几个加权系数0.3,0.59,0.11是根据人的亮度感知系统调节出来的参数，是个广泛使用的标准化参数。\n\n      - 二值化处理：\n\n        - 最简单的做法：给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来的就是衣服黑白图像\n        - 最常见的二值处理方法：是计算像素的平均值K，扫描图像的每个像素值如像素值大于K像素值设为255(白色)，值小于等于K像素值设为0(黑色)。该方法相比方法一，阈值的选取稍微有点智商，可以解释。但是使用平均值作为二值化阈值同样有个致命的缺点，可能导致部分对象像素或者背景像素丢失。二值化结果不能真实反映源图像信息。\n        - 使用直方图来寻找二值化阈值：直方图方法选择二值化阈值主要是发现图像的两个最高的峰，然后在阈值取值在两个峰之间的峰谷最低处。\n          - 直方图是图像中像素强度分布的图形表达方式。它统计了每一个强度值所具有的像素个数。\n\n      - 分段处理：好像就是边缘检测\n\n        - 边缘检测的实质是采用某种[算法](https://baike.baidu.com/item/算法)来提取出图像中对象与背景间的交界线。我们将边缘定义为图像中[灰度](https://baike.baidu.com/item/灰度)发生急剧变化的区域边界。图像灰度的变化情况可以用图像灰度分布的梯度来反映。\n        - 步骤\n          - 滤波：边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能。需要指出，大多数滤波器在降低噪声的同时也导致了边缘强度的损失，因此，增强边缘和降低噪声之间需要折中。\n          - 增加：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将邻域(或局部)强度值有显著变化的点突显出来。边缘增强一般是通过计算梯度幅值来完成的。\n          - 检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域中并不都是边缘，所以应该用某种方法来确定哪些点是边缘点。最简单的边缘检测判据是梯度幅值阈值判据。\n          - 定位：如果某一应用场合要求确定边缘位置，则边缘的位置可在子像素分辨率上来估计，边缘的方位也可以被估计出来。在边缘检测算法中，前三个步骤用得十分普遍。这是因为大多数场合下，仅仅需要边缘检测器指出边缘出现在图像某一像素点的附近，而没有必要指出边缘的精确位置或方向。\n\n        - 阈值越低，能够检测出的边线越多，结果也越容易受到图片噪声的影响，并且越容易从图像中挑出不相关的特性。与此相反，一个高的阈值将会遗失细的或者短的线段。\n\n      - 图像标准化处理：\n\n        - image_standardization $ =\\frac{\\mathrm{x}-\\mu}{\\text { adjusted\\_stddev }}$​​,u是图像均值，X表示图像矩阵\n        - adjusted_stddev $=\\max \\left(\\sigma, \\frac{1.0}{\\sqrt{\\mathrm{N}}}\\right)$​​​，第一个是方差，N为图像X的像素数量\n        - ![标准化处理结果](https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-17%2019.11.39.png)\n\n    - 第二，通过特征提取一组鉴别特征来表示手写文本\n\n    - 第三，做出分类决策\n\n      - 欧几里得距离\n      - 神经网络\n      - SVM\n\n  - 在线笔迹：包括速度、加速度、笔压、书写方向和笔划顺序","source":"_posts/8-17学习记录.md","raw":"---\ntitle: 笔迹识别（一）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 笔迹鉴定\ncategories:\n  - 论文\nsummary: 笔迹鉴定论文（一）\nabbrlink: 820c\ndate: 2021-08-17 19:01:35\npassword:\nkeywords:\ndescription:\n---\n## 文本识别\n\n1. 特征提取：特征提取是手写体汉字识别最关键的环节。\n\n   1.1纹理特征：纹理是一种不依赖于颜色或亮度变化的反映图像中同质现象的视觉特征，刻画了图像像素邻域灰度空间分布的规律。它是所有物体表面都具有的内在特征，不同物体具有不同的纹理，如云彩，树木，砖，织物等都有各自的纹理特征。\n\n   - 根据每个人不同的书写习惯，会产生自己的书写纹理特征，通过纹理特征能够区分不同书写人的笔迹。\n\n   - 文本图像作为一种特殊的图像，其纹理具有很强的方向性和以行为周期的准准确性，基于空间/频率域联合分析的方法可以描述纹理表面灰度级的整体周期，适合于描述文本图像的纹理。频率域可以将纹理的局部特性和全局特性有机的结合起来。\n\n     - 频域特征：Gabor滤波器可以在频域上不同尺度、不同方向上提取相关特征，Gabor滤波器是一个用于边缘检测的线性滤波器，可以在频域的不同尺度，不同方向上提取相关特征。\n\n     - gabor算子由一个高斯函数和一个余弦函数调制而成。gabor算子由六个参数控制，其中三个与余弦函数有关，两个与高斯函数有关。\n\n     - `cv.getGaborKernel`函数可以定义内核，它接受内核大小、高斯标准差、波的方向、波长、空间比和相位等参数。\n\n     - 滤波公式：$g(x, y ; \\lambda, \\theta, \\psi, \\sigma, \\gamma)=\\exp \\left(-\\frac{x^{\\prime 2}+\\gamma^{2} y^{2}}{2 \\sigma^{2}}\\right) \\exp \\left(i\\left(2 \\pi \\frac{x^{\\prime}}{\\lambda}+\\psi\\right)\\right)$​\n\n     -  （1） *x*,*y*分别表示像素坐标位置； \n        （2） *λ*表示滤波的波长\n        （3） *θ*表示Gabor核函数图像的倾斜角度； \n        （4） *ψ*表示相位偏移量，取值范围是-180~180； \n        （5） *σ*表示高斯函数的标准差； \n        （6） *γ*表示长宽比，决定这Gabor核函数图像的椭圆率。\n\n     - | ksize        | Size of the filter returned. 滤波器的大小（图片尺寸）        |\n       | ------------ | ------------------------------------------------------------ |\n       | sigma(**σ**) | Standard deviation of the gaussian envelope. **高斯函数标准差** |\n       | theta(**θ**) | Orientation of the normal to the parallel stripes of a Gabor function. **高斯函数：垂直于Gabor函数平行条纹的方向。** |\n       | lambd(**λ**) | Wavelength of the sinusoidal factor. **正弦因子的波长**      |\n       | gamma(**γ**) | Spatial aspect ratio. **高斯函数宽高比**                     |\n       | psi(**ψ**)   | Phase offset. **相位偏差**                                   |\n       | ktype        | Type of filter coefficients. It can be CV_32F or CV_64F . **滤波器系数的类型** |\n\n       不同参数下测试，ksize：111，sigam：5，theta：90，lambd：10，gamma：1.2\n\n       <img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132433303.png\" style=\"zoom:50%;\" />\n\n       ksize：111，sigam：10，theta：90，lambd：10，gamma：1.2\n\n       <img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132709822.png\" style=\"zoom:50%;\" />\n\n       !![6张对比图](https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817134252871.png)\n\n     - 空间分布特征：\n\n       - 灰度协方差矩阵：用于匹配图像，匹配一个图像是否包含于另一个图像中。在文字识别中，可以用作找两份文字是否出于同一个人写的，或者某个偏旁部首是否与文字中的相似。\n\n2. 文献\n\n- Writer Identification and Verification，书写人识别与验证\n\n  - 手写体生物识别需要在多个观察层次上具有广泛的知识\n  - 良好的生物特征具备普遍性、独特性、永久性和可收集性\n  - 四个导致书写变异的因素：\n    - 仿射变换，是书写人自愿控制的。大小、平移、旋转和剪切的变换是笔迹识别中令人讨厌的问题。\n    - 神经生物学变异性，局部环境和生理状态决定了在书写时所花费的精力。\n    - 手写过程中的瞬时系统状态，也就是笔顺，笔顺会对图像产生明显的影响\n    - 异体字变异，特定于书写者的字符形状现象，也就是每个人对某个特定字会有自己独特的写法\n\n- 8: **Handwriting Identification: a Direction Review**，笔迹鉴定：一个方向的回看？\n\n  - 书写者识别是从一组书写者中识别作者的过程\n\n  - 而书写者验证是确定两个手写样本是由相同的书写者还是由不同的书写者书写的任务。\n\n  - 基于笔迹的书写者身份的证明基于三个传统步骤：数据采集和预处理、特征提取和分类\n\n    - 首先对手写文本进行预处理（如二值化、分段和规范化）\n\n      - 第一步，先将彩色图像转变灰度图像，\n\n        - 平均法：将同一个像素位置3个RGB值进行平均\n        - 最大最小平均：取同一个像素位置的RGB中亮度最大的和最小的进行平均。\n        - 加权平均：这是最流行的方法。几个加权系数0.3,0.59,0.11是根据人的亮度感知系统调节出来的参数，是个广泛使用的标准化参数。\n\n      - 二值化处理：\n\n        - 最简单的做法：给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来的就是衣服黑白图像\n        - 最常见的二值处理方法：是计算像素的平均值K，扫描图像的每个像素值如像素值大于K像素值设为255(白色)，值小于等于K像素值设为0(黑色)。该方法相比方法一，阈值的选取稍微有点智商，可以解释。但是使用平均值作为二值化阈值同样有个致命的缺点，可能导致部分对象像素或者背景像素丢失。二值化结果不能真实反映源图像信息。\n        - 使用直方图来寻找二值化阈值：直方图方法选择二值化阈值主要是发现图像的两个最高的峰，然后在阈值取值在两个峰之间的峰谷最低处。\n          - 直方图是图像中像素强度分布的图形表达方式。它统计了每一个强度值所具有的像素个数。\n\n      - 分段处理：好像就是边缘检测\n\n        - 边缘检测的实质是采用某种[算法](https://baike.baidu.com/item/算法)来提取出图像中对象与背景间的交界线。我们将边缘定义为图像中[灰度](https://baike.baidu.com/item/灰度)发生急剧变化的区域边界。图像灰度的变化情况可以用图像灰度分布的梯度来反映。\n        - 步骤\n          - 滤波：边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能。需要指出，大多数滤波器在降低噪声的同时也导致了边缘强度的损失，因此，增强边缘和降低噪声之间需要折中。\n          - 增加：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将邻域(或局部)强度值有显著变化的点突显出来。边缘增强一般是通过计算梯度幅值来完成的。\n          - 检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域中并不都是边缘，所以应该用某种方法来确定哪些点是边缘点。最简单的边缘检测判据是梯度幅值阈值判据。\n          - 定位：如果某一应用场合要求确定边缘位置，则边缘的位置可在子像素分辨率上来估计，边缘的方位也可以被估计出来。在边缘检测算法中，前三个步骤用得十分普遍。这是因为大多数场合下，仅仅需要边缘检测器指出边缘出现在图像某一像素点的附近，而没有必要指出边缘的精确位置或方向。\n\n        - 阈值越低，能够检测出的边线越多，结果也越容易受到图片噪声的影响，并且越容易从图像中挑出不相关的特性。与此相反，一个高的阈值将会遗失细的或者短的线段。\n\n      - 图像标准化处理：\n\n        - image_standardization $ =\\frac{\\mathrm{x}-\\mu}{\\text { adjusted\\_stddev }}$​​,u是图像均值，X表示图像矩阵\n        - adjusted_stddev $=\\max \\left(\\sigma, \\frac{1.0}{\\sqrt{\\mathrm{N}}}\\right)$​​​，第一个是方差，N为图像X的像素数量\n        - ![标准化处理结果](https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-17%2019.11.39.png)\n\n    - 第二，通过特征提取一组鉴别特征来表示手写文本\n\n    - 第三，做出分类决策\n\n      - 欧几里得距离\n      - 神经网络\n      - SVM\n\n  - 在线笔迹：包括速度、加速度、笔压、书写方向和笔划顺序","slug":"8-17学习记录","published":1,"updated":"2021-08-19T10:09:48.903Z","_id":"cksie9q5l0014a09k4xyidjed","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"文本识别\"><a href=\"#文本识别\" class=\"headerlink\" title=\"文本识别\"></a>文本识别</h2><ol>\n<li><p>特征提取：特征提取是手写体汉字识别最关键的环节。</p>\n<p>1.1纹理特征：纹理是一种不依赖于颜色或亮度变化的反映图像中同质现象的视觉特征，刻画了图像像素邻域灰度空间分布的规律。它是所有物体表面都具有的内在特征，不同物体具有不同的纹理，如云彩，树木，砖，织物等都有各自的纹理特征。</p>\n<ul>\n<li><p>根据每个人不同的书写习惯，会产生自己的书写纹理特征，通过纹理特征能够区分不同书写人的笔迹。</p>\n</li>\n<li><p>文本图像作为一种特殊的图像，其纹理具有很强的方向性和以行为周期的准准确性，基于空间/频率域联合分析的方法可以描述纹理表面灰度级的整体周期，适合于描述文本图像的纹理。频率域可以将纹理的局部特性和全局特性有机的结合起来。</p>\n<ul>\n<li><p>频域特征：Gabor滤波器可以在频域上不同尺度、不同方向上提取相关特征，Gabor滤波器是一个用于边缘检测的线性滤波器，可以在频域的不同尺度，不同方向上提取相关特征。</p>\n</li>\n<li><p>gabor算子由一个高斯函数和一个余弦函数调制而成。gabor算子由六个参数控制，其中三个与余弦函数有关，两个与高斯函数有关。</p>\n</li>\n<li><p><code>cv.getGaborKernel</code>函数可以定义内核，它接受内核大小、高斯标准差、波的方向、波长、空间比和相位等参数。</p>\n</li>\n<li><p>滤波公式：$g(x, y ; \\lambda, \\theta, \\psi, \\sigma, \\gamma)=\\exp \\left(-\\frac{x^{\\prime 2}+\\gamma^{2} y^{2}}{2 \\sigma^{2}}\\right) \\exp \\left(i\\left(2 \\pi \\frac{x^{\\prime}}{\\lambda}+\\psi\\right)\\right)$​</p>\n</li>\n<li><p>（1） <em>x</em>,<em>y</em>分别表示像素坐标位置；<br>（2） <em>λ</em>表示滤波的波长<br>（3） <em>θ</em>表示Gabor核函数图像的倾斜角度；<br>（4） <em>ψ</em>表示相位偏移量，取值范围是-180~180；<br>（5） <em>σ</em>表示高斯函数的标准差；<br>（6） <em>γ</em>表示长宽比，决定这Gabor核函数图像的椭圆率。</p>\n</li>\n<li><p>| ksize        | Size of the filter returned. 滤波器的大小（图片尺寸）        |<br>| —————— | —————————————————————————————— |<br>| sigma(<strong>σ</strong>) | Standard deviation of the gaussian envelope. <strong>高斯函数标准差</strong> |<br>| theta(<strong>θ</strong>) | Orientation of the normal to the parallel stripes of a Gabor function. <strong>高斯函数：垂直于Gabor函数平行条纹的方向。</strong> |<br>| lambd(<strong>λ</strong>) | Wavelength of the sinusoidal factor. <strong>正弦因子的波长</strong>      |<br>| gamma(<strong>γ</strong>) | Spatial aspect ratio. <strong>高斯函数宽高比</strong>                     |<br>| psi(<strong>ψ</strong>)   | Phase offset. <strong>相位偏差</strong>                                   |<br>| ktype        | Type of filter coefficients. It can be CV_32F or CV_64F . <strong>滤波器系数的类型</strong> |</p>\n<p>不同参数下测试，ksize：111，sigam：5，theta：90，lambd：10，gamma：1.2</p>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132433303.png\" style=\"zoom:50%;\"></p>\n<p>ksize：111，sigam：10，theta：90，lambd：10，gamma：1.2</p>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132709822.png\" style=\"zoom:50%;\"></p>\n<p>!<img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817134252871.png\" alt=\"6张对比图\"></p>\n</li>\n<li><p>空间分布特征：</p>\n<ul>\n<li>灰度协方差矩阵：用于匹配图像，匹配一个图像是否包含于另一个图像中。在文字识别中，可以用作找两份文字是否出于同一个人写的，或者某个偏旁部首是否与文字中的相似。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文献</p>\n</li>\n</ol>\n<ul>\n<li><p>Writer Identification and Verification，书写人识别与验证</p>\n<ul>\n<li>手写体生物识别需要在多个观察层次上具有广泛的知识</li>\n<li>良好的生物特征具备普遍性、独特性、永久性和可收集性</li>\n<li>四个导致书写变异的因素：<ul>\n<li>仿射变换，是书写人自愿控制的。大小、平移、旋转和剪切的变换是笔迹识别中令人讨厌的问题。</li>\n<li>神经生物学变异性，局部环境和生理状态决定了在书写时所花费的精力。</li>\n<li>手写过程中的瞬时系统状态，也就是笔顺，笔顺会对图像产生明显的影响</li>\n<li>异体字变异，特定于书写者的字符形状现象，也就是每个人对某个特定字会有自己独特的写法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>8: <strong>Handwriting Identification: a Direction Review</strong>，笔迹鉴定：一个方向的回看？</p>\n<ul>\n<li><p>书写者识别是从一组书写者中识别作者的过程</p>\n</li>\n<li><p>而书写者验证是确定两个手写样本是由相同的书写者还是由不同的书写者书写的任务。</p>\n</li>\n<li><p>基于笔迹的书写者身份的证明基于三个传统步骤：数据采集和预处理、特征提取和分类</p>\n<ul>\n<li><p>首先对手写文本进行预处理（如二值化、分段和规范化）</p>\n<ul>\n<li><p>第一步，先将彩色图像转变灰度图像，</p>\n<ul>\n<li>平均法：将同一个像素位置3个RGB值进行平均</li>\n<li>最大最小平均：取同一个像素位置的RGB中亮度最大的和最小的进行平均。</li>\n<li>加权平均：这是最流行的方法。几个加权系数0.3,0.59,0.11是根据人的亮度感知系统调节出来的参数，是个广泛使用的标准化参数。</li>\n</ul>\n</li>\n<li><p>二值化处理：</p>\n<ul>\n<li>最简单的做法：给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来的就是衣服黑白图像</li>\n<li>最常见的二值处理方法：是计算像素的平均值K，扫描图像的每个像素值如像素值大于K像素值设为255(白色)，值小于等于K像素值设为0(黑色)。该方法相比方法一，阈值的选取稍微有点智商，可以解释。但是使用平均值作为二值化阈值同样有个致命的缺点，可能导致部分对象像素或者背景像素丢失。二值化结果不能真实反映源图像信息。</li>\n<li>使用直方图来寻找二值化阈值：直方图方法选择二值化阈值主要是发现图像的两个最高的峰，然后在阈值取值在两个峰之间的峰谷最低处。<ul>\n<li>直方图是图像中像素强度分布的图形表达方式。它统计了每一个强度值所具有的像素个数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分段处理：好像就是边缘检测</p>\n<ul>\n<li>边缘检测的实质是采用某种<a href=\"https://baike.baidu.com/item/算法\" target=\"_blank\" rel=\"noopener\">算法</a>来提取出图像中对象与背景间的交界线。我们将边缘定义为图像中<a href=\"https://baike.baidu.com/item/灰度\" target=\"_blank\" rel=\"noopener\">灰度</a>发生急剧变化的区域边界。图像灰度的变化情况可以用图像灰度分布的梯度来反映。</li>\n<li><p>步骤</p>\n<ul>\n<li>滤波：边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能。需要指出，大多数滤波器在降低噪声的同时也导致了边缘强度的损失，因此，增强边缘和降低噪声之间需要折中。</li>\n<li>增加：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将邻域(或局部)强度值有显著变化的点突显出来。边缘增强一般是通过计算梯度幅值来完成的。</li>\n<li>检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域中并不都是边缘，所以应该用某种方法来确定哪些点是边缘点。最简单的边缘检测判据是梯度幅值阈值判据。</li>\n<li>定位：如果某一应用场合要求确定边缘位置，则边缘的位置可在子像素分辨率上来估计，边缘的方位也可以被估计出来。在边缘检测算法中，前三个步骤用得十分普遍。这是因为大多数场合下，仅仅需要边缘检测器指出边缘出现在图像某一像素点的附近，而没有必要指出边缘的精确位置或方向。</li>\n</ul>\n</li>\n<li><p>阈值越低，能够检测出的边线越多，结果也越容易受到图片噪声的影响，并且越容易从图像中挑出不相关的特性。与此相反，一个高的阈值将会遗失细的或者短的线段。</p>\n</li>\n</ul>\n</li>\n<li><p>图像标准化处理：</p>\n<ul>\n<li>image_standardization $ =\\frac{\\mathrm{x}-\\mu}{\\text { adjusted_stddev }}$​​,u是图像均值，X表示图像矩阵</li>\n<li>adjusted_stddev $=\\max \\left(\\sigma, \\frac{1.0}{\\sqrt{\\mathrm{N}}}\\right)$​​​，第一个是方差，N为图像X的像素数量</li>\n<li><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-17%2019.11.39.png\" alt=\"标准化处理结果\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>第二，通过特征提取一组鉴别特征来表示手写文本</p>\n</li>\n<li><p>第三，做出分类决策</p>\n<ul>\n<li>欧几里得距离</li>\n<li>神经网络</li>\n<li>SVM</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在线笔迹：包括速度、加速度、笔压、书写方向和笔划顺序</p>\n</li>\n</ul>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"文本识别\"><a href=\"#文本识别\" class=\"headerlink\" title=\"文本识别\"></a>文本识别</h2><ol>\n<li><p>特征提取：特征提取是手写体汉字识别最关键的环节。</p>\n<p>1.1纹理特征：纹理是一种不依赖于颜色或亮度变化的反映图像中同质现象的视觉特征，刻画了图像像素邻域灰度空间分布的规律。它是所有物体表面都具有的内在特征，不同物体具有不同的纹理，如云彩，树木，砖，织物等都有各自的纹理特征。</p>\n<ul>\n<li><p>根据每个人不同的书写习惯，会产生自己的书写纹理特征，通过纹理特征能够区分不同书写人的笔迹。</p>\n</li>\n<li><p>文本图像作为一种特殊的图像，其纹理具有很强的方向性和以行为周期的准准确性，基于空间/频率域联合分析的方法可以描述纹理表面灰度级的整体周期，适合于描述文本图像的纹理。频率域可以将纹理的局部特性和全局特性有机的结合起来。</p>\n<ul>\n<li><p>频域特征：Gabor滤波器可以在频域上不同尺度、不同方向上提取相关特征，Gabor滤波器是一个用于边缘检测的线性滤波器，可以在频域的不同尺度，不同方向上提取相关特征。</p>\n</li>\n<li><p>gabor算子由一个高斯函数和一个余弦函数调制而成。gabor算子由六个参数控制，其中三个与余弦函数有关，两个与高斯函数有关。</p>\n</li>\n<li><p><code>cv.getGaborKernel</code>函数可以定义内核，它接受内核大小、高斯标准差、波的方向、波长、空间比和相位等参数。</p>\n</li>\n<li><p>滤波公式：$g(x, y ; \\lambda, \\theta, \\psi, \\sigma, \\gamma)=\\exp \\left(-\\frac{x^{\\prime 2}+\\gamma^{2} y^{2}}{2 \\sigma^{2}}\\right) \\exp \\left(i\\left(2 \\pi \\frac{x^{\\prime}}{\\lambda}+\\psi\\right)\\right)$​</p>\n</li>\n<li><p>（1） <em>x</em>,<em>y</em>分别表示像素坐标位置；<br>（2） <em>λ</em>表示滤波的波长<br>（3） <em>θ</em>表示Gabor核函数图像的倾斜角度；<br>（4） <em>ψ</em>表示相位偏移量，取值范围是-180~180；<br>（5） <em>σ</em>表示高斯函数的标准差；<br>（6） <em>γ</em>表示长宽比，决定这Gabor核函数图像的椭圆率。</p>\n</li>\n<li><p>| ksize        | Size of the filter returned. 滤波器的大小（图片尺寸）        |<br>| —————— | —————————————————————————————— |<br>| sigma(<strong>σ</strong>) | Standard deviation of the gaussian envelope. <strong>高斯函数标准差</strong> |<br>| theta(<strong>θ</strong>) | Orientation of the normal to the parallel stripes of a Gabor function. <strong>高斯函数：垂直于Gabor函数平行条纹的方向。</strong> |<br>| lambd(<strong>λ</strong>) | Wavelength of the sinusoidal factor. <strong>正弦因子的波长</strong>      |<br>| gamma(<strong>γ</strong>) | Spatial aspect ratio. <strong>高斯函数宽高比</strong>                     |<br>| psi(<strong>ψ</strong>)   | Phase offset. <strong>相位偏差</strong>                                   |<br>| ktype        | Type of filter coefficients. It can be CV_32F or CV_64F . <strong>滤波器系数的类型</strong> |</p>\n<p>不同参数下测试，ksize：111，sigam：5，theta：90，lambd：10，gamma：1.2</p>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132433303.png\" style=\"zoom:50%;\" /></p>\n<p>ksize：111，sigam：10，theta：90，lambd：10，gamma：1.2</p>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132709822.png\" style=\"zoom:50%;\" /></p>\n<p>!<img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817134252871.png\" alt=\"6张对比图\"></p>\n</li>\n<li><p>空间分布特征：</p>\n<ul>\n<li>灰度协方差矩阵：用于匹配图像，匹配一个图像是否包含于另一个图像中。在文字识别中，可以用作找两份文字是否出于同一个人写的，或者某个偏旁部首是否与文字中的相似。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文献</p>\n</li>\n</ol>\n<ul>\n<li><p>Writer Identification and Verification，书写人识别与验证</p>\n<ul>\n<li>手写体生物识别需要在多个观察层次上具有广泛的知识</li>\n<li>良好的生物特征具备普遍性、独特性、永久性和可收集性</li>\n<li>四个导致书写变异的因素：<ul>\n<li>仿射变换，是书写人自愿控制的。大小、平移、旋转和剪切的变换是笔迹识别中令人讨厌的问题。</li>\n<li>神经生物学变异性，局部环境和生理状态决定了在书写时所花费的精力。</li>\n<li>手写过程中的瞬时系统状态，也就是笔顺，笔顺会对图像产生明显的影响</li>\n<li>异体字变异，特定于书写者的字符形状现象，也就是每个人对某个特定字会有自己独特的写法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>8: <strong>Handwriting Identification: a Direction Review</strong>，笔迹鉴定：一个方向的回看？</p>\n<ul>\n<li><p>书写者识别是从一组书写者中识别作者的过程</p>\n</li>\n<li><p>而书写者验证是确定两个手写样本是由相同的书写者还是由不同的书写者书写的任务。</p>\n</li>\n<li><p>基于笔迹的书写者身份的证明基于三个传统步骤：数据采集和预处理、特征提取和分类</p>\n<ul>\n<li><p>首先对手写文本进行预处理（如二值化、分段和规范化）</p>\n<ul>\n<li><p>第一步，先将彩色图像转变灰度图像，</p>\n<ul>\n<li>平均法：将同一个像素位置3个RGB值进行平均</li>\n<li>最大最小平均：取同一个像素位置的RGB中亮度最大的和最小的进行平均。</li>\n<li>加权平均：这是最流行的方法。几个加权系数0.3,0.59,0.11是根据人的亮度感知系统调节出来的参数，是个广泛使用的标准化参数。</li>\n</ul>\n</li>\n<li><p>二值化处理：</p>\n<ul>\n<li>最简单的做法：给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来的就是衣服黑白图像</li>\n<li>最常见的二值处理方法：是计算像素的平均值K，扫描图像的每个像素值如像素值大于K像素值设为255(白色)，值小于等于K像素值设为0(黑色)。该方法相比方法一，阈值的选取稍微有点智商，可以解释。但是使用平均值作为二值化阈值同样有个致命的缺点，可能导致部分对象像素或者背景像素丢失。二值化结果不能真实反映源图像信息。</li>\n<li>使用直方图来寻找二值化阈值：直方图方法选择二值化阈值主要是发现图像的两个最高的峰，然后在阈值取值在两个峰之间的峰谷最低处。<ul>\n<li>直方图是图像中像素强度分布的图形表达方式。它统计了每一个强度值所具有的像素个数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分段处理：好像就是边缘检测</p>\n<ul>\n<li>边缘检测的实质是采用某种<a href=\"https://baike.baidu.com/item/算法\" target=\"_blank\" rel=\"noopener\">算法</a>来提取出图像中对象与背景间的交界线。我们将边缘定义为图像中<a href=\"https://baike.baidu.com/item/灰度\" target=\"_blank\" rel=\"noopener\">灰度</a>发生急剧变化的区域边界。图像灰度的变化情况可以用图像灰度分布的梯度来反映。</li>\n<li><p>步骤</p>\n<ul>\n<li>滤波：边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能。需要指出，大多数滤波器在降低噪声的同时也导致了边缘强度的损失，因此，增强边缘和降低噪声之间需要折中。</li>\n<li>增加：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将邻域(或局部)强度值有显著变化的点突显出来。边缘增强一般是通过计算梯度幅值来完成的。</li>\n<li>检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域中并不都是边缘，所以应该用某种方法来确定哪些点是边缘点。最简单的边缘检测判据是梯度幅值阈值判据。</li>\n<li>定位：如果某一应用场合要求确定边缘位置，则边缘的位置可在子像素分辨率上来估计，边缘的方位也可以被估计出来。在边缘检测算法中，前三个步骤用得十分普遍。这是因为大多数场合下，仅仅需要边缘检测器指出边缘出现在图像某一像素点的附近，而没有必要指出边缘的精确位置或方向。</li>\n</ul>\n</li>\n<li><p>阈值越低，能够检测出的边线越多，结果也越容易受到图片噪声的影响，并且越容易从图像中挑出不相关的特性。与此相反，一个高的阈值将会遗失细的或者短的线段。</p>\n</li>\n</ul>\n</li>\n<li><p>图像标准化处理：</p>\n<ul>\n<li>image_standardization $ =\\frac{\\mathrm{x}-\\mu}{\\text { adjusted_stddev }}$​​,u是图像均值，X表示图像矩阵</li>\n<li>adjusted_stddev $=\\max \\left(\\sigma, \\frac{1.0}{\\sqrt{\\mathrm{N}}}\\right)$​​​，第一个是方差，N为图像X的像素数量</li>\n<li><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-17%2019.11.39.png\" alt=\"标准化处理结果\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>第二，通过特征提取一组鉴别特征来表示手写文本</p>\n</li>\n<li><p>第三，做出分类决策</p>\n<ul>\n<li>欧几里得距离</li>\n<li>神经网络</li>\n<li>SVM</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在线笔迹：包括速度、加速度、笔压、书写方向和笔划顺序</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"SimCSE（一）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"SimCSE简介","abbrlink":"5c43","date":"2021-04-26T09:11:43.000Z","password":null,"keywords":null,"description":null,"_content":"## Simple Contrastive Learning of Sentence Embeddings（一）\n\nSimCSE的全称为 *Simple Contrastice  Learning of Sentence Embeddings*。**Sim代表Simple，就是简单**。\n\n他简单的运用了 **<font color = \"red\">dropout</font>** 的方法替换了传统的数据增强方法，将同一个输入dropout两次作为对比学习的正例，而且效果甚好。\n\n------------\n\n**<font color = \"red\">红色：</font>** 名词第一次出现\n\n**<font color = \"#6638F0\">紫色：</font>** 解释专有名词\n\n**<font color = \"#F78AE0\">粉色：</font>** 原因以及解决方法\n\n-------\n\n- **<font color = \"#6638F0\">拟合：</font>** 拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示，根据这个函数的不同有不同的拟合名字。\n- **<font color = \"#6638F0\">泛化误差：</font>** 对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为**泛化误差**。\n\n<img src=\"拟合图片.jpeg\" alt=\"拟合图片\" style=\"zoom: 67%;\" />\n\n- 训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络**过度拟合了训练集**，对训练集以外的数据却不work。\n\n<img src=\"拟合对比.png\" alt=\"拟合对比\"  />\n\n- **<font color = \"#6638F0\">欠拟合：</font>** 欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。\n  - **<font color = \"#F78AE0\">如何解决欠拟合：</font>** 欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过**增加网络复杂度**或者在模型中 **<font color = \"red\">增加特征</font>** ，这些都是很好解决欠拟合的方法。\n  - **<font color = \"#6638F0\">增加特征：</font>** 添加高次多项式，使模型泛化能力更强\n- **<font color = \"#6638F0\">过拟合：</font>** 过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，**模型在训练集上表现很好，但在测试集上却表现很差**。模型对训练集\"死记硬背\"（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，**泛化能力差**。\n  - **<font color = \"#F78AE0\">造成原因：</font>** **训练数据集样本单一，样本不足**。所以训练样本要尽可能的全面，覆盖所有的数据类型。**训练数据中噪声干扰过大**。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。**模型过于复杂。**模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。\n  - **<font color = \"#F78AE0\">防止过拟合：</font>** 要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。**正则化是指修改学习算法，使其降低泛化误差而非训练误差**。\n  - 常用的正则化方法根据具体的使用策略不同可分为：（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和 **<font color = \"red\">Dropout</font>** ；（3）不直接提供约束的隐式正则化方法，如数据增强等。 **目前主要学习Dropout方法** 。\n\n-----------\n\n### 1. Dropout简介\n\n#### 1.1 Dropout出现的原因\n\n在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。\n\n过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。\n\n综上所述，训练深度神经网络的时候，总是会遇到两大缺点：\n\n（1）容易过拟合\n\n（2）费时\n\nDropout可以比较有效的缓解过拟合的发生，在一定程度上达到 **<font color = \"red\">正则化</font>** 的效果。\n\n- **<font color = \"#6638F0\">正则化</font>** （regularization）是指为解决适定性问题或过拟合而加入额外信息的过程。\n\n#### 1.2 什么是Dropout\n\nDropout可以作为训练深度神经网络的 **<font color = \"red\">一种trick</font>** 供选择。在每个训练批次中，通过 **忽略一半** 的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。\n\nDropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图所示。\n\n<img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\" />\n\n### 2. Dropout工作流程及使用\n\n输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：\n\n1. 首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）\n\n> 还没有搞懂，下次再看到dropout时，再回来对应学习\n\n2. 然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。\n\n3. 然后继续重复这一过程：\n\n- 恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）\n- 从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。\n- 对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。\n","source":"_posts/SimCSE（一）.md","raw":"---\ntitle: SimCSE（一）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nsummary: SimCSE简介\nabbrlink: 5c43\ndate: 2021-04-26 17:11:43\npassword:\nkeywords:\ndescription:\n---\n## Simple Contrastive Learning of Sentence Embeddings（一）\n\nSimCSE的全称为 *Simple Contrastice  Learning of Sentence Embeddings*。**Sim代表Simple，就是简单**。\n\n他简单的运用了 **<font color = \"red\">dropout</font>** 的方法替换了传统的数据增强方法，将同一个输入dropout两次作为对比学习的正例，而且效果甚好。\n\n------------\n\n**<font color = \"red\">红色：</font>** 名词第一次出现\n\n**<font color = \"#6638F0\">紫色：</font>** 解释专有名词\n\n**<font color = \"#F78AE0\">粉色：</font>** 原因以及解决方法\n\n-------\n\n- **<font color = \"#6638F0\">拟合：</font>** 拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示，根据这个函数的不同有不同的拟合名字。\n- **<font color = \"#6638F0\">泛化误差：</font>** 对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为**泛化误差**。\n\n<img src=\"拟合图片.jpeg\" alt=\"拟合图片\" style=\"zoom: 67%;\" />\n\n- 训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络**过度拟合了训练集**，对训练集以外的数据却不work。\n\n<img src=\"拟合对比.png\" alt=\"拟合对比\"  />\n\n- **<font color = \"#6638F0\">欠拟合：</font>** 欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。\n  - **<font color = \"#F78AE0\">如何解决欠拟合：</font>** 欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过**增加网络复杂度**或者在模型中 **<font color = \"red\">增加特征</font>** ，这些都是很好解决欠拟合的方法。\n  - **<font color = \"#6638F0\">增加特征：</font>** 添加高次多项式，使模型泛化能力更强\n- **<font color = \"#6638F0\">过拟合：</font>** 过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，**模型在训练集上表现很好，但在测试集上却表现很差**。模型对训练集\"死记硬背\"（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，**泛化能力差**。\n  - **<font color = \"#F78AE0\">造成原因：</font>** **训练数据集样本单一，样本不足**。所以训练样本要尽可能的全面，覆盖所有的数据类型。**训练数据中噪声干扰过大**。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。**模型过于复杂。**模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。\n  - **<font color = \"#F78AE0\">防止过拟合：</font>** 要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。**正则化是指修改学习算法，使其降低泛化误差而非训练误差**。\n  - 常用的正则化方法根据具体的使用策略不同可分为：（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和 **<font color = \"red\">Dropout</font>** ；（3）不直接提供约束的隐式正则化方法，如数据增强等。 **目前主要学习Dropout方法** 。\n\n-----------\n\n### 1. Dropout简介\n\n#### 1.1 Dropout出现的原因\n\n在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。\n\n过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。\n\n综上所述，训练深度神经网络的时候，总是会遇到两大缺点：\n\n（1）容易过拟合\n\n（2）费时\n\nDropout可以比较有效的缓解过拟合的发生，在一定程度上达到 **<font color = \"red\">正则化</font>** 的效果。\n\n- **<font color = \"#6638F0\">正则化</font>** （regularization）是指为解决适定性问题或过拟合而加入额外信息的过程。\n\n#### 1.2 什么是Dropout\n\nDropout可以作为训练深度神经网络的 **<font color = \"red\">一种trick</font>** 供选择。在每个训练批次中，通过 **忽略一半** 的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。\n\nDropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图所示。\n\n<img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\" />\n\n### 2. Dropout工作流程及使用\n\n输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：\n\n1. 首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）\n\n> 还没有搞懂，下次再看到dropout时，再回来对应学习\n\n2. 然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。\n\n3. 然后继续重复这一过程：\n\n- 恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）\n- 从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。\n- 对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。\n","slug":"SimCSE（一）","published":1,"updated":"2021-04-28T06:56:47.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5n0019a09kgo4sdsqx","content":"<h2 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（一）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（一）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（一）\"></a>Simple Contrastive Learning of Sentence Embeddings（一）</h2><p>SimCSE的全称为 <em>Simple Contrastice  Learning of Sentence Embeddings</em>。<strong>Sim代表Simple，就是简单</strong>。</p>\n<p>他简单的运用了 <strong><font color=\"red\">dropout</font></strong> 的方法替换了传统的数据增强方法，将同一个输入dropout两次作为对比学习的正例，而且效果甚好。</p>\n<hr>\n<p><strong><font color=\"red\">红色：</font></strong> 名词第一次出现</p>\n<p><strong><font color=\"#6638F0\">紫色：</font></strong> 解释专有名词</p>\n<p><strong><font color=\"#F78AE0\">粉色：</font></strong> 原因以及解决方法</p>\n<hr>\n<ul>\n<li><strong><font color=\"#6638F0\">拟合：</font></strong> 拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示，根据这个函数的不同有不同的拟合名字。</li>\n<li><strong><font color=\"#6638F0\">泛化误差：</font></strong> 对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为<strong>泛化误差</strong>。</li>\n</ul>\n<p><img src=\"拟合图片.jpeg\" alt=\"拟合图片\" style=\"zoom: 67%;\"></p>\n<ul>\n<li>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络<strong>过度拟合了训练集</strong>，对训练集以外的数据却不work。</li>\n</ul>\n<p><img src=\"拟合对比.png\" alt=\"拟合对比\"></p>\n<ul>\n<li><strong><font color=\"#6638F0\">欠拟合：</font></strong> 欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。<ul>\n<li><strong><font color=\"#F78AE0\">如何解决欠拟合：</font></strong> 欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<strong>增加网络复杂度</strong>或者在模型中 <strong><font color=\"red\">增加特征</font></strong> ，这些都是很好解决欠拟合的方法。</li>\n<li><strong><font color=\"#6638F0\">增加特征：</font></strong> 添加高次多项式，使模型泛化能力更强</li>\n</ul>\n</li>\n<li><strong><font color=\"#6638F0\">过拟合：</font></strong> 过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<strong>模型在训练集上表现很好，但在测试集上却表现很差</strong>。模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，<strong>泛化能力差</strong>。<ul>\n<li><strong><font color=\"#F78AE0\">造成原因：</font></strong> <strong>训练数据集样本单一，样本不足</strong>。所以训练样本要尽可能的全面，覆盖所有的数据类型。<strong>训练数据中噪声干扰过大</strong>。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。<strong>模型过于复杂。</strong>模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</li>\n<li><strong><font color=\"#F78AE0\">防止过拟合：</font></strong> 要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。<strong>正则化是指修改学习算法，使其降低泛化误差而非训练误差</strong>。</li>\n<li>常用的正则化方法根据具体的使用策略不同可分为：（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和 <strong><font color=\"red\">Dropout</font></strong> ；（3）不直接提供约束的隐式正则化方法，如数据增强等。 <strong>目前主要学习Dropout方法</strong> 。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"1-Dropout简介\"><a href=\"#1-Dropout简介\" class=\"headerlink\" title=\"1. Dropout简介\"></a>1. Dropout简介</h3><h4 id=\"1-1-Dropout出现的原因\"><a href=\"#1-1-Dropout出现的原因\" class=\"headerlink\" title=\"1.1 Dropout出现的原因\"></a>1.1 Dropout出现的原因</h4><p>在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。</p>\n<p>过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。</p>\n<p>综上所述，训练深度神经网络的时候，总是会遇到两大缺点：</p>\n<p>（1）容易过拟合</p>\n<p>（2）费时</p>\n<p>Dropout可以比较有效的缓解过拟合的发生，在一定程度上达到 <strong><font color=\"red\">正则化</font></strong> 的效果。</p>\n<ul>\n<li><strong><font color=\"#6638F0\">正则化</font></strong> （regularization）是指为解决适定性问题或过拟合而加入额外信息的过程。</li>\n</ul>\n<h4 id=\"1-2-什么是Dropout\"><a href=\"#1-2-什么是Dropout\" class=\"headerlink\" title=\"1.2 什么是Dropout\"></a>1.2 什么是Dropout</h4><p>Dropout可以作为训练深度神经网络的 <strong><font color=\"red\">一种trick</font></strong> 供选择。在每个训练批次中，通过 <strong>忽略一半</strong> 的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。</p>\n<p>Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图所示。</p>\n<p><img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\"></p>\n<h3 id=\"2-Dropout工作流程及使用\"><a href=\"#2-Dropout工作流程及使用\" class=\"headerlink\" title=\"2. Dropout工作流程及使用\"></a>2. Dropout工作流程及使用</h3><p>输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：</p>\n<ol>\n<li>首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）</li>\n</ol>\n<blockquote>\n<p>还没有搞懂，下次再看到dropout时，再回来对应学习</p>\n</blockquote>\n<ol>\n<li><p>然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。</p>\n</li>\n<li><p>然后继续重复这一过程：</p>\n</li>\n</ol>\n<ul>\n<li>恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）</li>\n<li>从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。</li>\n<li>对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（一）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（一）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（一）\"></a>Simple Contrastive Learning of Sentence Embeddings（一）</h2><p>SimCSE的全称为 <em>Simple Contrastice  Learning of Sentence Embeddings</em>。<strong>Sim代表Simple，就是简单</strong>。</p>\n<p>他简单的运用了 <strong><font color = \"red\">dropout</font></strong> 的方法替换了传统的数据增强方法，将同一个输入dropout两次作为对比学习的正例，而且效果甚好。</p>\n<hr>\n<p><strong><font color = \"red\">红色：</font></strong> 名词第一次出现</p>\n<p><strong><font color = \"#6638F0\">紫色：</font></strong> 解释专有名词</p>\n<p><strong><font color = \"#F78AE0\">粉色：</font></strong> 原因以及解决方法</p>\n<hr>\n<ul>\n<li><strong><font color = \"#6638F0\">拟合：</font></strong> 拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示，根据这个函数的不同有不同的拟合名字。</li>\n<li><strong><font color = \"#6638F0\">泛化误差：</font></strong> 对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为<strong>泛化误差</strong>。</li>\n</ul>\n<p><img src=\"拟合图片.jpeg\" alt=\"拟合图片\" style=\"zoom: 67%;\" /></p>\n<ul>\n<li>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络<strong>过度拟合了训练集</strong>，对训练集以外的数据却不work。</li>\n</ul>\n<p><img src=\"拟合对比.png\" alt=\"拟合对比\"  /></p>\n<ul>\n<li><strong><font color = \"#6638F0\">欠拟合：</font></strong> 欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。<ul>\n<li><strong><font color = \"#F78AE0\">如何解决欠拟合：</font></strong> 欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<strong>增加网络复杂度</strong>或者在模型中 <strong><font color = \"red\">增加特征</font></strong> ，这些都是很好解决欠拟合的方法。</li>\n<li><strong><font color = \"#6638F0\">增加特征：</font></strong> 添加高次多项式，使模型泛化能力更强</li>\n</ul>\n</li>\n<li><strong><font color = \"#6638F0\">过拟合：</font></strong> 过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<strong>模型在训练集上表现很好，但在测试集上却表现很差</strong>。模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，<strong>泛化能力差</strong>。<ul>\n<li><strong><font color = \"#F78AE0\">造成原因：</font></strong> <strong>训练数据集样本单一，样本不足</strong>。所以训练样本要尽可能的全面，覆盖所有的数据类型。<strong>训练数据中噪声干扰过大</strong>。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。<strong>模型过于复杂。</strong>模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</li>\n<li><strong><font color = \"#F78AE0\">防止过拟合：</font></strong> 要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。<strong>正则化是指修改学习算法，使其降低泛化误差而非训练误差</strong>。</li>\n<li>常用的正则化方法根据具体的使用策略不同可分为：（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和 <strong><font color = \"red\">Dropout</font></strong> ；（3）不直接提供约束的隐式正则化方法，如数据增强等。 <strong>目前主要学习Dropout方法</strong> 。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"1-Dropout简介\"><a href=\"#1-Dropout简介\" class=\"headerlink\" title=\"1. Dropout简介\"></a>1. Dropout简介</h3><h4 id=\"1-1-Dropout出现的原因\"><a href=\"#1-1-Dropout出现的原因\" class=\"headerlink\" title=\"1.1 Dropout出现的原因\"></a>1.1 Dropout出现的原因</h4><p>在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。</p>\n<p>过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。</p>\n<p>综上所述，训练深度神经网络的时候，总是会遇到两大缺点：</p>\n<p>（1）容易过拟合</p>\n<p>（2）费时</p>\n<p>Dropout可以比较有效的缓解过拟合的发生，在一定程度上达到 <strong><font color = \"red\">正则化</font></strong> 的效果。</p>\n<ul>\n<li><strong><font color = \"#6638F0\">正则化</font></strong> （regularization）是指为解决适定性问题或过拟合而加入额外信息的过程。</li>\n</ul>\n<h4 id=\"1-2-什么是Dropout\"><a href=\"#1-2-什么是Dropout\" class=\"headerlink\" title=\"1.2 什么是Dropout\"></a>1.2 什么是Dropout</h4><p>Dropout可以作为训练深度神经网络的 <strong><font color = \"red\">一种trick</font></strong> 供选择。在每个训练批次中，通过 <strong>忽略一半</strong> 的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。</p>\n<p>Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图所示。</p>\n<p><img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\" /></p>\n<h3 id=\"2-Dropout工作流程及使用\"><a href=\"#2-Dropout工作流程及使用\" class=\"headerlink\" title=\"2. Dropout工作流程及使用\"></a>2. Dropout工作流程及使用</h3><p>输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：</p>\n<ol>\n<li>首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）</li>\n</ol>\n<blockquote>\n<p>还没有搞懂，下次再看到dropout时，再回来对应学习</p>\n</blockquote>\n<ol>\n<li><p>然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。</p>\n</li>\n<li><p>然后继续重复这一过程：</p>\n</li>\n</ol>\n<ul>\n<li>恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）</li>\n<li>从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。</li>\n<li>对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。</li>\n</ul>\n"},{"title":"SimCSE完成情况","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"SimCSE完成情况","abbrlink":"939d","date":"2021-04-27T07:07:14.000Z","password":null,"keywords":null,"description":null,"_content":"<center> <h2>SimCSE完成情况<h2></center>\n\nPS\n\n\n- :sun_with_face:为顺利完成\n\n- :relaxed:为休息一天\n\n- :frowning:为尚未完成\n\n| <center>日期</center> | <center>学习情况</center>                                    | <center>完成度</center>          |\n| --------------------- | ------------------------------------------------------------ | -------------------------------- |\n| 4/27                  | 1.学习拟合，过拟合，欠拟合基础含义以及对应解决方法，误差和Dropout等基础知识<br>2.逐字翻译论文摘要，详细理解摘要内容<br>3.输出两篇整理文章SimCSE（一）和SimCSE（二） | <center>:sun_with_face:</center> |\n| 4/28                  | 1.学习了SimCSE文章中Introduce章节，逐句翻译查看中英文，了解将相同的输入语句传递给预训练的编码器两次获取正对嵌入，使用in-batch  negatives的方式作为负例，还需学习blog开篇知识点<br>     2.看论文Contrastive Representation Learning对比表示学习，《Understanding Contrastive  Representation Learning through Alignment and Uniformity on the  Hypersphere》。还需继续了解Alignment和Uniformity信息 | <center>:sun_with_face:</center> |\n| 4/29                  | 1.学习了SimCSE文章中的Background章节，逐句翻译，     了解了它采用了两个参数x和x+，他两个是语义相关的，     利用h和h+对其训练，用h去表示他们的相关性。     将图像进行两次随机变换得到x和x+，我的理解是x是h计算过后的结果。     Alignment和uniformity是关键属性，一个来计算期望距离，一个来计算均匀分布程度。 | <center>:sun_with_face:</center> |\n| 4/30                  | 1.学习了SimCSE文章中的Unsupervised  SimCSE and supervised SimCSE章节，逐句翻译<br>      2.实验结果很明显的可以看出，SimCSE是远超其余数据增强方法的。传统数据增强的方法是对原始输入直接进行改变，在编码后，增强的数据与原始数据在语义空间的距离是要比直接用dropout的方式要远,所以这样语义度更匹配，而且这种方法它可以让alingnment和uniformity的值逐渐降低，非常nice | <center>:sun_with_face:</center> |\n| 5/1                   | CBA，辽宁队必胜！！！！！                                    | <center>:relaxed:</center>       |\n| 5/2                   | 休息，躺着，玩                                               | <center>:relaxed:</center>       |\n| 5/3                   | 休息，躺着，玩                                               | <center>:relaxed:</center>       |\n| 5/4                   | 1.学习了SimCSE文章中的Connection to  Anisotropy章节，逐句翻译<br>     2.安装pytroch包以及配置conda虚拟环境，以及各种库<br>     3.看论文github代码，啥也不懂。。。。 | <center>:frowning:</center>      |\n| 5/5                   | 1.成功运行SimCSE  GitHub代码，成功运行Evaluation评估代码，并下载好训练模型 | <center>:sun_with_face:</center> |\n| 5/6                   | 1.整理一周所学论文知识点，汇总制作PPT<br>     2.浏览智能对话诊疗评测比赛信息 | <center>:sun_with_face:</center> |\n\n","source":"_posts/SimCSE完成情况.md","raw":"---\ntitle: SimCSE完成情况\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - SimCSE\n  - 计划\ncategories:\n  - 计划\nsummary: SimCSE完成情况\nabbrlink: 939d\ndate: 2021-04-27 15:07:14\npassword:\nkeywords:\ndescription:\n---\n<center> <h2>SimCSE完成情况<h2></center>\n\nPS\n\n\n- :sun_with_face:为顺利完成\n\n- :relaxed:为休息一天\n\n- :frowning:为尚未完成\n\n| <center>日期</center> | <center>学习情况</center>                                    | <center>完成度</center>          |\n| --------------------- | ------------------------------------------------------------ | -------------------------------- |\n| 4/27                  | 1.学习拟合，过拟合，欠拟合基础含义以及对应解决方法，误差和Dropout等基础知识<br>2.逐字翻译论文摘要，详细理解摘要内容<br>3.输出两篇整理文章SimCSE（一）和SimCSE（二） | <center>:sun_with_face:</center> |\n| 4/28                  | 1.学习了SimCSE文章中Introduce章节，逐句翻译查看中英文，了解将相同的输入语句传递给预训练的编码器两次获取正对嵌入，使用in-batch  negatives的方式作为负例，还需学习blog开篇知识点<br>     2.看论文Contrastive Representation Learning对比表示学习，《Understanding Contrastive  Representation Learning through Alignment and Uniformity on the  Hypersphere》。还需继续了解Alignment和Uniformity信息 | <center>:sun_with_face:</center> |\n| 4/29                  | 1.学习了SimCSE文章中的Background章节，逐句翻译，     了解了它采用了两个参数x和x+，他两个是语义相关的，     利用h和h+对其训练，用h去表示他们的相关性。     将图像进行两次随机变换得到x和x+，我的理解是x是h计算过后的结果。     Alignment和uniformity是关键属性，一个来计算期望距离，一个来计算均匀分布程度。 | <center>:sun_with_face:</center> |\n| 4/30                  | 1.学习了SimCSE文章中的Unsupervised  SimCSE and supervised SimCSE章节，逐句翻译<br>      2.实验结果很明显的可以看出，SimCSE是远超其余数据增强方法的。传统数据增强的方法是对原始输入直接进行改变，在编码后，增强的数据与原始数据在语义空间的距离是要比直接用dropout的方式要远,所以这样语义度更匹配，而且这种方法它可以让alingnment和uniformity的值逐渐降低，非常nice | <center>:sun_with_face:</center> |\n| 5/1                   | CBA，辽宁队必胜！！！！！                                    | <center>:relaxed:</center>       |\n| 5/2                   | 休息，躺着，玩                                               | <center>:relaxed:</center>       |\n| 5/3                   | 休息，躺着，玩                                               | <center>:relaxed:</center>       |\n| 5/4                   | 1.学习了SimCSE文章中的Connection to  Anisotropy章节，逐句翻译<br>     2.安装pytroch包以及配置conda虚拟环境，以及各种库<br>     3.看论文github代码，啥也不懂。。。。 | <center>:frowning:</center>      |\n| 5/5                   | 1.成功运行SimCSE  GitHub代码，成功运行Evaluation评估代码，并下载好训练模型 | <center>:sun_with_face:</center> |\n| 5/6                   | 1.整理一周所学论文知识点，汇总制作PPT<br>     2.浏览智能对话诊疗评测比赛信息 | <center>:sun_with_face:</center> |\n\n","slug":"SimCSE完成情况","published":1,"updated":"2021-05-17T05:20:28.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5n001ca09kf56563ma","content":"<center> <h2>SimCSE完成情况</h2><h2></h2></center>\n\n<p>PS</p>\n<ul>\n<li><p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span>为顺利完成</p>\n</li>\n<li><p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span>为休息一天</p>\n</li>\n<li><p><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span>为尚未完成</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>日期</center></th>\n<th><center>学习情况</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4/27</td>\n<td>1.学习拟合，过拟合，欠拟合基础含义以及对应解决方法，误差和Dropout等基础知识<br>2.逐字翻译论文摘要，详细理解摘要内容<br>3.输出两篇整理文章SimCSE（一）和SimCSE（二）</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>4/28</td>\n<td>1.学习了SimCSE文章中Introduce章节，逐句翻译查看中英文，了解将相同的输入语句传递给预训练的编码器两次获取正对嵌入，使用in-batch  negatives的方式作为负例，还需学习blog开篇知识点<br>     2.看论文Contrastive Representation Learning对比表示学习，《Understanding Contrastive  Representation Learning through Alignment and Uniformity on the  Hypersphere》。还需继续了解Alignment和Uniformity信息</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>4/29</td>\n<td>1.学习了SimCSE文章中的Background章节，逐句翻译，     了解了它采用了两个参数x和x+，他两个是语义相关的，     利用h和h+对其训练，用h去表示他们的相关性。     将图像进行两次随机变换得到x和x+，我的理解是x是h计算过后的结果。     Alignment和uniformity是关键属性，一个来计算期望距离，一个来计算均匀分布程度。</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>4/30</td>\n<td>1.学习了SimCSE文章中的Unsupervised  SimCSE and supervised SimCSE章节，逐句翻译<br>      2.实验结果很明显的可以看出，SimCSE是远超其余数据增强方法的。传统数据增强的方法是对原始输入直接进行改变，在编码后，增强的数据与原始数据在语义空间的距离是要比直接用dropout的方式要远,所以这样语义度更匹配，而且这种方法它可以让alingnment和uniformity的值逐渐降低，非常nice</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>5/1</td>\n<td>CBA，辽宁队必胜！！！！！</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>5/2</td>\n<td>休息，躺着，玩</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>5/3</td>\n<td>休息，躺着，玩</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>5/4</td>\n<td>1.学习了SimCSE文章中的Connection to  Anisotropy章节，逐句翻译<br>     2.安装pytroch包以及配置conda虚拟环境，以及各种库<br>     3.看论文github代码，啥也不懂。。。。</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span></center></td>\n</tr>\n<tr>\n<td>5/5</td>\n<td>1.成功运行SimCSE  GitHub代码，成功运行Evaluation评估代码，并下载好训练模型</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>5/6</td>\n<td>1.整理一周所学论文知识点，汇总制作PPT<br>     2.浏览智能对话诊疗评测比赛信息</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<center> <h2>SimCSE完成情况<h2></center>\n\n<p>PS</p>\n<ul>\n<li><p>:sun_with_face:为顺利完成</p>\n</li>\n<li><p>:relaxed:为休息一天</p>\n</li>\n<li><p>:frowning:为尚未完成</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>日期</center></th>\n<th><center>学习情况</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4/27</td>\n<td>1.学习拟合，过拟合，欠拟合基础含义以及对应解决方法，误差和Dropout等基础知识<br>2.逐字翻译论文摘要，详细理解摘要内容<br>3.输出两篇整理文章SimCSE（一）和SimCSE（二）</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>4/28</td>\n<td>1.学习了SimCSE文章中Introduce章节，逐句翻译查看中英文，了解将相同的输入语句传递给预训练的编码器两次获取正对嵌入，使用in-batch  negatives的方式作为负例，还需学习blog开篇知识点<br>     2.看论文Contrastive Representation Learning对比表示学习，《Understanding Contrastive  Representation Learning through Alignment and Uniformity on the  Hypersphere》。还需继续了解Alignment和Uniformity信息</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>4/29</td>\n<td>1.学习了SimCSE文章中的Background章节，逐句翻译，     了解了它采用了两个参数x和x+，他两个是语义相关的，     利用h和h+对其训练，用h去表示他们的相关性。     将图像进行两次随机变换得到x和x+，我的理解是x是h计算过后的结果。     Alignment和uniformity是关键属性，一个来计算期望距离，一个来计算均匀分布程度。</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>4/30</td>\n<td>1.学习了SimCSE文章中的Unsupervised  SimCSE and supervised SimCSE章节，逐句翻译<br>      2.实验结果很明显的可以看出，SimCSE是远超其余数据增强方法的。传统数据增强的方法是对原始输入直接进行改变，在编码后，增强的数据与原始数据在语义空间的距离是要比直接用dropout的方式要远,所以这样语义度更匹配，而且这种方法它可以让alingnment和uniformity的值逐渐降低，非常nice</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>5/1</td>\n<td>CBA，辽宁队必胜！！！！！</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>5/2</td>\n<td>休息，躺着，玩</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>5/3</td>\n<td>休息，躺着，玩</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>5/4</td>\n<td>1.学习了SimCSE文章中的Connection to  Anisotropy章节，逐句翻译<br>     2.安装pytroch包以及配置conda虚拟环境，以及各种库<br>     3.看论文github代码，啥也不懂。。。。</td>\n<td><center>:frowning:</center></td>\n</tr>\n<tr>\n<td>5/5</td>\n<td>1.成功运行SimCSE  GitHub代码，成功运行Evaluation评估代码，并下载好训练模型</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>5/6</td>\n<td>1.整理一周所学论文知识点，汇总制作PPT<br>     2.浏览智能对话诊疗评测比赛信息</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"SimCSE（七）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"Connection to Anisotropy","abbrlink":"f664","date":"2021-05-04T07:30:08.000Z","password":null,"keywords":null,"description":null,"_content":"# Simple Contrastive Learning of Sentence Embeddings（七）\n\n### 5 Connection to Anisotropy 各向异性连接\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- anisotropy（各向异性）是什么意思\n- isotropic distribution 各向同性分布\n- 奇异值singular是什么东西\n- 这些公式都要再看一下\n\n---\n\n\n\n> Recent work identifies an anisotropy problem in language representations (Ethayarajh, 2019; Li et al., 2020), i.e., the learned embeddings occupy a narrow cone in the vector space, which largely limits their expressiveness. \n\n- 最近的研究发现了语言表征中的“各向异性”问题，即学习到的嵌入在向量空间中占据了一个狭窄的圆锥体，这在很大程度上限制了它们的表达能力。\n\n> Gao et al. (2019) term it as a *representation degeneration* problem and demonstrate that language models trained with tied input/output embeddings lead to anisotropic word embeddings, and this is further observed by Ethayarajh (2019) in pretrained contextual embeddings. \n\n- Gao将其称为“表征退化”问题，并证明使用捆绑输入/输出嵌入训练的语言模型会导致各向异性的单词嵌入，Ethayarajh在预先训练的上下文嵌入中进一步观察到了这一点。\n\n> Wang et al. (2020) show that the singular values of the word embedding matrix decay drastically. In other words, except for a few dominating singular values, all others are close to zero.\n\n- Wang证明单词嵌入矩阵的奇异值急剧衰减。换言之，除了少数占主导地位的奇异值外，其他所有奇异值都接近于零。\n\n> A simple way to alleviate the problem is postprocessing, either to eliminate the dominant principal components (Arora et al., 2017; Mu and Viswanath, 2018), or to map embeddings to an isotropic distribution (Li et al., 2020; Su et al., 2021). \n\n- 缓解问题的一个简单方法是后处理，即消除主要的主成分，或将嵌入映射到各向同性分布。\n\n> Alternatively, one can add regularization during training (Gao et al., 2019; Wang et al., 2020). \n\n- 或者，可以在训练期间添加正则化。\n\n> In this section, we show that the contrastive objective can inherently “flatten” the singular value distribution of the sentence-embedding matrix.\n\n- 在这一节中，我们证明了对比目标可以内在地“平坦”句子嵌入矩阵的奇异值分布。\n\n> Following Wang and Isola (2020), the asymptotics of the contrastive learning objective can be expressed by the following equation when the number of negative instances approaches infinity (assuming f(x) is normalized):\n\n- 在Wang和Isola的基础上，对比学习目标的渐近性可以用以下等式表示，当负实例的数量接近无穷大时（假设f（x）是标准化的）：\n\n$$\n\\begin{array}{l}\n-\\frac{1}{\\tau} \\underset{\\left(x, x^{+}\\right) \\sim p_{\\mathrm{pos}}}{\\mathbb{E}}\\left[f(x)^{\\top} f\\left(x^{+}\\right)\\right] \n+\\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right]\n\\end{array}\n$$\n\n> where the first term keeps positive instances similar and the second pushes negative pairs apart. When $p_{data}$ is uniform over finite samples $\\{x_i\\}_{i=1}^m$ , with $h_i=f(x)$, we can derive the following formula from the second term with Jensen’s inequality:\n\n- 其中第一项保持正的实例相似，第二项将负的对分开。当$p_{data}$在有限样本$\\{x_i\\}_{i=1}^m$上是一致的，且$h_i=f（x）$，我们可以从第二项和詹森不等式导出以下公式：\n\n$$\n\\begin{aligned}\n& \\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right] \\\\\n=& \\frac{1}{m} \\sum_{i=1}^{m} \\log \\left(\\frac{1}{m} \\sum_{j=1}^{m} e^{\\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j} / \\tau}\\right) \\\\\n\\geq & \\frac{1}{\\tau m^{2}} \\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}\n\\end{aligned}\n$$\n\n> Let $W$ be the sentence embedding matrix corresponding to $\\{x_i\\}_{i=1}^m$, i.e., the i-th row of $W$ is $h_i$. \n\n- 设$W$为$\\{x_i\\}_{i=1}^m$对应的句子嵌入矩阵，即W的第i行为$h_i$。\n\n> Ignoring the constant terms, optimizing the second term in Eq essentially minimizes an upper bound of the summation of all elements in $WW^T$, i.e., $\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$\n\n- 忽略常量项，优化了等式1中的第二项实质上最小化了$WW^T$中所有元素之和的上限，即$\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$\n\n\n\n> Since we normalize $h_i$, all elements on the diagonal of $WW^T$ are 1 and then $tr(WW^T)$, also the sum of all eigenvalues, is a constant. \n\n- 因为我们规范化了$h_i$，所以$WW^T$对角线上的所有元素都是1，$tr（WW^T）$，也是所有特征值的总和，是一个常数。\n\n> According to Merikoski (1984), if all elements in $WW^T$ are positive, which is the case in most times from Gao et al. (2019), then $Sum(WW^T)$ is an upper bound for the largest eigenvalue of $WW^T$. \n\n- 根据Merikoski，如果$WW^T$中的所有元素都是正的，这在Gao的大多数情况下都是这样，那么$Sum（WW^T）$是最大特征值$WW^T$的上界。\n\n> Therefore, when minimizing the second term in Eq1, we are reducing the top eigenvalue of $WW^T$ and inherently “flattening” the singular spectrum of the embedding space.\n\n- 因此，当最小化Eq1中的第二项时，我们减少了$WW^T$的顶部特征值，并且固有地“平坦”了嵌入空间的奇异谱。\n\n> Hence contrastive learning can potentially tackle the representation degeneration problem and improve the uniformity.\n\n- 因此，对比学习有可能解决表征退化问题，提高一致性。\n\n> Compared to postprocessing methods in Li et al. (2020); Su et al. (2021), which only aim to encourage isotropic representations, contrastive learning also optimizes for aligning positive pairs by the first term in Eq. 6, which is the key to the success of SimCSE (a quantitative analysis is given in §7).\n\n- 与Li等人（2020）的后处理方法相比；Su等人（2021年）只致力于鼓励各向同性表征，对比学习还优化了等式1中第一项的正对对齐，这是SimCSE成功的关键（定量分析见第七章表1）.\n\n---\n\n\n\n","source":"_posts/SimCSE（七）.md","raw":"---\ntitle: SimCSE（七）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nsummary: Connection to Anisotropy\nabbrlink: f664\ndate: 2021-05-04 15:30:08\npassword:\nkeywords:\ndescription:\n---\n# Simple Contrastive Learning of Sentence Embeddings（七）\n\n### 5 Connection to Anisotropy 各向异性连接\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- anisotropy（各向异性）是什么意思\n- isotropic distribution 各向同性分布\n- 奇异值singular是什么东西\n- 这些公式都要再看一下\n\n---\n\n\n\n> Recent work identifies an anisotropy problem in language representations (Ethayarajh, 2019; Li et al., 2020), i.e., the learned embeddings occupy a narrow cone in the vector space, which largely limits their expressiveness. \n\n- 最近的研究发现了语言表征中的“各向异性”问题，即学习到的嵌入在向量空间中占据了一个狭窄的圆锥体，这在很大程度上限制了它们的表达能力。\n\n> Gao et al. (2019) term it as a *representation degeneration* problem and demonstrate that language models trained with tied input/output embeddings lead to anisotropic word embeddings, and this is further observed by Ethayarajh (2019) in pretrained contextual embeddings. \n\n- Gao将其称为“表征退化”问题，并证明使用捆绑输入/输出嵌入训练的语言模型会导致各向异性的单词嵌入，Ethayarajh在预先训练的上下文嵌入中进一步观察到了这一点。\n\n> Wang et al. (2020) show that the singular values of the word embedding matrix decay drastically. In other words, except for a few dominating singular values, all others are close to zero.\n\n- Wang证明单词嵌入矩阵的奇异值急剧衰减。换言之，除了少数占主导地位的奇异值外，其他所有奇异值都接近于零。\n\n> A simple way to alleviate the problem is postprocessing, either to eliminate the dominant principal components (Arora et al., 2017; Mu and Viswanath, 2018), or to map embeddings to an isotropic distribution (Li et al., 2020; Su et al., 2021). \n\n- 缓解问题的一个简单方法是后处理，即消除主要的主成分，或将嵌入映射到各向同性分布。\n\n> Alternatively, one can add regularization during training (Gao et al., 2019; Wang et al., 2020). \n\n- 或者，可以在训练期间添加正则化。\n\n> In this section, we show that the contrastive objective can inherently “flatten” the singular value distribution of the sentence-embedding matrix.\n\n- 在这一节中，我们证明了对比目标可以内在地“平坦”句子嵌入矩阵的奇异值分布。\n\n> Following Wang and Isola (2020), the asymptotics of the contrastive learning objective can be expressed by the following equation when the number of negative instances approaches infinity (assuming f(x) is normalized):\n\n- 在Wang和Isola的基础上，对比学习目标的渐近性可以用以下等式表示，当负实例的数量接近无穷大时（假设f（x）是标准化的）：\n\n$$\n\\begin{array}{l}\n-\\frac{1}{\\tau} \\underset{\\left(x, x^{+}\\right) \\sim p_{\\mathrm{pos}}}{\\mathbb{E}}\\left[f(x)^{\\top} f\\left(x^{+}\\right)\\right] \n+\\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right]\n\\end{array}\n$$\n\n> where the first term keeps positive instances similar and the second pushes negative pairs apart. When $p_{data}$ is uniform over finite samples $\\{x_i\\}_{i=1}^m$ , with $h_i=f(x)$, we can derive the following formula from the second term with Jensen’s inequality:\n\n- 其中第一项保持正的实例相似，第二项将负的对分开。当$p_{data}$在有限样本$\\{x_i\\}_{i=1}^m$上是一致的，且$h_i=f（x）$，我们可以从第二项和詹森不等式导出以下公式：\n\n$$\n\\begin{aligned}\n& \\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right] \\\\\n=& \\frac{1}{m} \\sum_{i=1}^{m} \\log \\left(\\frac{1}{m} \\sum_{j=1}^{m} e^{\\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j} / \\tau}\\right) \\\\\n\\geq & \\frac{1}{\\tau m^{2}} \\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}\n\\end{aligned}\n$$\n\n> Let $W$ be the sentence embedding matrix corresponding to $\\{x_i\\}_{i=1}^m$, i.e., the i-th row of $W$ is $h_i$. \n\n- 设$W$为$\\{x_i\\}_{i=1}^m$对应的句子嵌入矩阵，即W的第i行为$h_i$。\n\n> Ignoring the constant terms, optimizing the second term in Eq essentially minimizes an upper bound of the summation of all elements in $WW^T$, i.e., $\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$\n\n- 忽略常量项，优化了等式1中的第二项实质上最小化了$WW^T$中所有元素之和的上限，即$\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$\n\n\n\n> Since we normalize $h_i$, all elements on the diagonal of $WW^T$ are 1 and then $tr(WW^T)$, also the sum of all eigenvalues, is a constant. \n\n- 因为我们规范化了$h_i$，所以$WW^T$对角线上的所有元素都是1，$tr（WW^T）$，也是所有特征值的总和，是一个常数。\n\n> According to Merikoski (1984), if all elements in $WW^T$ are positive, which is the case in most times from Gao et al. (2019), then $Sum(WW^T)$ is an upper bound for the largest eigenvalue of $WW^T$. \n\n- 根据Merikoski，如果$WW^T$中的所有元素都是正的，这在Gao的大多数情况下都是这样，那么$Sum（WW^T）$是最大特征值$WW^T$的上界。\n\n> Therefore, when minimizing the second term in Eq1, we are reducing the top eigenvalue of $WW^T$ and inherently “flattening” the singular spectrum of the embedding space.\n\n- 因此，当最小化Eq1中的第二项时，我们减少了$WW^T$的顶部特征值，并且固有地“平坦”了嵌入空间的奇异谱。\n\n> Hence contrastive learning can potentially tackle the representation degeneration problem and improve the uniformity.\n\n- 因此，对比学习有可能解决表征退化问题，提高一致性。\n\n> Compared to postprocessing methods in Li et al. (2020); Su et al. (2021), which only aim to encourage isotropic representations, contrastive learning also optimizes for aligning positive pairs by the first term in Eq. 6, which is the key to the success of SimCSE (a quantitative analysis is given in §7).\n\n- 与Li等人（2020）的后处理方法相比；Su等人（2021年）只致力于鼓励各向同性表征，对比学习还优化了等式1中第一项的正对对齐，这是SimCSE成功的关键（定量分析见第七章表1）.\n\n---\n\n\n\n","slug":"SimCSE（七）","published":1,"updated":"2021-05-04T07:34:27.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5o001ha09kfl1lf6sy","content":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（七）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（七）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（七）\"></a>Simple Contrastive Learning of Sentence Embeddings（七）</h1><h3 id=\"5-Connection-to-Anisotropy-各向异性连接\"><a href=\"#5-Connection-to-Anisotropy-各向异性连接\" class=\"headerlink\" title=\"5 Connection to Anisotropy 各向异性连接\"></a>5 Connection to Anisotropy 各向异性连接</h3><h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color=\"red\">还需学习的知识点</font></h4><ul>\n<li>anisotropy（各向异性）是什么意思</li>\n<li>isotropic distribution 各向同性分布</li>\n<li>奇异值singular是什么东西</li>\n<li>这些公式都要再看一下</li>\n</ul>\n<hr>\n<blockquote>\n<p>Recent work identifies an anisotropy problem in language representations (Ethayarajh, 2019; Li et al., 2020), i.e., the learned embeddings occupy a narrow cone in the vector space, which largely limits their expressiveness. </p>\n</blockquote>\n<ul>\n<li>最近的研究发现了语言表征中的“各向异性”问题，即学习到的嵌入在向量空间中占据了一个狭窄的圆锥体，这在很大程度上限制了它们的表达能力。</li>\n</ul>\n<blockquote>\n<p>Gao et al. (2019) term it as a <em>representation degeneration</em> problem and demonstrate that language models trained with tied input/output embeddings lead to anisotropic word embeddings, and this is further observed by Ethayarajh (2019) in pretrained contextual embeddings. </p>\n</blockquote>\n<ul>\n<li>Gao将其称为“表征退化”问题，并证明使用捆绑输入/输出嵌入训练的语言模型会导致各向异性的单词嵌入，Ethayarajh在预先训练的上下文嵌入中进一步观察到了这一点。</li>\n</ul>\n<blockquote>\n<p>Wang et al. (2020) show that the singular values of the word embedding matrix decay drastically. In other words, except for a few dominating singular values, all others are close to zero.</p>\n</blockquote>\n<ul>\n<li>Wang证明单词嵌入矩阵的奇异值急剧衰减。换言之，除了少数占主导地位的奇异值外，其他所有奇异值都接近于零。</li>\n</ul>\n<blockquote>\n<p>A simple way to alleviate the problem is postprocessing, either to eliminate the dominant principal components (Arora et al., 2017; Mu and Viswanath, 2018), or to map embeddings to an isotropic distribution (Li et al., 2020; Su et al., 2021). </p>\n</blockquote>\n<ul>\n<li>缓解问题的一个简单方法是后处理，即消除主要的主成分，或将嵌入映射到各向同性分布。</li>\n</ul>\n<blockquote>\n<p>Alternatively, one can add regularization during training (Gao et al., 2019; Wang et al., 2020). </p>\n</blockquote>\n<ul>\n<li>或者，可以在训练期间添加正则化。</li>\n</ul>\n<blockquote>\n<p>In this section, we show that the contrastive objective can inherently “flatten” the singular value distribution of the sentence-embedding matrix.</p>\n</blockquote>\n<ul>\n<li>在这一节中，我们证明了对比目标可以内在地“平坦”句子嵌入矩阵的奇异值分布。</li>\n</ul>\n<blockquote>\n<p>Following Wang and Isola (2020), the asymptotics of the contrastive learning objective can be expressed by the following equation when the number of negative instances approaches infinity (assuming f(x) is normalized):</p>\n</blockquote>\n<ul>\n<li>在Wang和Isola的基础上，对比学习目标的渐近性可以用以下等式表示，当负实例的数量接近无穷大时（假设f（x）是标准化的）：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}\n-\\frac{1}{\\tau} \\underset{\\left(x, x^{+}\\right) \\sim p_{\\mathrm{pos}}}{\\mathbb{E}}\\left[f(x)^{\\top} f\\left(x^{+}\\right)\\right] \n+\\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right]\n\\end{array}</script><blockquote>\n<p>where the first term keeps positive instances similar and the second pushes negative pairs apart. When $p_{data}$ is uniform over finite samples $\\{x_i\\}_{i=1}^m$ , with $h_i=f(x)$, we can derive the following formula from the second term with Jensen’s inequality:</p>\n</blockquote>\n<ul>\n<li>其中第一项保持正的实例相似，第二项将负的对分开。当$p_{data}$在有限样本$\\{x_i\\}_{i=1}^m$上是一致的，且$h_i=f（x）$，我们可以从第二项和詹森不等式导出以下公式：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n& \\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right] \\\\\n=& \\frac{1}{m} \\sum_{i=1}^{m} \\log \\left(\\frac{1}{m} \\sum_{j=1}^{m} e^{\\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j} / \\tau}\\right) \\\\\n\\geq & \\frac{1}{\\tau m^{2}} \\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}\n\\end{aligned}</script><blockquote>\n<p>Let $W$ be the sentence embedding matrix corresponding to $\\{x_i\\}_{i=1}^m$, i.e., the i-th row of $W$ is $h_i$. </p>\n</blockquote>\n<ul>\n<li>设$W$为$\\{x_i\\}_{i=1}^m$对应的句子嵌入矩阵，即W的第i行为$h_i$。</li>\n</ul>\n<blockquote>\n<p>Ignoring the constant terms, optimizing the second term in Eq essentially minimizes an upper bound of the summation of all elements in $WW^T$, i.e., $\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$</p>\n</blockquote>\n<ul>\n<li>忽略常量项，优化了等式1中的第二项实质上最小化了$WW^T$中所有元素之和的上限，即$\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$</li>\n</ul>\n<blockquote>\n<p>Since we normalize $h_i$, all elements on the diagonal of $WW^T$ are 1 and then $tr(WW^T)$, also the sum of all eigenvalues, is a constant. </p>\n</blockquote>\n<ul>\n<li>因为我们规范化了$h_i$，所以$WW^T$对角线上的所有元素都是1，$tr（WW^T）$，也是所有特征值的总和，是一个常数。</li>\n</ul>\n<blockquote>\n<p>According to Merikoski (1984), if all elements in $WW^T$ are positive, which is the case in most times from Gao et al. (2019), then $Sum(WW^T)$ is an upper bound for the largest eigenvalue of $WW^T$. </p>\n</blockquote>\n<ul>\n<li>根据Merikoski，如果$WW^T$中的所有元素都是正的，这在Gao的大多数情况下都是这样，那么$Sum（WW^T）$是最大特征值$WW^T$的上界。</li>\n</ul>\n<blockquote>\n<p>Therefore, when minimizing the second term in Eq1, we are reducing the top eigenvalue of $WW^T$ and inherently “flattening” the singular spectrum of the embedding space.</p>\n</blockquote>\n<ul>\n<li>因此，当最小化Eq1中的第二项时，我们减少了$WW^T$的顶部特征值，并且固有地“平坦”了嵌入空间的奇异谱。</li>\n</ul>\n<blockquote>\n<p>Hence contrastive learning can potentially tackle the representation degeneration problem and improve the uniformity.</p>\n</blockquote>\n<ul>\n<li>因此，对比学习有可能解决表征退化问题，提高一致性。</li>\n</ul>\n<blockquote>\n<p>Compared to postprocessing methods in Li et al. (2020); Su et al. (2021), which only aim to encourage isotropic representations, contrastive learning also optimizes for aligning positive pairs by the first term in Eq. 6, which is the key to the success of SimCSE (a quantitative analysis is given in §7).</p>\n</blockquote>\n<ul>\n<li>与Li等人（2020）的后处理方法相比；Su等人（2021年）只致力于鼓励各向同性表征，对比学习还优化了等式1中第一项的正对对齐，这是SimCSE成功的关键（定量分析见第七章表1）.</li>\n</ul>\n<hr>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（七）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（七）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（七）\"></a>Simple Contrastive Learning of Sentence Embeddings（七）</h1><h3 id=\"5-Connection-to-Anisotropy-各向异性连接\"><a href=\"#5-Connection-to-Anisotropy-各向异性连接\" class=\"headerlink\" title=\"5 Connection to Anisotropy 各向异性连接\"></a>5 Connection to Anisotropy 各向异性连接</h3><h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color = \"red\">还需学习的知识点</font></h4><ul>\n<li>anisotropy（各向异性）是什么意思</li>\n<li>isotropic distribution 各向同性分布</li>\n<li>奇异值singular是什么东西</li>\n<li>这些公式都要再看一下</li>\n</ul>\n<hr>\n<blockquote>\n<p>Recent work identifies an anisotropy problem in language representations (Ethayarajh, 2019; Li et al., 2020), i.e., the learned embeddings occupy a narrow cone in the vector space, which largely limits their expressiveness. </p>\n</blockquote>\n<ul>\n<li>最近的研究发现了语言表征中的“各向异性”问题，即学习到的嵌入在向量空间中占据了一个狭窄的圆锥体，这在很大程度上限制了它们的表达能力。</li>\n</ul>\n<blockquote>\n<p>Gao et al. (2019) term it as a <em>representation degeneration</em> problem and demonstrate that language models trained with tied input/output embeddings lead to anisotropic word embeddings, and this is further observed by Ethayarajh (2019) in pretrained contextual embeddings. </p>\n</blockquote>\n<ul>\n<li>Gao将其称为“表征退化”问题，并证明使用捆绑输入/输出嵌入训练的语言模型会导致各向异性的单词嵌入，Ethayarajh在预先训练的上下文嵌入中进一步观察到了这一点。</li>\n</ul>\n<blockquote>\n<p>Wang et al. (2020) show that the singular values of the word embedding matrix decay drastically. In other words, except for a few dominating singular values, all others are close to zero.</p>\n</blockquote>\n<ul>\n<li>Wang证明单词嵌入矩阵的奇异值急剧衰减。换言之，除了少数占主导地位的奇异值外，其他所有奇异值都接近于零。</li>\n</ul>\n<blockquote>\n<p>A simple way to alleviate the problem is postprocessing, either to eliminate the dominant principal components (Arora et al., 2017; Mu and Viswanath, 2018), or to map embeddings to an isotropic distribution (Li et al., 2020; Su et al., 2021). </p>\n</blockquote>\n<ul>\n<li>缓解问题的一个简单方法是后处理，即消除主要的主成分，或将嵌入映射到各向同性分布。</li>\n</ul>\n<blockquote>\n<p>Alternatively, one can add regularization during training (Gao et al., 2019; Wang et al., 2020). </p>\n</blockquote>\n<ul>\n<li>或者，可以在训练期间添加正则化。</li>\n</ul>\n<blockquote>\n<p>In this section, we show that the contrastive objective can inherently “flatten” the singular value distribution of the sentence-embedding matrix.</p>\n</blockquote>\n<ul>\n<li>在这一节中，我们证明了对比目标可以内在地“平坦”句子嵌入矩阵的奇异值分布。</li>\n</ul>\n<blockquote>\n<p>Following Wang and Isola (2020), the asymptotics of the contrastive learning objective can be expressed by the following equation when the number of negative instances approaches infinity (assuming f(x) is normalized):</p>\n</blockquote>\n<ul>\n<li>在Wang和Isola的基础上，对比学习目标的渐近性可以用以下等式表示，当负实例的数量接近无穷大时（假设f（x）是标准化的）：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}\n-\\frac{1}{\\tau} \\underset{\\left(x, x^{+}\\right) \\sim p_{\\mathrm{pos}}}{\\mathbb{E}}\\left[f(x)^{\\top} f\\left(x^{+}\\right)\\right] \n+\\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right]\n\\end{array}</script><blockquote>\n<p>where the first term keeps positive instances similar and the second pushes negative pairs apart. When $p_{data}$ is uniform over finite samples $\\{x_i\\}_{i=1}^m$ , with $h_i=f(x)$, we can derive the following formula from the second term with Jensen’s inequality:</p>\n</blockquote>\n<ul>\n<li>其中第一项保持正的实例相似，第二项将负的对分开。当$p_{data}$在有限样本$\\{x_i\\}_{i=1}^m$上是一致的，且$h_i=f（x）$，我们可以从第二项和詹森不等式导出以下公式：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n& \\underset{x \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[\\log \\underset{x^{-} \\sim p_{\\text {data }}}{\\mathbb{E}}\\left[e^{f(x)^{\\top} f\\left(x^{-}\\right) / \\tau}\\right]\\right] \\\\\n=& \\frac{1}{m} \\sum_{i=1}^{m} \\log \\left(\\frac{1}{m} \\sum_{j=1}^{m} e^{\\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j} / \\tau}\\right) \\\\\n\\geq & \\frac{1}{\\tau m^{2}} \\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}\n\\end{aligned}</script><blockquote>\n<p>Let $W$ be the sentence embedding matrix corresponding to $\\{x_i\\}_{i=1}^m$, i.e., the i-th row of $W$ is $h_i$. </p>\n</blockquote>\n<ul>\n<li>设$W$为$\\{x_i\\}_{i=1}^m$对应的句子嵌入矩阵，即W的第i行为$h_i$。</li>\n</ul>\n<blockquote>\n<p>Ignoring the constant terms, optimizing the second term in Eq essentially minimizes an upper bound of the summation of all elements in $WW^T$, i.e., $\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$</p>\n</blockquote>\n<ul>\n<li>忽略常量项，优化了等式1中的第二项实质上最小化了$WW^T$中所有元素之和的上限，即$\\operatorname{Sum}\\left(\\mathbf{W} \\mathbf{W}^{\\top}\\right)=\\sum_{i=1}^{m} \\sum_{j=1}^{m} \\mathbf{h}_{i}^{\\top} \\mathbf{h}_{j}$</li>\n</ul>\n<blockquote>\n<p>Since we normalize $h_i$, all elements on the diagonal of $WW^T$ are 1 and then $tr(WW^T)$, also the sum of all eigenvalues, is a constant. </p>\n</blockquote>\n<ul>\n<li>因为我们规范化了$h_i$，所以$WW^T$对角线上的所有元素都是1，$tr（WW^T）$，也是所有特征值的总和，是一个常数。</li>\n</ul>\n<blockquote>\n<p>According to Merikoski (1984), if all elements in $WW^T$ are positive, which is the case in most times from Gao et al. (2019), then $Sum(WW^T)$ is an upper bound for the largest eigenvalue of $WW^T$. </p>\n</blockquote>\n<ul>\n<li>根据Merikoski，如果$WW^T$中的所有元素都是正的，这在Gao的大多数情况下都是这样，那么$Sum（WW^T）$是最大特征值$WW^T$的上界。</li>\n</ul>\n<blockquote>\n<p>Therefore, when minimizing the second term in Eq1, we are reducing the top eigenvalue of $WW^T$ and inherently “flattening” the singular spectrum of the embedding space.</p>\n</blockquote>\n<ul>\n<li>因此，当最小化Eq1中的第二项时，我们减少了$WW^T$的顶部特征值，并且固有地“平坦”了嵌入空间的奇异谱。</li>\n</ul>\n<blockquote>\n<p>Hence contrastive learning can potentially tackle the representation degeneration problem and improve the uniformity.</p>\n</blockquote>\n<ul>\n<li>因此，对比学习有可能解决表征退化问题，提高一致性。</li>\n</ul>\n<blockquote>\n<p>Compared to postprocessing methods in Li et al. (2020); Su et al. (2021), which only aim to encourage isotropic representations, contrastive learning also optimizes for aligning positive pairs by the first term in Eq. 6, which is the key to the success of SimCSE (a quantitative analysis is given in §7).</p>\n</blockquote>\n<ul>\n<li>与Li等人（2020）的后处理方法相比；Su等人（2021年）只致力于鼓励各向同性表征，对比学习还优化了等式1中第一项的正对对齐，这是SimCSE成功的关键（定量分析见第七章表1）.</li>\n</ul>\n<hr>\n"},{"title":"SimCSE（三）","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"3b4c","date":"2021-04-28T02:31:04.000Z","password":null,"keywords":null,"description":null,"summary":"ICML2020","_content":"## Simple Contrastive Learning of Sentence Embeddings（三）\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- **Alignment**\n- **Uniformity**\n\n------\n\n#### 对比表示学习（Contrastive Representation Learning）\n\n\n对比学习的核心思想是将正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。\n\n> **Title**: 《Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere》\n> **Author**:Tongzhou Wang ; Phillip Isola\n\n\n\n[Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere](ICML2020.pdf) （通过超球面上的对齐和一致性理解对比表示学习）指出了Contrastive representation learning的两个重要属性：\n\n- **Alignment（计算正例对之间的向量距离的期望）:** two samples forming a positive pair should be mapped to nearby features, and thus be （mostly） invariant to unneeded noise factors. **Similar samples have similar features.** （正例之间表示保持较近距离）\n  - 越相似的样例之间的alignment程度越高。因为alignment使用距离来衡量，所以距离越小，表示alignment的程度越高。\n- **Uniformity（评估所有数据的向量均匀分布的程度，越均匀，保留的信息越多）:** feature vectors should be roughly uniformly distributed on the unit hypersphere, pre-serving as much information of the data as possible. **Illustration of alignment and uniformity of feature distributions on the output unit hypersphere.** （随机样例的表示应分散在超球面上）\n  - 可以想象任意从表示空间中采样两个数据和, 希望他们的距离比较远。他们的距离越远，证明空间分布越uniform。所以uniformity的值也是越低越好。\n\n![对比表示学习](对比表示学习.webp)\n\nSimCSE也采用这两个指标来衡量生成的句子向量，并证明了文本的语义空间也满足：alignment值越低且uniformity值越低，向量表示的质量越高，在STS任务上的Spearman相关系数越高。\n\n\n- 作者证明了现有的一些对比学习的算法正是较好地满足了这两条性质才取得了不错的效果。\n- 作者提出了一个可优化的 metric (策略方法)来直接量化这两条属性。通过直接优化该loss（损失），也取得了较好的效果。\n\n","source":"_posts/SimCSE（三）.md","raw":"---\ntitle: SimCSE（三）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nabbrlink: 3b4c\ndate: 2021-04-28 10:31:04\npassword:\nkeywords:\ndescription:\nsummary: ICML2020\n---\n## Simple Contrastive Learning of Sentence Embeddings（三）\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- **Alignment**\n- **Uniformity**\n\n------\n\n#### 对比表示学习（Contrastive Representation Learning）\n\n\n对比学习的核心思想是将正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。\n\n> **Title**: 《Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere》\n> **Author**:Tongzhou Wang ; Phillip Isola\n\n\n\n[Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere](ICML2020.pdf) （通过超球面上的对齐和一致性理解对比表示学习）指出了Contrastive representation learning的两个重要属性：\n\n- **Alignment（计算正例对之间的向量距离的期望）:** two samples forming a positive pair should be mapped to nearby features, and thus be （mostly） invariant to unneeded noise factors. **Similar samples have similar features.** （正例之间表示保持较近距离）\n  - 越相似的样例之间的alignment程度越高。因为alignment使用距离来衡量，所以距离越小，表示alignment的程度越高。\n- **Uniformity（评估所有数据的向量均匀分布的程度，越均匀，保留的信息越多）:** feature vectors should be roughly uniformly distributed on the unit hypersphere, pre-serving as much information of the data as possible. **Illustration of alignment and uniformity of feature distributions on the output unit hypersphere.** （随机样例的表示应分散在超球面上）\n  - 可以想象任意从表示空间中采样两个数据和, 希望他们的距离比较远。他们的距离越远，证明空间分布越uniform。所以uniformity的值也是越低越好。\n\n![对比表示学习](对比表示学习.webp)\n\nSimCSE也采用这两个指标来衡量生成的句子向量，并证明了文本的语义空间也满足：alignment值越低且uniformity值越低，向量表示的质量越高，在STS任务上的Spearman相关系数越高。\n\n\n- 作者证明了现有的一些对比学习的算法正是较好地满足了这两条性质才取得了不错的效果。\n- 作者提出了一个可优化的 metric (策略方法)来直接量化这两条属性。通过直接优化该loss（损失），也取得了较好的效果。\n\n","slug":"SimCSE（三）","published":1,"updated":"2021-04-28T06:53:15.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5p001ka09kdpcj16mv","content":"<h2 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（三）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（三）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（三）\"></a>Simple Contrastive Learning of Sentence Embeddings（三）</h2><h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color=\"red\">还需学习的知识点</font></h4><ul>\n<li><strong>Alignment</strong></li>\n<li><strong>Uniformity</strong></li>\n</ul>\n<hr>\n<h4 id=\"对比表示学习（Contrastive-Representation-Learning）\"><a href=\"#对比表示学习（Contrastive-Representation-Learning）\" class=\"headerlink\" title=\"对比表示学习（Contrastive Representation Learning）\"></a>对比表示学习（Contrastive Representation Learning）</h4><p>对比学习的核心思想是将正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。</p>\n<blockquote>\n<p><strong>Title</strong>: 《Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere》<br><strong>Author</strong>:Tongzhou Wang ; Phillip Isola</p>\n</blockquote>\n<p><a href=\"ICML2020.pdf\">Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</a> （通过超球面上的对齐和一致性理解对比表示学习）指出了Contrastive representation learning的两个重要属性：</p>\n<ul>\n<li><strong>Alignment（计算正例对之间的向量距离的期望）:</strong> two samples forming a positive pair should be mapped to nearby features, and thus be （mostly） invariant to unneeded noise factors. <strong>Similar samples have similar features.</strong> （正例之间表示保持较近距离）<ul>\n<li>越相似的样例之间的alignment程度越高。因为alignment使用距离来衡量，所以距离越小，表示alignment的程度越高。</li>\n</ul>\n</li>\n<li><strong>Uniformity（评估所有数据的向量均匀分布的程度，越均匀，保留的信息越多）:</strong> feature vectors should be roughly uniformly distributed on the unit hypersphere, pre-serving as much information of the data as possible. <strong>Illustration of alignment and uniformity of feature distributions on the output unit hypersphere.</strong> （随机样例的表示应分散在超球面上）<ul>\n<li>可以想象任意从表示空间中采样两个数据和, 希望他们的距离比较远。他们的距离越远，证明空间分布越uniform。所以uniformity的值也是越低越好。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"对比表示学习.webp\" alt=\"对比表示学习\"></p>\n<p>SimCSE也采用这两个指标来衡量生成的句子向量，并证明了文本的语义空间也满足：alignment值越低且uniformity值越低，向量表示的质量越高，在STS任务上的Spearman相关系数越高。</p>\n<ul>\n<li>作者证明了现有的一些对比学习的算法正是较好地满足了这两条性质才取得了不错的效果。</li>\n<li>作者提出了一个可优化的 metric (策略方法)来直接量化这两条属性。通过直接优化该loss（损失），也取得了较好的效果。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（三）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（三）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（三）\"></a>Simple Contrastive Learning of Sentence Embeddings（三）</h2><h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color = \"red\">还需学习的知识点</font></h4><ul>\n<li><strong>Alignment</strong></li>\n<li><strong>Uniformity</strong></li>\n</ul>\n<hr>\n<h4 id=\"对比表示学习（Contrastive-Representation-Learning）\"><a href=\"#对比表示学习（Contrastive-Representation-Learning）\" class=\"headerlink\" title=\"对比表示学习（Contrastive Representation Learning）\"></a>对比表示学习（Contrastive Representation Learning）</h4><p>对比学习的核心思想是将正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。</p>\n<blockquote>\n<p><strong>Title</strong>: 《Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere》<br><strong>Author</strong>:Tongzhou Wang ; Phillip Isola</p>\n</blockquote>\n<p><a href=\"ICML2020.pdf\">Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</a> （通过超球面上的对齐和一致性理解对比表示学习）指出了Contrastive representation learning的两个重要属性：</p>\n<ul>\n<li><strong>Alignment（计算正例对之间的向量距离的期望）:</strong> two samples forming a positive pair should be mapped to nearby features, and thus be （mostly） invariant to unneeded noise factors. <strong>Similar samples have similar features.</strong> （正例之间表示保持较近距离）<ul>\n<li>越相似的样例之间的alignment程度越高。因为alignment使用距离来衡量，所以距离越小，表示alignment的程度越高。</li>\n</ul>\n</li>\n<li><strong>Uniformity（评估所有数据的向量均匀分布的程度，越均匀，保留的信息越多）:</strong> feature vectors should be roughly uniformly distributed on the unit hypersphere, pre-serving as much information of the data as possible. <strong>Illustration of alignment and uniformity of feature distributions on the output unit hypersphere.</strong> （随机样例的表示应分散在超球面上）<ul>\n<li>可以想象任意从表示空间中采样两个数据和, 希望他们的距离比较远。他们的距离越远，证明空间分布越uniform。所以uniformity的值也是越低越好。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"对比表示学习.webp\" alt=\"对比表示学习\"></p>\n<p>SimCSE也采用这两个指标来衡量生成的句子向量，并证明了文本的语义空间也满足：alignment值越低且uniformity值越低，向量表示的质量越高，在STS任务上的Spearman相关系数越高。</p>\n<ul>\n<li>作者证明了现有的一些对比学习的算法正是较好地满足了这两条性质才取得了不错的效果。</li>\n<li>作者提出了一个可优化的 metric (策略方法)来直接量化这两条属性。通过直接优化该loss（损失），也取得了较好的效果。</li>\n</ul>\n"},{"title":"SimCSE（九）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"初步代码运行","abbrlink":"1e5f","date":"2021-05-05T07:41:25.000Z","password":null,"keywords":null,"description":null,"_content":"# SimCSE运行\n\n# 运行结果\n\n<img src=\"训练结果.png\" alt=\"训练结果\" style=\"zoom:67%;\" />\n\n---\n\n- 先安装好torch和所需库\n\n- 先下载评估数据，并且要安装wegt以便运行bash语句\n\n- ```sh\n  cd SentEval/data/downstream/\n  bash download_dataset.sh\n  ```\n\n- **经向作者发邮件咨询如何运行以及参数调试**\n\n- ```python\n  python evaluation.py --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased\n  ```\n\n- 运行语句设置\n\n- ```python\n  python evaluation.py \\\n      --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased \\\n      --pooler cls \\\n      --task_set sts \\\n      --mode test\n  ```\n\n## Evaluation\n\nArguments for the evaluation script are as follows,\n\n- `--model_name_or_path`: The name or path of a `transformers`-based pre-trained checkpoint. You can directly use the models in the above table, e.g., `princeton-nlp/sup-simcse-bert-base-uncased`.\n- `--pooler`: Pooling method. Now we support\n  - `cls` (default): Use the representation of `[CLS]` token. A linear+activation layer is applied after the representation (it's in the standard BERT implementation). If you use SimCSE, you should use this option.\n  - `cls_before_pooler`: Use the representation of `[CLS]` token without the extra linear+activation.\n  - `avg`: Average embeddings of the last layer. If you use checkpoints of SBERT/SRoBERTa ([paper](https://arxiv.org/abs/1908.10084)), you should use this option.\n  - `avg_top2`: Average embeddings of the last two layers.\n  - `avg_first_last`: Average embeddings of the first and last layers. If you use vanilla BERT or RoBERTa, this works the best.\n- `--mode`: Evaluation mode\n  - `test` (default): The default test mode. To faithfully reproduce our results, you should use this option.\n  - `dev`: Report the development set results. Note that in STS tasks, only `STS-B` and `SICK-R` have development sets, so we only report their numbers. It also takes a fast mode for transfer tasks, so the running time is much shorter than the `test` mode (though numbers are slightly lower).\n  - `fasttest`: It is the same as `test`, but with a fast mode so the running time is much shorter, but the reported numbers may be lower (only for transfer tasks).\n- `--task_set`: What set of tasks to evaluate on (if set, it will override `--tasks`)\n  - `sts` (default): Evaluate on STS tasks, including `STS 12~16`, `STS-B` and `SICK-R`. This is the most commonly-used set of tasks to evaluate the quality of sentence embeddings.\n  - `transfer`: Evaluate on transfer tasks.\n  - `full`: Evaluate on both STS and transfer tasks.\n  - `na`: Manually set tasks by `--tasks`.\n- `--tasks`: Specify which dataset(s) to evaluate on. Will be overridden if `--task_set` is not `na`. See the code for a full list of tasks.\n\n","source":"_posts/SimCSE（九）.md","raw":"---\ntitle: SimCSE（九）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 知识图谱\n  - SimCSE\n  - 代码\ncategories:\n  - 论文\nsummary: 初步代码运行\nabbrlink: 1e5f\ndate: 2021-05-05 15:41:25\npassword:\nkeywords:\ndescription:\n---\n# SimCSE运行\n\n# 运行结果\n\n<img src=\"训练结果.png\" alt=\"训练结果\" style=\"zoom:67%;\" />\n\n---\n\n- 先安装好torch和所需库\n\n- 先下载评估数据，并且要安装wegt以便运行bash语句\n\n- ```sh\n  cd SentEval/data/downstream/\n  bash download_dataset.sh\n  ```\n\n- **经向作者发邮件咨询如何运行以及参数调试**\n\n- ```python\n  python evaluation.py --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased\n  ```\n\n- 运行语句设置\n\n- ```python\n  python evaluation.py \\\n      --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased \\\n      --pooler cls \\\n      --task_set sts \\\n      --mode test\n  ```\n\n## Evaluation\n\nArguments for the evaluation script are as follows,\n\n- `--model_name_or_path`: The name or path of a `transformers`-based pre-trained checkpoint. You can directly use the models in the above table, e.g., `princeton-nlp/sup-simcse-bert-base-uncased`.\n- `--pooler`: Pooling method. Now we support\n  - `cls` (default): Use the representation of `[CLS]` token. A linear+activation layer is applied after the representation (it's in the standard BERT implementation). If you use SimCSE, you should use this option.\n  - `cls_before_pooler`: Use the representation of `[CLS]` token without the extra linear+activation.\n  - `avg`: Average embeddings of the last layer. If you use checkpoints of SBERT/SRoBERTa ([paper](https://arxiv.org/abs/1908.10084)), you should use this option.\n  - `avg_top2`: Average embeddings of the last two layers.\n  - `avg_first_last`: Average embeddings of the first and last layers. If you use vanilla BERT or RoBERTa, this works the best.\n- `--mode`: Evaluation mode\n  - `test` (default): The default test mode. To faithfully reproduce our results, you should use this option.\n  - `dev`: Report the development set results. Note that in STS tasks, only `STS-B` and `SICK-R` have development sets, so we only report their numbers. It also takes a fast mode for transfer tasks, so the running time is much shorter than the `test` mode (though numbers are slightly lower).\n  - `fasttest`: It is the same as `test`, but with a fast mode so the running time is much shorter, but the reported numbers may be lower (only for transfer tasks).\n- `--task_set`: What set of tasks to evaluate on (if set, it will override `--tasks`)\n  - `sts` (default): Evaluate on STS tasks, including `STS 12~16`, `STS-B` and `SICK-R`. This is the most commonly-used set of tasks to evaluate the quality of sentence embeddings.\n  - `transfer`: Evaluate on transfer tasks.\n  - `full`: Evaluate on both STS and transfer tasks.\n  - `na`: Manually set tasks by `--tasks`.\n- `--tasks`: Specify which dataset(s) to evaluate on. Will be overridden if `--task_set` is not `na`. See the code for a full list of tasks.\n\n","slug":"SimCSE（九）","published":1,"updated":"2021-05-05T07:44:17.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5q001pa09k69qb6xc2","content":"<h1 id=\"SimCSE运行\"><a href=\"#SimCSE运行\" class=\"headerlink\" title=\"SimCSE运行\"></a>SimCSE运行</h1><h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p><img src=\"训练结果.png\" alt=\"训练结果\" style=\"zoom:67%;\"></p>\n<hr>\n<ul>\n<li><p>先安装好torch和所需库</p>\n</li>\n<li><p>先下载评估数据，并且要安装wegt以便运行bash语句</p>\n</li>\n<li><pre class=\"line-numbers language-lang-sh\"><code class=\"language-lang-sh\">cd SentEval/data/downstream/\nbash download_dataset.sh\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>经向作者发邮件咨询如何运行以及参数调试</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">python evaluation.py --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>运行语句设置</p>\n</li>\n<li><pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">python evaluation.py \\\n    --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased \\\n    --pooler cls \\\n    --task_set sts \\\n    --mode test\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><p>Arguments for the evaluation script are as follows,</p>\n<ul>\n<li><code>--model_name_or_path</code>: The name or path of a <code>transformers</code>-based pre-trained checkpoint. You can directly use the models in the above table, e.g., <code>princeton-nlp/sup-simcse-bert-base-uncased</code>.</li>\n<li><code>--pooler</code>: Pooling method. Now we support<ul>\n<li><code>cls</code> (default): Use the representation of <code>[CLS]</code> token. A linear+activation layer is applied after the representation (it’s in the standard BERT implementation). If you use SimCSE, you should use this option.</li>\n<li><code>cls_before_pooler</code>: Use the representation of <code>[CLS]</code> token without the extra linear+activation.</li>\n<li><code>avg</code>: Average embeddings of the last layer. If you use checkpoints of SBERT/SRoBERTa (<a href=\"https://arxiv.org/abs/1908.10084\" target=\"_blank\" rel=\"noopener\">paper</a>), you should use this option.</li>\n<li><code>avg_top2</code>: Average embeddings of the last two layers.</li>\n<li><code>avg_first_last</code>: Average embeddings of the first and last layers. If you use vanilla BERT or RoBERTa, this works the best.</li>\n</ul>\n</li>\n<li><code>--mode</code>: Evaluation mode<ul>\n<li><code>test</code> (default): The default test mode. To faithfully reproduce our results, you should use this option.</li>\n<li><code>dev</code>: Report the development set results. Note that in STS tasks, only <code>STS-B</code> and <code>SICK-R</code> have development sets, so we only report their numbers. It also takes a fast mode for transfer tasks, so the running time is much shorter than the <code>test</code> mode (though numbers are slightly lower).</li>\n<li><code>fasttest</code>: It is the same as <code>test</code>, but with a fast mode so the running time is much shorter, but the reported numbers may be lower (only for transfer tasks).</li>\n</ul>\n</li>\n<li><code>--task_set</code>: What set of tasks to evaluate on (if set, it will override <code>--tasks</code>)<ul>\n<li><code>sts</code> (default): Evaluate on STS tasks, including <code>STS 12~16</code>, <code>STS-B</code> and <code>SICK-R</code>. This is the most commonly-used set of tasks to evaluate the quality of sentence embeddings.</li>\n<li><code>transfer</code>: Evaluate on transfer tasks.</li>\n<li><code>full</code>: Evaluate on both STS and transfer tasks.</li>\n<li><code>na</code>: Manually set tasks by <code>--tasks</code>.</li>\n</ul>\n</li>\n<li><code>--tasks</code>: Specify which dataset(s) to evaluate on. Will be overridden if <code>--task_set</code> is not <code>na</code>. See the code for a full list of tasks.</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"SimCSE运行\"><a href=\"#SimCSE运行\" class=\"headerlink\" title=\"SimCSE运行\"></a>SimCSE运行</h1><h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p><img src=\"训练结果.png\" alt=\"训练结果\" style=\"zoom:67%;\" /></p>\n<hr>\n<ul>\n<li><p>先安装好torch和所需库</p>\n</li>\n<li><p>先下载评估数据，并且要安装wegt以便运行bash语句</p>\n</li>\n<li><pre><code class=\"lang-sh\">cd SentEval/data/downstream/\nbash download_dataset.sh\n</code></pre>\n</li>\n<li><p><strong>经向作者发邮件咨询如何运行以及参数调试</strong></p>\n</li>\n<li><pre><code class=\"lang-python\">python evaluation.py --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased\n</code></pre>\n</li>\n<li><p>运行语句设置</p>\n</li>\n<li><pre><code class=\"lang-python\">python evaluation.py \\\n    --model_name_or_path princeton-nlp/sup-simcse-bert-base-uncased \\\n    --pooler cls \\\n    --task_set sts \\\n    --mode test\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><p>Arguments for the evaluation script are as follows,</p>\n<ul>\n<li><code>--model_name_or_path</code>: The name or path of a <code>transformers</code>-based pre-trained checkpoint. You can directly use the models in the above table, e.g., <code>princeton-nlp/sup-simcse-bert-base-uncased</code>.</li>\n<li><code>--pooler</code>: Pooling method. Now we support<ul>\n<li><code>cls</code> (default): Use the representation of <code>[CLS]</code> token. A linear+activation layer is applied after the representation (it’s in the standard BERT implementation). If you use SimCSE, you should use this option.</li>\n<li><code>cls_before_pooler</code>: Use the representation of <code>[CLS]</code> token without the extra linear+activation.</li>\n<li><code>avg</code>: Average embeddings of the last layer. If you use checkpoints of SBERT/SRoBERTa (<a href=\"https://arxiv.org/abs/1908.10084\" target=\"_blank\" rel=\"noopener\">paper</a>), you should use this option.</li>\n<li><code>avg_top2</code>: Average embeddings of the last two layers.</li>\n<li><code>avg_first_last</code>: Average embeddings of the first and last layers. If you use vanilla BERT or RoBERTa, this works the best.</li>\n</ul>\n</li>\n<li><code>--mode</code>: Evaluation mode<ul>\n<li><code>test</code> (default): The default test mode. To faithfully reproduce our results, you should use this option.</li>\n<li><code>dev</code>: Report the development set results. Note that in STS tasks, only <code>STS-B</code> and <code>SICK-R</code> have development sets, so we only report their numbers. It also takes a fast mode for transfer tasks, so the running time is much shorter than the <code>test</code> mode (though numbers are slightly lower).</li>\n<li><code>fasttest</code>: It is the same as <code>test</code>, but with a fast mode so the running time is much shorter, but the reported numbers may be lower (only for transfer tasks).</li>\n</ul>\n</li>\n<li><code>--task_set</code>: What set of tasks to evaluate on (if set, it will override <code>--tasks</code>)<ul>\n<li><code>sts</code> (default): Evaluate on STS tasks, including <code>STS 12~16</code>, <code>STS-B</code> and <code>SICK-R</code>. This is the most commonly-used set of tasks to evaluate the quality of sentence embeddings.</li>\n<li><code>transfer</code>: Evaluate on transfer tasks.</li>\n<li><code>full</code>: Evaluate on both STS and transfer tasks.</li>\n<li><code>na</code>: Manually set tasks by <code>--tasks</code>.</li>\n</ul>\n</li>\n<li><code>--tasks</code>: Specify which dataset(s) to evaluate on. Will be overridden if <code>--task_set</code> is not <code>na</code>. See the code for a full list of tasks.</li>\n</ul>\n"},{"title":"SimCSE（二）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"SimCSE Abstract","abbrlink":"221e","date":"2021-04-27T06:07:32.000Z","password":null,"keywords":null,"description":null,"_content":"## Simple Contrastive Learning of Sentence Embeddings（二）\n\n#### 单词预览\n\n- contrastive，对比\n- state-of-the-art，最先进的\n- unsupervise，无监督\n- predict，预测\n- objective，目标\n- contrastive，对比\n- on par with，与……同一水平\n- represent，代表，表示\n- inspiration，灵感\n- incorporate，包含\n- annotate，注释\n- pairs from，来自\n- entailment，蕴含\n- semantic，语义\n- correlate，有关系的\n- respective，分别，各自\n\n-----\n\n> 两端对齐并调整行间距: style=\"text-align:justify\";line-height:1.8rem\n>\n> html斜体使用i标签\n\n#### 英文摘要Abstract\n\n<div style=\"text-align:justify;line-height:1.8rem\">This paper presents SimCSE, a simple contrastive learning framework that greatly advances the state-of-the-art sentence embeddings. We first describe an unsupervised approach, which takes an input sentence and predicts <i>itself</i> in a contrastive objective, with only standard dropout used as noise. This simple method works surprisingly well, performing on par with previous supervised counterparts. We hypothesize that dropout acts as minimal data augmentation and removing it leads to a representation collapse. Then, we draw inspiration from the recent success of learning sentence embeddings from natural language inference（NLI）datasets and incorporate annotated pairs from NLI datasets into contrastive learning by using “entailment” pairs as pos- itives and “contradiction” pairs as hard negatives. We evaluate SimCSE on standard semantic textual similarity（STS）tasks, and our unsupervised and supervised models using BERTbase achieve an average of 74.5% and 81.6% Spearman’s correlation respectively, a 7.9 and 4.6 points improvement compared to previous best results. We also show that contrastive learning theoretically regularizes pretrained embeddings’ anisotropic space to be more uniform, and it better aligns positive pairs when supervised signals are available.</div>\n\n-----\n\n#### 详细翻译中文摘要\n\n<div style=\"text-align:justify;line-height:1.8rem\">文章主要介绍了SimCSE，一种简单对比学习框架，SimCSE对比学习框架极大的提高了最先进的句子嵌入技术。我们首先描述了一种无监督的方法，这种方法采用一个输入语句，并根据一个对比目标进行预测，仅使用标准的dropout作为噪声。这种简单方法非常好，表现的与以前的可监督方法水平不相上下。我们假设，dropout做为最小的数据增加和删除，它会导致表示崩溃。然后，我们从最近的自然语言推理（NLI）数据集的成功经验获得灵感，将来自NLI数据集中的注释合并到对比学习中，并使用“蕴含”作为正向，“矛盾”作为负向。我们在标准的语义-文本相似度（STS）任务中对SimSCE进行了评估，使用Bear的无监督和有监督模型的相关度平均达到74.5%和81.6%的Spearman相关度，与以前的最佳结果分别提高了7.9和4.6个点。我们也展示了相对学习理论使预训练嵌入的各向异性空间更加均匀，并在有监督信号的情况下可以更好的对其正向嵌入。</div>\n\n","source":"_posts/SimCSE（二）.md","raw":"---\ntitle: SimCSE（二）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nsummary: SimCSE Abstract\nabbrlink: 221e\ndate: 2021-04-27 14:07:32\npassword:\nkeywords:\ndescription:\n---\n## Simple Contrastive Learning of Sentence Embeddings（二）\n\n#### 单词预览\n\n- contrastive，对比\n- state-of-the-art，最先进的\n- unsupervise，无监督\n- predict，预测\n- objective，目标\n- contrastive，对比\n- on par with，与……同一水平\n- represent，代表，表示\n- inspiration，灵感\n- incorporate，包含\n- annotate，注释\n- pairs from，来自\n- entailment，蕴含\n- semantic，语义\n- correlate，有关系的\n- respective，分别，各自\n\n-----\n\n> 两端对齐并调整行间距: style=\"text-align:justify\";line-height:1.8rem\n>\n> html斜体使用i标签\n\n#### 英文摘要Abstract\n\n<div style=\"text-align:justify;line-height:1.8rem\">This paper presents SimCSE, a simple contrastive learning framework that greatly advances the state-of-the-art sentence embeddings. We first describe an unsupervised approach, which takes an input sentence and predicts <i>itself</i> in a contrastive objective, with only standard dropout used as noise. This simple method works surprisingly well, performing on par with previous supervised counterparts. We hypothesize that dropout acts as minimal data augmentation and removing it leads to a representation collapse. Then, we draw inspiration from the recent success of learning sentence embeddings from natural language inference（NLI）datasets and incorporate annotated pairs from NLI datasets into contrastive learning by using “entailment” pairs as pos- itives and “contradiction” pairs as hard negatives. We evaluate SimCSE on standard semantic textual similarity（STS）tasks, and our unsupervised and supervised models using BERTbase achieve an average of 74.5% and 81.6% Spearman’s correlation respectively, a 7.9 and 4.6 points improvement compared to previous best results. We also show that contrastive learning theoretically regularizes pretrained embeddings’ anisotropic space to be more uniform, and it better aligns positive pairs when supervised signals are available.</div>\n\n-----\n\n#### 详细翻译中文摘要\n\n<div style=\"text-align:justify;line-height:1.8rem\">文章主要介绍了SimCSE，一种简单对比学习框架，SimCSE对比学习框架极大的提高了最先进的句子嵌入技术。我们首先描述了一种无监督的方法，这种方法采用一个输入语句，并根据一个对比目标进行预测，仅使用标准的dropout作为噪声。这种简单方法非常好，表现的与以前的可监督方法水平不相上下。我们假设，dropout做为最小的数据增加和删除，它会导致表示崩溃。然后，我们从最近的自然语言推理（NLI）数据集的成功经验获得灵感，将来自NLI数据集中的注释合并到对比学习中，并使用“蕴含”作为正向，“矛盾”作为负向。我们在标准的语义-文本相似度（STS）任务中对SimSCE进行了评估，使用Bear的无监督和有监督模型的相关度平均达到74.5%和81.6%的Spearman相关度，与以前的最佳结果分别提高了7.9和4.6个点。我们也展示了相对学习理论使预训练嵌入的各向异性空间更加均匀，并在有监督信号的情况下可以更好的对其正向嵌入。</div>\n\n","slug":"SimCSE（二）","published":1,"updated":"2021-04-28T06:57:20.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5q001ra09kb0evesmc","content":"<h2 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（二）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（二）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（二）\"></a>Simple Contrastive Learning of Sentence Embeddings（二）</h2><h4 id=\"单词预览\"><a href=\"#单词预览\" class=\"headerlink\" title=\"单词预览\"></a>单词预览</h4><ul>\n<li>contrastive，对比</li>\n<li>state-of-the-art，最先进的</li>\n<li>unsupervise，无监督</li>\n<li>predict，预测</li>\n<li>objective，目标</li>\n<li>contrastive，对比</li>\n<li>on par with，与……同一水平</li>\n<li>represent，代表，表示</li>\n<li>inspiration，灵感</li>\n<li>incorporate，包含</li>\n<li>annotate，注释</li>\n<li>pairs from，来自</li>\n<li>entailment，蕴含</li>\n<li>semantic，语义</li>\n<li>correlate，有关系的</li>\n<li>respective，分别，各自</li>\n</ul>\n<hr>\n<blockquote>\n<p>两端对齐并调整行间距: style=”text-align:justify”;line-height:1.8rem</p>\n<p>html斜体使用i标签</p>\n</blockquote>\n<h4 id=\"英文摘要Abstract\"><a href=\"#英文摘要Abstract\" class=\"headerlink\" title=\"英文摘要Abstract\"></a>英文摘要Abstract</h4><div style=\"text-align:justify;line-height:1.8rem\">This paper presents SimCSE, a simple contrastive learning framework that greatly advances the state-of-the-art sentence embeddings. We first describe an unsupervised approach, which takes an input sentence and predicts <i>itself</i> in a contrastive objective, with only standard dropout used as noise. This simple method works surprisingly well, performing on par with previous supervised counterparts. We hypothesize that dropout acts as minimal data augmentation and removing it leads to a representation collapse. Then, we draw inspiration from the recent success of learning sentence embeddings from natural language inference（NLI）datasets and incorporate annotated pairs from NLI datasets into contrastive learning by using “entailment” pairs as pos- itives and “contradiction” pairs as hard negatives. We evaluate SimCSE on standard semantic textual similarity（STS）tasks, and our unsupervised and supervised models using BERTbase achieve an average of 74.5% and 81.6% Spearman’s correlation respectively, a 7.9 and 4.6 points improvement compared to previous best results. We also show that contrastive learning theoretically regularizes pretrained embeddings’ anisotropic space to be more uniform, and it better aligns positive pairs when supervised signals are available.</div>\n\n<hr>\n<h4 id=\"详细翻译中文摘要\"><a href=\"#详细翻译中文摘要\" class=\"headerlink\" title=\"详细翻译中文摘要\"></a>详细翻译中文摘要</h4><div style=\"text-align:justify;line-height:1.8rem\">文章主要介绍了SimCSE，一种简单对比学习框架，SimCSE对比学习框架极大的提高了最先进的句子嵌入技术。我们首先描述了一种无监督的方法，这种方法采用一个输入语句，并根据一个对比目标进行预测，仅使用标准的dropout作为噪声。这种简单方法非常好，表现的与以前的可监督方法水平不相上下。我们假设，dropout做为最小的数据增加和删除，它会导致表示崩溃。然后，我们从最近的自然语言推理（NLI）数据集的成功经验获得灵感，将来自NLI数据集中的注释合并到对比学习中，并使用“蕴含”作为正向，“矛盾”作为负向。我们在标准的语义-文本相似度（STS）任务中对SimSCE进行了评估，使用Bear的无监督和有监督模型的相关度平均达到74.5%和81.6%的Spearman相关度，与以前的最佳结果分别提高了7.9和4.6个点。我们也展示了相对学习理论使预训练嵌入的各向异性空间更加均匀，并在有监督信号的情况下可以更好的对其正向嵌入。</div>\n\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（二）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（二）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（二）\"></a>Simple Contrastive Learning of Sentence Embeddings（二）</h2><h4 id=\"单词预览\"><a href=\"#单词预览\" class=\"headerlink\" title=\"单词预览\"></a>单词预览</h4><ul>\n<li>contrastive，对比</li>\n<li>state-of-the-art，最先进的</li>\n<li>unsupervise，无监督</li>\n<li>predict，预测</li>\n<li>objective，目标</li>\n<li>contrastive，对比</li>\n<li>on par with，与……同一水平</li>\n<li>represent，代表，表示</li>\n<li>inspiration，灵感</li>\n<li>incorporate，包含</li>\n<li>annotate，注释</li>\n<li>pairs from，来自</li>\n<li>entailment，蕴含</li>\n<li>semantic，语义</li>\n<li>correlate，有关系的</li>\n<li>respective，分别，各自</li>\n</ul>\n<hr>\n<blockquote>\n<p>两端对齐并调整行间距: style=”text-align:justify”;line-height:1.8rem</p>\n<p>html斜体使用i标签</p>\n</blockquote>\n<h4 id=\"英文摘要Abstract\"><a href=\"#英文摘要Abstract\" class=\"headerlink\" title=\"英文摘要Abstract\"></a>英文摘要Abstract</h4><div style=\"text-align:justify;line-height:1.8rem\">This paper presents SimCSE, a simple contrastive learning framework that greatly advances the state-of-the-art sentence embeddings. We first describe an unsupervised approach, which takes an input sentence and predicts <i>itself</i> in a contrastive objective, with only standard dropout used as noise. This simple method works surprisingly well, performing on par with previous supervised counterparts. We hypothesize that dropout acts as minimal data augmentation and removing it leads to a representation collapse. Then, we draw inspiration from the recent success of learning sentence embeddings from natural language inference（NLI）datasets and incorporate annotated pairs from NLI datasets into contrastive learning by using “entailment” pairs as pos- itives and “contradiction” pairs as hard negatives. We evaluate SimCSE on standard semantic textual similarity（STS）tasks, and our unsupervised and supervised models using BERTbase achieve an average of 74.5% and 81.6% Spearman’s correlation respectively, a 7.9 and 4.6 points improvement compared to previous best results. We also show that contrastive learning theoretically regularizes pretrained embeddings’ anisotropic space to be more uniform, and it better aligns positive pairs when supervised signals are available.</div>\n\n<hr>\n<h4 id=\"详细翻译中文摘要\"><a href=\"#详细翻译中文摘要\" class=\"headerlink\" title=\"详细翻译中文摘要\"></a>详细翻译中文摘要</h4><div style=\"text-align:justify;line-height:1.8rem\">文章主要介绍了SimCSE，一种简单对比学习框架，SimCSE对比学习框架极大的提高了最先进的句子嵌入技术。我们首先描述了一种无监督的方法，这种方法采用一个输入语句，并根据一个对比目标进行预测，仅使用标准的dropout作为噪声。这种简单方法非常好，表现的与以前的可监督方法水平不相上下。我们假设，dropout做为最小的数据增加和删除，它会导致表示崩溃。然后，我们从最近的自然语言推理（NLI）数据集的成功经验获得灵感，将来自NLI数据集中的注释合并到对比学习中，并使用“蕴含”作为正向，“矛盾”作为负向。我们在标准的语义-文本相似度（STS）任务中对SimSCE进行了评估，使用Bear的无监督和有监督模型的相关度平均达到74.5%和81.6%的Spearman相关度，与以前的最佳结果分别提高了7.9和4.6个点。我们也展示了相对学习理论使预训练嵌入的各向异性空间更加均匀，并在有监督信号的情况下可以更好的对其正向嵌入。</div>\n\n"},{"title":"SimCSE（五）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"SimCSE Background","abbrlink":"8218","date":"2021-04-29T06:59:06.000Z","password":null,"keywords":null,"description":null,"_content":"# Simple Contrastive Learning of Sentence Embeddings（五）\n\n### 2 Background: Contrastive Learning\n\n----\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- 交叉熵（cross-entropy）https://www.zhihu.com/question/65288314\n\n- 批次内负采样 （in-batch negatives）\n\n- 博客中的公式显示问题，以后都改为图片引用，不使用代码操作\n\n---\n\n> Contrastive learning aims to learn effective representation by pulling semantically close neighbors together and pushing apart non-neighbors. \n\n- 对比学习的目的是通过把语义相近的邻域拉近在一起，把非邻域分开来学习有效的表达。\n\n> It assumes a set of paired examples $ \\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m} $ , where $x_i$ and $x_{i}^{+}$ are semantically related. \n\n- 它假设一组成对的例子$\\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m}$，$x_i$和$x_{i}^{+}$ 是语义相关的\n\n> We follow the contrastive framework in Chen and take a cross-entropy objective with in-batch negatives : \n\n- 取一个批次内负采样 (in-batch negatives)作为的交叉熵（cross-entropy）目标\n\n> let $h_i$ and $h_{i}^{+}$ denote the representations of $x_i$ and $x_{i}^{+}$, for a mini-batch with N pairs, the training objective for ($x_i,x_{i}^{+}$) is:\n\n- 假设$h{i}$和$h{i}^{+}$表示$x{i}$和$x{i}^{+}$，对于N对的小批量， $(x_i,x_{i}^{+})$ 的训练目标是：\n\n$$\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}\n$$\n\n> where $\\mathcal{T}$ is a temperature hyperparameter and sim$(h_1,h_2)$ is the cosine similarity $\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left\\|\\mathbf{h}_{1}\\right\\| \\cdot\\left\\|\\mathbf{h}_{2}\\right\\|}$. \n\n- 其中$\\mathcal{T}$是温度超参数,sim$(h_1，h_2)$是余弦相似性$\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left\\|\\mathbf{h}_{1}\\right\\| \\cdot\\left\\|\\mathbf{h}_{2}\\right\\|}$\n\n> In this work, we encode input sentences using a pre-trained language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019): $\\mathbf{h}=f_{\\theta}(x)$, \n\n- 在这项工作中，我们使用预先训练的语言模型（如BERT或RoBERTa）对输入句子进行编码：$\\mathbf{h}=f_{\\theta}(x)$\n\n> and then fine-tune all the parameters using the contrastive learning objective (Eq. 1).\n\n- 然后使用对比学习目标（等式1）微调所有参数。\n\n---\n\n#### Positive instances 正例\n\n> One critical question in contrastive learning is how to construct  ($x_i,x_{i}^{+}$)  pairs. \n\n- 对比学习中的一个关键问题是如何构建（$x_i，x_{i}^{+}$）对。\n\n> In visual representations, an effective solution is to take two random transformations of the same image (e.g., cropping, flipping, distortion and rotation) as $x_i$ and $x_{i}^{+}$.\n\n- 在视觉表示中，一个有效的解决方案是对同一个图像进行两次随机变换（例如，裁剪、翻转、失真和旋转），分别为$x_i$和$x_{i}^{+}$。\n\n> A similar approach has been recently adopted in language representations (Wu et al., 2020; Meng et al., 2021), by applying augmentation techniques such as word deletion, reordering, and substitution.\n\n- 最近在语言表征中也采用了类似的方法，通过应用增广技术，如单词删除，重新排序和替代。\n\n> However, data augmentation in NLP is inherently difficult because of its discrete nature.\n\n- 然而，NLP中的数据扩充由于其离散性而具有固有的困难性。\n\n> As we will see in §3, using standard dropout on intermediate representations outperforms these discrete operators.\n\n- 我们将在§3中看到.在中间表示上使用dropout优于这些离散运算符。\n\n> In NLP, a similar contrastive learning objective has been also explored in different contexts. \n\n- 在自然语言处理中，在不同的语境中也探讨了类似的对比学习目标。\n\n> In these cases,$(x_i，x_{i}^{+})$are collected from supervised datasets such as mention-entity, or question-passage pairs. \n\n- 在这些情况下，$（x_i，x_{i}^{+}）$是从有监督的数据集（如提及实体或问题通道对）收集的。\n\n> Because of the distinct nature of $x_i$ and $x_{i}^{+}$ by definition, these approaches always use a dual- encoder framework, i.e., using two independent encoders $f_{\\theta_{1}}$ and $f_{\\theta_{2}}$ for $x_i$ and $x_{i}^{+}$. \n\n- 由于定义上$x_{i}$和$x_{i}^{+}$的不同性质，这些方法总是使用双编码器框架，即使用两个独立的编码器$f{\\theta{1}}$和$f{\\theta{2}}$来表示$x_{i}$和$x_{i}^{+}$。\n\n> For sentence embeddings, Logeswaran and Lee (2018) also use contrastive learning with a dual-encoder approach, by forming (current sentence, next sentence) as $（x_i，x_{i}^{+}）$. \n\n- 对于句子嵌入，Logeswaran和Lee（2018）也使用了双编码器方法的对比学习，将（当前句子，下一个句子）形成$（x_i，x_{i}^{+}）$。\n\n> Zhang et al. (2020) consider global sentence representations and local token representations of the same sentence as positive instances.\n\n- Zhang将同一句子的整体句子表征和局部标记表征视为正例。\n\n#### Alignment and uniformity 对齐性和一致性\n\n> Recently, Wang and Isola (2020) identify two key properties related to contrastive learning: alignment and uniformity and propose metrics to measure the quality of representations. \n\n- 最近，Wang和Isola确定了与对比学习相关的两个关键属性：对齐性和一致性并提出了衡量表征质量的指标。\n\n> Given a distribution of positive pairs $p_{pos}$, alignment calculates expected distance between embeddings of the paired instances (assuming representations are already normalized),\n\n- 给定正对分布$p_{pos}$，alignment计算成对实例的嵌入之间的预期距离（假设表示已经规范化），\n\n$$\n\\ell_{\\text {align }} \\triangleq \\underset{\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}}{\\mathbb{E}}\\left\\|f(x)-f\\left(x^{+}\\right)\\right\\|^{2}\n$$\n\n> On the other hand, uniformity measures how well the embeddings are uniformly distributed:\n\n- 另一方面，uniformity衡量嵌入物均匀分布的程度：\n\n$$\n\\ell_{\\text {uniform }} \\triangleq \\log \\quad \\underset{\\quad x, y^\\stackrel{i . i . d .}{\\sim}p_{data}}{\\mathbb{E}} e^{-2\\|f(x)-f(y)\\|^{2}}\n$$\n\n> where $p_{data}$ denotes the data distribution. These two metrics are well aligned with the objective of contrastive learning: positive instances should stay close and embeddings for random instances should scatter on the hypersphere.\n\n- 其中，$p_{data}$表示数据分布。这两个指标很好地符合对比学习的目标：正例应该保持紧密，随机实例的嵌入应该分散在超球体上。\n\n> In the following sections, we will also use the two metrics to justify the inner workings of our approaches.\n\n- 在下面的部分中，我们还将使用这两个度量来证明我们的方法的内部工作。\n\n\n\n\n\n\n\n","source":"_posts/SimCSE（五）.md","raw":"---\ntitle: SimCSE（五）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nsummary: SimCSE Background\nabbrlink: '8218'\ndate: 2021-04-29 14:59:06\npassword:\nkeywords:\ndescription:\n---\n# Simple Contrastive Learning of Sentence Embeddings（五）\n\n### 2 Background: Contrastive Learning\n\n----\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- 交叉熵（cross-entropy）https://www.zhihu.com/question/65288314\n\n- 批次内负采样 （in-batch negatives）\n\n- 博客中的公式显示问题，以后都改为图片引用，不使用代码操作\n\n---\n\n> Contrastive learning aims to learn effective representation by pulling semantically close neighbors together and pushing apart non-neighbors. \n\n- 对比学习的目的是通过把语义相近的邻域拉近在一起，把非邻域分开来学习有效的表达。\n\n> It assumes a set of paired examples $ \\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m} $ , where $x_i$ and $x_{i}^{+}$ are semantically related. \n\n- 它假设一组成对的例子$\\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m}$，$x_i$和$x_{i}^{+}$ 是语义相关的\n\n> We follow the contrastive framework in Chen and take a cross-entropy objective with in-batch negatives : \n\n- 取一个批次内负采样 (in-batch negatives)作为的交叉熵（cross-entropy）目标\n\n> let $h_i$ and $h_{i}^{+}$ denote the representations of $x_i$ and $x_{i}^{+}$, for a mini-batch with N pairs, the training objective for ($x_i,x_{i}^{+}$) is:\n\n- 假设$h{i}$和$h{i}^{+}$表示$x{i}$和$x{i}^{+}$，对于N对的小批量， $(x_i,x_{i}^{+})$ 的训练目标是：\n\n$$\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}\n$$\n\n> where $\\mathcal{T}$ is a temperature hyperparameter and sim$(h_1,h_2)$ is the cosine similarity $\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left\\|\\mathbf{h}_{1}\\right\\| \\cdot\\left\\|\\mathbf{h}_{2}\\right\\|}$. \n\n- 其中$\\mathcal{T}$是温度超参数,sim$(h_1，h_2)$是余弦相似性$\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left\\|\\mathbf{h}_{1}\\right\\| \\cdot\\left\\|\\mathbf{h}_{2}\\right\\|}$\n\n> In this work, we encode input sentences using a pre-trained language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019): $\\mathbf{h}=f_{\\theta}(x)$, \n\n- 在这项工作中，我们使用预先训练的语言模型（如BERT或RoBERTa）对输入句子进行编码：$\\mathbf{h}=f_{\\theta}(x)$\n\n> and then fine-tune all the parameters using the contrastive learning objective (Eq. 1).\n\n- 然后使用对比学习目标（等式1）微调所有参数。\n\n---\n\n#### Positive instances 正例\n\n> One critical question in contrastive learning is how to construct  ($x_i,x_{i}^{+}$)  pairs. \n\n- 对比学习中的一个关键问题是如何构建（$x_i，x_{i}^{+}$）对。\n\n> In visual representations, an effective solution is to take two random transformations of the same image (e.g., cropping, flipping, distortion and rotation) as $x_i$ and $x_{i}^{+}$.\n\n- 在视觉表示中，一个有效的解决方案是对同一个图像进行两次随机变换（例如，裁剪、翻转、失真和旋转），分别为$x_i$和$x_{i}^{+}$。\n\n> A similar approach has been recently adopted in language representations (Wu et al., 2020; Meng et al., 2021), by applying augmentation techniques such as word deletion, reordering, and substitution.\n\n- 最近在语言表征中也采用了类似的方法，通过应用增广技术，如单词删除，重新排序和替代。\n\n> However, data augmentation in NLP is inherently difficult because of its discrete nature.\n\n- 然而，NLP中的数据扩充由于其离散性而具有固有的困难性。\n\n> As we will see in §3, using standard dropout on intermediate representations outperforms these discrete operators.\n\n- 我们将在§3中看到.在中间表示上使用dropout优于这些离散运算符。\n\n> In NLP, a similar contrastive learning objective has been also explored in different contexts. \n\n- 在自然语言处理中，在不同的语境中也探讨了类似的对比学习目标。\n\n> In these cases,$(x_i，x_{i}^{+})$are collected from supervised datasets such as mention-entity, or question-passage pairs. \n\n- 在这些情况下，$（x_i，x_{i}^{+}）$是从有监督的数据集（如提及实体或问题通道对）收集的。\n\n> Because of the distinct nature of $x_i$ and $x_{i}^{+}$ by definition, these approaches always use a dual- encoder framework, i.e., using two independent encoders $f_{\\theta_{1}}$ and $f_{\\theta_{2}}$ for $x_i$ and $x_{i}^{+}$. \n\n- 由于定义上$x_{i}$和$x_{i}^{+}$的不同性质，这些方法总是使用双编码器框架，即使用两个独立的编码器$f{\\theta{1}}$和$f{\\theta{2}}$来表示$x_{i}$和$x_{i}^{+}$。\n\n> For sentence embeddings, Logeswaran and Lee (2018) also use contrastive learning with a dual-encoder approach, by forming (current sentence, next sentence) as $（x_i，x_{i}^{+}）$. \n\n- 对于句子嵌入，Logeswaran和Lee（2018）也使用了双编码器方法的对比学习，将（当前句子，下一个句子）形成$（x_i，x_{i}^{+}）$。\n\n> Zhang et al. (2020) consider global sentence representations and local token representations of the same sentence as positive instances.\n\n- Zhang将同一句子的整体句子表征和局部标记表征视为正例。\n\n#### Alignment and uniformity 对齐性和一致性\n\n> Recently, Wang and Isola (2020) identify two key properties related to contrastive learning: alignment and uniformity and propose metrics to measure the quality of representations. \n\n- 最近，Wang和Isola确定了与对比学习相关的两个关键属性：对齐性和一致性并提出了衡量表征质量的指标。\n\n> Given a distribution of positive pairs $p_{pos}$, alignment calculates expected distance between embeddings of the paired instances (assuming representations are already normalized),\n\n- 给定正对分布$p_{pos}$，alignment计算成对实例的嵌入之间的预期距离（假设表示已经规范化），\n\n$$\n\\ell_{\\text {align }} \\triangleq \\underset{\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}}{\\mathbb{E}}\\left\\|f(x)-f\\left(x^{+}\\right)\\right\\|^{2}\n$$\n\n> On the other hand, uniformity measures how well the embeddings are uniformly distributed:\n\n- 另一方面，uniformity衡量嵌入物均匀分布的程度：\n\n$$\n\\ell_{\\text {uniform }} \\triangleq \\log \\quad \\underset{\\quad x, y^\\stackrel{i . i . d .}{\\sim}p_{data}}{\\mathbb{E}} e^{-2\\|f(x)-f(y)\\|^{2}}\n$$\n\n> where $p_{data}$ denotes the data distribution. These two metrics are well aligned with the objective of contrastive learning: positive instances should stay close and embeddings for random instances should scatter on the hypersphere.\n\n- 其中，$p_{data}$表示数据分布。这两个指标很好地符合对比学习的目标：正例应该保持紧密，随机实例的嵌入应该分散在超球体上。\n\n> In the following sections, we will also use the two metrics to justify the inner workings of our approaches.\n\n- 在下面的部分中，我们还将使用这两个度量来证明我们的方法的内部工作。\n\n\n\n\n\n\n\n","slug":"SimCSE（五）","published":1,"updated":"2021-04-29T07:39:08.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5r001va09ka0rjaial","content":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（五）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（五）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（五）\"></a>Simple Contrastive Learning of Sentence Embeddings（五）</h1><h3 id=\"2-Background-Contrastive-Learning\"><a href=\"#2-Background-Contrastive-Learning\" class=\"headerlink\" title=\"2 Background: Contrastive Learning\"></a>2 Background: Contrastive Learning</h3><hr>\n<h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color=\"red\">还需学习的知识点</font></h4><ul>\n<li><p>交叉熵（cross-entropy）<a href=\"https://www.zhihu.com/question/65288314\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/65288314</a></p>\n</li>\n<li><p>批次内负采样 （in-batch negatives）</p>\n</li>\n<li><p>博客中的公式显示问题，以后都改为图片引用，不使用代码操作</p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>Contrastive learning aims to learn effective representation by pulling semantically close neighbors together and pushing apart non-neighbors. </p>\n</blockquote>\n<ul>\n<li>对比学习的目的是通过把语义相近的邻域拉近在一起，把非邻域分开来学习有效的表达。</li>\n</ul>\n<blockquote>\n<p>It assumes a set of paired examples $ \\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m} $ , where $x_i$ and $x_{i}^{+}$ are semantically related. </p>\n</blockquote>\n<ul>\n<li>它假设一组成对的例子$\\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m}$，$x_i$和$x_{i}^{+}$ 是语义相关的</li>\n</ul>\n<blockquote>\n<p>We follow the contrastive framework in Chen and take a cross-entropy objective with in-batch negatives : </p>\n</blockquote>\n<ul>\n<li>取一个批次内负采样 (in-batch negatives)作为的交叉熵（cross-entropy）目标</li>\n</ul>\n<blockquote>\n<p>let $h_i$ and $h_{i}^{+}$ denote the representations of $x_i$ and $x_{i}^{+}$, for a mini-batch with N pairs, the training objective for ($x_i,x_{i}^{+}$) is:</p>\n</blockquote>\n<ul>\n<li>假设$h{i}$和$h{i}^{+}$表示$x{i}$和$x{i}^{+}$，对于N对的小批量， $(x_i,x_{i}^{+})$ 的训练目标是：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}</script><blockquote>\n<p>where $\\mathcal{T}$ is a temperature hyperparameter and sim$(h_1,h_2)$ is the cosine similarity $\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left|\\mathbf{h}_{1}\\right| \\cdot\\left|\\mathbf{h}_{2}\\right|}$. </p>\n</blockquote>\n<ul>\n<li>其中$\\mathcal{T}$是温度超参数,sim$(h_1，h_2)$是余弦相似性$\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left|\\mathbf{h}_{1}\\right| \\cdot\\left|\\mathbf{h}_{2}\\right|}$</li>\n</ul>\n<blockquote>\n<p>In this work, we encode input sentences using a pre-trained language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019): $\\mathbf{h}=f_{\\theta}(x)$, </p>\n</blockquote>\n<ul>\n<li>在这项工作中，我们使用预先训练的语言模型（如BERT或RoBERTa）对输入句子进行编码：$\\mathbf{h}=f_{\\theta}(x)$</li>\n</ul>\n<blockquote>\n<p>and then fine-tune all the parameters using the contrastive learning objective (Eq. 1).</p>\n</blockquote>\n<ul>\n<li>然后使用对比学习目标（等式1）微调所有参数。</li>\n</ul>\n<hr>\n<h4 id=\"Positive-instances-正例\"><a href=\"#Positive-instances-正例\" class=\"headerlink\" title=\"Positive instances 正例\"></a>Positive instances 正例</h4><blockquote>\n<p>One critical question in contrastive learning is how to construct  ($x_i,x_{i}^{+}$)  pairs. </p>\n</blockquote>\n<ul>\n<li>对比学习中的一个关键问题是如何构建（$x_i，x_{i}^{+}$）对。</li>\n</ul>\n<blockquote>\n<p>In visual representations, an effective solution is to take two random transformations of the same image (e.g., cropping, flipping, distortion and rotation) as $x_i$ and $x_{i}^{+}$.</p>\n</blockquote>\n<ul>\n<li>在视觉表示中，一个有效的解决方案是对同一个图像进行两次随机变换（例如，裁剪、翻转、失真和旋转），分别为$x_i$和$x_{i}^{+}$。</li>\n</ul>\n<blockquote>\n<p>A similar approach has been recently adopted in language representations (Wu et al., 2020; Meng et al., 2021), by applying augmentation techniques such as word deletion, reordering, and substitution.</p>\n</blockquote>\n<ul>\n<li>最近在语言表征中也采用了类似的方法，通过应用增广技术，如单词删除，重新排序和替代。</li>\n</ul>\n<blockquote>\n<p>However, data augmentation in NLP is inherently difficult because of its discrete nature.</p>\n</blockquote>\n<ul>\n<li>然而，NLP中的数据扩充由于其离散性而具有固有的困难性。</li>\n</ul>\n<blockquote>\n<p>As we will see in §3, using standard dropout on intermediate representations outperforms these discrete operators.</p>\n</blockquote>\n<ul>\n<li>我们将在§3中看到.在中间表示上使用dropout优于这些离散运算符。</li>\n</ul>\n<blockquote>\n<p>In NLP, a similar contrastive learning objective has been also explored in different contexts. </p>\n</blockquote>\n<ul>\n<li>在自然语言处理中，在不同的语境中也探讨了类似的对比学习目标。</li>\n</ul>\n<blockquote>\n<p>In these cases,$(x_i，x_{i}^{+})$are collected from supervised datasets such as mention-entity, or question-passage pairs. </p>\n</blockquote>\n<ul>\n<li>在这些情况下，$（x_i，x_{i}^{+}）$是从有监督的数据集（如提及实体或问题通道对）收集的。</li>\n</ul>\n<blockquote>\n<p>Because of the distinct nature of $x_i$ and $x_{i}^{+}$ by definition, these approaches always use a dual- encoder framework, i.e., using two independent encoders $f_{\\theta_{1}}$ and $f_{\\theta_{2}}$ for $x_i$ and $x_{i}^{+}$. </p>\n</blockquote>\n<ul>\n<li>由于定义上$x_{i}$和$x_{i}^{+}$的不同性质，这些方法总是使用双编码器框架，即使用两个独立的编码器$f{\\theta{1}}$和$f{\\theta{2}}$来表示$x_{i}$和$x_{i}^{+}$。</li>\n</ul>\n<blockquote>\n<p>For sentence embeddings, Logeswaran and Lee (2018) also use contrastive learning with a dual-encoder approach, by forming (current sentence, next sentence) as $（x_i，x_{i}^{+}）$. </p>\n</blockquote>\n<ul>\n<li>对于句子嵌入，Logeswaran和Lee（2018）也使用了双编码器方法的对比学习，将（当前句子，下一个句子）形成$（x_i，x_{i}^{+}）$。</li>\n</ul>\n<blockquote>\n<p>Zhang et al. (2020) consider global sentence representations and local token representations of the same sentence as positive instances.</p>\n</blockquote>\n<ul>\n<li>Zhang将同一句子的整体句子表征和局部标记表征视为正例。</li>\n</ul>\n<h4 id=\"Alignment-and-uniformity-对齐性和一致性\"><a href=\"#Alignment-and-uniformity-对齐性和一致性\" class=\"headerlink\" title=\"Alignment and uniformity 对齐性和一致性\"></a>Alignment and uniformity 对齐性和一致性</h4><blockquote>\n<p>Recently, Wang and Isola (2020) identify two key properties related to contrastive learning: alignment and uniformity and propose metrics to measure the quality of representations. </p>\n</blockquote>\n<ul>\n<li>最近，Wang和Isola确定了与对比学习相关的两个关键属性：对齐性和一致性并提出了衡量表征质量的指标。</li>\n</ul>\n<blockquote>\n<p>Given a distribution of positive pairs $p_{pos}$, alignment calculates expected distance between embeddings of the paired instances (assuming representations are already normalized),</p>\n</blockquote>\n<ul>\n<li>给定正对分布$p_{pos}$，alignment计算成对实例的嵌入之间的预期距离（假设表示已经规范化），</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{\\text {align }} \\triangleq \\underset{\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}}{\\mathbb{E}}\\left\\|f(x)-f\\left(x^{+}\\right)\\right\\|^{2}</script><blockquote>\n<p>On the other hand, uniformity measures how well the embeddings are uniformly distributed:</p>\n</blockquote>\n<ul>\n<li>另一方面，uniformity衡量嵌入物均匀分布的程度：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{\\text {uniform }} \\triangleq \\log \\quad \\underset{\\quad x, y^\\stackrel{i . i . d .}{\\sim}p_{data}}{\\mathbb{E}} e^{-2\\|f(x)-f(y)\\|^{2}}</script><blockquote>\n<p>where $p_{data}$ denotes the data distribution. These two metrics are well aligned with the objective of contrastive learning: positive instances should stay close and embeddings for random instances should scatter on the hypersphere.</p>\n</blockquote>\n<ul>\n<li>其中，$p_{data}$表示数据分布。这两个指标很好地符合对比学习的目标：正例应该保持紧密，随机实例的嵌入应该分散在超球体上。</li>\n</ul>\n<blockquote>\n<p>In the following sections, we will also use the two metrics to justify the inner workings of our approaches.</p>\n</blockquote>\n<ul>\n<li>在下面的部分中，我们还将使用这两个度量来证明我们的方法的内部工作。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（五）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（五）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（五）\"></a>Simple Contrastive Learning of Sentence Embeddings（五）</h1><h3 id=\"2-Background-Contrastive-Learning\"><a href=\"#2-Background-Contrastive-Learning\" class=\"headerlink\" title=\"2 Background: Contrastive Learning\"></a>2 Background: Contrastive Learning</h3><hr>\n<h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color = \"red\">还需学习的知识点</font></h4><ul>\n<li><p>交叉熵（cross-entropy）<a href=\"https://www.zhihu.com/question/65288314\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/65288314</a></p>\n</li>\n<li><p>批次内负采样 （in-batch negatives）</p>\n</li>\n<li><p>博客中的公式显示问题，以后都改为图片引用，不使用代码操作</p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>Contrastive learning aims to learn effective representation by pulling semantically close neighbors together and pushing apart non-neighbors. </p>\n</blockquote>\n<ul>\n<li>对比学习的目的是通过把语义相近的邻域拉近在一起，把非邻域分开来学习有效的表达。</li>\n</ul>\n<blockquote>\n<p>It assumes a set of paired examples $ \\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m} $ , where $x_i$ and $x_{i}^{+}$ are semantically related. </p>\n</blockquote>\n<ul>\n<li>它假设一组成对的例子$\\mathcal{D}=\\left\\{\\left(x_{i}, x_{i}^{+}\\right)\\right\\}_{i=1}^{m}$，$x_i$和$x_{i}^{+}$ 是语义相关的</li>\n</ul>\n<blockquote>\n<p>We follow the contrastive framework in Chen and take a cross-entropy objective with in-batch negatives : </p>\n</blockquote>\n<ul>\n<li>取一个批次内负采样 (in-batch negatives)作为的交叉熵（cross-entropy）目标</li>\n</ul>\n<blockquote>\n<p>let $h_i$ and $h_{i}^{+}$ denote the representations of $x_i$ and $x_{i}^{+}$, for a mini-batch with N pairs, the training objective for ($x_i,x_{i}^{+}$) is:</p>\n</blockquote>\n<ul>\n<li>假设$h{i}$和$h{i}^{+}$表示$x{i}$和$x{i}^{+}$，对于N对的小批量， $(x_i,x_{i}^{+})$ 的训练目标是：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}</script><blockquote>\n<p>where $\\mathcal{T}$ is a temperature hyperparameter and sim$(h_1,h_2)$ is the cosine similarity $\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left|\\mathbf{h}_{1}\\right| \\cdot\\left|\\mathbf{h}_{2}\\right|}$. </p>\n</blockquote>\n<ul>\n<li>其中$\\mathcal{T}$是温度超参数,sim$(h_1，h_2)$是余弦相似性$\\frac{\\mathbf{h}_{1}^{\\top} \\mathbf{h}_{2}}{\\left|\\mathbf{h}_{1}\\right| \\cdot\\left|\\mathbf{h}_{2}\\right|}$</li>\n</ul>\n<blockquote>\n<p>In this work, we encode input sentences using a pre-trained language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019): $\\mathbf{h}=f_{\\theta}(x)$, </p>\n</blockquote>\n<ul>\n<li>在这项工作中，我们使用预先训练的语言模型（如BERT或RoBERTa）对输入句子进行编码：$\\mathbf{h}=f_{\\theta}(x)$</li>\n</ul>\n<blockquote>\n<p>and then fine-tune all the parameters using the contrastive learning objective (Eq. 1).</p>\n</blockquote>\n<ul>\n<li>然后使用对比学习目标（等式1）微调所有参数。</li>\n</ul>\n<hr>\n<h4 id=\"Positive-instances-正例\"><a href=\"#Positive-instances-正例\" class=\"headerlink\" title=\"Positive instances 正例\"></a>Positive instances 正例</h4><blockquote>\n<p>One critical question in contrastive learning is how to construct  ($x_i,x_{i}^{+}$)  pairs. </p>\n</blockquote>\n<ul>\n<li>对比学习中的一个关键问题是如何构建（$x_i，x_{i}^{+}$）对。</li>\n</ul>\n<blockquote>\n<p>In visual representations, an effective solution is to take two random transformations of the same image (e.g., cropping, flipping, distortion and rotation) as $x_i$ and $x_{i}^{+}$.</p>\n</blockquote>\n<ul>\n<li>在视觉表示中，一个有效的解决方案是对同一个图像进行两次随机变换（例如，裁剪、翻转、失真和旋转），分别为$x_i$和$x_{i}^{+}$。</li>\n</ul>\n<blockquote>\n<p>A similar approach has been recently adopted in language representations (Wu et al., 2020; Meng et al., 2021), by applying augmentation techniques such as word deletion, reordering, and substitution.</p>\n</blockquote>\n<ul>\n<li>最近在语言表征中也采用了类似的方法，通过应用增广技术，如单词删除，重新排序和替代。</li>\n</ul>\n<blockquote>\n<p>However, data augmentation in NLP is inherently difficult because of its discrete nature.</p>\n</blockquote>\n<ul>\n<li>然而，NLP中的数据扩充由于其离散性而具有固有的困难性。</li>\n</ul>\n<blockquote>\n<p>As we will see in §3, using standard dropout on intermediate representations outperforms these discrete operators.</p>\n</blockquote>\n<ul>\n<li>我们将在§3中看到.在中间表示上使用dropout优于这些离散运算符。</li>\n</ul>\n<blockquote>\n<p>In NLP, a similar contrastive learning objective has been also explored in different contexts. </p>\n</blockquote>\n<ul>\n<li>在自然语言处理中，在不同的语境中也探讨了类似的对比学习目标。</li>\n</ul>\n<blockquote>\n<p>In these cases,$(x_i，x_{i}^{+})$are collected from supervised datasets such as mention-entity, or question-passage pairs. </p>\n</blockquote>\n<ul>\n<li>在这些情况下，$（x_i，x_{i}^{+}）$是从有监督的数据集（如提及实体或问题通道对）收集的。</li>\n</ul>\n<blockquote>\n<p>Because of the distinct nature of $x_i$ and $x_{i}^{+}$ by definition, these approaches always use a dual- encoder framework, i.e., using two independent encoders $f_{\\theta_{1}}$ and $f_{\\theta_{2}}$ for $x_i$ and $x_{i}^{+}$. </p>\n</blockquote>\n<ul>\n<li>由于定义上$x_{i}$和$x_{i}^{+}$的不同性质，这些方法总是使用双编码器框架，即使用两个独立的编码器$f{\\theta{1}}$和$f{\\theta{2}}$来表示$x_{i}$和$x_{i}^{+}$。</li>\n</ul>\n<blockquote>\n<p>For sentence embeddings, Logeswaran and Lee (2018) also use contrastive learning with a dual-encoder approach, by forming (current sentence, next sentence) as $（x_i，x_{i}^{+}）$. </p>\n</blockquote>\n<ul>\n<li>对于句子嵌入，Logeswaran和Lee（2018）也使用了双编码器方法的对比学习，将（当前句子，下一个句子）形成$（x_i，x_{i}^{+}）$。</li>\n</ul>\n<blockquote>\n<p>Zhang et al. (2020) consider global sentence representations and local token representations of the same sentence as positive instances.</p>\n</blockquote>\n<ul>\n<li>Zhang将同一句子的整体句子表征和局部标记表征视为正例。</li>\n</ul>\n<h4 id=\"Alignment-and-uniformity-对齐性和一致性\"><a href=\"#Alignment-and-uniformity-对齐性和一致性\" class=\"headerlink\" title=\"Alignment and uniformity 对齐性和一致性\"></a>Alignment and uniformity 对齐性和一致性</h4><blockquote>\n<p>Recently, Wang and Isola (2020) identify two key properties related to contrastive learning: alignment and uniformity and propose metrics to measure the quality of representations. </p>\n</blockquote>\n<ul>\n<li>最近，Wang和Isola确定了与对比学习相关的两个关键属性：对齐性和一致性并提出了衡量表征质量的指标。</li>\n</ul>\n<blockquote>\n<p>Given a distribution of positive pairs $p_{pos}$, alignment calculates expected distance between embeddings of the paired instances (assuming representations are already normalized),</p>\n</blockquote>\n<ul>\n<li>给定正对分布$p_{pos}$，alignment计算成对实例的嵌入之间的预期距离（假设表示已经规范化），</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{\\text {align }} \\triangleq \\underset{\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}}{\\mathbb{E}}\\left\\|f(x)-f\\left(x^{+}\\right)\\right\\|^{2}</script><blockquote>\n<p>On the other hand, uniformity measures how well the embeddings are uniformly distributed:</p>\n</blockquote>\n<ul>\n<li>另一方面，uniformity衡量嵌入物均匀分布的程度：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{\\text {uniform }} \\triangleq \\log \\quad \\underset{\\quad x, y^\\stackrel{i . i . d .}{\\sim}p_{data}}{\\mathbb{E}} e^{-2\\|f(x)-f(y)\\|^{2}}</script><blockquote>\n<p>where $p_{data}$ denotes the data distribution. These two metrics are well aligned with the objective of contrastive learning: positive instances should stay close and embeddings for random instances should scatter on the hypersphere.</p>\n</blockquote>\n<ul>\n<li>其中，$p_{data}$表示数据分布。这两个指标很好地符合对比学习的目标：正例应该保持紧密，随机实例的嵌入应该分散在超球体上。</li>\n</ul>\n<blockquote>\n<p>In the following sections, we will also use the two metrics to justify the inner workings of our approaches.</p>\n</blockquote>\n<ul>\n<li>在下面的部分中，我们还将使用这两个度量来证明我们的方法的内部工作。</li>\n</ul>\n"},{"title":"SimCSE（十）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"SimCSE归纳总结","abbrlink":"9be8","date":"2021-05-06T12:47:14.000Z","password":null,"keywords":null,"description":null,"_content":"# SimCSE归纳总结\n\n1. SimCSE，运用了dropout的方法替换了原有的数据增强方法，将输入两次dropout产生的结果当作学习的正例\n\n   - 为什么要进行数据增强：在深度学习中，一般要求样本的数量要充足，样本数量越多，训练出来的模型效果越好，模型的泛化能力越强。但是实际中，样本数量不足或者样本质量不够好，这就要对样本做数据增强，来提高样本质量\n\n   - 传统数据增强方法：\n     - 图片：如果数据集都是图片类，可以运用翻转，旋转，缩放，剪裁，平移，添加噪声\n     - 文本：数据是文本类的，可以使用回译，替换同义词，随机插入一个词语，随机交换词语，p概率删除一个词语\n\n2. 用**自然语言推理NLI**的数据用于有监督的对比学习：自然语言推理研究一个假设是否可以从一个前提中推断出来，假设和前提都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三类：       \n\n   - 蕴涵：假设可以从前提中推断出来。       \n\n   - 矛盾：假设的否定可以从前提推断出来。       \n\n   - 中立：所有其情况。       \n\n自然语言推理也被称为识别文本蕴涵任务。例如，下面的一对会被标记为蕴涵，因为假设中的“示爱”可以从前提中的“拥抱”中推断出来。       \n\n前提：两个女人互相拥抱。       \n\n假设：两个女人在表达爱意。       \n\n下面是一个矛盾的例子，因为“运行代码”表示“不睡觉”而不是“睡眠”。       \n\n前提：一个男人正在运行一个代码示例\n\n假设：这个人正在睡觉。       \n\n第三个例子显示了一种中立关系，因为“为演出”的事实不能推断出“著名”和“不出名”。       \n\n前提：音乐家正在表演。       \n\n假设：音乐家是有名的。       \n\n3. 有监督学习(supervised learning)和无监督学习(unsupervised learning)\n\n   - supervised learning：通过已有的样本去群里安处一个最优模型，再利用这个模型将就可以将其他的未知数据输入，得到已知的分类。就像小时候父母告诉我们这个是苹果，这个是狗，这就是已构建好的模型和函数以及分类，当身边没有大人时，当我们看到类似的东西时，也可以分辨出其他的水果以及动物。经典有监督学习（KNN，SVM以后学习一下）\n   - unsupervised learning：我们没有任何训练样本，直接利用已有数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。\n   - 有训练样本就用有监督学习，没有训练样本肯定用不了有监督学习。但现实中，在没有训练样本的情况下，我们可以通过人工标注一些样本，然后去用有监督的方法去做\n\n4. 泛化误差：对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为**泛化误差**。\n\n   - 训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络**过度拟合了训练集**，对训练集以外的数据却不work。\n\n   <img src=\"拟合对比.png\" alt=\"拟合对比\"  />\n\n   - 具体过拟合欠拟合等解决办法见http://blog.bangbangbangbang.top/posts/5c43.html/\n\n5. Dropout：是一种防止过拟合的方法，处理过后也可作为新数据加入数据集中，增加数据集的多样性。\n\n   - 在每次训练中，减少每个相关元素之间一半的关联，就可以明显减少过拟合现象。通过这种方法，可以减少相关元素之间的相互作用，可以使模型的泛化能力更强，因为不会过于依赖某些局部特征\n\n   <img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\" />\n\n6. 对比表示学习（Contrastive Representation Learning）\n   - 主要是要**构建正样本$x^+$和负样本$x^-$**，正例就是与x相似的数据，负例就是与x不同的数据\n   - 在论文[Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere](http://blog.bangbangbangbang.top/posts/3b4c.html/ICML2020.pdf)中指出了对比学习的两个指标\n   - **Alignment**对齐性，针对正例：计算正例对之间的向量距离的期望，越相似的正例对之间的alignment程度越高，距离越小。\n   - **Uniformity**均匀性，针对负例：所有数据的向量分布越均匀，保留的信息越多。最极端的反例，所有数据都映射到单位超球面的同一点上，这就极度违背了uniformity原则，这代表数据的所有信息都没了，只有一个点的信息了。负例对之间，距离越远愈好\n   - 这篇论文也采用这两个指标来衡量生成的句子向量，alignment和uniformity越低，向量的质量越高，在STS任务上的Spearman相关系数越高。spearman是一种相关系数方法\n\n7. 论文中的SimCSE方法\n\n   - Unsupervised SimCSE：引入dropout给输入加入噪声，假设加入噪声后的输入与原始输入在语义空间上距离相近。然后将相同的语句输入两次给预训练模型，得到一个正例对。因为dropout每次是以p概率隐去一半的相关性，所以相同输入所传出的值每次都是不同的，可以用作正例。\n\n   - supervised SimCSE：利用标注数据来构造对比学习的正负例子，最终选择NLI作为数据集\n\n8. 熵entropy\n   - 熵**(Entropy)**：可以表示一个事件A的自信息量，也就是A包含多少信息。\n   - KL散度**(Kullback-Leibler Divergence)**：可以用来表示从事件A的角度来看，事件B有多大不同。\n   - 交叉熵**(Cross Entropy)**：可以用来表示从事件A的角度来看，如何描述事件B。\n   - **KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价**。","source":"_posts/SimCSE（十）.md","raw":"---\ntitle: SimCSE（十）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nsummary: SimCSE归纳总结\nabbrlink: 9be8\ndate: 2021-05-06 20:47:14\npassword:\nkeywords:\ndescription:\n---\n# SimCSE归纳总结\n\n1. SimCSE，运用了dropout的方法替换了原有的数据增强方法，将输入两次dropout产生的结果当作学习的正例\n\n   - 为什么要进行数据增强：在深度学习中，一般要求样本的数量要充足，样本数量越多，训练出来的模型效果越好，模型的泛化能力越强。但是实际中，样本数量不足或者样本质量不够好，这就要对样本做数据增强，来提高样本质量\n\n   - 传统数据增强方法：\n     - 图片：如果数据集都是图片类，可以运用翻转，旋转，缩放，剪裁，平移，添加噪声\n     - 文本：数据是文本类的，可以使用回译，替换同义词，随机插入一个词语，随机交换词语，p概率删除一个词语\n\n2. 用**自然语言推理NLI**的数据用于有监督的对比学习：自然语言推理研究一个假设是否可以从一个前提中推断出来，假设和前提都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三类：       \n\n   - 蕴涵：假设可以从前提中推断出来。       \n\n   - 矛盾：假设的否定可以从前提推断出来。       \n\n   - 中立：所有其情况。       \n\n自然语言推理也被称为识别文本蕴涵任务。例如，下面的一对会被标记为蕴涵，因为假设中的“示爱”可以从前提中的“拥抱”中推断出来。       \n\n前提：两个女人互相拥抱。       \n\n假设：两个女人在表达爱意。       \n\n下面是一个矛盾的例子，因为“运行代码”表示“不睡觉”而不是“睡眠”。       \n\n前提：一个男人正在运行一个代码示例\n\n假设：这个人正在睡觉。       \n\n第三个例子显示了一种中立关系，因为“为演出”的事实不能推断出“著名”和“不出名”。       \n\n前提：音乐家正在表演。       \n\n假设：音乐家是有名的。       \n\n3. 有监督学习(supervised learning)和无监督学习(unsupervised learning)\n\n   - supervised learning：通过已有的样本去群里安处一个最优模型，再利用这个模型将就可以将其他的未知数据输入，得到已知的分类。就像小时候父母告诉我们这个是苹果，这个是狗，这就是已构建好的模型和函数以及分类，当身边没有大人时，当我们看到类似的东西时，也可以分辨出其他的水果以及动物。经典有监督学习（KNN，SVM以后学习一下）\n   - unsupervised learning：我们没有任何训练样本，直接利用已有数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。\n   - 有训练样本就用有监督学习，没有训练样本肯定用不了有监督学习。但现实中，在没有训练样本的情况下，我们可以通过人工标注一些样本，然后去用有监督的方法去做\n\n4. 泛化误差：对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为**泛化误差**。\n\n   - 训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络**过度拟合了训练集**，对训练集以外的数据却不work。\n\n   <img src=\"拟合对比.png\" alt=\"拟合对比\"  />\n\n   - 具体过拟合欠拟合等解决办法见http://blog.bangbangbangbang.top/posts/5c43.html/\n\n5. Dropout：是一种防止过拟合的方法，处理过后也可作为新数据加入数据集中，增加数据集的多样性。\n\n   - 在每次训练中，减少每个相关元素之间一半的关联，就可以明显减少过拟合现象。通过这种方法，可以减少相关元素之间的相互作用，可以使模型的泛化能力更强，因为不会过于依赖某些局部特征\n\n   <img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\" />\n\n6. 对比表示学习（Contrastive Representation Learning）\n   - 主要是要**构建正样本$x^+$和负样本$x^-$**，正例就是与x相似的数据，负例就是与x不同的数据\n   - 在论文[Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere](http://blog.bangbangbangbang.top/posts/3b4c.html/ICML2020.pdf)中指出了对比学习的两个指标\n   - **Alignment**对齐性，针对正例：计算正例对之间的向量距离的期望，越相似的正例对之间的alignment程度越高，距离越小。\n   - **Uniformity**均匀性，针对负例：所有数据的向量分布越均匀，保留的信息越多。最极端的反例，所有数据都映射到单位超球面的同一点上，这就极度违背了uniformity原则，这代表数据的所有信息都没了，只有一个点的信息了。负例对之间，距离越远愈好\n   - 这篇论文也采用这两个指标来衡量生成的句子向量，alignment和uniformity越低，向量的质量越高，在STS任务上的Spearman相关系数越高。spearman是一种相关系数方法\n\n7. 论文中的SimCSE方法\n\n   - Unsupervised SimCSE：引入dropout给输入加入噪声，假设加入噪声后的输入与原始输入在语义空间上距离相近。然后将相同的语句输入两次给预训练模型，得到一个正例对。因为dropout每次是以p概率隐去一半的相关性，所以相同输入所传出的值每次都是不同的，可以用作正例。\n\n   - supervised SimCSE：利用标注数据来构造对比学习的正负例子，最终选择NLI作为数据集\n\n8. 熵entropy\n   - 熵**(Entropy)**：可以表示一个事件A的自信息量，也就是A包含多少信息。\n   - KL散度**(Kullback-Leibler Divergence)**：可以用来表示从事件A的角度来看，事件B有多大不同。\n   - 交叉熵**(Cross Entropy)**：可以用来表示从事件A的角度来看，如何描述事件B。\n   - **KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价**。","slug":"SimCSE（十）","published":1,"updated":"2021-05-06T12:49:30.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5r001ya09k0eb01ep7","content":"<h1 id=\"SimCSE归纳总结\"><a href=\"#SimCSE归纳总结\" class=\"headerlink\" title=\"SimCSE归纳总结\"></a>SimCSE归纳总结</h1><ol>\n<li><p>SimCSE，运用了dropout的方法替换了原有的数据增强方法，将输入两次dropout产生的结果当作学习的正例</p>\n<ul>\n<li><p>为什么要进行数据增强：在深度学习中，一般要求样本的数量要充足，样本数量越多，训练出来的模型效果越好，模型的泛化能力越强。但是实际中，样本数量不足或者样本质量不够好，这就要对样本做数据增强，来提高样本质量</p>\n</li>\n<li><p>传统数据增强方法：</p>\n<ul>\n<li>图片：如果数据集都是图片类，可以运用翻转，旋转，缩放，剪裁，平移，添加噪声</li>\n<li>文本：数据是文本类的，可以使用回译，替换同义词，随机插入一个词语，随机交换词语，p概率删除一个词语</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>用<strong>自然语言推理NLI</strong>的数据用于有监督的对比学习：自然语言推理研究一个假设是否可以从一个前提中推断出来，假设和前提都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三类：       </p>\n<ul>\n<li><p>蕴涵：假设可以从前提中推断出来。       </p>\n</li>\n<li><p>矛盾：假设的否定可以从前提推断出来。       </p>\n</li>\n<li><p>中立：所有其情况。       </p>\n</li>\n</ul>\n</li>\n</ol>\n<p>自然语言推理也被称为识别文本蕴涵任务。例如，下面的一对会被标记为蕴涵，因为假设中的“示爱”可以从前提中的“拥抱”中推断出来。       </p>\n<p>前提：两个女人互相拥抱。       </p>\n<p>假设：两个女人在表达爱意。       </p>\n<p>下面是一个矛盾的例子，因为“运行代码”表示“不睡觉”而不是“睡眠”。       </p>\n<p>前提：一个男人正在运行一个代码示例</p>\n<p>假设：这个人正在睡觉。       </p>\n<p>第三个例子显示了一种中立关系，因为“为演出”的事实不能推断出“著名”和“不出名”。       </p>\n<p>前提：音乐家正在表演。       </p>\n<p>假设：音乐家是有名的。       </p>\n<ol>\n<li><p>有监督学习(supervised learning)和无监督学习(unsupervised learning)</p>\n<ul>\n<li>supervised learning：通过已有的样本去群里安处一个最优模型，再利用这个模型将就可以将其他的未知数据输入，得到已知的分类。就像小时候父母告诉我们这个是苹果，这个是狗，这就是已构建好的模型和函数以及分类，当身边没有大人时，当我们看到类似的东西时，也可以分辨出其他的水果以及动物。经典有监督学习（KNN，SVM以后学习一下）</li>\n<li>unsupervised learning：我们没有任何训练样本，直接利用已有数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。</li>\n<li>有训练样本就用有监督学习，没有训练样本肯定用不了有监督学习。但现实中，在没有训练样本的情况下，我们可以通过人工标注一些样本，然后去用有监督的方法去做</li>\n</ul>\n</li>\n<li><p>泛化误差：对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为<strong>泛化误差</strong>。</p>\n<ul>\n<li>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络<strong>过度拟合了训练集</strong>，对训练集以外的数据却不work。</li>\n</ul>\n<p><img src=\"拟合对比.png\" alt=\"拟合对比\"></p>\n<ul>\n<li>具体过拟合欠拟合等解决办法见<a href=\"http://blog.bangbangbangbang.top/posts/5c43.html/\">http://blog.bangbangbangbang.top/posts/5c43.html/</a></li>\n</ul>\n</li>\n<li><p>Dropout：是一种防止过拟合的方法，处理过后也可作为新数据加入数据集中，增加数据集的多样性。</p>\n<ul>\n<li>在每次训练中，减少每个相关元素之间一半的关联，就可以明显减少过拟合现象。通过这种方法，可以减少相关元素之间的相互作用，可以使模型的泛化能力更强，因为不会过于依赖某些局部特征</li>\n</ul>\n<p><img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\"></p>\n</li>\n<li><p>对比表示学习（Contrastive Representation Learning）</p>\n<ul>\n<li>主要是要<strong>构建正样本$x^+$和负样本$x^-$</strong>，正例就是与x相似的数据，负例就是与x不同的数据</li>\n<li>在论文<a href=\"http://blog.bangbangbangbang.top/posts/3b4c.html/ICML2020.pdf\">Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</a>中指出了对比学习的两个指标</li>\n<li><strong>Alignment</strong>对齐性，针对正例：计算正例对之间的向量距离的期望，越相似的正例对之间的alignment程度越高，距离越小。</li>\n<li><strong>Uniformity</strong>均匀性，针对负例：所有数据的向量分布越均匀，保留的信息越多。最极端的反例，所有数据都映射到单位超球面的同一点上，这就极度违背了uniformity原则，这代表数据的所有信息都没了，只有一个点的信息了。负例对之间，距离越远愈好</li>\n<li>这篇论文也采用这两个指标来衡量生成的句子向量，alignment和uniformity越低，向量的质量越高，在STS任务上的Spearman相关系数越高。spearman是一种相关系数方法</li>\n</ul>\n</li>\n<li><p>论文中的SimCSE方法</p>\n<ul>\n<li><p>Unsupervised SimCSE：引入dropout给输入加入噪声，假设加入噪声后的输入与原始输入在语义空间上距离相近。然后将相同的语句输入两次给预训练模型，得到一个正例对。因为dropout每次是以p概率隐去一半的相关性，所以相同输入所传出的值每次都是不同的，可以用作正例。</p>\n</li>\n<li><p>supervised SimCSE：利用标注数据来构造对比学习的正负例子，最终选择NLI作为数据集</p>\n</li>\n</ul>\n</li>\n<li><p>熵entropy</p>\n<ul>\n<li>熵<strong>(Entropy)</strong>：可以表示一个事件A的自信息量，也就是A包含多少信息。</li>\n<li>KL散度<strong>(Kullback-Leibler Divergence)</strong>：可以用来表示从事件A的角度来看，事件B有多大不同。</li>\n<li>交叉熵<strong>(Cross Entropy)</strong>：可以用来表示从事件A的角度来看，如何描述事件B。</li>\n<li><strong>KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价</strong>。</li>\n</ul>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"SimCSE归纳总结\"><a href=\"#SimCSE归纳总结\" class=\"headerlink\" title=\"SimCSE归纳总结\"></a>SimCSE归纳总结</h1><ol>\n<li><p>SimCSE，运用了dropout的方法替换了原有的数据增强方法，将输入两次dropout产生的结果当作学习的正例</p>\n<ul>\n<li><p>为什么要进行数据增强：在深度学习中，一般要求样本的数量要充足，样本数量越多，训练出来的模型效果越好，模型的泛化能力越强。但是实际中，样本数量不足或者样本质量不够好，这就要对样本做数据增强，来提高样本质量</p>\n</li>\n<li><p>传统数据增强方法：</p>\n<ul>\n<li>图片：如果数据集都是图片类，可以运用翻转，旋转，缩放，剪裁，平移，添加噪声</li>\n<li>文本：数据是文本类的，可以使用回译，替换同义词，随机插入一个词语，随机交换词语，p概率删除一个词语</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>用<strong>自然语言推理NLI</strong>的数据用于有监督的对比学习：自然语言推理研究一个假设是否可以从一个前提中推断出来，假设和前提都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三类：       </p>\n<ul>\n<li><p>蕴涵：假设可以从前提中推断出来。       </p>\n</li>\n<li><p>矛盾：假设的否定可以从前提推断出来。       </p>\n</li>\n<li><p>中立：所有其情况。       </p>\n</li>\n</ul>\n</li>\n</ol>\n<p>自然语言推理也被称为识别文本蕴涵任务。例如，下面的一对会被标记为蕴涵，因为假设中的“示爱”可以从前提中的“拥抱”中推断出来。       </p>\n<p>前提：两个女人互相拥抱。       </p>\n<p>假设：两个女人在表达爱意。       </p>\n<p>下面是一个矛盾的例子，因为“运行代码”表示“不睡觉”而不是“睡眠”。       </p>\n<p>前提：一个男人正在运行一个代码示例</p>\n<p>假设：这个人正在睡觉。       </p>\n<p>第三个例子显示了一种中立关系，因为“为演出”的事实不能推断出“著名”和“不出名”。       </p>\n<p>前提：音乐家正在表演。       </p>\n<p>假设：音乐家是有名的。       </p>\n<ol>\n<li><p>有监督学习(supervised learning)和无监督学习(unsupervised learning)</p>\n<ul>\n<li>supervised learning：通过已有的样本去群里安处一个最优模型，再利用这个模型将就可以将其他的未知数据输入，得到已知的分类。就像小时候父母告诉我们这个是苹果，这个是狗，这就是已构建好的模型和函数以及分类，当身边没有大人时，当我们看到类似的东西时，也可以分辨出其他的水果以及动物。经典有监督学习（KNN，SVM以后学习一下）</li>\n<li>unsupervised learning：我们没有任何训练样本，直接利用已有数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。</li>\n<li>有训练样本就用有监督学习，没有训练样本肯定用不了有监督学习。但现实中，在没有训练样本的情况下，我们可以通过人工标注一些样本，然后去用有监督的方法去做</li>\n</ul>\n</li>\n<li><p>泛化误差：对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为<strong>泛化误差</strong>。</p>\n<ul>\n<li>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络<strong>过度拟合了训练集</strong>，对训练集以外的数据却不work。</li>\n</ul>\n<p><img src=\"拟合对比.png\" alt=\"拟合对比\"  /></p>\n<ul>\n<li>具体过拟合欠拟合等解决办法见<a href=\"http://blog.bangbangbangbang.top/posts/5c43.html/\">http://blog.bangbangbangbang.top/posts/5c43.html/</a></li>\n</ul>\n</li>\n<li><p>Dropout：是一种防止过拟合的方法，处理过后也可作为新数据加入数据集中，增加数据集的多样性。</p>\n<ul>\n<li>在每次训练中，减少每个相关元素之间一半的关联，就可以明显减少过拟合现象。通过这种方法，可以减少相关元素之间的相互作用，可以使模型的泛化能力更强，因为不会过于依赖某些局部特征</li>\n</ul>\n<p><img src=\"dropout.jpeg\" alt=\"dropout\" style=\"zoom:50%;\" /></p>\n</li>\n<li><p>对比表示学习（Contrastive Representation Learning）</p>\n<ul>\n<li>主要是要<strong>构建正样本$x^+$和负样本$x^-$</strong>，正例就是与x相似的数据，负例就是与x不同的数据</li>\n<li>在论文<a href=\"http://blog.bangbangbangbang.top/posts/3b4c.html/ICML2020.pdf\">Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</a>中指出了对比学习的两个指标</li>\n<li><strong>Alignment</strong>对齐性，针对正例：计算正例对之间的向量距离的期望，越相似的正例对之间的alignment程度越高，距离越小。</li>\n<li><strong>Uniformity</strong>均匀性，针对负例：所有数据的向量分布越均匀，保留的信息越多。最极端的反例，所有数据都映射到单位超球面的同一点上，这就极度违背了uniformity原则，这代表数据的所有信息都没了，只有一个点的信息了。负例对之间，距离越远愈好</li>\n<li>这篇论文也采用这两个指标来衡量生成的句子向量，alignment和uniformity越低，向量的质量越高，在STS任务上的Spearman相关系数越高。spearman是一种相关系数方法</li>\n</ul>\n</li>\n<li><p>论文中的SimCSE方法</p>\n<ul>\n<li><p>Unsupervised SimCSE：引入dropout给输入加入噪声，假设加入噪声后的输入与原始输入在语义空间上距离相近。然后将相同的语句输入两次给预训练模型，得到一个正例对。因为dropout每次是以p概率隐去一半的相关性，所以相同输入所传出的值每次都是不同的，可以用作正例。</p>\n</li>\n<li><p>supervised SimCSE：利用标注数据来构造对比学习的正负例子，最终选择NLI作为数据集</p>\n</li>\n</ul>\n</li>\n<li><p>熵entropy</p>\n<ul>\n<li>熵<strong>(Entropy)</strong>：可以表示一个事件A的自信息量，也就是A包含多少信息。</li>\n<li>KL散度<strong>(Kullback-Leibler Divergence)</strong>：可以用来表示从事件A的角度来看，事件B有多大不同。</li>\n<li>交叉熵<strong>(Cross Entropy)</strong>：可以用来表示从事件A的角度来看，如何描述事件B。</li>\n<li><strong>KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价</strong>。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"SimCSE（八）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"代码环境配置","abbrlink":"4201","date":"2021-05-04T07:35:14.000Z","password":null,"keywords":null,"description":null,"_content":"# SimCSE代码Mac配置\n\n- 安装conda虚拟环境https://github.com/conda-forge/miniforge/#download\n\n- ```shell\n  bash Miniforge3-MacOSX-arm64.sh\n  ```\n\n- 配置环境变量\n\n- ```shell\n  vim ~/.bash_profile\n  export PATH=\"/Users/leng/miniforge3/bin:$PATH\"\n  #刷新变量\n  source $HOME/.bash_profile\n  ```\n\n- 创建python虚拟环境\n\n- ```shell\n  conda create -n py38 python=3.8\n  # 激活环境\n  source activate\n  # 打开虚拟环境\n  conda activate py38\n  # 退出环境\n  source deactivate\n  ```\n\n- 创造Virtualenv虚拟环境\n\n- ```shell\n  # 在项目目录下生成venv目录\n  python -m venv venv\n  # 将下载好的安装脚本放在venv同级目录下，安装\n  bash download_and_install.sh\n  # 输入虚拟环境的路径，注意要以venv结尾\n  ```\n\n  \n\n","source":"_posts/SimCSE（八）.md","raw":"---\ntitle: SimCSE（八）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 知识图谱\n  - SimCSE\n  - 代码\ncategories:\n  - 论文\nsummary: 代码环境配置\nabbrlink: '4201'\ndate: 2021-05-04 15:35:14\npassword:\nkeywords:\ndescription:\n---\n# SimCSE代码Mac配置\n\n- 安装conda虚拟环境https://github.com/conda-forge/miniforge/#download\n\n- ```shell\n  bash Miniforge3-MacOSX-arm64.sh\n  ```\n\n- 配置环境变量\n\n- ```shell\n  vim ~/.bash_profile\n  export PATH=\"/Users/leng/miniforge3/bin:$PATH\"\n  #刷新变量\n  source $HOME/.bash_profile\n  ```\n\n- 创建python虚拟环境\n\n- ```shell\n  conda create -n py38 python=3.8\n  # 激活环境\n  source activate\n  # 打开虚拟环境\n  conda activate py38\n  # 退出环境\n  source deactivate\n  ```\n\n- 创造Virtualenv虚拟环境\n\n- ```shell\n  # 在项目目录下生成venv目录\n  python -m venv venv\n  # 将下载好的安装脚本放在venv同级目录下，安装\n  bash download_and_install.sh\n  # 输入虚拟环境的路径，注意要以venv结尾\n  ```\n\n  \n\n","slug":"SimCSE（八）","published":1,"updated":"2021-05-04T07:36:51.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5s0021a09k13hi3lq3","content":"<h1 id=\"SimCSE代码Mac配置\"><a href=\"#SimCSE代码Mac配置\" class=\"headerlink\" title=\"SimCSE代码Mac配置\"></a>SimCSE代码Mac配置</h1><ul>\n<li><p>安装conda虚拟环境<a href=\"https://github.com/conda-forge/miniforge/#download\" target=\"_blank\" rel=\"noopener\">https://github.com/conda-forge/miniforge/#download</a></p>\n</li>\n<li><pre class=\"line-numbers language-lang-shell\"><code class=\"language-lang-shell\">bash Miniforge3-MacOSX-arm64.sh\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>配置环境变量</p>\n</li>\n<li><pre class=\"line-numbers language-lang-shell\"><code class=\"language-lang-shell\">vim ~/.bash_profile\nexport PATH=\"/Users/leng/miniforge3/bin:$PATH\"\n#刷新变量\nsource $HOME/.bash_profile\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建python虚拟环境</p>\n</li>\n<li><pre class=\"line-numbers language-lang-shell\"><code class=\"language-lang-shell\">conda create -n py38 python=3.8\n# 激活环境\nsource activate\n# 打开虚拟环境\nconda activate py38\n# 退出环境\nsource deactivate\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创造Virtualenv虚拟环境</p>\n</li>\n<li><pre class=\"line-numbers language-lang-shell\"><code class=\"language-lang-shell\"># 在项目目录下生成venv目录\npython -m venv venv\n# 将下载好的安装脚本放在venv同级目录下，安装\nbash download_and_install.sh\n# 输入虚拟环境的路径，注意要以venv结尾\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"SimCSE代码Mac配置\"><a href=\"#SimCSE代码Mac配置\" class=\"headerlink\" title=\"SimCSE代码Mac配置\"></a>SimCSE代码Mac配置</h1><ul>\n<li><p>安装conda虚拟环境<a href=\"https://github.com/conda-forge/miniforge/#download\" target=\"_blank\" rel=\"noopener\">https://github.com/conda-forge/miniforge/#download</a></p>\n</li>\n<li><pre><code class=\"lang-shell\">bash Miniforge3-MacOSX-arm64.sh\n</code></pre>\n</li>\n<li><p>配置环境变量</p>\n</li>\n<li><pre><code class=\"lang-shell\">vim ~/.bash_profile\nexport PATH=&quot;/Users/leng/miniforge3/bin:$PATH&quot;\n#刷新变量\nsource $HOME/.bash_profile\n</code></pre>\n</li>\n<li><p>创建python虚拟环境</p>\n</li>\n<li><pre><code class=\"lang-shell\">conda create -n py38 python=3.8\n# 激活环境\nsource activate\n# 打开虚拟环境\nconda activate py38\n# 退出环境\nsource deactivate\n</code></pre>\n</li>\n<li><p>创造Virtualenv虚拟环境</p>\n</li>\n<li><pre><code class=\"lang-shell\"># 在项目目录下生成venv目录\npython -m venv venv\n# 将下载好的安装脚本放在venv同级目录下，安装\nbash download_and_install.sh\n# 输入虚拟环境的路径，注意要以venv结尾\n</code></pre>\n</li>\n</ul>\n"},{"title":"SimCSE（六）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"Unsupervised and supervised SimCSE","abbrlink":"ca01","date":"2021-04-30T05:39:24.000Z","password":null,"keywords":null,"description":null,"_content":"# Simple Contrastive Learning of Sentence Embeddings（六）\n\n### 3 Unsupervised SimCSE and supervised SimCSE\n\n---\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- dropout mask，mask是什么意思\n- STS-B（Semantic Textual Similarity Benchmark）：语义文本相似度基准\n\n- write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). \n\n---\n\n> In this section, we describe our unsupervised SimCSE model. \n\n- 在本节中，我们将介绍我们的无监督SimCSE模型。\n\n> The idea is extremely simple: we take a collection of sentences $\\left\\{x_{i}\\right\\}_{i=1}^{m}$ and use $x_i^+=x_i$. \n\n- 这个想法非常简单：我们取一组句子$\\left\\{x_{i}\\right\\}_{i=1}^{m}$，然后使$x_i^+=x_i$。\n\n> The key ingredient to get this to work with identical positive pairs is through the use of independently sampled *dropout masks*. \n\n- 关键的因素是通过使用独立取样的“dropout masks”，使这项工作与相同的正对。\n\n> In standard training of Transformers (Vaswani et al., 2017), there is a dropout mask placed on fully-connected layers as well as attention probabilities (default p = 0.1). \n\n- 在Transformers的标准训练中，在完全连接的层上以及注意概率（默认p=0.1）上放置了一个dropout mask。\n\n> We denote $\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$ where $z$ is a random mask for dropout. \n\n- 我们用$\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$表示，$z$是一个随机的dropout mask\n\n> We simply feed the same input to the encoder twice by applying different dropout masks  $z, z^{\\prime}$ and the training objective becomes:\n\n- 我们只需通过应用不同的dropout mask，$z，z^{\\prime}$将相同的输入输入输入编码器两次，训练目标就变成：\n\n> for a mini-batch with N sentences. \n\n- 对于少量的句子N\n\n> Note that z is just the standard dropout mask in Transformers and we do not add any additional dropout.\n\n- 注意，z只是转变中的标准dropout mask，我们没有添加任何额外的dropout。\n\n#### Dropout noise as data augmentation 作为数据增强的dropout噪声\n\n> We view this approach as a minimal form of data augmentation: the positive pair takes exactly the same sentence, and their embeddings only differ in dropout masks. \n\n- 我们将这种方法视为数据扩充的一种最小形式：正例对采用完全相同的句子，它们的嵌入只在dropout mask上有所不同。\n\n> We compare this approach to common augmentation techniques and other training objectives on the STS-B development set (Cer et al., 2017).\n\n- 我们将这种方法与常见的增强技术和STS-B开发集上的其他训练目标进行了比较。\n\n> We use $N=512$ and $m = 10^6$ sentences randomly drawn from English Wikipedia in these experiments. \n\n在这些实验中，我们使用从英文维基百科中随机抽取的$N=512$ 和 $m = 10^6$ 个句子。\n\n> **Table 2** compares our approach to common data augmentation techniques such as crop, word deletion and replacement, which can be viewed as $\\mathbf{h}=f_{\\theta}(g(x), z)$ and $g$ is a (random) discrete operator on $x$. \n\n- **表2**将我们的方法与常见的数据扩充技术（如裁剪、字删除和替换）进行了比较，这些技术可以看作是$\\mathbf{h}=f_{\\theta}(g(x), z)$ ，而$g$是$x$上的（随机）离散运算符。\n\n  <img src=\"Table 2.png\" alt=\"Table 2\" style=\"zoom:50%;\" />\n\n\n\n> We find that even deleting one word would hurt performance and none of the discrete augmentations outperforms basic dropout noise.\n\n- 我们发现，即使删除一个单词也会影响性能，并且没有一个离散增强比基本的丢失噪声更好。\n\n> We also compare this self-prediction training objective to next-sentence objective used in Logeswaran and Lee (2018), taking either one encoder or two independent encoders. \n\n- 我们还将这个自我预测训练目标与Logeswaran和Lee中使用的下一个句子目标进行比较，选择一个编码器或两个独立的编码器。\n\n> As shown in Table 3, we find that SimCSE performs much better than the next-sentence objectives (79.1 vs 69.7 on STS-B) and using one encoder instead of two makes a significant difference in our approach.\n\n- 如表3所示，我们发现SimCSE比下一个句子目标（79.1 vs STS-B为69.7）的表现要好得多，并且使用一个编码器而不是两个编码器使我们的方法有显著的不同。\n\n  <img src=\"Table 3.png\" alt=\"Table 3\" style=\"zoom:50%;\" />\n\n---\n\n#### Why does it work?\n\n> To further understand the role of dropout noise in unsupervised SimCSE, we try out different dropout rates in Table 4 and observe that all the variants underperform the default dropout probability p = 0.1 from Transformers. \n\n- 为了进一步了解在无监督SimCSE中丢失噪声的作用，我们在表4中尝试了不同的丢失率，并观察到所有变体都低于Transformers的默认丢失概率p=0.1。\n\n<img src=\"Table 4.png\" alt=\"Table 4\" style=\"zoom:50%;\" />\n\n> We find two extreme cases particularly interesting: “no dropout” (p = 0) and “fixed 0.1” (using default dropout p = 0.1 but the same dropout masks for the pair).\n\n- 我们发现两个极端的情况特别有趣：“无dropout”（p=0）和“固定0.1”（使用默认的dropoutp=0.1，但对这两种情况使用相同的dropout mask）。\n\n\n\n\n\n In both cases, the resulting embeddings for the pair are exactly the same, and it leads to a dramatic performance degradation. \n\n- 在这两种情况下，生成的嵌入对完全相同，这会导致性能急剧下降。\n\n> We take the checkpoints of these models every 10 steps during training and visualize the alignment and uniformity metrics2 in Figure 2, along with a simple data augmentation model “delete one word”. \n\n- 在训练过程中，我们每10步对这些模型进行一次检查点检查，并在图2中可视化对齐和一致性度量2，以及一个简单的数据处理模型“删除一个单词”。\n\n<img src=\"Figure 2.png\" alt=\"Figure 2\" style=\"zoom:50%;\" />\n\n> As is clearly shown, all models largely improve the uniformity. \n\n- 如图所示，所有模型在很大程度上改善了均匀性。\n\n> However, the alignment of the two special variants also degrades drastically, while our unsupervised SimCSE keeps a steady alignment, thanks to the use of dropout noise. \n\n- 然而，这两种特殊变体的对齐也会急剧下降，而我们的无监督SimCSE由于使用了衰减噪声，保持了稳定的对齐。\n\n> On the other hand, although “delete one word” slightly improves the alignment, it has a smaller gain on the uniformity, and eventually underperforms unsupervised SimCSE.\n\n- 另一方面，虽然“删除一个单词”稍微提高了对齐度，但它在一致性方面的增益较小，最终表现不如无监督SimCSE。\n\n------\n\n### 4 Supervised SimCSE\n\n> We have demonstrated that adding dropout noise is able to learn a good alignment for positive pairs $\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$. \n\n- 我们已经证明，对于正对$\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$，添加dropout噪声能够学习良好的对齐性。\n\n> In this section, we study whether we can leverage supervised datasets to provide better training signals for improving alignment of our approach.\n\n- 在本节中，我们将研究是否可以利用监督数据集来提供更好的训练信号，以改进方法的一致性。\n\n> Prior work (Conneau et al., 2017; Reimers and Gurevych, 2019) has demonstrated that supervised natural language inference (NLI) datasets (Bowman et al., 2015; Williams et al., 2018) are effective for learning sentence embeddings, by predicting whether the relationship between two sentences is *entailment*, *neutral* or *contradiction*. \n\n- 前期工作已经证明了有监督的自然语言推理（NLI）数据集通过预测两个句子之间的关系是蕴涵、中性还是矛盾，来有效地学习句子嵌入。\n\n> In our contrastive learning framework, we instead directly take $(x_i,x_i^+)$pairs from supervised datasets and use them to optimize Eq. 1.\n\n- 在我们的对比学习框架中，我们直接从有监督的数据集中提取$(x_i,x_i^+)$对，并使用它们来优化等式1。\n\n$$\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}\n$$\n\n---\n\n#### Exploiting supervised data利用监督数据\n\n> We first explore which annotated datasets are especially suitable for constructing positive pairs $(x_i,x_i^+)$. \n\n- 我们首先探讨哪些带注释的数据集特别适合于构造正对$(x_i,x_i^+)$。\n\n> We exiperiment with a number of datasets with sentence-pair examples, including QQP4: Quora question pairs; Flickr30k (Young et al., 2014): each image is annotated with 5 human-written captions and we consider any two captions of the same image as a positive pair; ParaNMT (Wieting and Gimpel, 2018): a large-scale back-translation paraphrase dataset; and finally NLI datasets: SNLI (Bowman et al., 2015) and MNLI (Williams et al., 2018).\n\n- 我们用一些句子对的例子进行了实验，包括QQP问题对；Flickr：每幅图像都有5个人类书写的字幕注释，我们将同一幅图像的任意两个字幕视为正对；ParaNMT：大规模反译释义数据集；最后是NLI数据集：SNLI和MNLI。\n\n> We train the contrastive learning model (Eq. 1) with different datasets and compare the results in Table 5 （for a fair comparison, we also run experiments with the same # of training pairs）. \n\n- 我们用不同的数据集训练对比学习模型（等式1），并比较表5中的结果（为了公平比较，我们还用相同的训练对进行实验）。\n\n<img src=\"Table 5.png\" alt=\"Table 5\" style=\"zoom:50%;\" />\n\n> We find that most of these models using supervised datasets outperform our unsupervised approach, showing a clear benefit from supervised signals. \n\n- 我们发现，大多数使用监督数据集的模型都比我们的无监督方法有更好的性能，显示出监督信号的明显优势。\n\n> Among all the options, using entailment pairs from the NLI (SNLI + MNLI) datasets perform the best. \n\n在所有选项中，使用NLI（SNLI+MNLI）数据集entailment对表现最好。\n\n> We think this is reasonable, as the NLI datasets consist of high-quality and crowd-sourced pairs, and human annotators are expected to write the hypotheses manually based on the premises, and hence two sentences tend to have less lexical overlap. \n\n- 我们认为这是合理的，因为NLI数据集由高质量和众包的成对数据组成，并且人类注释者需要根据前提手工编写假设，因此两句话的词汇重叠较少。\n\n> For instance, we find that the lexical overlap (F1 measured between two bags of words) for the entailment pairs (SNLI + MNLI) is 39%, while they are 60% and 55% for QQP and ParaNMT.\n\n- 例如，我们发现蕴涵对（SNLI+MNLI）的词汇重叠（两袋词之间的F1）为39%，而QQP和ParaNMT分别为60%和55%。\n\n---\n\n#### Contradiction as hard negatives否定的矛盾\n\n> Finally, we further take the advantage of the NLI datasets by using its contradiction pairs as hard negatives. \n\n- 最后，我们进一步利用NLI数据集的矛盾对作为硬否定。\n\n> In NLI datasets, given one premise, annotators are required to manually write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). \n\n- 在NLI数据集中，给定一个前提，注释者需要手动编写一个绝对正确的句子（蕴涵），一个可能正确的句子（中性），一个绝对错误的句子（矛盾）。\n\n> Thus for each premise and its entailment hypothesis, there is an accompanying contradiction hypothesis7 (see Figure 1 for an example).\n\n- 因此，对于每个前提及其蕴涵假设，都有一个伴随的矛盾假设（参见图1中的示例）。\n\n> Formally, we extend $(x_i,x_i^+)$ to $(x_i,x_i^+,x_i^-)$ where $x_i$ is the premise, $x_i^+$and $x_i^-$ are entailment and contradiction hypotheses. \n\n- 形式上，我们将$（x_i，x_i^+）$扩展到$(x_i,x_i^+,x_i^-)$，其中$x_i$是前提，$x_i^+$和$x_i^-$是蕴涵和矛盾假设\n\n> The training objective $\\ell_{i}$ is then defined by (N is the mini-batch size):\n\n- 训练目标$\\ell{i}$由（N是最小批量大小）定义：\n\n$$\n-\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N}\\left(e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}+e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{-}\\right) / \\tau}\\right)}\n$$\n\n> As shown in Table 5, adding hard negatives can further improve performance (84.9 $\\rightarrow$ 86.2) and this is our final supervised SimCSE. \n\n- 如表5所示，添加消极可以进一步提高性能（84.9$\\rightarrow$86.2），这是我们的最终有监督SimCSE。\n\n> We also tried to add the ANLI dataset (Nie et al., 2020) or combine it with our unsupervised SimCSE approach, but didn’t find a meaningful improvement. \n\n- 我们还尝试添加ANLI数据集或将其与我们的无监督SimCSE方法相结合，但没有发现有意义的改进。\n\n> We also considered a dual encoder framework in supervised SimCSE and it hurt performance (86.2$\\rightarrow$ 84.2).\n\n- 我们还考虑了监督SimCSE中的双编码器框架，它会影响性能（86.2$\\rightarrow$84.2）。\n\n","source":"_posts/SimCSE（六）.md","raw":"---\ntitle: SimCSE（六）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nsummary: Unsupervised and supervised SimCSE\nabbrlink: ca01\ndate: 2021-04-30 13:39:24\npassword:\nkeywords:\ndescription:\n---\n# Simple Contrastive Learning of Sentence Embeddings（六）\n\n### 3 Unsupervised SimCSE and supervised SimCSE\n\n---\n\n#### <font color = \"red\">还需学习的知识点</font>\n\n- dropout mask，mask是什么意思\n- STS-B（Semantic Textual Similarity Benchmark）：语义文本相似度基准\n\n- write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). \n\n---\n\n> In this section, we describe our unsupervised SimCSE model. \n\n- 在本节中，我们将介绍我们的无监督SimCSE模型。\n\n> The idea is extremely simple: we take a collection of sentences $\\left\\{x_{i}\\right\\}_{i=1}^{m}$ and use $x_i^+=x_i$. \n\n- 这个想法非常简单：我们取一组句子$\\left\\{x_{i}\\right\\}_{i=1}^{m}$，然后使$x_i^+=x_i$。\n\n> The key ingredient to get this to work with identical positive pairs is through the use of independently sampled *dropout masks*. \n\n- 关键的因素是通过使用独立取样的“dropout masks”，使这项工作与相同的正对。\n\n> In standard training of Transformers (Vaswani et al., 2017), there is a dropout mask placed on fully-connected layers as well as attention probabilities (default p = 0.1). \n\n- 在Transformers的标准训练中，在完全连接的层上以及注意概率（默认p=0.1）上放置了一个dropout mask。\n\n> We denote $\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$ where $z$ is a random mask for dropout. \n\n- 我们用$\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$表示，$z$是一个随机的dropout mask\n\n> We simply feed the same input to the encoder twice by applying different dropout masks  $z, z^{\\prime}$ and the training objective becomes:\n\n- 我们只需通过应用不同的dropout mask，$z，z^{\\prime}$将相同的输入输入输入编码器两次，训练目标就变成：\n\n> for a mini-batch with N sentences. \n\n- 对于少量的句子N\n\n> Note that z is just the standard dropout mask in Transformers and we do not add any additional dropout.\n\n- 注意，z只是转变中的标准dropout mask，我们没有添加任何额外的dropout。\n\n#### Dropout noise as data augmentation 作为数据增强的dropout噪声\n\n> We view this approach as a minimal form of data augmentation: the positive pair takes exactly the same sentence, and their embeddings only differ in dropout masks. \n\n- 我们将这种方法视为数据扩充的一种最小形式：正例对采用完全相同的句子，它们的嵌入只在dropout mask上有所不同。\n\n> We compare this approach to common augmentation techniques and other training objectives on the STS-B development set (Cer et al., 2017).\n\n- 我们将这种方法与常见的增强技术和STS-B开发集上的其他训练目标进行了比较。\n\n> We use $N=512$ and $m = 10^6$ sentences randomly drawn from English Wikipedia in these experiments. \n\n在这些实验中，我们使用从英文维基百科中随机抽取的$N=512$ 和 $m = 10^6$ 个句子。\n\n> **Table 2** compares our approach to common data augmentation techniques such as crop, word deletion and replacement, which can be viewed as $\\mathbf{h}=f_{\\theta}(g(x), z)$ and $g$ is a (random) discrete operator on $x$. \n\n- **表2**将我们的方法与常见的数据扩充技术（如裁剪、字删除和替换）进行了比较，这些技术可以看作是$\\mathbf{h}=f_{\\theta}(g(x), z)$ ，而$g$是$x$上的（随机）离散运算符。\n\n  <img src=\"Table 2.png\" alt=\"Table 2\" style=\"zoom:50%;\" />\n\n\n\n> We find that even deleting one word would hurt performance and none of the discrete augmentations outperforms basic dropout noise.\n\n- 我们发现，即使删除一个单词也会影响性能，并且没有一个离散增强比基本的丢失噪声更好。\n\n> We also compare this self-prediction training objective to next-sentence objective used in Logeswaran and Lee (2018), taking either one encoder or two independent encoders. \n\n- 我们还将这个自我预测训练目标与Logeswaran和Lee中使用的下一个句子目标进行比较，选择一个编码器或两个独立的编码器。\n\n> As shown in Table 3, we find that SimCSE performs much better than the next-sentence objectives (79.1 vs 69.7 on STS-B) and using one encoder instead of two makes a significant difference in our approach.\n\n- 如表3所示，我们发现SimCSE比下一个句子目标（79.1 vs STS-B为69.7）的表现要好得多，并且使用一个编码器而不是两个编码器使我们的方法有显著的不同。\n\n  <img src=\"Table 3.png\" alt=\"Table 3\" style=\"zoom:50%;\" />\n\n---\n\n#### Why does it work?\n\n> To further understand the role of dropout noise in unsupervised SimCSE, we try out different dropout rates in Table 4 and observe that all the variants underperform the default dropout probability p = 0.1 from Transformers. \n\n- 为了进一步了解在无监督SimCSE中丢失噪声的作用，我们在表4中尝试了不同的丢失率，并观察到所有变体都低于Transformers的默认丢失概率p=0.1。\n\n<img src=\"Table 4.png\" alt=\"Table 4\" style=\"zoom:50%;\" />\n\n> We find two extreme cases particularly interesting: “no dropout” (p = 0) and “fixed 0.1” (using default dropout p = 0.1 but the same dropout masks for the pair).\n\n- 我们发现两个极端的情况特别有趣：“无dropout”（p=0）和“固定0.1”（使用默认的dropoutp=0.1，但对这两种情况使用相同的dropout mask）。\n\n\n\n\n\n In both cases, the resulting embeddings for the pair are exactly the same, and it leads to a dramatic performance degradation. \n\n- 在这两种情况下，生成的嵌入对完全相同，这会导致性能急剧下降。\n\n> We take the checkpoints of these models every 10 steps during training and visualize the alignment and uniformity metrics2 in Figure 2, along with a simple data augmentation model “delete one word”. \n\n- 在训练过程中，我们每10步对这些模型进行一次检查点检查，并在图2中可视化对齐和一致性度量2，以及一个简单的数据处理模型“删除一个单词”。\n\n<img src=\"Figure 2.png\" alt=\"Figure 2\" style=\"zoom:50%;\" />\n\n> As is clearly shown, all models largely improve the uniformity. \n\n- 如图所示，所有模型在很大程度上改善了均匀性。\n\n> However, the alignment of the two special variants also degrades drastically, while our unsupervised SimCSE keeps a steady alignment, thanks to the use of dropout noise. \n\n- 然而，这两种特殊变体的对齐也会急剧下降，而我们的无监督SimCSE由于使用了衰减噪声，保持了稳定的对齐。\n\n> On the other hand, although “delete one word” slightly improves the alignment, it has a smaller gain on the uniformity, and eventually underperforms unsupervised SimCSE.\n\n- 另一方面，虽然“删除一个单词”稍微提高了对齐度，但它在一致性方面的增益较小，最终表现不如无监督SimCSE。\n\n------\n\n### 4 Supervised SimCSE\n\n> We have demonstrated that adding dropout noise is able to learn a good alignment for positive pairs $\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$. \n\n- 我们已经证明，对于正对$\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$，添加dropout噪声能够学习良好的对齐性。\n\n> In this section, we study whether we can leverage supervised datasets to provide better training signals for improving alignment of our approach.\n\n- 在本节中，我们将研究是否可以利用监督数据集来提供更好的训练信号，以改进方法的一致性。\n\n> Prior work (Conneau et al., 2017; Reimers and Gurevych, 2019) has demonstrated that supervised natural language inference (NLI) datasets (Bowman et al., 2015; Williams et al., 2018) are effective for learning sentence embeddings, by predicting whether the relationship between two sentences is *entailment*, *neutral* or *contradiction*. \n\n- 前期工作已经证明了有监督的自然语言推理（NLI）数据集通过预测两个句子之间的关系是蕴涵、中性还是矛盾，来有效地学习句子嵌入。\n\n> In our contrastive learning framework, we instead directly take $(x_i,x_i^+)$pairs from supervised datasets and use them to optimize Eq. 1.\n\n- 在我们的对比学习框架中，我们直接从有监督的数据集中提取$(x_i,x_i^+)$对，并使用它们来优化等式1。\n\n$$\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}\n$$\n\n---\n\n#### Exploiting supervised data利用监督数据\n\n> We first explore which annotated datasets are especially suitable for constructing positive pairs $(x_i,x_i^+)$. \n\n- 我们首先探讨哪些带注释的数据集特别适合于构造正对$(x_i,x_i^+)$。\n\n> We exiperiment with a number of datasets with sentence-pair examples, including QQP4: Quora question pairs; Flickr30k (Young et al., 2014): each image is annotated with 5 human-written captions and we consider any two captions of the same image as a positive pair; ParaNMT (Wieting and Gimpel, 2018): a large-scale back-translation paraphrase dataset; and finally NLI datasets: SNLI (Bowman et al., 2015) and MNLI (Williams et al., 2018).\n\n- 我们用一些句子对的例子进行了实验，包括QQP问题对；Flickr：每幅图像都有5个人类书写的字幕注释，我们将同一幅图像的任意两个字幕视为正对；ParaNMT：大规模反译释义数据集；最后是NLI数据集：SNLI和MNLI。\n\n> We train the contrastive learning model (Eq. 1) with different datasets and compare the results in Table 5 （for a fair comparison, we also run experiments with the same # of training pairs）. \n\n- 我们用不同的数据集训练对比学习模型（等式1），并比较表5中的结果（为了公平比较，我们还用相同的训练对进行实验）。\n\n<img src=\"Table 5.png\" alt=\"Table 5\" style=\"zoom:50%;\" />\n\n> We find that most of these models using supervised datasets outperform our unsupervised approach, showing a clear benefit from supervised signals. \n\n- 我们发现，大多数使用监督数据集的模型都比我们的无监督方法有更好的性能，显示出监督信号的明显优势。\n\n> Among all the options, using entailment pairs from the NLI (SNLI + MNLI) datasets perform the best. \n\n在所有选项中，使用NLI（SNLI+MNLI）数据集entailment对表现最好。\n\n> We think this is reasonable, as the NLI datasets consist of high-quality and crowd-sourced pairs, and human annotators are expected to write the hypotheses manually based on the premises, and hence two sentences tend to have less lexical overlap. \n\n- 我们认为这是合理的，因为NLI数据集由高质量和众包的成对数据组成，并且人类注释者需要根据前提手工编写假设，因此两句话的词汇重叠较少。\n\n> For instance, we find that the lexical overlap (F1 measured between two bags of words) for the entailment pairs (SNLI + MNLI) is 39%, while they are 60% and 55% for QQP and ParaNMT.\n\n- 例如，我们发现蕴涵对（SNLI+MNLI）的词汇重叠（两袋词之间的F1）为39%，而QQP和ParaNMT分别为60%和55%。\n\n---\n\n#### Contradiction as hard negatives否定的矛盾\n\n> Finally, we further take the advantage of the NLI datasets by using its contradiction pairs as hard negatives. \n\n- 最后，我们进一步利用NLI数据集的矛盾对作为硬否定。\n\n> In NLI datasets, given one premise, annotators are required to manually write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). \n\n- 在NLI数据集中，给定一个前提，注释者需要手动编写一个绝对正确的句子（蕴涵），一个可能正确的句子（中性），一个绝对错误的句子（矛盾）。\n\n> Thus for each premise and its entailment hypothesis, there is an accompanying contradiction hypothesis7 (see Figure 1 for an example).\n\n- 因此，对于每个前提及其蕴涵假设，都有一个伴随的矛盾假设（参见图1中的示例）。\n\n> Formally, we extend $(x_i,x_i^+)$ to $(x_i,x_i^+,x_i^-)$ where $x_i$ is the premise, $x_i^+$and $x_i^-$ are entailment and contradiction hypotheses. \n\n- 形式上，我们将$（x_i，x_i^+）$扩展到$(x_i,x_i^+,x_i^-)$，其中$x_i$是前提，$x_i^+$和$x_i^-$是蕴涵和矛盾假设\n\n> The training objective $\\ell_{i}$ is then defined by (N is the mini-batch size):\n\n- 训练目标$\\ell{i}$由（N是最小批量大小）定义：\n\n$$\n-\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N}\\left(e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}+e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{-}\\right) / \\tau}\\right)}\n$$\n\n> As shown in Table 5, adding hard negatives can further improve performance (84.9 $\\rightarrow$ 86.2) and this is our final supervised SimCSE. \n\n- 如表5所示，添加消极可以进一步提高性能（84.9$\\rightarrow$86.2），这是我们的最终有监督SimCSE。\n\n> We also tried to add the ANLI dataset (Nie et al., 2020) or combine it with our unsupervised SimCSE approach, but didn’t find a meaningful improvement. \n\n- 我们还尝试添加ANLI数据集或将其与我们的无监督SimCSE方法相结合，但没有发现有意义的改进。\n\n> We also considered a dual encoder framework in supervised SimCSE and it hurt performance (86.2$\\rightarrow$ 84.2).\n\n- 我们还考虑了监督SimCSE中的双编码器框架，它会影响性能（86.2$\\rightarrow$84.2）。\n\n","slug":"SimCSE（六）","published":1,"updated":"2021-04-30T06:13:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5s0025a09kcfzb49sw","content":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（六）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（六）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（六）\"></a>Simple Contrastive Learning of Sentence Embeddings（六）</h1><h3 id=\"3-Unsupervised-SimCSE-and-supervised-SimCSE\"><a href=\"#3-Unsupervised-SimCSE-and-supervised-SimCSE\" class=\"headerlink\" title=\"3 Unsupervised SimCSE and supervised SimCSE\"></a>3 Unsupervised SimCSE and supervised SimCSE</h3><hr>\n<h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color=\"red\">还需学习的知识点</font></h4><ul>\n<li>dropout mask，mask是什么意思</li>\n<li><p>STS-B（Semantic Textual Similarity Benchmark）：语义文本相似度基准</p>\n</li>\n<li><p>write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). </p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>In this section, we describe our unsupervised SimCSE model. </p>\n</blockquote>\n<ul>\n<li>在本节中，我们将介绍我们的无监督SimCSE模型。</li>\n</ul>\n<blockquote>\n<p>The idea is extremely simple: we take a collection of sentences $\\left\\{x_{i}\\right\\}_{i=1}^{m}$ and use $x_i^+=x_i$. </p>\n</blockquote>\n<ul>\n<li>这个想法非常简单：我们取一组句子$\\left\\{x_{i}\\right\\}_{i=1}^{m}$，然后使$x_i^+=x_i$。</li>\n</ul>\n<blockquote>\n<p>The key ingredient to get this to work with identical positive pairs is through the use of independently sampled <em>dropout masks</em>. </p>\n</blockquote>\n<ul>\n<li>关键的因素是通过使用独立取样的“dropout masks”，使这项工作与相同的正对。</li>\n</ul>\n<blockquote>\n<p>In standard training of Transformers (Vaswani et al., 2017), there is a dropout mask placed on fully-connected layers as well as attention probabilities (default p = 0.1). </p>\n</blockquote>\n<ul>\n<li>在Transformers的标准训练中，在完全连接的层上以及注意概率（默认p=0.1）上放置了一个dropout mask。</li>\n</ul>\n<blockquote>\n<p>We denote $\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$ where $z$ is a random mask for dropout. </p>\n</blockquote>\n<ul>\n<li>我们用$\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$表示，$z$是一个随机的dropout mask</li>\n</ul>\n<blockquote>\n<p>We simply feed the same input to the encoder twice by applying different dropout masks  $z, z^{\\prime}$ and the training objective becomes:</p>\n</blockquote>\n<ul>\n<li>我们只需通过应用不同的dropout mask，$z，z^{\\prime}$将相同的输入输入输入编码器两次，训练目标就变成：</li>\n</ul>\n<blockquote>\n<p>for a mini-batch with N sentences. </p>\n</blockquote>\n<ul>\n<li>对于少量的句子N</li>\n</ul>\n<blockquote>\n<p>Note that z is just the standard dropout mask in Transformers and we do not add any additional dropout.</p>\n</blockquote>\n<ul>\n<li>注意，z只是转变中的标准dropout mask，我们没有添加任何额外的dropout。</li>\n</ul>\n<h4 id=\"Dropout-noise-as-data-augmentation-作为数据增强的dropout噪声\"><a href=\"#Dropout-noise-as-data-augmentation-作为数据增强的dropout噪声\" class=\"headerlink\" title=\"Dropout noise as data augmentation 作为数据增强的dropout噪声\"></a>Dropout noise as data augmentation 作为数据增强的dropout噪声</h4><blockquote>\n<p>We view this approach as a minimal form of data augmentation: the positive pair takes exactly the same sentence, and their embeddings only differ in dropout masks. </p>\n</blockquote>\n<ul>\n<li>我们将这种方法视为数据扩充的一种最小形式：正例对采用完全相同的句子，它们的嵌入只在dropout mask上有所不同。</li>\n</ul>\n<blockquote>\n<p>We compare this approach to common augmentation techniques and other training objectives on the STS-B development set (Cer et al., 2017).</p>\n</blockquote>\n<ul>\n<li>我们将这种方法与常见的增强技术和STS-B开发集上的其他训练目标进行了比较。</li>\n</ul>\n<blockquote>\n<p>We use $N=512$ and $m = 10^6$ sentences randomly drawn from English Wikipedia in these experiments. </p>\n</blockquote>\n<p>在这些实验中，我们使用从英文维基百科中随机抽取的$N=512$ 和 $m = 10^6$ 个句子。</p>\n<blockquote>\n<p><strong>Table 2</strong> compares our approach to common data augmentation techniques such as crop, word deletion and replacement, which can be viewed as $\\mathbf{h}=f_{\\theta}(g(x), z)$ and $g$ is a (random) discrete operator on $x$. </p>\n</blockquote>\n<ul>\n<li><p><strong>表2</strong>将我们的方法与常见的数据扩充技术（如裁剪、字删除和替换）进行了比较，这些技术可以看作是$\\mathbf{h}=f_{\\theta}(g(x), z)$ ，而$g$是$x$上的（随机）离散运算符。</p>\n<p><img src=\"Table 2.png\" alt=\"Table 2\" style=\"zoom:50%;\"></p>\n</li>\n</ul>\n<blockquote>\n<p>We find that even deleting one word would hurt performance and none of the discrete augmentations outperforms basic dropout noise.</p>\n</blockquote>\n<ul>\n<li>我们发现，即使删除一个单词也会影响性能，并且没有一个离散增强比基本的丢失噪声更好。</li>\n</ul>\n<blockquote>\n<p>We also compare this self-prediction training objective to next-sentence objective used in Logeswaran and Lee (2018), taking either one encoder or two independent encoders. </p>\n</blockquote>\n<ul>\n<li>我们还将这个自我预测训练目标与Logeswaran和Lee中使用的下一个句子目标进行比较，选择一个编码器或两个独立的编码器。</li>\n</ul>\n<blockquote>\n<p>As shown in Table 3, we find that SimCSE performs much better than the next-sentence objectives (79.1 vs 69.7 on STS-B) and using one encoder instead of two makes a significant difference in our approach.</p>\n</blockquote>\n<ul>\n<li><p>如表3所示，我们发现SimCSE比下一个句子目标（79.1 vs STS-B为69.7）的表现要好得多，并且使用一个编码器而不是两个编码器使我们的方法有显著的不同。</p>\n<p><img src=\"Table 3.png\" alt=\"Table 3\" style=\"zoom:50%;\"></p>\n</li>\n</ul>\n<hr>\n<h4 id=\"Why-does-it-work\"><a href=\"#Why-does-it-work\" class=\"headerlink\" title=\"Why does it work?\"></a>Why does it work?</h4><blockquote>\n<p>To further understand the role of dropout noise in unsupervised SimCSE, we try out different dropout rates in Table 4 and observe that all the variants underperform the default dropout probability p = 0.1 from Transformers. </p>\n</blockquote>\n<ul>\n<li>为了进一步了解在无监督SimCSE中丢失噪声的作用，我们在表4中尝试了不同的丢失率，并观察到所有变体都低于Transformers的默认丢失概率p=0.1。</li>\n</ul>\n<p><img src=\"Table 4.png\" alt=\"Table 4\" style=\"zoom:50%;\"></p>\n<blockquote>\n<p>We find two extreme cases particularly interesting: “no dropout” (p = 0) and “fixed 0.1” (using default dropout p = 0.1 but the same dropout masks for the pair).</p>\n</blockquote>\n<ul>\n<li>我们发现两个极端的情况特别有趣：“无dropout”（p=0）和“固定0.1”（使用默认的dropoutp=0.1，但对这两种情况使用相同的dropout mask）。</li>\n</ul>\n<p> In both cases, the resulting embeddings for the pair are exactly the same, and it leads to a dramatic performance degradation. </p>\n<ul>\n<li>在这两种情况下，生成的嵌入对完全相同，这会导致性能急剧下降。</li>\n</ul>\n<blockquote>\n<p>We take the checkpoints of these models every 10 steps during training and visualize the alignment and uniformity metrics2 in Figure 2, along with a simple data augmentation model “delete one word”. </p>\n</blockquote>\n<ul>\n<li>在训练过程中，我们每10步对这些模型进行一次检查点检查，并在图2中可视化对齐和一致性度量2，以及一个简单的数据处理模型“删除一个单词”。</li>\n</ul>\n<p><img src=\"Figure 2.png\" alt=\"Figure 2\" style=\"zoom:50%;\"></p>\n<blockquote>\n<p>As is clearly shown, all models largely improve the uniformity. </p>\n</blockquote>\n<ul>\n<li>如图所示，所有模型在很大程度上改善了均匀性。</li>\n</ul>\n<blockquote>\n<p>However, the alignment of the two special variants also degrades drastically, while our unsupervised SimCSE keeps a steady alignment, thanks to the use of dropout noise. </p>\n</blockquote>\n<ul>\n<li>然而，这两种特殊变体的对齐也会急剧下降，而我们的无监督SimCSE由于使用了衰减噪声，保持了稳定的对齐。</li>\n</ul>\n<blockquote>\n<p>On the other hand, although “delete one word” slightly improves the alignment, it has a smaller gain on the uniformity, and eventually underperforms unsupervised SimCSE.</p>\n</blockquote>\n<ul>\n<li>另一方面，虽然“删除一个单词”稍微提高了对齐度，但它在一致性方面的增益较小，最终表现不如无监督SimCSE。</li>\n</ul>\n<hr>\n<h3 id=\"4-Supervised-SimCSE\"><a href=\"#4-Supervised-SimCSE\" class=\"headerlink\" title=\"4 Supervised SimCSE\"></a>4 Supervised SimCSE</h3><blockquote>\n<p>We have demonstrated that adding dropout noise is able to learn a good alignment for positive pairs $\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$. </p>\n</blockquote>\n<ul>\n<li>我们已经证明，对于正对$\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$，添加dropout噪声能够学习良好的对齐性。</li>\n</ul>\n<blockquote>\n<p>In this section, we study whether we can leverage supervised datasets to provide better training signals for improving alignment of our approach.</p>\n</blockquote>\n<ul>\n<li>在本节中，我们将研究是否可以利用监督数据集来提供更好的训练信号，以改进方法的一致性。</li>\n</ul>\n<blockquote>\n<p>Prior work (Conneau et al., 2017; Reimers and Gurevych, 2019) has demonstrated that supervised natural language inference (NLI) datasets (Bowman et al., 2015; Williams et al., 2018) are effective for learning sentence embeddings, by predicting whether the relationship between two sentences is <em>entailment</em>, <em>neutral</em> or <em>contradiction</em>. </p>\n</blockquote>\n<ul>\n<li>前期工作已经证明了有监督的自然语言推理（NLI）数据集通过预测两个句子之间的关系是蕴涵、中性还是矛盾，来有效地学习句子嵌入。</li>\n</ul>\n<blockquote>\n<p>In our contrastive learning framework, we instead directly take $(x_i,x_i^+)$pairs from supervised datasets and use them to optimize Eq. 1.</p>\n</blockquote>\n<ul>\n<li>在我们的对比学习框架中，我们直接从有监督的数据集中提取$(x_i,x_i^+)$对，并使用它们来优化等式1。</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}</script><hr>\n<h4 id=\"Exploiting-supervised-data利用监督数据\"><a href=\"#Exploiting-supervised-data利用监督数据\" class=\"headerlink\" title=\"Exploiting supervised data利用监督数据\"></a>Exploiting supervised data利用监督数据</h4><blockquote>\n<p>We first explore which annotated datasets are especially suitable for constructing positive pairs $(x_i,x_i^+)$. </p>\n</blockquote>\n<ul>\n<li>我们首先探讨哪些带注释的数据集特别适合于构造正对$(x_i,x_i^+)$。</li>\n</ul>\n<blockquote>\n<p>We exiperiment with a number of datasets with sentence-pair examples, including QQP4: Quora question pairs; Flickr30k (Young et al., 2014): each image is annotated with 5 human-written captions and we consider any two captions of the same image as a positive pair; ParaNMT (Wieting and Gimpel, 2018): a large-scale back-translation paraphrase dataset; and finally NLI datasets: SNLI (Bowman et al., 2015) and MNLI (Williams et al., 2018).</p>\n</blockquote>\n<ul>\n<li>我们用一些句子对的例子进行了实验，包括QQP问题对；Flickr：每幅图像都有5个人类书写的字幕注释，我们将同一幅图像的任意两个字幕视为正对；ParaNMT：大规模反译释义数据集；最后是NLI数据集：SNLI和MNLI。</li>\n</ul>\n<blockquote>\n<p>We train the contrastive learning model (Eq. 1) with different datasets and compare the results in Table 5 （for a fair comparison, we also run experiments with the same # of training pairs）. </p>\n</blockquote>\n<ul>\n<li>我们用不同的数据集训练对比学习模型（等式1），并比较表5中的结果（为了公平比较，我们还用相同的训练对进行实验）。</li>\n</ul>\n<p><img src=\"Table 5.png\" alt=\"Table 5\" style=\"zoom:50%;\"></p>\n<blockquote>\n<p>We find that most of these models using supervised datasets outperform our unsupervised approach, showing a clear benefit from supervised signals. </p>\n</blockquote>\n<ul>\n<li>我们发现，大多数使用监督数据集的模型都比我们的无监督方法有更好的性能，显示出监督信号的明显优势。</li>\n</ul>\n<blockquote>\n<p>Among all the options, using entailment pairs from the NLI (SNLI + MNLI) datasets perform the best. </p>\n</blockquote>\n<p>在所有选项中，使用NLI（SNLI+MNLI）数据集entailment对表现最好。</p>\n<blockquote>\n<p>We think this is reasonable, as the NLI datasets consist of high-quality and crowd-sourced pairs, and human annotators are expected to write the hypotheses manually based on the premises, and hence two sentences tend to have less lexical overlap. </p>\n</blockquote>\n<ul>\n<li>我们认为这是合理的，因为NLI数据集由高质量和众包的成对数据组成，并且人类注释者需要根据前提手工编写假设，因此两句话的词汇重叠较少。</li>\n</ul>\n<blockquote>\n<p>For instance, we find that the lexical overlap (F1 measured between two bags of words) for the entailment pairs (SNLI + MNLI) is 39%, while they are 60% and 55% for QQP and ParaNMT.</p>\n</blockquote>\n<ul>\n<li>例如，我们发现蕴涵对（SNLI+MNLI）的词汇重叠（两袋词之间的F1）为39%，而QQP和ParaNMT分别为60%和55%。</li>\n</ul>\n<hr>\n<h4 id=\"Contradiction-as-hard-negatives否定的矛盾\"><a href=\"#Contradiction-as-hard-negatives否定的矛盾\" class=\"headerlink\" title=\"Contradiction as hard negatives否定的矛盾\"></a>Contradiction as hard negatives否定的矛盾</h4><blockquote>\n<p>Finally, we further take the advantage of the NLI datasets by using its contradiction pairs as hard negatives. </p>\n</blockquote>\n<ul>\n<li>最后，我们进一步利用NLI数据集的矛盾对作为硬否定。</li>\n</ul>\n<blockquote>\n<p>In NLI datasets, given one premise, annotators are required to manually write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). </p>\n</blockquote>\n<ul>\n<li>在NLI数据集中，给定一个前提，注释者需要手动编写一个绝对正确的句子（蕴涵），一个可能正确的句子（中性），一个绝对错误的句子（矛盾）。</li>\n</ul>\n<blockquote>\n<p>Thus for each premise and its entailment hypothesis, there is an accompanying contradiction hypothesis7 (see Figure 1 for an example).</p>\n</blockquote>\n<ul>\n<li>因此，对于每个前提及其蕴涵假设，都有一个伴随的矛盾假设（参见图1中的示例）。</li>\n</ul>\n<blockquote>\n<p>Formally, we extend $(x_i,x_i^+)$ to $(x_i,x_i^+,x_i^-)$ where $x_i$ is the premise, $x_i^+$and $x_i^-$ are entailment and contradiction hypotheses. </p>\n</blockquote>\n<ul>\n<li>形式上，我们将$（x_i，x_i^+）$扩展到$(x_i,x_i^+,x_i^-)$，其中$x_i$是前提，$x_i^+$和$x_i^-$是蕴涵和矛盾假设</li>\n</ul>\n<blockquote>\n<p>The training objective $\\ell_{i}$ is then defined by (N is the mini-batch size):</p>\n</blockquote>\n<ul>\n<li>训练目标$\\ell{i}$由（N是最小批量大小）定义：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n-\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N}\\left(e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}+e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{-}\\right) / \\tau}\\right)}</script><blockquote>\n<p>As shown in Table 5, adding hard negatives can further improve performance (84.9 $\\rightarrow$ 86.2) and this is our final supervised SimCSE. </p>\n</blockquote>\n<ul>\n<li>如表5所示，添加消极可以进一步提高性能（84.9$\\rightarrow$86.2），这是我们的最终有监督SimCSE。</li>\n</ul>\n<blockquote>\n<p>We also tried to add the ANLI dataset (Nie et al., 2020) or combine it with our unsupervised SimCSE approach, but didn’t find a meaningful improvement. </p>\n</blockquote>\n<ul>\n<li>我们还尝试添加ANLI数据集或将其与我们的无监督SimCSE方法相结合，但没有发现有意义的改进。</li>\n</ul>\n<blockquote>\n<p>We also considered a dual encoder framework in supervised SimCSE and it hurt performance (86.2$\\rightarrow$ 84.2).</p>\n</blockquote>\n<ul>\n<li>我们还考虑了监督SimCSE中的双编码器框架，它会影响性能（86.2$\\rightarrow$84.2）。</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（六）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（六）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（六）\"></a>Simple Contrastive Learning of Sentence Embeddings（六）</h1><h3 id=\"3-Unsupervised-SimCSE-and-supervised-SimCSE\"><a href=\"#3-Unsupervised-SimCSE-and-supervised-SimCSE\" class=\"headerlink\" title=\"3 Unsupervised SimCSE and supervised SimCSE\"></a>3 Unsupervised SimCSE and supervised SimCSE</h3><hr>\n<h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color = \"red\">还需学习的知识点</font></h4><ul>\n<li>dropout mask，mask是什么意思</li>\n<li><p>STS-B（Semantic Textual Similarity Benchmark）：语义文本相似度基准</p>\n</li>\n<li><p>write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). </p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>In this section, we describe our unsupervised SimCSE model. </p>\n</blockquote>\n<ul>\n<li>在本节中，我们将介绍我们的无监督SimCSE模型。</li>\n</ul>\n<blockquote>\n<p>The idea is extremely simple: we take a collection of sentences $\\left\\{x_{i}\\right\\}_{i=1}^{m}$ and use $x_i^+=x_i$. </p>\n</blockquote>\n<ul>\n<li>这个想法非常简单：我们取一组句子$\\left\\{x_{i}\\right\\}_{i=1}^{m}$，然后使$x_i^+=x_i$。</li>\n</ul>\n<blockquote>\n<p>The key ingredient to get this to work with identical positive pairs is through the use of independently sampled <em>dropout masks</em>. </p>\n</blockquote>\n<ul>\n<li>关键的因素是通过使用独立取样的“dropout masks”，使这项工作与相同的正对。</li>\n</ul>\n<blockquote>\n<p>In standard training of Transformers (Vaswani et al., 2017), there is a dropout mask placed on fully-connected layers as well as attention probabilities (default p = 0.1). </p>\n</blockquote>\n<ul>\n<li>在Transformers的标准训练中，在完全连接的层上以及注意概率（默认p=0.1）上放置了一个dropout mask。</li>\n</ul>\n<blockquote>\n<p>We denote $\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$ where $z$ is a random mask for dropout. </p>\n</blockquote>\n<ul>\n<li>我们用$\\mathbf{h}_{i}^{z}=f_{\\theta}\\left(x_{i}, z\\right)$表示，$z$是一个随机的dropout mask</li>\n</ul>\n<blockquote>\n<p>We simply feed the same input to the encoder twice by applying different dropout masks  $z, z^{\\prime}$ and the training objective becomes:</p>\n</blockquote>\n<ul>\n<li>我们只需通过应用不同的dropout mask，$z，z^{\\prime}$将相同的输入输入输入编码器两次，训练目标就变成：</li>\n</ul>\n<blockquote>\n<p>for a mini-batch with N sentences. </p>\n</blockquote>\n<ul>\n<li>对于少量的句子N</li>\n</ul>\n<blockquote>\n<p>Note that z is just the standard dropout mask in Transformers and we do not add any additional dropout.</p>\n</blockquote>\n<ul>\n<li>注意，z只是转变中的标准dropout mask，我们没有添加任何额外的dropout。</li>\n</ul>\n<h4 id=\"Dropout-noise-as-data-augmentation-作为数据增强的dropout噪声\"><a href=\"#Dropout-noise-as-data-augmentation-作为数据增强的dropout噪声\" class=\"headerlink\" title=\"Dropout noise as data augmentation 作为数据增强的dropout噪声\"></a>Dropout noise as data augmentation 作为数据增强的dropout噪声</h4><blockquote>\n<p>We view this approach as a minimal form of data augmentation: the positive pair takes exactly the same sentence, and their embeddings only differ in dropout masks. </p>\n</blockquote>\n<ul>\n<li>我们将这种方法视为数据扩充的一种最小形式：正例对采用完全相同的句子，它们的嵌入只在dropout mask上有所不同。</li>\n</ul>\n<blockquote>\n<p>We compare this approach to common augmentation techniques and other training objectives on the STS-B development set (Cer et al., 2017).</p>\n</blockquote>\n<ul>\n<li>我们将这种方法与常见的增强技术和STS-B开发集上的其他训练目标进行了比较。</li>\n</ul>\n<blockquote>\n<p>We use $N=512$ and $m = 10^6$ sentences randomly drawn from English Wikipedia in these experiments. </p>\n</blockquote>\n<p>在这些实验中，我们使用从英文维基百科中随机抽取的$N=512$ 和 $m = 10^6$ 个句子。</p>\n<blockquote>\n<p><strong>Table 2</strong> compares our approach to common data augmentation techniques such as crop, word deletion and replacement, which can be viewed as $\\mathbf{h}=f_{\\theta}(g(x), z)$ and $g$ is a (random) discrete operator on $x$. </p>\n</blockquote>\n<ul>\n<li><p><strong>表2</strong>将我们的方法与常见的数据扩充技术（如裁剪、字删除和替换）进行了比较，这些技术可以看作是$\\mathbf{h}=f_{\\theta}(g(x), z)$ ，而$g$是$x$上的（随机）离散运算符。</p>\n<p><img src=\"Table 2.png\" alt=\"Table 2\" style=\"zoom:50%;\" /></p>\n</li>\n</ul>\n<blockquote>\n<p>We find that even deleting one word would hurt performance and none of the discrete augmentations outperforms basic dropout noise.</p>\n</blockquote>\n<ul>\n<li>我们发现，即使删除一个单词也会影响性能，并且没有一个离散增强比基本的丢失噪声更好。</li>\n</ul>\n<blockquote>\n<p>We also compare this self-prediction training objective to next-sentence objective used in Logeswaran and Lee (2018), taking either one encoder or two independent encoders. </p>\n</blockquote>\n<ul>\n<li>我们还将这个自我预测训练目标与Logeswaran和Lee中使用的下一个句子目标进行比较，选择一个编码器或两个独立的编码器。</li>\n</ul>\n<blockquote>\n<p>As shown in Table 3, we find that SimCSE performs much better than the next-sentence objectives (79.1 vs 69.7 on STS-B) and using one encoder instead of two makes a significant difference in our approach.</p>\n</blockquote>\n<ul>\n<li><p>如表3所示，我们发现SimCSE比下一个句子目标（79.1 vs STS-B为69.7）的表现要好得多，并且使用一个编码器而不是两个编码器使我们的方法有显著的不同。</p>\n<p><img src=\"Table 3.png\" alt=\"Table 3\" style=\"zoom:50%;\" /></p>\n</li>\n</ul>\n<hr>\n<h4 id=\"Why-does-it-work\"><a href=\"#Why-does-it-work\" class=\"headerlink\" title=\"Why does it work?\"></a>Why does it work?</h4><blockquote>\n<p>To further understand the role of dropout noise in unsupervised SimCSE, we try out different dropout rates in Table 4 and observe that all the variants underperform the default dropout probability p = 0.1 from Transformers. </p>\n</blockquote>\n<ul>\n<li>为了进一步了解在无监督SimCSE中丢失噪声的作用，我们在表4中尝试了不同的丢失率，并观察到所有变体都低于Transformers的默认丢失概率p=0.1。</li>\n</ul>\n<p><img src=\"Table 4.png\" alt=\"Table 4\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>We find two extreme cases particularly interesting: “no dropout” (p = 0) and “fixed 0.1” (using default dropout p = 0.1 but the same dropout masks for the pair).</p>\n</blockquote>\n<ul>\n<li>我们发现两个极端的情况特别有趣：“无dropout”（p=0）和“固定0.1”（使用默认的dropoutp=0.1，但对这两种情况使用相同的dropout mask）。</li>\n</ul>\n<p> In both cases, the resulting embeddings for the pair are exactly the same, and it leads to a dramatic performance degradation. </p>\n<ul>\n<li>在这两种情况下，生成的嵌入对完全相同，这会导致性能急剧下降。</li>\n</ul>\n<blockquote>\n<p>We take the checkpoints of these models every 10 steps during training and visualize the alignment and uniformity metrics2 in Figure 2, along with a simple data augmentation model “delete one word”. </p>\n</blockquote>\n<ul>\n<li>在训练过程中，我们每10步对这些模型进行一次检查点检查，并在图2中可视化对齐和一致性度量2，以及一个简单的数据处理模型“删除一个单词”。</li>\n</ul>\n<p><img src=\"Figure 2.png\" alt=\"Figure 2\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>As is clearly shown, all models largely improve the uniformity. </p>\n</blockquote>\n<ul>\n<li>如图所示，所有模型在很大程度上改善了均匀性。</li>\n</ul>\n<blockquote>\n<p>However, the alignment of the two special variants also degrades drastically, while our unsupervised SimCSE keeps a steady alignment, thanks to the use of dropout noise. </p>\n</blockquote>\n<ul>\n<li>然而，这两种特殊变体的对齐也会急剧下降，而我们的无监督SimCSE由于使用了衰减噪声，保持了稳定的对齐。</li>\n</ul>\n<blockquote>\n<p>On the other hand, although “delete one word” slightly improves the alignment, it has a smaller gain on the uniformity, and eventually underperforms unsupervised SimCSE.</p>\n</blockquote>\n<ul>\n<li>另一方面，虽然“删除一个单词”稍微提高了对齐度，但它在一致性方面的增益较小，最终表现不如无监督SimCSE。</li>\n</ul>\n<hr>\n<h3 id=\"4-Supervised-SimCSE\"><a href=\"#4-Supervised-SimCSE\" class=\"headerlink\" title=\"4 Supervised SimCSE\"></a>4 Supervised SimCSE</h3><blockquote>\n<p>We have demonstrated that adding dropout noise is able to learn a good alignment for positive pairs $\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$. </p>\n</blockquote>\n<ul>\n<li>我们已经证明，对于正对$\\left(x, x^{+}\\right) \\sim p_{\\text {pos }}$，添加dropout噪声能够学习良好的对齐性。</li>\n</ul>\n<blockquote>\n<p>In this section, we study whether we can leverage supervised datasets to provide better training signals for improving alignment of our approach.</p>\n</blockquote>\n<ul>\n<li>在本节中，我们将研究是否可以利用监督数据集来提供更好的训练信号，以改进方法的一致性。</li>\n</ul>\n<blockquote>\n<p>Prior work (Conneau et al., 2017; Reimers and Gurevych, 2019) has demonstrated that supervised natural language inference (NLI) datasets (Bowman et al., 2015; Williams et al., 2018) are effective for learning sentence embeddings, by predicting whether the relationship between two sentences is <em>entailment</em>, <em>neutral</em> or <em>contradiction</em>. </p>\n</blockquote>\n<ul>\n<li>前期工作已经证明了有监督的自然语言推理（NLI）数据集通过预测两个句子之间的关系是蕴涵、中性还是矛盾，来有效地学习句子嵌入。</li>\n</ul>\n<blockquote>\n<p>In our contrastive learning framework, we instead directly take $(x_i,x_i^+)$pairs from supervised datasets and use them to optimize Eq. 1.</p>\n</blockquote>\n<ul>\n<li>在我们的对比学习框架中，我们直接从有监督的数据集中提取$(x_i,x_i^+)$对，并使用它们来优化等式1。</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\ell_{i}=\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N} e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}}</script><hr>\n<h4 id=\"Exploiting-supervised-data利用监督数据\"><a href=\"#Exploiting-supervised-data利用监督数据\" class=\"headerlink\" title=\"Exploiting supervised data利用监督数据\"></a>Exploiting supervised data利用监督数据</h4><blockquote>\n<p>We first explore which annotated datasets are especially suitable for constructing positive pairs $(x_i,x_i^+)$. </p>\n</blockquote>\n<ul>\n<li>我们首先探讨哪些带注释的数据集特别适合于构造正对$(x_i,x_i^+)$。</li>\n</ul>\n<blockquote>\n<p>We exiperiment with a number of datasets with sentence-pair examples, including QQP4: Quora question pairs; Flickr30k (Young et al., 2014): each image is annotated with 5 human-written captions and we consider any two captions of the same image as a positive pair; ParaNMT (Wieting and Gimpel, 2018): a large-scale back-translation paraphrase dataset; and finally NLI datasets: SNLI (Bowman et al., 2015) and MNLI (Williams et al., 2018).</p>\n</blockquote>\n<ul>\n<li>我们用一些句子对的例子进行了实验，包括QQP问题对；Flickr：每幅图像都有5个人类书写的字幕注释，我们将同一幅图像的任意两个字幕视为正对；ParaNMT：大规模反译释义数据集；最后是NLI数据集：SNLI和MNLI。</li>\n</ul>\n<blockquote>\n<p>We train the contrastive learning model (Eq. 1) with different datasets and compare the results in Table 5 （for a fair comparison, we also run experiments with the same # of training pairs）. </p>\n</blockquote>\n<ul>\n<li>我们用不同的数据集训练对比学习模型（等式1），并比较表5中的结果（为了公平比较，我们还用相同的训练对进行实验）。</li>\n</ul>\n<p><img src=\"Table 5.png\" alt=\"Table 5\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>We find that most of these models using supervised datasets outperform our unsupervised approach, showing a clear benefit from supervised signals. </p>\n</blockquote>\n<ul>\n<li>我们发现，大多数使用监督数据集的模型都比我们的无监督方法有更好的性能，显示出监督信号的明显优势。</li>\n</ul>\n<blockquote>\n<p>Among all the options, using entailment pairs from the NLI (SNLI + MNLI) datasets perform the best. </p>\n</blockquote>\n<p>在所有选项中，使用NLI（SNLI+MNLI）数据集entailment对表现最好。</p>\n<blockquote>\n<p>We think this is reasonable, as the NLI datasets consist of high-quality and crowd-sourced pairs, and human annotators are expected to write the hypotheses manually based on the premises, and hence two sentences tend to have less lexical overlap. </p>\n</blockquote>\n<ul>\n<li>我们认为这是合理的，因为NLI数据集由高质量和众包的成对数据组成，并且人类注释者需要根据前提手工编写假设，因此两句话的词汇重叠较少。</li>\n</ul>\n<blockquote>\n<p>For instance, we find that the lexical overlap (F1 measured between two bags of words) for the entailment pairs (SNLI + MNLI) is 39%, while they are 60% and 55% for QQP and ParaNMT.</p>\n</blockquote>\n<ul>\n<li>例如，我们发现蕴涵对（SNLI+MNLI）的词汇重叠（两袋词之间的F1）为39%，而QQP和ParaNMT分别为60%和55%。</li>\n</ul>\n<hr>\n<h4 id=\"Contradiction-as-hard-negatives否定的矛盾\"><a href=\"#Contradiction-as-hard-negatives否定的矛盾\" class=\"headerlink\" title=\"Contradiction as hard negatives否定的矛盾\"></a>Contradiction as hard negatives否定的矛盾</h4><blockquote>\n<p>Finally, we further take the advantage of the NLI datasets by using its contradiction pairs as hard negatives. </p>\n</blockquote>\n<ul>\n<li>最后，我们进一步利用NLI数据集的矛盾对作为硬否定。</li>\n</ul>\n<blockquote>\n<p>In NLI datasets, given one premise, annotators are required to manually write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). </p>\n</blockquote>\n<ul>\n<li>在NLI数据集中，给定一个前提，注释者需要手动编写一个绝对正确的句子（蕴涵），一个可能正确的句子（中性），一个绝对错误的句子（矛盾）。</li>\n</ul>\n<blockquote>\n<p>Thus for each premise and its entailment hypothesis, there is an accompanying contradiction hypothesis7 (see Figure 1 for an example).</p>\n</blockquote>\n<ul>\n<li>因此，对于每个前提及其蕴涵假设，都有一个伴随的矛盾假设（参见图1中的示例）。</li>\n</ul>\n<blockquote>\n<p>Formally, we extend $(x_i,x_i^+)$ to $(x_i,x_i^+,x_i^-)$ where $x_i$ is the premise, $x_i^+$and $x_i^-$ are entailment and contradiction hypotheses. </p>\n</blockquote>\n<ul>\n<li>形式上，我们将$（x_i，x_i^+）$扩展到$(x_i,x_i^+,x_i^-)$，其中$x_i$是前提，$x_i^+$和$x_i^-$是蕴涵和矛盾假设</li>\n</ul>\n<blockquote>\n<p>The training objective $\\ell_{i}$ is then defined by (N is the mini-batch size):</p>\n</blockquote>\n<ul>\n<li>训练目标$\\ell{i}$由（N是最小批量大小）定义：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n-\\log \\frac{e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{i}^{+}\\right) / \\tau}}{\\sum_{j=1}^{N}\\left(e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{+}\\right) / \\tau}+e^{\\operatorname{sim}\\left(\\mathbf{h}_{i}, \\mathbf{h}_{j}^{-}\\right) / \\tau}\\right)}</script><blockquote>\n<p>As shown in Table 5, adding hard negatives can further improve performance (84.9 $\\rightarrow$ 86.2) and this is our final supervised SimCSE. </p>\n</blockquote>\n<ul>\n<li>如表5所示，添加消极可以进一步提高性能（84.9$\\rightarrow$86.2），这是我们的最终有监督SimCSE。</li>\n</ul>\n<blockquote>\n<p>We also tried to add the ANLI dataset (Nie et al., 2020) or combine it with our unsupervised SimCSE approach, but didn’t find a meaningful improvement. </p>\n</blockquote>\n<ul>\n<li>我们还尝试添加ANLI数据集或将其与我们的无监督SimCSE方法相结合，但没有发现有意义的改进。</li>\n</ul>\n<blockquote>\n<p>We also considered a dual encoder framework in supervised SimCSE and it hurt performance (86.2$\\rightarrow$ 84.2).</p>\n</blockquote>\n<ul>\n<li>我们还考虑了监督SimCSE中的双编码器框架，它会影响性能（86.2$\\rightarrow$84.2）。</li>\n</ul>\n"},{"title":"SimCSE（四）","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"40a6","date":"2021-04-28T04:38:25.000Z","password":null,"keywords":null,"description":null,"summary":"SimCSE Introduction","_content":"\n# Simple Contrastive Learning of Sentence Embeddings（四）\n\n**SimCSE**有两个变体：**Unsupervised SimCSE**和**Supervised SimCSE**，主要不同在于对比学习的正负例的构造。下面详细介绍下他们的构造方式。\n\n----\n\n####  <font color = \"red\">还需学习的知识点</font>\n\n- **in-batch和negatives方法还不懂，需要学习**\n\n- **正例和负例具体指什么数据**\n\n- **自然语言推理（NLI）数据集**\n\n- **句子嵌入是什么意思以及如何实现**\n\n- **有监督和无监督是什么意思**\n\n-----\n\n## 无监督SimCSE\n\n> Learning universal sentence embeddings is a fundamental problem in natural language processing and has been studied extensively in the literature.\n\n- 通用句嵌入的学习是自然语言处理中的一个基本问题，已有文献对此进行了广泛的研究。\n\n> In this work, we advance state-of-the-art sentence embedding methods and demonstrate that a contrastive objective can be extremely effective in learning sentence embeddings, coupled with pre-trained language models such as BERT and RoBERTa. \n\n- 在这项工作中，我们提出了最先进的句子嵌入方法，并证明对比目标在学习句子嵌入时是非常有效的，再加上预先训练的语言模型，如BERT和RoBERTa。\n\n> We present SimCSE, a simple contrastive sentence embedding framework, which can be used to produce superior sentence embeddings, from either unlabeled or labeled data.\n\n- 我们提出了一个简单的对比句子嵌入框架SimCSE，它可以用来从未标记或标记的数据中产生更好的句子嵌入。\n\n\n\n> Our *unsupervised* SimCSE simply predicts the input sentence itself, with only *dropout* (Srivastava et al., 2014) used as noise （Figure 1（a））.\n\n- 我们的无监督SimCSE只是预测输入句子本身，只有*dropout*用作噪声（图1（a））。\n\n<img src=\"Unsupervised SimCSE.png\" alt=\"Unsupervised SimCSE\" style=\"zoom:50%;\" />\n\n> In other words, we pass the same input sentence to the pretrained encoder twice and obtain two embeddings as “positive pairs”, by applying independently sampled dropout masks. \n\n- 换言之，我们将相同的输入语句传递给预训练的编码器两次，并通过应用独立采样的dropout掩码获得两个作为“正对”的嵌入。\n\n- 对于**Unsupervised SimCSE**，核心在于如何生成dropout mask。因为BERT内部每次dropout都随机会生成一个不同的dropout mask。所以SimCSL不需要改变原始BERT，只需要将同一个句子喂给模型两次，得到的两个向量就是应用两次不同dropout mask的结果。然后将两个向量作为正例对。（真的simple）\n\n> Although it may appear strikingly simple, we find that this approach largely outperforms training objectives such as predicting next sentences and common data augmentation techniques, e.g., word deletion and replacement.\n\n- 虽然它看起来非常简单，但是我们发现这种方法在很大程度上优于训练目标，例如预测下一句话和常用的数据增强技术，例如单词删除和替换。\n\n> More surprisingly, this unsupervised embedding method already matches all the previous supervised approaches. \n\n- 更令人惊讶的是，这种无监督的嵌入方法已经匹配了所有以前的监督方法。\n\n> Through careful analysis, we find that dropout essentially acts as minimal data augmentation, while removing it leads to a representation collapse.\n\n- 通过仔细的分析，我们发现退dropout本质上是作为最小的数据扩充，而删除它会导致表示崩溃。\n\n**Unsupervised SimCSE** 引入dropout给输入加噪声，假设加噪后的输入仍与原始输入在语义空间距离相近。其正负例的构造方式如下：\n\n> 正例：给定输入，用预训练语言模型编码两次得到的两个向量和作为正例对。我理解的正例就是大于平均值的数据，负例就是低于平均值的数据\n\n> 负例：使用in-batch negatives的方式，即随机采样一个batch中另一个输入作为的负例。\n\n----\n\n## 有监督SimCSE\n\n**Supervised SimCSE**，利用标注数据来构造对比学习的正负例子。为探究哪种标注数据更有利于句子向量的学习，文中在多种数据集上做了实验，最后发现NLI数据最有利于学习句子表示。下面以NLI数据为例介绍Supervised SimCSE的流程。\n\nSupervised SimCSE 引入了NLI任务来监督对比学习过程。该模型假设如果两个句子存在蕴含关系，那么它们之间的句子向量距离应该较近；如果两个句子存在矛盾关系，那么它们的距离应该较远。因此NLI中的蕴含句对和矛盾句对分别对应对比学习中的正例对和负例对。所以在Supervised SimCSE中，正负例的构造方式如下:\n\n> 正例：NLI中entailment关系样例对。负例：a) in-batch negatives b)NLI中关系为contradiction的样例对。\n\n---\n\n> In our *supervised* SimCSE, we build upon the recent success of leveraging natural language inference （NLI） datasets for sentence embeddings （Conneau et al., 2017; Reimers and Gurevych, 2019） and incorporate supervised sentence pairs in contrastive learning （Figure 1(b)）. \n\n- 在我们的有监督SimCSE中，我们建立在利用自然语言推理（NLI）数据集进行句子嵌入的最新成功基础上，并将有监督句对纳入对比学习（图1（b））。\n\n<img src=\"Supervised SimCSE.png\" alt=\"Supervised SimCSE\" style=\"zoom:50%;\" />\n\n> Unlike previous work that casts it as a 3-way classification task （entailment/neutral/contradiction）, we take advantage of the fact that **entailment** pairs can be naturally used as positive instances.\n\n- 与以前的工作不同的是，我们将它作为一个三向分类任务（蕴涵/中立/矛盾），我们利用了蕴涵对可以自然地用作正实例这一事实。\n\n\n\n> We also find that adding corresponding contradiction pairs as hard negatives further improves performance. \n\n- 我们还发现，添加相应的矛盾对作为硬否定进一步提高了性能。\n\n\n\n> This simple use of NLI datasets achieves a greater performance compared to prior methods using the same datasets. \n\n- 与以前使用相同数据集的方法相比，NLI数据集的这种简单使用实现了更高的性能。\n\n> We also compare to other (annotated) sentence-pair datasets and find that NLI datasets are especially effective for learning sentence embeddings.\n\n- 我们还比较了其他（带注释的）句子对数据集，发现NLI数据集对于学习句子嵌入特别有效。\n\n\n\n\n\n> To better understand the superior performance of SimCSE, we borrow the analysis tool from Wang and Isola (2020), which takes *alignment* between semantically-related positive pairs and *uniformity* of the whole representation space to measure the quality of learned embeddings. \n\n- 为了更好地理解SimCSE的优越性能，我们借用了Wang和Isola（2020）的分析工具，它采用语义相关正对之间的对齐度和整个表示空间的一致度来衡量学习嵌入的质量。\n\n\n\n> We prove that theoretically the contrastive learning objective “flattens” the singular value distribution of the sentence embedding space, hence improving the uniformity. \n\n- 我们从理论上证明了对比学习目标“平坦”了句子嵌入空间的奇异值分布，从而提高了一致性。\n\n\n\n\n\n> We also draw a connection to the recent findings that pre-trained word embeddings suffer from anisotropy (Ethayarajh, 2019; Li et al., 2020).\n\n- 我们还与最近的研究结果相联系，即预先训练的单词嵌入会受到各向异性的影响。\n\n\n\n\n\n> We find that our unsupervised SimCSE essentially improves uniformity while avoiding degenerated alignment via dropout noise, thus greatly improves the expressiveness of the representations. \n\n- 我们发现，我们的无监督SimCSE本质上改善了一致性，同时避免了通过丢失噪声退化对齐，从而大大提高了表示的表达能力。\n\n\n\n> We also demonstrate that the NLI training signal can further improve alignment between positive pairs and hence produce better sentence embeddings.\n\n- 我们还证明，NLI训练信号可以进一步改善正对之间的对齐，从而产生更好的句子嵌入。\n\n\n\n\n\n\n\n第三段\n\n\n\n> We conduct a comprehensive evaluation of SimCSE, along with previous state-of-the-art models on 7 semantic textual similarity (STS) tasks and 7 transfer tasks.\n\n- 我们对SimCSE进行了综合评价，并对7个语义-文本相似度（STS）任务和7个迁移任务进行了分析。\n\n\n\n> On STS tasks, we show that our unsupervised and supervised models achieve a 74.5% and 81.6% averaged Spearman’s correlation respectively using BERTbase , largely outperforming previous best (Table 1). \n\n- 在STS任务中，我们发现我们的无监督和有监督模型使用BERTbase分别达到了74.5%和81.6%的平均Spearman相关性，在很大程度上优于以前的最佳（表1）。\n\n\n\n> We also achieve competitive performance on the transfer tasks. Additionally, we identify an incoherent evaluation issue in existing work and consolidate results of different evaluation settings for future research.\n\n- 我们在转移任务上也取得了有竞争力的表现。此外，我们在现有工作中发现了一个不连贯的评估问题，并将不同评估设置的结果进行了整合，以备将来研究之用。\n\n\n\n\n------\n\n\n\n","source":"_posts/SimCSE（四）.md","raw":"---\ntitle: SimCSE（四）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 知识图谱\n  - SimCSE\ncategories:\n  - 论文\nabbrlink: 40a6\ndate: 2021-04-28 12:38:25\npassword:\nkeywords:\ndescription:\nsummary: SimCSE Introduction\n---\n\n# Simple Contrastive Learning of Sentence Embeddings（四）\n\n**SimCSE**有两个变体：**Unsupervised SimCSE**和**Supervised SimCSE**，主要不同在于对比学习的正负例的构造。下面详细介绍下他们的构造方式。\n\n----\n\n####  <font color = \"red\">还需学习的知识点</font>\n\n- **in-batch和negatives方法还不懂，需要学习**\n\n- **正例和负例具体指什么数据**\n\n- **自然语言推理（NLI）数据集**\n\n- **句子嵌入是什么意思以及如何实现**\n\n- **有监督和无监督是什么意思**\n\n-----\n\n## 无监督SimCSE\n\n> Learning universal sentence embeddings is a fundamental problem in natural language processing and has been studied extensively in the literature.\n\n- 通用句嵌入的学习是自然语言处理中的一个基本问题，已有文献对此进行了广泛的研究。\n\n> In this work, we advance state-of-the-art sentence embedding methods and demonstrate that a contrastive objective can be extremely effective in learning sentence embeddings, coupled with pre-trained language models such as BERT and RoBERTa. \n\n- 在这项工作中，我们提出了最先进的句子嵌入方法，并证明对比目标在学习句子嵌入时是非常有效的，再加上预先训练的语言模型，如BERT和RoBERTa。\n\n> We present SimCSE, a simple contrastive sentence embedding framework, which can be used to produce superior sentence embeddings, from either unlabeled or labeled data.\n\n- 我们提出了一个简单的对比句子嵌入框架SimCSE，它可以用来从未标记或标记的数据中产生更好的句子嵌入。\n\n\n\n> Our *unsupervised* SimCSE simply predicts the input sentence itself, with only *dropout* (Srivastava et al., 2014) used as noise （Figure 1（a））.\n\n- 我们的无监督SimCSE只是预测输入句子本身，只有*dropout*用作噪声（图1（a））。\n\n<img src=\"Unsupervised SimCSE.png\" alt=\"Unsupervised SimCSE\" style=\"zoom:50%;\" />\n\n> In other words, we pass the same input sentence to the pretrained encoder twice and obtain two embeddings as “positive pairs”, by applying independently sampled dropout masks. \n\n- 换言之，我们将相同的输入语句传递给预训练的编码器两次，并通过应用独立采样的dropout掩码获得两个作为“正对”的嵌入。\n\n- 对于**Unsupervised SimCSE**，核心在于如何生成dropout mask。因为BERT内部每次dropout都随机会生成一个不同的dropout mask。所以SimCSL不需要改变原始BERT，只需要将同一个句子喂给模型两次，得到的两个向量就是应用两次不同dropout mask的结果。然后将两个向量作为正例对。（真的simple）\n\n> Although it may appear strikingly simple, we find that this approach largely outperforms training objectives such as predicting next sentences and common data augmentation techniques, e.g., word deletion and replacement.\n\n- 虽然它看起来非常简单，但是我们发现这种方法在很大程度上优于训练目标，例如预测下一句话和常用的数据增强技术，例如单词删除和替换。\n\n> More surprisingly, this unsupervised embedding method already matches all the previous supervised approaches. \n\n- 更令人惊讶的是，这种无监督的嵌入方法已经匹配了所有以前的监督方法。\n\n> Through careful analysis, we find that dropout essentially acts as minimal data augmentation, while removing it leads to a representation collapse.\n\n- 通过仔细的分析，我们发现退dropout本质上是作为最小的数据扩充，而删除它会导致表示崩溃。\n\n**Unsupervised SimCSE** 引入dropout给输入加噪声，假设加噪后的输入仍与原始输入在语义空间距离相近。其正负例的构造方式如下：\n\n> 正例：给定输入，用预训练语言模型编码两次得到的两个向量和作为正例对。我理解的正例就是大于平均值的数据，负例就是低于平均值的数据\n\n> 负例：使用in-batch negatives的方式，即随机采样一个batch中另一个输入作为的负例。\n\n----\n\n## 有监督SimCSE\n\n**Supervised SimCSE**，利用标注数据来构造对比学习的正负例子。为探究哪种标注数据更有利于句子向量的学习，文中在多种数据集上做了实验，最后发现NLI数据最有利于学习句子表示。下面以NLI数据为例介绍Supervised SimCSE的流程。\n\nSupervised SimCSE 引入了NLI任务来监督对比学习过程。该模型假设如果两个句子存在蕴含关系，那么它们之间的句子向量距离应该较近；如果两个句子存在矛盾关系，那么它们的距离应该较远。因此NLI中的蕴含句对和矛盾句对分别对应对比学习中的正例对和负例对。所以在Supervised SimCSE中，正负例的构造方式如下:\n\n> 正例：NLI中entailment关系样例对。负例：a) in-batch negatives b)NLI中关系为contradiction的样例对。\n\n---\n\n> In our *supervised* SimCSE, we build upon the recent success of leveraging natural language inference （NLI） datasets for sentence embeddings （Conneau et al., 2017; Reimers and Gurevych, 2019） and incorporate supervised sentence pairs in contrastive learning （Figure 1(b)）. \n\n- 在我们的有监督SimCSE中，我们建立在利用自然语言推理（NLI）数据集进行句子嵌入的最新成功基础上，并将有监督句对纳入对比学习（图1（b））。\n\n<img src=\"Supervised SimCSE.png\" alt=\"Supervised SimCSE\" style=\"zoom:50%;\" />\n\n> Unlike previous work that casts it as a 3-way classification task （entailment/neutral/contradiction）, we take advantage of the fact that **entailment** pairs can be naturally used as positive instances.\n\n- 与以前的工作不同的是，我们将它作为一个三向分类任务（蕴涵/中立/矛盾），我们利用了蕴涵对可以自然地用作正实例这一事实。\n\n\n\n> We also find that adding corresponding contradiction pairs as hard negatives further improves performance. \n\n- 我们还发现，添加相应的矛盾对作为硬否定进一步提高了性能。\n\n\n\n> This simple use of NLI datasets achieves a greater performance compared to prior methods using the same datasets. \n\n- 与以前使用相同数据集的方法相比，NLI数据集的这种简单使用实现了更高的性能。\n\n> We also compare to other (annotated) sentence-pair datasets and find that NLI datasets are especially effective for learning sentence embeddings.\n\n- 我们还比较了其他（带注释的）句子对数据集，发现NLI数据集对于学习句子嵌入特别有效。\n\n\n\n\n\n> To better understand the superior performance of SimCSE, we borrow the analysis tool from Wang and Isola (2020), which takes *alignment* between semantically-related positive pairs and *uniformity* of the whole representation space to measure the quality of learned embeddings. \n\n- 为了更好地理解SimCSE的优越性能，我们借用了Wang和Isola（2020）的分析工具，它采用语义相关正对之间的对齐度和整个表示空间的一致度来衡量学习嵌入的质量。\n\n\n\n> We prove that theoretically the contrastive learning objective “flattens” the singular value distribution of the sentence embedding space, hence improving the uniformity. \n\n- 我们从理论上证明了对比学习目标“平坦”了句子嵌入空间的奇异值分布，从而提高了一致性。\n\n\n\n\n\n> We also draw a connection to the recent findings that pre-trained word embeddings suffer from anisotropy (Ethayarajh, 2019; Li et al., 2020).\n\n- 我们还与最近的研究结果相联系，即预先训练的单词嵌入会受到各向异性的影响。\n\n\n\n\n\n> We find that our unsupervised SimCSE essentially improves uniformity while avoiding degenerated alignment via dropout noise, thus greatly improves the expressiveness of the representations. \n\n- 我们发现，我们的无监督SimCSE本质上改善了一致性，同时避免了通过丢失噪声退化对齐，从而大大提高了表示的表达能力。\n\n\n\n> We also demonstrate that the NLI training signal can further improve alignment between positive pairs and hence produce better sentence embeddings.\n\n- 我们还证明，NLI训练信号可以进一步改善正对之间的对齐，从而产生更好的句子嵌入。\n\n\n\n\n\n\n\n第三段\n\n\n\n> We conduct a comprehensive evaluation of SimCSE, along with previous state-of-the-art models on 7 semantic textual similarity (STS) tasks and 7 transfer tasks.\n\n- 我们对SimCSE进行了综合评价，并对7个语义-文本相似度（STS）任务和7个迁移任务进行了分析。\n\n\n\n> On STS tasks, we show that our unsupervised and supervised models achieve a 74.5% and 81.6% averaged Spearman’s correlation respectively using BERTbase , largely outperforming previous best (Table 1). \n\n- 在STS任务中，我们发现我们的无监督和有监督模型使用BERTbase分别达到了74.5%和81.6%的平均Spearman相关性，在很大程度上优于以前的最佳（表1）。\n\n\n\n> We also achieve competitive performance on the transfer tasks. Additionally, we identify an incoherent evaluation issue in existing work and consolidate results of different evaluation settings for future research.\n\n- 我们在转移任务上也取得了有竞争力的表现。此外，我们在现有工作中发现了一个不连贯的评估问题，并将不同评估设置的结果进行了整合，以备将来研究之用。\n\n\n\n\n------\n\n\n\n","slug":"SimCSE（四）","published":1,"updated":"2021-04-28T06:46:13.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5t0029a09kfsp05wa9","content":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（四）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（四）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（四）\"></a>Simple Contrastive Learning of Sentence Embeddings（四）</h1><p><strong>SimCSE</strong>有两个变体：<strong>Unsupervised SimCSE</strong>和<strong>Supervised SimCSE</strong>，主要不同在于对比学习的正负例的构造。下面详细介绍下他们的构造方式。</p>\n<hr>\n<h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color=\"red\">还需学习的知识点</font></h4><ul>\n<li><p><strong>in-batch和negatives方法还不懂，需要学习</strong></p>\n</li>\n<li><p><strong>正例和负例具体指什么数据</strong></p>\n</li>\n<li><p><strong>自然语言推理（NLI）数据集</strong></p>\n</li>\n<li><p><strong>句子嵌入是什么意思以及如何实现</strong></p>\n</li>\n<li><p><strong>有监督和无监督是什么意思</strong></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"无监督SimCSE\"><a href=\"#无监督SimCSE\" class=\"headerlink\" title=\"无监督SimCSE\"></a>无监督SimCSE</h2><blockquote>\n<p>Learning universal sentence embeddings is a fundamental problem in natural language processing and has been studied extensively in the literature.</p>\n</blockquote>\n<ul>\n<li>通用句嵌入的学习是自然语言处理中的一个基本问题，已有文献对此进行了广泛的研究。</li>\n</ul>\n<blockquote>\n<p>In this work, we advance state-of-the-art sentence embedding methods and demonstrate that a contrastive objective can be extremely effective in learning sentence embeddings, coupled with pre-trained language models such as BERT and RoBERTa. </p>\n</blockquote>\n<ul>\n<li>在这项工作中，我们提出了最先进的句子嵌入方法，并证明对比目标在学习句子嵌入时是非常有效的，再加上预先训练的语言模型，如BERT和RoBERTa。</li>\n</ul>\n<blockquote>\n<p>We present SimCSE, a simple contrastive sentence embedding framework, which can be used to produce superior sentence embeddings, from either unlabeled or labeled data.</p>\n</blockquote>\n<ul>\n<li>我们提出了一个简单的对比句子嵌入框架SimCSE，它可以用来从未标记或标记的数据中产生更好的句子嵌入。</li>\n</ul>\n<blockquote>\n<p>Our <em>unsupervised</em> SimCSE simply predicts the input sentence itself, with only <em>dropout</em> (Srivastava et al., 2014) used as noise （Figure 1（a））.</p>\n</blockquote>\n<ul>\n<li>我们的无监督SimCSE只是预测输入句子本身，只有<em>dropout</em>用作噪声（图1（a））。</li>\n</ul>\n<p><img src=\"Unsupervised SimCSE.png\" alt=\"Unsupervised SimCSE\" style=\"zoom:50%;\"></p>\n<blockquote>\n<p>In other words, we pass the same input sentence to the pretrained encoder twice and obtain two embeddings as “positive pairs”, by applying independently sampled dropout masks. </p>\n</blockquote>\n<ul>\n<li><p>换言之，我们将相同的输入语句传递给预训练的编码器两次，并通过应用独立采样的dropout掩码获得两个作为“正对”的嵌入。</p>\n</li>\n<li><p>对于<strong>Unsupervised SimCSE</strong>，核心在于如何生成dropout mask。因为BERT内部每次dropout都随机会生成一个不同的dropout mask。所以SimCSL不需要改变原始BERT，只需要将同一个句子喂给模型两次，得到的两个向量就是应用两次不同dropout mask的结果。然后将两个向量作为正例对。（真的simple）</p>\n</li>\n</ul>\n<blockquote>\n<p>Although it may appear strikingly simple, we find that this approach largely outperforms training objectives such as predicting next sentences and common data augmentation techniques, e.g., word deletion and replacement.</p>\n</blockquote>\n<ul>\n<li>虽然它看起来非常简单，但是我们发现这种方法在很大程度上优于训练目标，例如预测下一句话和常用的数据增强技术，例如单词删除和替换。</li>\n</ul>\n<blockquote>\n<p>More surprisingly, this unsupervised embedding method already matches all the previous supervised approaches. </p>\n</blockquote>\n<ul>\n<li>更令人惊讶的是，这种无监督的嵌入方法已经匹配了所有以前的监督方法。</li>\n</ul>\n<blockquote>\n<p>Through careful analysis, we find that dropout essentially acts as minimal data augmentation, while removing it leads to a representation collapse.</p>\n</blockquote>\n<ul>\n<li>通过仔细的分析，我们发现退dropout本质上是作为最小的数据扩充，而删除它会导致表示崩溃。</li>\n</ul>\n<p><strong>Unsupervised SimCSE</strong> 引入dropout给输入加噪声，假设加噪后的输入仍与原始输入在语义空间距离相近。其正负例的构造方式如下：</p>\n<blockquote>\n<p>正例：给定输入，用预训练语言模型编码两次得到的两个向量和作为正例对。我理解的正例就是大于平均值的数据，负例就是低于平均值的数据</p>\n<p>负例：使用in-batch negatives的方式，即随机采样一个batch中另一个输入作为的负例。</p>\n</blockquote>\n<hr>\n<h2 id=\"有监督SimCSE\"><a href=\"#有监督SimCSE\" class=\"headerlink\" title=\"有监督SimCSE\"></a>有监督SimCSE</h2><p><strong>Supervised SimCSE</strong>，利用标注数据来构造对比学习的正负例子。为探究哪种标注数据更有利于句子向量的学习，文中在多种数据集上做了实验，最后发现NLI数据最有利于学习句子表示。下面以NLI数据为例介绍Supervised SimCSE的流程。</p>\n<p>Supervised SimCSE 引入了NLI任务来监督对比学习过程。该模型假设如果两个句子存在蕴含关系，那么它们之间的句子向量距离应该较近；如果两个句子存在矛盾关系，那么它们的距离应该较远。因此NLI中的蕴含句对和矛盾句对分别对应对比学习中的正例对和负例对。所以在Supervised SimCSE中，正负例的构造方式如下:</p>\n<blockquote>\n<p>正例：NLI中entailment关系样例对。负例：a) in-batch negatives b)NLI中关系为contradiction的样例对。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>In our <em>supervised</em> SimCSE, we build upon the recent success of leveraging natural language inference （NLI） datasets for sentence embeddings （Conneau et al., 2017; Reimers and Gurevych, 2019） and incorporate supervised sentence pairs in contrastive learning （Figure 1(b)）. </p>\n</blockquote>\n<ul>\n<li>在我们的有监督SimCSE中，我们建立在利用自然语言推理（NLI）数据集进行句子嵌入的最新成功基础上，并将有监督句对纳入对比学习（图1（b））。</li>\n</ul>\n<p><img src=\"Supervised SimCSE.png\" alt=\"Supervised SimCSE\" style=\"zoom:50%;\"></p>\n<blockquote>\n<p>Unlike previous work that casts it as a 3-way classification task （entailment/neutral/contradiction）, we take advantage of the fact that <strong>entailment</strong> pairs can be naturally used as positive instances.</p>\n</blockquote>\n<ul>\n<li>与以前的工作不同的是，我们将它作为一个三向分类任务（蕴涵/中立/矛盾），我们利用了蕴涵对可以自然地用作正实例这一事实。</li>\n</ul>\n<blockquote>\n<p>We also find that adding corresponding contradiction pairs as hard negatives further improves performance. </p>\n</blockquote>\n<ul>\n<li>我们还发现，添加相应的矛盾对作为硬否定进一步提高了性能。</li>\n</ul>\n<blockquote>\n<p>This simple use of NLI datasets achieves a greater performance compared to prior methods using the same datasets. </p>\n</blockquote>\n<ul>\n<li>与以前使用相同数据集的方法相比，NLI数据集的这种简单使用实现了更高的性能。</li>\n</ul>\n<blockquote>\n<p>We also compare to other (annotated) sentence-pair datasets and find that NLI datasets are especially effective for learning sentence embeddings.</p>\n</blockquote>\n<ul>\n<li>我们还比较了其他（带注释的）句子对数据集，发现NLI数据集对于学习句子嵌入特别有效。</li>\n</ul>\n<blockquote>\n<p>To better understand the superior performance of SimCSE, we borrow the analysis tool from Wang and Isola (2020), which takes <em>alignment</em> between semantically-related positive pairs and <em>uniformity</em> of the whole representation space to measure the quality of learned embeddings. </p>\n</blockquote>\n<ul>\n<li>为了更好地理解SimCSE的优越性能，我们借用了Wang和Isola（2020）的分析工具，它采用语义相关正对之间的对齐度和整个表示空间的一致度来衡量学习嵌入的质量。</li>\n</ul>\n<blockquote>\n<p>We prove that theoretically the contrastive learning objective “flattens” the singular value distribution of the sentence embedding space, hence improving the uniformity. </p>\n</blockquote>\n<ul>\n<li>我们从理论上证明了对比学习目标“平坦”了句子嵌入空间的奇异值分布，从而提高了一致性。</li>\n</ul>\n<blockquote>\n<p>We also draw a connection to the recent findings that pre-trained word embeddings suffer from anisotropy (Ethayarajh, 2019; Li et al., 2020).</p>\n</blockquote>\n<ul>\n<li>我们还与最近的研究结果相联系，即预先训练的单词嵌入会受到各向异性的影响。</li>\n</ul>\n<blockquote>\n<p>We find that our unsupervised SimCSE essentially improves uniformity while avoiding degenerated alignment via dropout noise, thus greatly improves the expressiveness of the representations. </p>\n</blockquote>\n<ul>\n<li>我们发现，我们的无监督SimCSE本质上改善了一致性，同时避免了通过丢失噪声退化对齐，从而大大提高了表示的表达能力。</li>\n</ul>\n<blockquote>\n<p>We also demonstrate that the NLI training signal can further improve alignment between positive pairs and hence produce better sentence embeddings.</p>\n</blockquote>\n<ul>\n<li>我们还证明，NLI训练信号可以进一步改善正对之间的对齐，从而产生更好的句子嵌入。</li>\n</ul>\n<p>第三段</p>\n<blockquote>\n<p>We conduct a comprehensive evaluation of SimCSE, along with previous state-of-the-art models on 7 semantic textual similarity (STS) tasks and 7 transfer tasks.</p>\n</blockquote>\n<ul>\n<li>我们对SimCSE进行了综合评价，并对7个语义-文本相似度（STS）任务和7个迁移任务进行了分析。</li>\n</ul>\n<blockquote>\n<p>On STS tasks, we show that our unsupervised and supervised models achieve a 74.5% and 81.6% averaged Spearman’s correlation respectively using BERTbase , largely outperforming previous best (Table 1). </p>\n</blockquote>\n<ul>\n<li>在STS任务中，我们发现我们的无监督和有监督模型使用BERTbase分别达到了74.5%和81.6%的平均Spearman相关性，在很大程度上优于以前的最佳（表1）。</li>\n</ul>\n<blockquote>\n<p>We also achieve competitive performance on the transfer tasks. Additionally, we identify an incoherent evaluation issue in existing work and consolidate results of different evaluation settings for future research.</p>\n</blockquote>\n<ul>\n<li>我们在转移任务上也取得了有竞争力的表现。此外，我们在现有工作中发现了一个不连贯的评估问题，并将不同评估设置的结果进行了整合，以备将来研究之用。</li>\n</ul>\n<hr>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Simple-Contrastive-Learning-of-Sentence-Embeddings（四）\"><a href=\"#Simple-Contrastive-Learning-of-Sentence-Embeddings（四）\" class=\"headerlink\" title=\"Simple Contrastive Learning of Sentence Embeddings（四）\"></a>Simple Contrastive Learning of Sentence Embeddings（四）</h1><p><strong>SimCSE</strong>有两个变体：<strong>Unsupervised SimCSE</strong>和<strong>Supervised SimCSE</strong>，主要不同在于对比学习的正负例的构造。下面详细介绍下他们的构造方式。</p>\n<hr>\n<h4 id=\"还需学习的知识点\"><a href=\"#还需学习的知识点\" class=\"headerlink\" title=\"还需学习的知识点\"></a><font color = \"red\">还需学习的知识点</font></h4><ul>\n<li><p><strong>in-batch和negatives方法还不懂，需要学习</strong></p>\n</li>\n<li><p><strong>正例和负例具体指什么数据</strong></p>\n</li>\n<li><p><strong>自然语言推理（NLI）数据集</strong></p>\n</li>\n<li><p><strong>句子嵌入是什么意思以及如何实现</strong></p>\n</li>\n<li><p><strong>有监督和无监督是什么意思</strong></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"无监督SimCSE\"><a href=\"#无监督SimCSE\" class=\"headerlink\" title=\"无监督SimCSE\"></a>无监督SimCSE</h2><blockquote>\n<p>Learning universal sentence embeddings is a fundamental problem in natural language processing and has been studied extensively in the literature.</p>\n</blockquote>\n<ul>\n<li>通用句嵌入的学习是自然语言处理中的一个基本问题，已有文献对此进行了广泛的研究。</li>\n</ul>\n<blockquote>\n<p>In this work, we advance state-of-the-art sentence embedding methods and demonstrate that a contrastive objective can be extremely effective in learning sentence embeddings, coupled with pre-trained language models such as BERT and RoBERTa. </p>\n</blockquote>\n<ul>\n<li>在这项工作中，我们提出了最先进的句子嵌入方法，并证明对比目标在学习句子嵌入时是非常有效的，再加上预先训练的语言模型，如BERT和RoBERTa。</li>\n</ul>\n<blockquote>\n<p>We present SimCSE, a simple contrastive sentence embedding framework, which can be used to produce superior sentence embeddings, from either unlabeled or labeled data.</p>\n</blockquote>\n<ul>\n<li>我们提出了一个简单的对比句子嵌入框架SimCSE，它可以用来从未标记或标记的数据中产生更好的句子嵌入。</li>\n</ul>\n<blockquote>\n<p>Our <em>unsupervised</em> SimCSE simply predicts the input sentence itself, with only <em>dropout</em> (Srivastava et al., 2014) used as noise （Figure 1（a））.</p>\n</blockquote>\n<ul>\n<li>我们的无监督SimCSE只是预测输入句子本身，只有<em>dropout</em>用作噪声（图1（a））。</li>\n</ul>\n<p><img src=\"Unsupervised SimCSE.png\" alt=\"Unsupervised SimCSE\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>In other words, we pass the same input sentence to the pretrained encoder twice and obtain two embeddings as “positive pairs”, by applying independently sampled dropout masks. </p>\n</blockquote>\n<ul>\n<li><p>换言之，我们将相同的输入语句传递给预训练的编码器两次，并通过应用独立采样的dropout掩码获得两个作为“正对”的嵌入。</p>\n</li>\n<li><p>对于<strong>Unsupervised SimCSE</strong>，核心在于如何生成dropout mask。因为BERT内部每次dropout都随机会生成一个不同的dropout mask。所以SimCSL不需要改变原始BERT，只需要将同一个句子喂给模型两次，得到的两个向量就是应用两次不同dropout mask的结果。然后将两个向量作为正例对。（真的simple）</p>\n</li>\n</ul>\n<blockquote>\n<p>Although it may appear strikingly simple, we find that this approach largely outperforms training objectives such as predicting next sentences and common data augmentation techniques, e.g., word deletion and replacement.</p>\n</blockquote>\n<ul>\n<li>虽然它看起来非常简单，但是我们发现这种方法在很大程度上优于训练目标，例如预测下一句话和常用的数据增强技术，例如单词删除和替换。</li>\n</ul>\n<blockquote>\n<p>More surprisingly, this unsupervised embedding method already matches all the previous supervised approaches. </p>\n</blockquote>\n<ul>\n<li>更令人惊讶的是，这种无监督的嵌入方法已经匹配了所有以前的监督方法。</li>\n</ul>\n<blockquote>\n<p>Through careful analysis, we find that dropout essentially acts as minimal data augmentation, while removing it leads to a representation collapse.</p>\n</blockquote>\n<ul>\n<li>通过仔细的分析，我们发现退dropout本质上是作为最小的数据扩充，而删除它会导致表示崩溃。</li>\n</ul>\n<p><strong>Unsupervised SimCSE</strong> 引入dropout给输入加噪声，假设加噪后的输入仍与原始输入在语义空间距离相近。其正负例的构造方式如下：</p>\n<blockquote>\n<p>正例：给定输入，用预训练语言模型编码两次得到的两个向量和作为正例对。我理解的正例就是大于平均值的数据，负例就是低于平均值的数据</p>\n<p>负例：使用in-batch negatives的方式，即随机采样一个batch中另一个输入作为的负例。</p>\n</blockquote>\n<hr>\n<h2 id=\"有监督SimCSE\"><a href=\"#有监督SimCSE\" class=\"headerlink\" title=\"有监督SimCSE\"></a>有监督SimCSE</h2><p><strong>Supervised SimCSE</strong>，利用标注数据来构造对比学习的正负例子。为探究哪种标注数据更有利于句子向量的学习，文中在多种数据集上做了实验，最后发现NLI数据最有利于学习句子表示。下面以NLI数据为例介绍Supervised SimCSE的流程。</p>\n<p>Supervised SimCSE 引入了NLI任务来监督对比学习过程。该模型假设如果两个句子存在蕴含关系，那么它们之间的句子向量距离应该较近；如果两个句子存在矛盾关系，那么它们的距离应该较远。因此NLI中的蕴含句对和矛盾句对分别对应对比学习中的正例对和负例对。所以在Supervised SimCSE中，正负例的构造方式如下:</p>\n<blockquote>\n<p>正例：NLI中entailment关系样例对。负例：a) in-batch negatives b)NLI中关系为contradiction的样例对。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>In our <em>supervised</em> SimCSE, we build upon the recent success of leveraging natural language inference （NLI） datasets for sentence embeddings （Conneau et al., 2017; Reimers and Gurevych, 2019） and incorporate supervised sentence pairs in contrastive learning （Figure 1(b)）. </p>\n</blockquote>\n<ul>\n<li>在我们的有监督SimCSE中，我们建立在利用自然语言推理（NLI）数据集进行句子嵌入的最新成功基础上，并将有监督句对纳入对比学习（图1（b））。</li>\n</ul>\n<p><img src=\"Supervised SimCSE.png\" alt=\"Supervised SimCSE\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>Unlike previous work that casts it as a 3-way classification task （entailment/neutral/contradiction）, we take advantage of the fact that <strong>entailment</strong> pairs can be naturally used as positive instances.</p>\n</blockquote>\n<ul>\n<li>与以前的工作不同的是，我们将它作为一个三向分类任务（蕴涵/中立/矛盾），我们利用了蕴涵对可以自然地用作正实例这一事实。</li>\n</ul>\n<blockquote>\n<p>We also find that adding corresponding contradiction pairs as hard negatives further improves performance. </p>\n</blockquote>\n<ul>\n<li>我们还发现，添加相应的矛盾对作为硬否定进一步提高了性能。</li>\n</ul>\n<blockquote>\n<p>This simple use of NLI datasets achieves a greater performance compared to prior methods using the same datasets. </p>\n</blockquote>\n<ul>\n<li>与以前使用相同数据集的方法相比，NLI数据集的这种简单使用实现了更高的性能。</li>\n</ul>\n<blockquote>\n<p>We also compare to other (annotated) sentence-pair datasets and find that NLI datasets are especially effective for learning sentence embeddings.</p>\n</blockquote>\n<ul>\n<li>我们还比较了其他（带注释的）句子对数据集，发现NLI数据集对于学习句子嵌入特别有效。</li>\n</ul>\n<blockquote>\n<p>To better understand the superior performance of SimCSE, we borrow the analysis tool from Wang and Isola (2020), which takes <em>alignment</em> between semantically-related positive pairs and <em>uniformity</em> of the whole representation space to measure the quality of learned embeddings. </p>\n</blockquote>\n<ul>\n<li>为了更好地理解SimCSE的优越性能，我们借用了Wang和Isola（2020）的分析工具，它采用语义相关正对之间的对齐度和整个表示空间的一致度来衡量学习嵌入的质量。</li>\n</ul>\n<blockquote>\n<p>We prove that theoretically the contrastive learning objective “flattens” the singular value distribution of the sentence embedding space, hence improving the uniformity. </p>\n</blockquote>\n<ul>\n<li>我们从理论上证明了对比学习目标“平坦”了句子嵌入空间的奇异值分布，从而提高了一致性。</li>\n</ul>\n<blockquote>\n<p>We also draw a connection to the recent findings that pre-trained word embeddings suffer from anisotropy (Ethayarajh, 2019; Li et al., 2020).</p>\n</blockquote>\n<ul>\n<li>我们还与最近的研究结果相联系，即预先训练的单词嵌入会受到各向异性的影响。</li>\n</ul>\n<blockquote>\n<p>We find that our unsupervised SimCSE essentially improves uniformity while avoiding degenerated alignment via dropout noise, thus greatly improves the expressiveness of the representations. </p>\n</blockquote>\n<ul>\n<li>我们发现，我们的无监督SimCSE本质上改善了一致性，同时避免了通过丢失噪声退化对齐，从而大大提高了表示的表达能力。</li>\n</ul>\n<blockquote>\n<p>We also demonstrate that the NLI training signal can further improve alignment between positive pairs and hence produce better sentence embeddings.</p>\n</blockquote>\n<ul>\n<li>我们还证明，NLI训练信号可以进一步改善正对之间的对齐，从而产生更好的句子嵌入。</li>\n</ul>\n<p>第三段</p>\n<blockquote>\n<p>We conduct a comprehensive evaluation of SimCSE, along with previous state-of-the-art models on 7 semantic textual similarity (STS) tasks and 7 transfer tasks.</p>\n</blockquote>\n<ul>\n<li>我们对SimCSE进行了综合评价，并对7个语义-文本相似度（STS）任务和7个迁移任务进行了分析。</li>\n</ul>\n<blockquote>\n<p>On STS tasks, we show that our unsupervised and supervised models achieve a 74.5% and 81.6% averaged Spearman’s correlation respectively using BERTbase , largely outperforming previous best (Table 1). </p>\n</blockquote>\n<ul>\n<li>在STS任务中，我们发现我们的无监督和有监督模型使用BERTbase分别达到了74.5%和81.6%的平均Spearman相关性，在很大程度上优于以前的最佳（表1）。</li>\n</ul>\n<blockquote>\n<p>We also achieve competitive performance on the transfer tasks. Additionally, we identify an incoherent evaluation issue in existing work and consolidate results of different evaluation settings for future research.</p>\n</blockquote>\n<ul>\n<li>我们在转移任务上也取得了有竞争力的表现。此外，我们在现有工作中发现了一个不连贯的评估问题，并将不同评估设置的结果进行了整合，以备将来研究之用。</li>\n</ul>\n<hr>\n"},{"title":"8月份学习计划","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"学习计划","abbrlink":"b074","date":"2020-08-10T10:17:59.000Z","password":null,"_content":"<center> <h2>8月份学习计划<h2></center>\n\n| <center>8月份</center> | <center>数学</center>                                        | <center>专业课</center>                                      | <center>英语</center>                                | <center>政治</center>                         | <center>完成度</center>          |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- | --------------------------------------------- | -------------------------------- |\n| 8.1                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.2                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.3                    | 1.看线代第3章讲解 <br>2.闭关修炼第一章                       | 1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈 | 1.做真题2015.4并看李旭相应视频 <br>２.背所学课程单词 | 1.社会形态 <br>2.做1000剩余第二章单选         | <center>:sun_with_face:</center> |\n| 8.4                    | 1.看线代第4章讲解 <br>2.闭关修炼第二章 <br>3.18讲第三讲      | 1.2012年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈 | 1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词 | 社会的基本矛盾                                | <center>:frowning:</center>      |\n| 8.5                    | 玩耍                                                         | 玩耍                                                         | 玩耍                                                 | 玩耍                                          | <center>:relaxed:</center>       |\n| 8.6                    | 1.看线代第五章前三课讲解 <br>2.闭关修炼第三章                | 1.2011年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈 | 1.做真题2012.4并看李旭相应视频 <br>２.背所学课程单词 | 1.社会的基本矛盾 <br>2.1000第二章单选对答案   | <center>:sun_with_face:</center> |\n| 8.7                    | 1.看线代第五章后两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲 | 1.2010年软专数据结构基础题 <br>2.整理计网基础第六章blog <br>3.冲刺讲义数据结构看4.6 <br>4.每日一题 栈 | 1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词 | 1.社会形态-1 <br>2.1000第二章单选对答案       | <center>:sun_with_face:</center> |\n| 8.8                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.9                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.10                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.11                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.12                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.13                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.14                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.15                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.16                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.17                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.18                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.19                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.20                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.21                   | 1.线代第六章前两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲 | 1.整理计网基础第七章blog <br>2.算法讲义1页blog整理理解       | 1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词 | 1.社会形态-1                                  | <center>:sun_with_face:</center> |\n| 8.22                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.23                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.24                   | 1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲 | 1.整理计网基础第八章blog <br>2.算法讲义1、2、3页blog整理理解 | 1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词 | 1.马原第五章 <br>2.1000第二章单选对答案       | <center>:frowning:</center>      |\n| 8.25                   | 1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲 | 1.整理计网基础第八章blog剩余部分 <br>2.算法讲义顺序表blog整理 | 1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词 | 1.马原第四章 <br>2.1000第二章单选对答案       | <center>:sun_with_face:</center> |\n| 8.26                   | 1.线代第七章一二课讲解 <br>2.18讲第六讲34课 <br>3.闭关修炼第六章 | 1.整理计网强化部分 <br>2.算法讲义链表blog整理理解            | 1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词 | 1.马原商品的二因素 <br>2.1000第二章单选对答案 | <center>:frowning:</center>      |\n| 8.27                   | 1.线代第七章C组讲解 <br>2.18讲第7讲12课 <br>3.闭关修炼第七章 | 1.整理计网强化部分 <br>2.算法讲义链表剩余blog整理理解        | 1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词 | 1.马原商品的二因素 <br>2.1000第二章单选对答案 |                                  |\n| 8.28                   |                                                              |                                                              |                                                      |                                               |                                  |\n| 8.29                   |                                                              |                                                              |                                                      |                                               |                                  |\n| 8.30                   |                                                              |                                                              |                                                      |                                               |                                  |","source":"_posts/八月份学习计划.md","raw":"---\ntitle: 8月份学习计划\ntop: false\ncover: false\ntoc: false\nmathjax: true\nsummary: 学习计划\ntags:\n  - 考研\n  - 计划\ncategories:\n  - 男男\nabbrlink: b074\ndate: 2020-08-10 18:17:59\npassword:\n---\n<center> <h2>8月份学习计划<h2></center>\n\n| <center>8月份</center> | <center>数学</center>                                        | <center>专业课</center>                                      | <center>英语</center>                                | <center>政治</center>                         | <center>完成度</center>          |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- | --------------------------------------------- | -------------------------------- |\n| 8.1                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.2                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.3                    | 1.看线代第3章讲解 <br>2.闭关修炼第一章                       | 1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈 | 1.做真题2015.4并看李旭相应视频 <br>２.背所学课程单词 | 1.社会形态 <br>2.做1000剩余第二章单选         | <center>:sun_with_face:</center> |\n| 8.4                    | 1.看线代第4章讲解 <br>2.闭关修炼第二章 <br>3.18讲第三讲      | 1.2012年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈 | 1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词 | 社会的基本矛盾                                | <center>:frowning:</center>      |\n| 8.5                    | 玩耍                                                         | 玩耍                                                         | 玩耍                                                 | 玩耍                                          | <center>:relaxed:</center>       |\n| 8.6                    | 1.看线代第五章前三课讲解 <br>2.闭关修炼第三章                | 1.2011年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈 | 1.做真题2012.4并看李旭相应视频 <br>２.背所学课程单词 | 1.社会的基本矛盾 <br>2.1000第二章单选对答案   | <center>:sun_with_face:</center> |\n| 8.7                    | 1.看线代第五章后两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲 | 1.2010年软专数据结构基础题 <br>2.整理计网基础第六章blog <br>3.冲刺讲义数据结构看4.6 <br>4.每日一题 栈 | 1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词 | 1.社会形态-1 <br>2.1000第二章单选对答案       | <center>:sun_with_face:</center> |\n| 8.8                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.9                    | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.10                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.11                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.12                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.13                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.14                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.15                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.16                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.17                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.18                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.19                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.20                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.21                   | 1.线代第六章前两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲 | 1.整理计网基础第七章blog <br>2.算法讲义1页blog整理理解       | 1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词 | 1.社会形态-1                                  | <center>:sun_with_face:</center> |\n| 8.22                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.23                   | 休息一天                                                     | 休息一天                                                     | 休息一天                                             | 休息一天                                      | <center>:relaxed:</center>       |\n| 8.24                   | 1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲 | 1.整理计网基础第八章blog <br>2.算法讲义1、2、3页blog整理理解 | 1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词 | 1.马原第五章 <br>2.1000第二章单选对答案       | <center>:frowning:</center>      |\n| 8.25                   | 1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲 | 1.整理计网基础第八章blog剩余部分 <br>2.算法讲义顺序表blog整理 | 1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词 | 1.马原第四章 <br>2.1000第二章单选对答案       | <center>:sun_with_face:</center> |\n| 8.26                   | 1.线代第七章一二课讲解 <br>2.18讲第六讲34课 <br>3.闭关修炼第六章 | 1.整理计网强化部分 <br>2.算法讲义链表blog整理理解            | 1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词 | 1.马原商品的二因素 <br>2.1000第二章单选对答案 | <center>:frowning:</center>      |\n| 8.27                   | 1.线代第七章C组讲解 <br>2.18讲第7讲12课 <br>3.闭关修炼第七章 | 1.整理计网强化部分 <br>2.算法讲义链表剩余blog整理理解        | 1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词 | 1.马原商品的二因素 <br>2.1000第二章单选对答案 |                                  |\n| 8.28                   |                                                              |                                                              |                                                      |                                               |                                  |\n| 8.29                   |                                                              |                                                              |                                                      |                                               |                                  |\n| 8.30                   |                                                              |                                                              |                                                      |                                               |                                  |","slug":"八月份学习计划","published":1,"updated":"2020-09-19T13:35:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5u002da09k8v1z5g0y","content":"<center> <h2>8月份学习计划</h2><h2></h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>8月份</center></th>\n<th><center>数学</center></th>\n<th><center>专业课</center></th>\n<th><center>英语</center></th>\n<th><center>政治</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>8.1</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.2</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.3</td>\n<td>1.看线代第3章讲解 <br>2.闭关修炼第一章</td>\n<td>1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td>\n<td>1.做真题2015.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态 <br>2.做1000剩余第二章单选</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>8.4</td>\n<td>1.看线代第4章讲解 <br>2.闭关修炼第二章 <br>3.18讲第三讲</td>\n<td>1.2012年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈</td>\n<td>1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>社会的基本矛盾</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span></center></td>\n</tr>\n<tr>\n<td>8.5</td>\n<td>玩耍</td>\n<td>玩耍</td>\n<td>玩耍</td>\n<td>玩耍</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.6</td>\n<td>1.看线代第五章前三课讲解 <br>2.闭关修炼第三章</td>\n<td>1.2011年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈</td>\n<td>1.做真题2012.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会的基本矛盾 <br>2.1000第二章单选对答案</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>8.7</td>\n<td>1.看线代第五章后两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲</td>\n<td>1.2010年软专数据结构基础题 <br>2.整理计网基础第六章blog <br>3.冲刺讲义数据结构看4.6 <br>4.每日一题 栈</td>\n<td>1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态-1 <br>2.1000第二章单选对答案</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>8.8</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.9</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.10</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.11</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.12</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.13</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.14</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.15</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.16</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.17</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.18</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.19</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.20</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.21</td>\n<td>1.线代第六章前两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲</td>\n<td>1.整理计网基础第七章blog <br>2.算法讲义1页blog整理理解</td>\n<td>1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态-1</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>8.22</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.23</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8\">☺</span></center></td>\n</tr>\n<tr>\n<td>8.24</td>\n<td>1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲</td>\n<td>1.整理计网基础第八章blog <br>2.算法讲义1、2、3页blog整理理解</td>\n<td>1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原第五章 <br>2.1000第二章单选对答案</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span></center></td>\n</tr>\n<tr>\n<td>8.25</td>\n<td>1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲</td>\n<td>1.整理计网基础第八章blog剩余部分 <br>2.算法讲义顺序表blog整理</td>\n<td>1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原第四章 <br>2.1000第二章单选对答案</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8\">🌞</span></center></td>\n</tr>\n<tr>\n<td>8.26</td>\n<td>1.线代第七章一二课讲解 <br>2.18讲第六讲34课 <br>3.闭关修炼第六章</td>\n<td>1.整理计网强化部分 <br>2.算法讲义链表blog整理理解</td>\n<td>1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原商品的二因素 <br>2.1000第二章单选对答案</td>\n<td><center><span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8\">😦</span></center></td>\n</tr>\n<tr>\n<td>8.27</td>\n<td>1.线代第七章C组讲解 <br>2.18讲第7讲12课 <br>3.闭关修炼第七章</td>\n<td>1.整理计网强化部分 <br>2.算法讲义链表剩余blog整理理解</td>\n<td>1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原商品的二因素 <br>2.1000第二章单选对答案</td>\n<td></td>\n</tr>\n<tr>\n<td>8.28</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8.29</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8.30</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<center> <h2>8月份学习计划<h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><center>8月份</center></th>\n<th><center>数学</center></th>\n<th><center>专业课</center></th>\n<th><center>英语</center></th>\n<th><center>政治</center></th>\n<th><center>完成度</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>8.1</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.2</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.3</td>\n<td>1.看线代第3章讲解 <br>2.闭关修炼第一章</td>\n<td>1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td>\n<td>1.做真题2015.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态 <br>2.做1000剩余第二章单选</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>8.4</td>\n<td>1.看线代第4章讲解 <br>2.闭关修炼第二章 <br>3.18讲第三讲</td>\n<td>1.2012年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈</td>\n<td>1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>社会的基本矛盾</td>\n<td><center>:frowning:</center></td>\n</tr>\n<tr>\n<td>8.5</td>\n<td>玩耍</td>\n<td>玩耍</td>\n<td>玩耍</td>\n<td>玩耍</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.6</td>\n<td>1.看线代第五章前三课讲解 <br>2.闭关修炼第三章</td>\n<td>1.2011年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈</td>\n<td>1.做真题2012.4并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会的基本矛盾 <br>2.1000第二章单选对答案</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>8.7</td>\n<td>1.看线代第五章后两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲</td>\n<td>1.2010年软专数据结构基础题 <br>2.整理计网基础第六章blog <br>3.冲刺讲义数据结构看4.6 <br>4.每日一题 栈</td>\n<td>1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态-1 <br>2.1000第二章单选对答案</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>8.8</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.9</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.10</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.11</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.12</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.13</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.14</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.15</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.16</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.17</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.18</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.19</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.20</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.21</td>\n<td>1.线代第六章前两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲</td>\n<td>1.整理计网基础第七章blog <br>2.算法讲义1页blog整理理解</td>\n<td>1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.社会形态-1</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>8.22</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.23</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><center>:relaxed:</center></td>\n</tr>\n<tr>\n<td>8.24</td>\n<td>1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲</td>\n<td>1.整理计网基础第八章blog <br>2.算法讲义1、2、3页blog整理理解</td>\n<td>1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原第五章 <br>2.1000第二章单选对答案</td>\n<td><center>:frowning:</center></td>\n</tr>\n<tr>\n<td>8.25</td>\n<td>1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲</td>\n<td>1.整理计网基础第八章blog剩余部分 <br>2.算法讲义顺序表blog整理</td>\n<td>1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原第四章 <br>2.1000第二章单选对答案</td>\n<td><center>:sun_with_face:</center></td>\n</tr>\n<tr>\n<td>8.26</td>\n<td>1.线代第七章一二课讲解 <br>2.18讲第六讲34课 <br>3.闭关修炼第六章</td>\n<td>1.整理计网强化部分 <br>2.算法讲义链表blog整理理解</td>\n<td>1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原商品的二因素 <br>2.1000第二章单选对答案</td>\n<td><center>:frowning:</center></td>\n</tr>\n<tr>\n<td>8.27</td>\n<td>1.线代第七章C组讲解 <br>2.18讲第7讲12课 <br>3.闭关修炼第七章</td>\n<td>1.整理计网强化部分 <br>2.算法讲义链表剩余blog整理理解</td>\n<td>1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词</td>\n<td>1.马原商品的二因素 <br>2.1000第二章单选对答案</td>\n<td></td>\n</tr>\n<tr>\n<td>8.28</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8.29</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8.30</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"tensorflow（一）","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"tensorflow模型建立训练及预测","abbrlink":"bd21","date":"2021-05-07T11:12:57.000Z","password":null,"keywords":null,"description":null,"_content":"# tensorflow入门（一）\n\n数据集和py文件 [训练模型及使用.py](https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.py) ， [Sarcasm_Headlines_Dataset.json](https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/Sarcasm_Headlines_Dataset.json)  ，[sarcasm.json](https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/sarcasm.json) \n\n----\n\n1. 初始定义参数\n\n   ```python\n   # 分词保留的最大单词数\n   vocab_size = 10000\n   # 每个词创建的向量维度\n   embedding_dim = 16\n   # 数据最大长度\n   max_length = 100\n   # 数据长度大于所设定句子长度maxlen，可加入截断参数，truncating='post'，\n   trunc_type = 'post'\n   # 在句子后边补齐\n   padding_type = 'post'\n   # oov_token属性，将语料库中没有的单词标记出来\n   oov_tok = \"<OOV>\"\n   # 两万训练数据\n   training_size = 20000\n   ```\n\n\n2. 从本地读取json文件\n\n- json.load()和json.loads()都实现了反序列化，变量内容从序列化的对象重新读到内存里称之为反序列化，反序列化是流转换为对象。也就是由json（双引号）转变为dict（键值对用单引号包起来的就是dict）字典可供python操作。\n\n  - load：针对文件句柄，将json格式的字符转换为dict，从文件中读取（将string转换为dict）\n\n    `a_json = json.load(open('demo.json','r'))`\n\n  - loads：针对内存对象，将string转化为dict\n\n    `a = json.loads('{'a':'1111','b':'2222'}')`\n\n- json.dump()和json.dumps()都实现了序列化，变量从内存中变成可存储或传输的过程称之为序列化，序列化是将对象状态转化为可保存或可传输格式的过程。\n\n  - dump：将dict类型转化为json字符串格式，写入到文件**（易存储）**\n\n  ```python\n  a_dict = {'a':'1111','b':'2222'}\n  json.dump(a_dict, open('demo.json', 'w'))\n  ```\n\n  - dumps：将dict转化为string**（易传输）**\n\n  ```python\n  a_dict = {'a':'1111','b':'2222'}\n  a_str = json.dumps(a_dict)\n  ```\n\n  \n\n- 方法一：适用于少量数据规整，标准json格式\n\n  ```python\n  with open(\"data/sarcasm.json\", 'r') as f:\n    \t# json.load将json转化为python可操作的dict字典\n  \t\tdatastore = json.load(f)\n        \n  # 定义空数组      \n  sentences = []\n  labels = []\n  urls = []\n  # json数据样式\n  # {\"article_link\": \"https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5\", \"headline\": \"former versace store clerk sues over secret 'black code' for minority shoppers\", \"is_sarcastic\": 0},\n  # 循环将数据插入格式化\n  for item in datastore:\n    \t#append，字符串插入操作\n    \tsentences.append(item['headline'])\n    \tlabels.append(item['is_sarcastic'])\n  \t\turls.append(item['article_link'])\n  ```\n\n- 方法二：适用于大量冗余数据\n\n  ```python\n  # 先定义打开文件操作，这个文件不标准，不是标准json，中间没有逗号\n  file = open(\"data/Sarcasm_Headlines_Dataset.json\", 'r')\n  \n  # 定义空数组      \n  sentences = []\n  labels = []\n  urls = []\n  \n  # json数据样式\n  # {\"article_link\": \"https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5\", \"headline\": \"former versace store clerk sues over secret 'black code' for minority shoppers\", \"is_sarcastic\": 0},\n  \n  # 调用readlines()方法逐行扫描json并插入数组，规范化数据\n  for line in file.readlines():\n    \t# 将每次扫描到的那一行转化为dict数据，然后再插入到数组中\n      datastore = json.loads(line)\n      sentences.append(datastore['headline'])\n      labels.append(datastore['is_sarcastic'])\n      # urls.append(datastore['article_link'])\n  ```\n\n2. 进行分片，使训练集和测试集互不影响\n\n   ```python\n   training_sentences = sentences[0:training_size]\n   testing_sentences = sentences[training_size:]\n   training_labels = labels[0:training_size]\n   testing_labels = labels[training_size:]\n   ```\n\n3. 实例化分词器，然后用训练集training_sentences创建字典并对应编号。再生成每个训练集句子的对应数字编号所组成的每个句子的token序列，然后设置训练集数据格式，最大长度，位数不够时补零方式以及位数超出时截断方式\n\n   ```python\n   # 要保证创建的神经网络只见过训练集，没有见过训练集\n   # 分词保留的最大单词数，为了显示语料库中没有的单词，利用oov_token属性，将其设置为语料库中无法识别的内容显示为1\n   # 实例化分词器\n   tokenizer = Tokenizer(num_words=vocab_size,\n                         oov_token=oov_tok)\n   # 用这个训练集创建token字典\n   tokenizer.fit_on_texts(training_sentences)\n   # 分词并编号\n   word_index = tokenizer.word_index\n   \n   # 每个句子的token序列\n   training_sequences = tokenizer.texts_to_sequences(training_sentences)\n   # 填充序列变为同样长度，以最长的为基准\n   # 如果添加参数 padding='post'，代表在token序列后方加入0补齐\n   # 也可以加入参数maxlen，指定所需句子长度，如 maxlen=5\n   # 如果数据长度大于所设定句子长度maxlen，可加入截断参数，post从后面截断，默认是pre，truncating='post'，\n   training_padded = pad_sequences(training_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n   \n   testing_sequences =\n   tokenizer.texts_to_sequences(testing_sentences)\n   testing_padded = pad_sequences(testing_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n   ```\n\n   \n\n4. 引入科学计算库numpy，训练模型中的训练数据只支持numpy数组\n\n   ```python\n   # numpy一个科学计算库\n   import numpy as np\n   \n   # np.array将数组等其他形式转化为numpy数组，以便进行矩阵等运算\n   training_padded_after = np.array(training_padded)\n   training_labels_after = np.array(training_labels)\n   testing_padded_after = np.array(testing_padded)\n   testing_labels_after = np.array(testing_labels)\n   ```\n\n   \n\n5. 建立模型\n\n   ```python\n   # 建立模型\n   model = tf.keras.Sequential([\n       # 每个单词的情感方向都会被一次又一次的学习\n       tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),\n       # 将向量进行相加\n       tf.keras.layers.GlobalAveragePooling1D(),\n   \n       # 然后嵌入到一个普通的神经网络中，24输出维度大小units（该层有多少个神经元），activation激活函数\n       # 输入层和隐层，输出层等等,下面Dense就是神经网络的两层\n       # https://blog.csdn.net/ybdesire/article/details/85217688\n       tf.keras.layers.Dense(24, activation='relu'),\n       tf.keras.layers.Dense(1, activation='sigmoid')\n   ])\n   # 查看https://blog.csdn.net/chaojishuai123/article/details/114580892\n   # loss目标函数，'binary_crossentropy'对数损失；metrics评价函数（acc和val_acc就是通过定义评价函数得到的）\n   model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n   \n   # 通过model.summary()输出模型各层的参数情况\n   model.summary()\n   ```\n\n   \n\n6. 输入训练数据以及测试数据进行模型的训练以及评估\n\n   ```python\n   # 30次迭代训练\n   num_epochs = 30\n   # 训练以及检测\n   # training_padded训练集输入特征，training_labels训练集标签\n   # epochs迭代次数，validation_data = (测试集的输入特征，测试集的标签），verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录\n   # https://blog.csdn.net/LuYi_WeiLin/article/details/88555813\n   # numpy格式数组\n   history = model.fit(training_padded_after, training_labels_after,epochs=num_epochs,validation_data=(testing_padded_after, testing_labels_after),verbose=2)\n   \n   #训练以及评估结果\n   Epoch 30/30\n   625/625 - 0s - loss: 0.0199 - accuracy: 0.9945 - val_loss: 1.1787 - val_accuracy: 0.8109\n   ```\n\n   ![模型情况](模型情况.png)\n\n7. matlabplot画图\n\n   ```python\n   import matplotlib.pyplot as plt\n   \n   # 画图\n   def plot_graphs(history, string):\n       plt.plot(history.history[string])\n       plt.plot(history.history['val_' + string])\n       plt.xlabel(\"Epochs\")\n       plt.ylabel(string)\n       plt.legend([string, 'val_' + string])\n       plt.show()\n   \n   plot_graphs(history, \"accuracy\")\n   plot_graphs(history, \"loss\")\n   ```\n\n   ![accuracy](下载1.png)\n\n   ![loss](下载2.png)\n\n8. 转化key和value，返回该层的权重，有多少个神经元，可以不写代码里\n\n   ```python\n   # 将value和key转化，可以互相反查\n   reverse_word_index = dict([(value, key) for (key, value) in word_index.items()])\n   \n   def decode_sentence(text):\n       # 字典dict.get,返回指定键i的值，如果没有返回'？'。\n       # join用法，把？，用空格连接\n       return ' '.join([reverse_word_index.get(i, '?') for i in text])\n   \n   # 测试一下对不对\n   print('training_padded[0]为：',training_padded[0])\n   print(decode_sentence(training_padded[0]))\n   print(training_sentences[2])\n   print(labels[2])\n   \n   e = model.layers[0]\n   # 返回该层的权重\n   weights = e.get_weights()[0]\n   print(weights.shape)  # shape: (vocab_size, embedding_dim)\n   ```\n\n   \n\n9. 利用训练好的模型，传入新句子，判断情感色彩\n\n   ```python\n   # 利用神经网络，判断新句子的情感色彩\n   new_sentence = [\"granny starting to fear spiders in the garden might be real\",\n                   \"game of thrones season finale showing this sunday night\"]\n   # 求出新句子的token序列，分词编号用的是训练集\n   new_sequences = tokenizer.texts_to_sequences(new_sentence)\n   # 规范化序列\n   padded = pad_sequences(new_sequences, maxlen=max_length,\n                          padding=padding_type,\n                          truncating=trunc_type)\n   # 输出预测结果\n   print(model.predict(padded))\n   # 结果 [[9.8276615e-01] [3.8519531e-04]]，表示第一句话负面性概率为98.2%，第二句负面性为38.5%\n   ```\n\n   \n\n","source":"_posts/tensorflow（一）.md","raw":"---\ntitle: tensorflow（一）\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 研究生\n  - tensorflow\n  - NLP\n  - 神经网络\ncategories:\n  - tensorflow\nsummary: tensorflow模型建立训练及预测\nabbrlink: bd21\ndate: 2021-05-07 19:12:57\npassword:\nkeywords:\ndescription:\n---\n# tensorflow入门（一）\n\n数据集和py文件 [训练模型及使用.py](https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.py) ， [Sarcasm_Headlines_Dataset.json](https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/Sarcasm_Headlines_Dataset.json)  ，[sarcasm.json](https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/sarcasm.json) \n\n----\n\n1. 初始定义参数\n\n   ```python\n   # 分词保留的最大单词数\n   vocab_size = 10000\n   # 每个词创建的向量维度\n   embedding_dim = 16\n   # 数据最大长度\n   max_length = 100\n   # 数据长度大于所设定句子长度maxlen，可加入截断参数，truncating='post'，\n   trunc_type = 'post'\n   # 在句子后边补齐\n   padding_type = 'post'\n   # oov_token属性，将语料库中没有的单词标记出来\n   oov_tok = \"<OOV>\"\n   # 两万训练数据\n   training_size = 20000\n   ```\n\n\n2. 从本地读取json文件\n\n- json.load()和json.loads()都实现了反序列化，变量内容从序列化的对象重新读到内存里称之为反序列化，反序列化是流转换为对象。也就是由json（双引号）转变为dict（键值对用单引号包起来的就是dict）字典可供python操作。\n\n  - load：针对文件句柄，将json格式的字符转换为dict，从文件中读取（将string转换为dict）\n\n    `a_json = json.load(open('demo.json','r'))`\n\n  - loads：针对内存对象，将string转化为dict\n\n    `a = json.loads('{'a':'1111','b':'2222'}')`\n\n- json.dump()和json.dumps()都实现了序列化，变量从内存中变成可存储或传输的过程称之为序列化，序列化是将对象状态转化为可保存或可传输格式的过程。\n\n  - dump：将dict类型转化为json字符串格式，写入到文件**（易存储）**\n\n  ```python\n  a_dict = {'a':'1111','b':'2222'}\n  json.dump(a_dict, open('demo.json', 'w'))\n  ```\n\n  - dumps：将dict转化为string**（易传输）**\n\n  ```python\n  a_dict = {'a':'1111','b':'2222'}\n  a_str = json.dumps(a_dict)\n  ```\n\n  \n\n- 方法一：适用于少量数据规整，标准json格式\n\n  ```python\n  with open(\"data/sarcasm.json\", 'r') as f:\n    \t# json.load将json转化为python可操作的dict字典\n  \t\tdatastore = json.load(f)\n        \n  # 定义空数组      \n  sentences = []\n  labels = []\n  urls = []\n  # json数据样式\n  # {\"article_link\": \"https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5\", \"headline\": \"former versace store clerk sues over secret 'black code' for minority shoppers\", \"is_sarcastic\": 0},\n  # 循环将数据插入格式化\n  for item in datastore:\n    \t#append，字符串插入操作\n    \tsentences.append(item['headline'])\n    \tlabels.append(item['is_sarcastic'])\n  \t\turls.append(item['article_link'])\n  ```\n\n- 方法二：适用于大量冗余数据\n\n  ```python\n  # 先定义打开文件操作，这个文件不标准，不是标准json，中间没有逗号\n  file = open(\"data/Sarcasm_Headlines_Dataset.json\", 'r')\n  \n  # 定义空数组      \n  sentences = []\n  labels = []\n  urls = []\n  \n  # json数据样式\n  # {\"article_link\": \"https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5\", \"headline\": \"former versace store clerk sues over secret 'black code' for minority shoppers\", \"is_sarcastic\": 0},\n  \n  # 调用readlines()方法逐行扫描json并插入数组，规范化数据\n  for line in file.readlines():\n    \t# 将每次扫描到的那一行转化为dict数据，然后再插入到数组中\n      datastore = json.loads(line)\n      sentences.append(datastore['headline'])\n      labels.append(datastore['is_sarcastic'])\n      # urls.append(datastore['article_link'])\n  ```\n\n2. 进行分片，使训练集和测试集互不影响\n\n   ```python\n   training_sentences = sentences[0:training_size]\n   testing_sentences = sentences[training_size:]\n   training_labels = labels[0:training_size]\n   testing_labels = labels[training_size:]\n   ```\n\n3. 实例化分词器，然后用训练集training_sentences创建字典并对应编号。再生成每个训练集句子的对应数字编号所组成的每个句子的token序列，然后设置训练集数据格式，最大长度，位数不够时补零方式以及位数超出时截断方式\n\n   ```python\n   # 要保证创建的神经网络只见过训练集，没有见过训练集\n   # 分词保留的最大单词数，为了显示语料库中没有的单词，利用oov_token属性，将其设置为语料库中无法识别的内容显示为1\n   # 实例化分词器\n   tokenizer = Tokenizer(num_words=vocab_size,\n                         oov_token=oov_tok)\n   # 用这个训练集创建token字典\n   tokenizer.fit_on_texts(training_sentences)\n   # 分词并编号\n   word_index = tokenizer.word_index\n   \n   # 每个句子的token序列\n   training_sequences = tokenizer.texts_to_sequences(training_sentences)\n   # 填充序列变为同样长度，以最长的为基准\n   # 如果添加参数 padding='post'，代表在token序列后方加入0补齐\n   # 也可以加入参数maxlen，指定所需句子长度，如 maxlen=5\n   # 如果数据长度大于所设定句子长度maxlen，可加入截断参数，post从后面截断，默认是pre，truncating='post'，\n   training_padded = pad_sequences(training_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n   \n   testing_sequences =\n   tokenizer.texts_to_sequences(testing_sentences)\n   testing_padded = pad_sequences(testing_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n   ```\n\n   \n\n4. 引入科学计算库numpy，训练模型中的训练数据只支持numpy数组\n\n   ```python\n   # numpy一个科学计算库\n   import numpy as np\n   \n   # np.array将数组等其他形式转化为numpy数组，以便进行矩阵等运算\n   training_padded_after = np.array(training_padded)\n   training_labels_after = np.array(training_labels)\n   testing_padded_after = np.array(testing_padded)\n   testing_labels_after = np.array(testing_labels)\n   ```\n\n   \n\n5. 建立模型\n\n   ```python\n   # 建立模型\n   model = tf.keras.Sequential([\n       # 每个单词的情感方向都会被一次又一次的学习\n       tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),\n       # 将向量进行相加\n       tf.keras.layers.GlobalAveragePooling1D(),\n   \n       # 然后嵌入到一个普通的神经网络中，24输出维度大小units（该层有多少个神经元），activation激活函数\n       # 输入层和隐层，输出层等等,下面Dense就是神经网络的两层\n       # https://blog.csdn.net/ybdesire/article/details/85217688\n       tf.keras.layers.Dense(24, activation='relu'),\n       tf.keras.layers.Dense(1, activation='sigmoid')\n   ])\n   # 查看https://blog.csdn.net/chaojishuai123/article/details/114580892\n   # loss目标函数，'binary_crossentropy'对数损失；metrics评价函数（acc和val_acc就是通过定义评价函数得到的）\n   model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n   \n   # 通过model.summary()输出模型各层的参数情况\n   model.summary()\n   ```\n\n   \n\n6. 输入训练数据以及测试数据进行模型的训练以及评估\n\n   ```python\n   # 30次迭代训练\n   num_epochs = 30\n   # 训练以及检测\n   # training_padded训练集输入特征，training_labels训练集标签\n   # epochs迭代次数，validation_data = (测试集的输入特征，测试集的标签），verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录\n   # https://blog.csdn.net/LuYi_WeiLin/article/details/88555813\n   # numpy格式数组\n   history = model.fit(training_padded_after, training_labels_after,epochs=num_epochs,validation_data=(testing_padded_after, testing_labels_after),verbose=2)\n   \n   #训练以及评估结果\n   Epoch 30/30\n   625/625 - 0s - loss: 0.0199 - accuracy: 0.9945 - val_loss: 1.1787 - val_accuracy: 0.8109\n   ```\n\n   ![模型情况](模型情况.png)\n\n7. matlabplot画图\n\n   ```python\n   import matplotlib.pyplot as plt\n   \n   # 画图\n   def plot_graphs(history, string):\n       plt.plot(history.history[string])\n       plt.plot(history.history['val_' + string])\n       plt.xlabel(\"Epochs\")\n       plt.ylabel(string)\n       plt.legend([string, 'val_' + string])\n       plt.show()\n   \n   plot_graphs(history, \"accuracy\")\n   plot_graphs(history, \"loss\")\n   ```\n\n   ![accuracy](下载1.png)\n\n   ![loss](下载2.png)\n\n8. 转化key和value，返回该层的权重，有多少个神经元，可以不写代码里\n\n   ```python\n   # 将value和key转化，可以互相反查\n   reverse_word_index = dict([(value, key) for (key, value) in word_index.items()])\n   \n   def decode_sentence(text):\n       # 字典dict.get,返回指定键i的值，如果没有返回'？'。\n       # join用法，把？，用空格连接\n       return ' '.join([reverse_word_index.get(i, '?') for i in text])\n   \n   # 测试一下对不对\n   print('training_padded[0]为：',training_padded[0])\n   print(decode_sentence(training_padded[0]))\n   print(training_sentences[2])\n   print(labels[2])\n   \n   e = model.layers[0]\n   # 返回该层的权重\n   weights = e.get_weights()[0]\n   print(weights.shape)  # shape: (vocab_size, embedding_dim)\n   ```\n\n   \n\n9. 利用训练好的模型，传入新句子，判断情感色彩\n\n   ```python\n   # 利用神经网络，判断新句子的情感色彩\n   new_sentence = [\"granny starting to fear spiders in the garden might be real\",\n                   \"game of thrones season finale showing this sunday night\"]\n   # 求出新句子的token序列，分词编号用的是训练集\n   new_sequences = tokenizer.texts_to_sequences(new_sentence)\n   # 规范化序列\n   padded = pad_sequences(new_sequences, maxlen=max_length,\n                          padding=padding_type,\n                          truncating=trunc_type)\n   # 输出预测结果\n   print(model.predict(padded))\n   # 结果 [[9.8276615e-01] [3.8519531e-04]]，表示第一句话负面性概率为98.2%，第二句负面性为38.5%\n   ```\n\n   \n\n","slug":"tensorflow（一）","published":1,"updated":"2021-05-07T12:06:51.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5u002ha09k2ws22eph","content":"<h1 id=\"tensorflow入门（一）\"><a href=\"#tensorflow入门（一）\" class=\"headerlink\" title=\"tensorflow入门（一）\"></a>tensorflow入门（一）</h1><p>数据集和py文件 <a href=\"https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.py\" target=\"_blank\" rel=\"noopener\">训练模型及使用.py</a> ， <a href=\"https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/Sarcasm_Headlines_Dataset.json\" target=\"_blank\" rel=\"noopener\">Sarcasm_Headlines_Dataset.json</a>  ，<a href=\"https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/sarcasm.json\" target=\"_blank\" rel=\"noopener\">sarcasm.json</a> </p>\n<hr>\n<ol>\n<li><p>初始定义参数</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 分词保留的最大单词数\nvocab_size = 10000\n# 每个词创建的向量维度\nembedding_dim = 16\n# 数据最大长度\nmax_length = 100\n# 数据长度大于所设定句子长度maxlen，可加入截断参数，truncating='post'，\ntrunc_type = 'post'\n# 在句子后边补齐\npadding_type = 'post'\n# oov_token属性，将语料库中没有的单词标记出来\noov_tok = \"<OOV>\"\n# 两万训练数据\ntraining_size = 20000\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol>\n<li>从本地读取json文件</li>\n</ol>\n<ul>\n<li><p>json.load()和json.loads()都实现了反序列化，变量内容从序列化的对象重新读到内存里称之为反序列化，反序列化是流转换为对象。也就是由json（双引号）转变为dict（键值对用单引号包起来的就是dict）字典可供python操作。</p>\n<ul>\n<li><p>load：针对文件句柄，将json格式的字符转换为dict，从文件中读取（将string转换为dict）</p>\n<p><code>a_json = json.load(open('demo.json','r'))</code></p>\n</li>\n<li><p>loads：针对内存对象，将string转化为dict</p>\n<p><code>a = json.loads('{'a':'1111','b':'2222'}')</code></p>\n</li>\n</ul>\n</li>\n<li><p>json.dump()和json.dumps()都实现了序列化，变量从内存中变成可存储或传输的过程称之为序列化，序列化是将对象状态转化为可保存或可传输格式的过程。</p>\n<ul>\n<li>dump：将dict类型转化为json字符串格式，写入到文件<strong>（易存储）</strong></li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">a_dict = {'a':'1111','b':'2222'}\njson.dump(a_dict, open('demo.json', 'w'))\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li>dumps：将dict转化为string<strong>（易传输）</strong></li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">a_dict = {'a':'1111','b':'2222'}\na_str = json.dumps(a_dict)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>方法一：适用于少量数据规整，标准json格式</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">with open(\"data/sarcasm.json\", 'r') as f:\n      # json.load将json转化为python可操作的dict字典\n        datastore = json.load(f)\n\n# 定义空数组      \nsentences = []\nlabels = []\nurls = []\n# json数据样式\n# {\"article_link\": \"https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5\", \"headline\": \"former versace store clerk sues over secret 'black code' for minority shoppers\", \"is_sarcastic\": 0},\n# 循环将数据插入格式化\nfor item in datastore:\n      #append，字符串插入操作\n      sentences.append(item['headline'])\n      labels.append(item['is_sarcastic'])\n        urls.append(item['article_link'])\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>方法二：适用于大量冗余数据</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 先定义打开文件操作，这个文件不标准，不是标准json，中间没有逗号\nfile = open(\"data/Sarcasm_Headlines_Dataset.json\", 'r')\n\n# 定义空数组      \nsentences = []\nlabels = []\nurls = []\n\n# json数据样式\n# {\"article_link\": \"https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5\", \"headline\": \"former versace store clerk sues over secret 'black code' for minority shoppers\", \"is_sarcastic\": 0},\n\n# 调用readlines()方法逐行扫描json并插入数组，规范化数据\nfor line in file.readlines():\n      # 将每次扫描到的那一行转化为dict数据，然后再插入到数组中\n    datastore = json.loads(line)\n    sentences.append(datastore['headline'])\n    labels.append(datastore['is_sarcastic'])\n    # urls.append(datastore['article_link'])\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<ol>\n<li><p>进行分片，使训练集和测试集互不影响</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">training_sentences = sentences[0:training_size]\ntesting_sentences = sentences[training_size:]\ntraining_labels = labels[0:training_size]\ntesting_labels = labels[training_size:]\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>实例化分词器，然后用训练集training_sentences创建字典并对应编号。再生成每个训练集句子的对应数字编号所组成的每个句子的token序列，然后设置训练集数据格式，最大长度，位数不够时补零方式以及位数超出时截断方式</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 要保证创建的神经网络只见过训练集，没有见过训练集\n# 分词保留的最大单词数，为了显示语料库中没有的单词，利用oov_token属性，将其设置为语料库中无法识别的内容显示为1\n# 实例化分词器\ntokenizer = Tokenizer(num_words=vocab_size,\n                      oov_token=oov_tok)\n# 用这个训练集创建token字典\ntokenizer.fit_on_texts(training_sentences)\n# 分词并编号\nword_index = tokenizer.word_index\n\n# 每个句子的token序列\ntraining_sequences = tokenizer.texts_to_sequences(training_sentences)\n# 填充序列变为同样长度，以最长的为基准\n# 如果添加参数 padding='post'，代表在token序列后方加入0补齐\n# 也可以加入参数maxlen，指定所需句子长度，如 maxlen=5\n# 如果数据长度大于所设定句子长度maxlen，可加入截断参数，post从后面截断，默认是pre，truncating='post'，\ntraining_padded = pad_sequences(training_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n\ntesting_sequences =\ntokenizer.texts_to_sequences(testing_sentences)\ntesting_padded = pad_sequences(testing_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol>\n<li><p>引入科学计算库numpy，训练模型中的训练数据只支持numpy数组</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># numpy一个科学计算库\nimport numpy as np\n\n# np.array将数组等其他形式转化为numpy数组，以便进行矩阵等运算\ntraining_padded_after = np.array(training_padded)\ntraining_labels_after = np.array(training_labels)\ntesting_padded_after = np.array(testing_padded)\ntesting_labels_after = np.array(testing_labels)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol>\n<li><p>建立模型</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 建立模型\nmodel = tf.keras.Sequential([\n    # 每个单词的情感方向都会被一次又一次的学习\n    tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),\n    # 将向量进行相加\n    tf.keras.layers.GlobalAveragePooling1D(),\n\n    # 然后嵌入到一个普通的神经网络中，24输出维度大小units（该层有多少个神经元），activation激活函数\n    # 输入层和隐层，输出层等等,下面Dense就是神经网络的两层\n    # https://blog.csdn.net/ybdesire/article/details/85217688\n    tf.keras.layers.Dense(24, activation='relu'),\n    tf.keras.layers.Dense(1, activation='sigmoid')\n])\n# 查看https://blog.csdn.net/chaojishuai123/article/details/114580892\n# loss目标函数，'binary_crossentropy'对数损失；metrics评价函数（acc和val_acc就是通过定义评价函数得到的）\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n# 通过model.summary()输出模型各层的参数情况\nmodel.summary()\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol>\n<li><p>输入训练数据以及测试数据进行模型的训练以及评估</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 30次迭代训练\nnum_epochs = 30\n# 训练以及检测\n# training_padded训练集输入特征，training_labels训练集标签\n# epochs迭代次数，validation_data = (测试集的输入特征，测试集的标签），verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录\n# https://blog.csdn.net/LuYi_WeiLin/article/details/88555813\n# numpy格式数组\nhistory = model.fit(training_padded_after, training_labels_after,epochs=num_epochs,validation_data=(testing_padded_after, testing_labels_after),verbose=2)\n\n#训练以及评估结果\nEpoch 30/30\n625/625 - 0s - loss: 0.0199 - accuracy: 0.9945 - val_loss: 1.1787 - val_accuracy: 0.8109\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"模型情况.png\" alt=\"模型情况\"></p>\n</li>\n<li><p>matlabplot画图</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">import matplotlib.pyplot as plt\n\n# 画图\ndef plot_graphs(history, string):\n    plt.plot(history.history[string])\n    plt.plot(history.history['val_' + string])\n    plt.xlabel(\"Epochs\")\n    plt.ylabel(string)\n    plt.legend([string, 'val_' + string])\n    plt.show()\n\nplot_graphs(history, \"accuracy\")\nplot_graphs(history, \"loss\")\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"下载1.png\" alt=\"accuracy\"></p>\n<p><img src=\"下载2.png\" alt=\"loss\"></p>\n</li>\n<li><p>转化key和value，返回该层的权重，有多少个神经元，可以不写代码里</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 将value和key转化，可以互相反查\nreverse_word_index = dict([(value, key) for (key, value) in word_index.items()])\n\ndef decode_sentence(text):\n    # 字典dict.get,返回指定键i的值，如果没有返回'？'。\n    # join用法，把？，用空格连接\n    return ' '.join([reverse_word_index.get(i, '?') for i in text])\n\n# 测试一下对不对\nprint('training_padded[0]为：',training_padded[0])\nprint(decode_sentence(training_padded[0]))\nprint(training_sentences[2])\nprint(labels[2])\n\ne = model.layers[0]\n# 返回该层的权重\nweights = e.get_weights()[0]\nprint(weights.shape)  # shape: (vocab_size, embedding_dim)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol>\n<li><p>利用训练好的模型，传入新句子，判断情感色彩</p>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\"># 利用神经网络，判断新句子的情感色彩\nnew_sentence = [\"granny starting to fear spiders in the garden might be real\",\n                \"game of thrones season finale showing this sunday night\"]\n# 求出新句子的token序列，分词编号用的是训练集\nnew_sequences = tokenizer.texts_to_sequences(new_sentence)\n# 规范化序列\npadded = pad_sequences(new_sequences, maxlen=max_length,\n                       padding=padding_type,\n                       truncating=trunc_type)\n# 输出预测结果\nprint(model.predict(padded))\n# 结果 [[9.8276615e-01] [3.8519531e-04]]，表示第一句话负面性概率为98.2%，第二句负面性为38.5%\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"tensorflow入门（一）\"><a href=\"#tensorflow入门（一）\" class=\"headerlink\" title=\"tensorflow入门（一）\"></a>tensorflow入门（一）</h1><p>数据集和py文件 <a href=\"https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.py\" target=\"_blank\" rel=\"noopener\">训练模型及使用.py</a> ， <a href=\"https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/Sarcasm_Headlines_Dataset.json\" target=\"_blank\" rel=\"noopener\">Sarcasm_Headlines_Dataset.json</a>  ，<a href=\"https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/sarcasm.json\" target=\"_blank\" rel=\"noopener\">sarcasm.json</a> </p>\n<hr>\n<ol>\n<li><p>初始定义参数</p>\n<pre><code class=\"lang-python\"># 分词保留的最大单词数\nvocab_size = 10000\n# 每个词创建的向量维度\nembedding_dim = 16\n# 数据最大长度\nmax_length = 100\n# 数据长度大于所设定句子长度maxlen，可加入截断参数，truncating=&#39;post&#39;，\ntrunc_type = &#39;post&#39;\n# 在句子后边补齐\npadding_type = &#39;post&#39;\n# oov_token属性，将语料库中没有的单词标记出来\noov_tok = &quot;&lt;OOV&gt;&quot;\n# 两万训练数据\ntraining_size = 20000\n</code></pre>\n</li>\n</ol>\n<ol>\n<li>从本地读取json文件</li>\n</ol>\n<ul>\n<li><p>json.load()和json.loads()都实现了反序列化，变量内容从序列化的对象重新读到内存里称之为反序列化，反序列化是流转换为对象。也就是由json（双引号）转变为dict（键值对用单引号包起来的就是dict）字典可供python操作。</p>\n<ul>\n<li><p>load：针对文件句柄，将json格式的字符转换为dict，从文件中读取（将string转换为dict）</p>\n<p><code>a_json = json.load(open(&#39;demo.json&#39;,&#39;r&#39;))</code></p>\n</li>\n<li><p>loads：针对内存对象，将string转化为dict</p>\n<p><code>a = json.loads(&#39;{&#39;a&#39;:&#39;1111&#39;,&#39;b&#39;:&#39;2222&#39;}&#39;)</code></p>\n</li>\n</ul>\n</li>\n<li><p>json.dump()和json.dumps()都实现了序列化，变量从内存中变成可存储或传输的过程称之为序列化，序列化是将对象状态转化为可保存或可传输格式的过程。</p>\n<ul>\n<li>dump：将dict类型转化为json字符串格式，写入到文件<strong>（易存储）</strong></li>\n</ul>\n<pre><code class=\"lang-python\">a_dict = {&#39;a&#39;:&#39;1111&#39;,&#39;b&#39;:&#39;2222&#39;}\njson.dump(a_dict, open(&#39;demo.json&#39;, &#39;w&#39;))\n</code></pre>\n<ul>\n<li>dumps：将dict转化为string<strong>（易传输）</strong></li>\n</ul>\n<pre><code class=\"lang-python\">a_dict = {&#39;a&#39;:&#39;1111&#39;,&#39;b&#39;:&#39;2222&#39;}\na_str = json.dumps(a_dict)\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>方法一：适用于少量数据规整，标准json格式</p>\n<pre><code class=\"lang-python\">with open(&quot;data/sarcasm.json&quot;, &#39;r&#39;) as f:\n      # json.load将json转化为python可操作的dict字典\n        datastore = json.load(f)\n\n# 定义空数组      \nsentences = []\nlabels = []\nurls = []\n# json数据样式\n# {&quot;article_link&quot;: &quot;https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;, &quot;headline&quot;: &quot;former versace store clerk sues over secret &#39;black code&#39; for minority shoppers&quot;, &quot;is_sarcastic&quot;: 0},\n# 循环将数据插入格式化\nfor item in datastore:\n      #append，字符串插入操作\n      sentences.append(item[&#39;headline&#39;])\n      labels.append(item[&#39;is_sarcastic&#39;])\n        urls.append(item[&#39;article_link&#39;])\n</code></pre>\n</li>\n<li><p>方法二：适用于大量冗余数据</p>\n<pre><code class=\"lang-python\"># 先定义打开文件操作，这个文件不标准，不是标准json，中间没有逗号\nfile = open(&quot;data/Sarcasm_Headlines_Dataset.json&quot;, &#39;r&#39;)\n\n# 定义空数组      \nsentences = []\nlabels = []\nurls = []\n\n# json数据样式\n# {&quot;article_link&quot;: &quot;https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;, &quot;headline&quot;: &quot;former versace store clerk sues over secret &#39;black code&#39; for minority shoppers&quot;, &quot;is_sarcastic&quot;: 0},\n\n# 调用readlines()方法逐行扫描json并插入数组，规范化数据\nfor line in file.readlines():\n      # 将每次扫描到的那一行转化为dict数据，然后再插入到数组中\n    datastore = json.loads(line)\n    sentences.append(datastore[&#39;headline&#39;])\n    labels.append(datastore[&#39;is_sarcastic&#39;])\n    # urls.append(datastore[&#39;article_link&#39;])\n</code></pre>\n</li>\n</ul>\n<ol>\n<li><p>进行分片，使训练集和测试集互不影响</p>\n<pre><code class=\"lang-python\">training_sentences = sentences[0:training_size]\ntesting_sentences = sentences[training_size:]\ntraining_labels = labels[0:training_size]\ntesting_labels = labels[training_size:]\n</code></pre>\n</li>\n<li><p>实例化分词器，然后用训练集training_sentences创建字典并对应编号。再生成每个训练集句子的对应数字编号所组成的每个句子的token序列，然后设置训练集数据格式，最大长度，位数不够时补零方式以及位数超出时截断方式</p>\n<pre><code class=\"lang-python\"># 要保证创建的神经网络只见过训练集，没有见过训练集\n# 分词保留的最大单词数，为了显示语料库中没有的单词，利用oov_token属性，将其设置为语料库中无法识别的内容显示为1\n# 实例化分词器\ntokenizer = Tokenizer(num_words=vocab_size,\n                      oov_token=oov_tok)\n# 用这个训练集创建token字典\ntokenizer.fit_on_texts(training_sentences)\n# 分词并编号\nword_index = tokenizer.word_index\n\n# 每个句子的token序列\ntraining_sequences = tokenizer.texts_to_sequences(training_sentences)\n# 填充序列变为同样长度，以最长的为基准\n# 如果添加参数 padding=&#39;post&#39;，代表在token序列后方加入0补齐\n# 也可以加入参数maxlen，指定所需句子长度，如 maxlen=5\n# 如果数据长度大于所设定句子长度maxlen，可加入截断参数，post从后面截断，默认是pre，truncating=&#39;post&#39;，\ntraining_padded = pad_sequences(training_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n\ntesting_sequences =\ntokenizer.texts_to_sequences(testing_sentences)\ntesting_padded = pad_sequences(testing_sequences,maxlen=max_length,padding=padding_type,truncating=trunc_type)\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>引入科学计算库numpy，训练模型中的训练数据只支持numpy数组</p>\n<pre><code class=\"lang-python\"># numpy一个科学计算库\nimport numpy as np\n\n# np.array将数组等其他形式转化为numpy数组，以便进行矩阵等运算\ntraining_padded_after = np.array(training_padded)\ntraining_labels_after = np.array(training_labels)\ntesting_padded_after = np.array(testing_padded)\ntesting_labels_after = np.array(testing_labels)\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>建立模型</p>\n<pre><code class=\"lang-python\"># 建立模型\nmodel = tf.keras.Sequential([\n    # 每个单词的情感方向都会被一次又一次的学习\n    tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),\n    # 将向量进行相加\n    tf.keras.layers.GlobalAveragePooling1D(),\n\n    # 然后嵌入到一个普通的神经网络中，24输出维度大小units（该层有多少个神经元），activation激活函数\n    # 输入层和隐层，输出层等等,下面Dense就是神经网络的两层\n    # https://blog.csdn.net/ybdesire/article/details/85217688\n    tf.keras.layers.Dense(24, activation=&#39;relu&#39;),\n    tf.keras.layers.Dense(1, activation=&#39;sigmoid&#39;)\n])\n# 查看https://blog.csdn.net/chaojishuai123/article/details/114580892\n# loss目标函数，&#39;binary_crossentropy&#39;对数损失；metrics评价函数（acc和val_acc就是通过定义评价函数得到的）\nmodel.compile(loss=&#39;binary_crossentropy&#39;, optimizer=&#39;adam&#39;, metrics=[&#39;accuracy&#39;])\n\n# 通过model.summary()输出模型各层的参数情况\nmodel.summary()\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>输入训练数据以及测试数据进行模型的训练以及评估</p>\n<pre><code class=\"lang-python\"># 30次迭代训练\nnum_epochs = 30\n# 训练以及检测\n# training_padded训练集输入特征，training_labels训练集标签\n# epochs迭代次数，validation_data = (测试集的输入特征，测试集的标签），verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录\n# https://blog.csdn.net/LuYi_WeiLin/article/details/88555813\n# numpy格式数组\nhistory = model.fit(training_padded_after, training_labels_after,epochs=num_epochs,validation_data=(testing_padded_after, testing_labels_after),verbose=2)\n\n#训练以及评估结果\nEpoch 30/30\n625/625 - 0s - loss: 0.0199 - accuracy: 0.9945 - val_loss: 1.1787 - val_accuracy: 0.8109\n</code></pre>\n<p><img src=\"模型情况.png\" alt=\"模型情况\"></p>\n</li>\n<li><p>matlabplot画图</p>\n<pre><code class=\"lang-python\">import matplotlib.pyplot as plt\n\n# 画图\ndef plot_graphs(history, string):\n    plt.plot(history.history[string])\n    plt.plot(history.history[&#39;val_&#39; + string])\n    plt.xlabel(&quot;Epochs&quot;)\n    plt.ylabel(string)\n    plt.legend([string, &#39;val_&#39; + string])\n    plt.show()\n\nplot_graphs(history, &quot;accuracy&quot;)\nplot_graphs(history, &quot;loss&quot;)\n</code></pre>\n<p><img src=\"下载1.png\" alt=\"accuracy\"></p>\n<p><img src=\"下载2.png\" alt=\"loss\"></p>\n</li>\n<li><p>转化key和value，返回该层的权重，有多少个神经元，可以不写代码里</p>\n<pre><code class=\"lang-python\"># 将value和key转化，可以互相反查\nreverse_word_index = dict([(value, key) for (key, value) in word_index.items()])\n\ndef decode_sentence(text):\n    # 字典dict.get,返回指定键i的值，如果没有返回&#39;？&#39;。\n    # join用法，把？，用空格连接\n    return &#39; &#39;.join([reverse_word_index.get(i, &#39;?&#39;) for i in text])\n\n# 测试一下对不对\nprint(&#39;training_padded[0]为：&#39;,training_padded[0])\nprint(decode_sentence(training_padded[0]))\nprint(training_sentences[2])\nprint(labels[2])\n\ne = model.layers[0]\n# 返回该层的权重\nweights = e.get_weights()[0]\nprint(weights.shape)  # shape: (vocab_size, embedding_dim)\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>利用训练好的模型，传入新句子，判断情感色彩</p>\n<pre><code class=\"lang-python\"># 利用神经网络，判断新句子的情感色彩\nnew_sentence = [&quot;granny starting to fear spiders in the garden might be real&quot;,\n                &quot;game of thrones season finale showing this sunday night&quot;]\n# 求出新句子的token序列，分词编号用的是训练集\nnew_sequences = tokenizer.texts_to_sequences(new_sentence)\n# 规范化序列\npadded = pad_sequences(new_sequences, maxlen=max_length,\n                       padding=padding_type,\n                       truncating=trunc_type)\n# 输出预测结果\nprint(model.predict(padded))\n# 结果 [[9.8276615e-01] [3.8519531e-04]]，表示第一句话负面性概率为98.2%，第二句负面性为38.5%\n</code></pre>\n</li>\n</ol>\n"},{"title":"前端设计原稿","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"Vue-elementUi idea","abbrlink":"51d4","date":"2021-05-17T07:52:08.000Z","password":null,"keywords":null,"description":null,"_content":"# 前端idea原稿（逐步更新）\n\n### 1. 首页（图表展示，数据总计，操作展示）\n\n### 2. 爬取设置\n\n [爬取设置.pdf](爬取设置.pdf) \n\n<img src=\"爬取设置.png\" alt=\"爬取设置\" style=\"zoom: 50%;\" />\n\n### 3. 数据表格展示，以及增删改查操作\n\n [数据表格展示.pdf](数据表格展示.pdf) \n\n<img src=\"数据表格1.png\" alt=\"数据表格1\" style=\"zoom:67%;\" />\n\n<img src=\"数据表格2.png\" alt=\"数据表格2\" style=\"zoom:67%;\" />","source":"_posts/前端设计原稿.md","raw":"---\ntitle: 前端设计原稿\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 前端\n  - Vue\n  - 项目\ncategories:\n  - 项目\nsummary: Vue-elementUi idea\nabbrlink: 51d4\ndate: 2021-05-17 15:52:08\npassword:\nkeywords:\ndescription:\n---\n# 前端idea原稿（逐步更新）\n\n### 1. 首页（图表展示，数据总计，操作展示）\n\n### 2. 爬取设置\n\n [爬取设置.pdf](爬取设置.pdf) \n\n<img src=\"爬取设置.png\" alt=\"爬取设置\" style=\"zoom: 50%;\" />\n\n### 3. 数据表格展示，以及增删改查操作\n\n [数据表格展示.pdf](数据表格展示.pdf) \n\n<img src=\"数据表格1.png\" alt=\"数据表格1\" style=\"zoom:67%;\" />\n\n<img src=\"数据表格2.png\" alt=\"数据表格2\" style=\"zoom:67%;\" />","slug":"前端设计原稿","published":1,"updated":"2021-05-17T08:05:02.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5v002la09k3phaghpr","content":"<h1 id=\"前端idea原稿（逐步更新）\"><a href=\"#前端idea原稿（逐步更新）\" class=\"headerlink\" title=\"前端idea原稿（逐步更新）\"></a>前端idea原稿（逐步更新）</h1><h3 id=\"1-首页（图表展示，数据总计，操作展示）\"><a href=\"#1-首页（图表展示，数据总计，操作展示）\" class=\"headerlink\" title=\"1. 首页（图表展示，数据总计，操作展示）\"></a>1. 首页（图表展示，数据总计，操作展示）</h3><h3 id=\"2-爬取设置\"><a href=\"#2-爬取设置\" class=\"headerlink\" title=\"2. 爬取设置\"></a>2. 爬取设置</h3><p> <a href=\"爬取设置.pdf\">爬取设置.pdf</a> </p>\n<p><img src=\"爬取设置.png\" alt=\"爬取设置\" style=\"zoom: 50%;\"></p>\n<h3 id=\"3-数据表格展示，以及增删改查操作\"><a href=\"#3-数据表格展示，以及增删改查操作\" class=\"headerlink\" title=\"3. 数据表格展示，以及增删改查操作\"></a>3. 数据表格展示，以及增删改查操作</h3><p> <a href=\"数据表格展示.pdf\">数据表格展示.pdf</a> </p>\n<p><img src=\"数据表格1.png\" alt=\"数据表格1\" style=\"zoom:67%;\"></p>\n<p><img src=\"数据表格2.png\" alt=\"数据表格2\" style=\"zoom:67%;\"></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"前端idea原稿（逐步更新）\"><a href=\"#前端idea原稿（逐步更新）\" class=\"headerlink\" title=\"前端idea原稿（逐步更新）\"></a>前端idea原稿（逐步更新）</h1><h3 id=\"1-首页（图表展示，数据总计，操作展示）\"><a href=\"#1-首页（图表展示，数据总计，操作展示）\" class=\"headerlink\" title=\"1. 首页（图表展示，数据总计，操作展示）\"></a>1. 首页（图表展示，数据总计，操作展示）</h3><h3 id=\"2-爬取设置\"><a href=\"#2-爬取设置\" class=\"headerlink\" title=\"2. 爬取设置\"></a>2. 爬取设置</h3><p> <a href=\"爬取设置.pdf\">爬取设置.pdf</a> </p>\n<p><img src=\"爬取设置.png\" alt=\"爬取设置\" style=\"zoom: 50%;\" /></p>\n<h3 id=\"3-数据表格展示，以及增删改查操作\"><a href=\"#3-数据表格展示，以及增删改查操作\" class=\"headerlink\" title=\"3. 数据表格展示，以及增删改查操作\"></a>3. 数据表格展示，以及增删改查操作</h3><p> <a href=\"数据表格展示.pdf\">数据表格展示.pdf</a> </p>\n<p><img src=\"数据表格1.png\" alt=\"数据表格1\" style=\"zoom:67%;\" /></p>\n<p><img src=\"数据表格2.png\" alt=\"数据表格2\" style=\"zoom:67%;\" /></p>\n"},{"title":"吉林大学2019年招生目录","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"2019招生目录","abbrlink":"2e9c","date":"2020-06-03T13:22:56.000Z","password":null,"_content":"## - 吉林大学2019年全日制硕士研究生招生专业目录 - \n### - 哲学社会学院 -\n***\n#### 学硕\n![](学硕.png)\n#### 专硕\n![](专硕.png)\n***\n### - 计算机科学与技术学院 -\n***\n#### 学硕\n![](计算机学硕1.png)\n![](计算机学硕2.png)\n#### 专硕\n![](计算机专硕.png)\n***","source":"_posts/吉林大学招生简章.md","raw":"---\ntitle: 吉林大学2019年招生目录\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 2019招生目录\ntags:\n  - 考研\n  - 心理学\n  - 计算机\ncategories:\n  - 吉林大学\nabbrlink: 2e9c\ndate: 2020-06-03 21:22:56\npassword:\n---\n## - 吉林大学2019年全日制硕士研究生招生专业目录 - \n### - 哲学社会学院 -\n***\n#### 学硕\n![](学硕.png)\n#### 专硕\n![](专硕.png)\n***\n### - 计算机科学与技术学院 -\n***\n#### 学硕\n![](计算机学硕1.png)\n![](计算机学硕2.png)\n#### 专硕\n![](计算机专硕.png)\n***","slug":"吉林大学招生简章","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5v002oa09kdh43d9e1","content":"<h2 id=\"吉林大学2019年全日制硕士研究生招生专业目录\"><a href=\"#吉林大学2019年全日制硕士研究生招生专业目录\" class=\"headerlink\" title=\"- 吉林大学2019年全日制硕士研究生招生专业目录 -\"></a>- 吉林大学2019年全日制硕士研究生招生专业目录 -</h2><h3 id=\"哲学社会学院\"><a href=\"#哲学社会学院\" class=\"headerlink\" title=\"- 哲学社会学院 -\"></a>- 哲学社会学院 -</h3><hr>\n<h4 id=\"学硕\"><a href=\"#学硕\" class=\"headerlink\" title=\"学硕\"></a>学硕</h4><p><img src=\"学硕.png\" alt=\"\"></p>\n<h4 id=\"专硕\"><a href=\"#专硕\" class=\"headerlink\" title=\"专硕\"></a>专硕</h4><p><img src=\"专硕.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"计算机科学与技术学院\"><a href=\"#计算机科学与技术学院\" class=\"headerlink\" title=\"- 计算机科学与技术学院 -\"></a>- 计算机科学与技术学院 -</h3><hr>\n<h4 id=\"学硕-1\"><a href=\"#学硕-1\" class=\"headerlink\" title=\"学硕\"></a>学硕</h4><p><img src=\"计算机学硕1.png\" alt=\"\"><br><img src=\"计算机学硕2.png\" alt=\"\"></p>\n<h4 id=\"专硕-1\"><a href=\"#专硕-1\" class=\"headerlink\" title=\"专硕\"></a>专硕</h4><p><img src=\"计算机专硕.png\" alt=\"\"></p>\n<hr>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"吉林大学2019年全日制硕士研究生招生专业目录\"><a href=\"#吉林大学2019年全日制硕士研究生招生专业目录\" class=\"headerlink\" title=\"- 吉林大学2019年全日制硕士研究生招生专业目录 -\"></a>- 吉林大学2019年全日制硕士研究生招生专业目录 -</h2><h3 id=\"哲学社会学院\"><a href=\"#哲学社会学院\" class=\"headerlink\" title=\"- 哲学社会学院 -\"></a>- 哲学社会学院 -</h3><hr>\n<h4 id=\"学硕\"><a href=\"#学硕\" class=\"headerlink\" title=\"学硕\"></a>学硕</h4><p><img src=\"学硕.png\" alt=\"\"></p>\n<h4 id=\"专硕\"><a href=\"#专硕\" class=\"headerlink\" title=\"专硕\"></a>专硕</h4><p><img src=\"专硕.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"计算机科学与技术学院\"><a href=\"#计算机科学与技术学院\" class=\"headerlink\" title=\"- 计算机科学与技术学院 -\"></a>- 计算机科学与技术学院 -</h3><hr>\n<h4 id=\"学硕-1\"><a href=\"#学硕-1\" class=\"headerlink\" title=\"学硕\"></a>学硕</h4><p><img src=\"计算机学硕1.png\" alt=\"\"><br><img src=\"计算机学硕2.png\" alt=\"\"></p>\n<h4 id=\"专硕-1\"><a href=\"#专硕-1\" class=\"headerlink\" title=\"专硕\"></a>专硕</h4><p><img src=\"计算机专硕.png\" alt=\"\"></p>\n<hr>\n"},{"title":"后台部署","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"NodeJS后台环境部署","abbrlink":"c728","date":"2021-05-17T05:16:34.000Z","password":null,"keywords":null,"description":null,"_content":"# NodeJS后台环境部署\n\n### 1. 建立环境\n\n```bash\n# 建立nodejs后台环境\nnode create 项目名称\nvar express = require('express'); //express框架模块\nvar path = require('path'); //系统路径模块\nvar fs = require('fs'); //文件模块\nvar bodyParser = require('body-parser'); //对post请求的请求体进行解析模块\nvar app = express();\nvar mysql = require('mysql');  //导入mysql包\nvar cors = require(\"cors\"); // 解决跨域问题.npm install cors 装一下\n```\n\n### 2. 连接mysql数据库\n\n```bash\n//连接mysql数据库\nvar connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'lgn970722',\n    port: '3306',\n    database: 'mySpider',\n    useConnectionPooling: true,\n    timezone: '08:00'\n  });\nconnection.connect();\n```\n\n### 3. 分页complex_table_data mysql数据\n\n```bash\napp.get('/complex-table_data', function (req, res) {\n    var response = {\n        \"page\":req.query.page,\n        \"limit\":req.query.limit,\n    };\n    console.log(req.query.page)\n    //  var selectSQL = \"SELECT * from alarmData\";\n    //\n    a = (response.page - 1) * req.query.limit;\n    console.log('a:' + a);\n    var selectSQL = \"select * from complex_table_data limit \"+  req.query.limit +\" offset \" + a;\n    \nconnection.query(selectSQL, function (err, result) {\n  if (err) {\n    console.log('[data ERROR] - ', err.message);\n    return;\n  }\n  //console.log(result);\n  if (result == '') {\n    console.log(\"数据没了\");\n    res.end(\"0\");//如果登录失败就给客户端返回0，\n  }\n  else {\n    // console.log(selectSQL);\n    console.log(result);\n    // res.json({success_code: 200, message: '获取分页数据成功', data: results })\n    // for (var i = 0; i < result.length; i++) {\n    //   result[i].alarmGrade = +result[i].alarmGrade\n  \n    // };\n    console.log(result);\n    //解决中文乱码，加入头文件\n    // res.writeHead(200, { 'Content-Type': 'text/html;charset=utf-8' })\n    res.end(JSON.stringify({\n        code :20000,\n        data: {\n            total: 100,\n            items: result\n        }\n    }));\n    // res.json(data:result)\n    \n  }\n});\n//  console.log(result);\n//res.end(JSON.stringify(response));\n```\n\n### 4. 创建get接口，获取本地json数据，以便用于测试\n\n```bash\n//创建get接口\napp.get('/api', function(req, res) {\n\t//console.log(req.body); //获取请求参数\n\nvar file = path.join(__dirname, 'data/test.json'); //文件路径，__dirname为当前运行js文件的目录\n//var file = 'f:\\\\nodejs\\\\data\\\\test.json'; //也可以用这种方式指定路径\n\n//读取json文件\nfs.readFile(file, 'utf-8', function(err, data) {\n    if (err) {\n        res.send('文件读取失败');\n    } else {\n        res.send(data);\n        console.log('数据读取成功');\n    }\n});\n});\n```\n\n### 5. 运行端口\n\n```bash\nvar server = app.listen(8080, function () {\n\n    var host = server.address().address\n    var port = server.address().port\n      \n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n})\n```\n\n","source":"_posts/后台部署.md","raw":"---\ntitle: 后台部署\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - NodeJS\n  - API\n  - 部署\n  - 项目\ncategories:\n  - 项目\nsummary: NodeJS后台环境部署\nabbrlink: c728\ndate: 2021-05-17 13:16:34\npassword:\nkeywords:\ndescription:\n---\n# NodeJS后台环境部署\n\n### 1. 建立环境\n\n```bash\n# 建立nodejs后台环境\nnode create 项目名称\nvar express = require('express'); //express框架模块\nvar path = require('path'); //系统路径模块\nvar fs = require('fs'); //文件模块\nvar bodyParser = require('body-parser'); //对post请求的请求体进行解析模块\nvar app = express();\nvar mysql = require('mysql');  //导入mysql包\nvar cors = require(\"cors\"); // 解决跨域问题.npm install cors 装一下\n```\n\n### 2. 连接mysql数据库\n\n```bash\n//连接mysql数据库\nvar connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'lgn970722',\n    port: '3306',\n    database: 'mySpider',\n    useConnectionPooling: true,\n    timezone: '08:00'\n  });\nconnection.connect();\n```\n\n### 3. 分页complex_table_data mysql数据\n\n```bash\napp.get('/complex-table_data', function (req, res) {\n    var response = {\n        \"page\":req.query.page,\n        \"limit\":req.query.limit,\n    };\n    console.log(req.query.page)\n    //  var selectSQL = \"SELECT * from alarmData\";\n    //\n    a = (response.page - 1) * req.query.limit;\n    console.log('a:' + a);\n    var selectSQL = \"select * from complex_table_data limit \"+  req.query.limit +\" offset \" + a;\n    \nconnection.query(selectSQL, function (err, result) {\n  if (err) {\n    console.log('[data ERROR] - ', err.message);\n    return;\n  }\n  //console.log(result);\n  if (result == '') {\n    console.log(\"数据没了\");\n    res.end(\"0\");//如果登录失败就给客户端返回0，\n  }\n  else {\n    // console.log(selectSQL);\n    console.log(result);\n    // res.json({success_code: 200, message: '获取分页数据成功', data: results })\n    // for (var i = 0; i < result.length; i++) {\n    //   result[i].alarmGrade = +result[i].alarmGrade\n  \n    // };\n    console.log(result);\n    //解决中文乱码，加入头文件\n    // res.writeHead(200, { 'Content-Type': 'text/html;charset=utf-8' })\n    res.end(JSON.stringify({\n        code :20000,\n        data: {\n            total: 100,\n            items: result\n        }\n    }));\n    // res.json(data:result)\n    \n  }\n});\n//  console.log(result);\n//res.end(JSON.stringify(response));\n```\n\n### 4. 创建get接口，获取本地json数据，以便用于测试\n\n```bash\n//创建get接口\napp.get('/api', function(req, res) {\n\t//console.log(req.body); //获取请求参数\n\nvar file = path.join(__dirname, 'data/test.json'); //文件路径，__dirname为当前运行js文件的目录\n//var file = 'f:\\\\nodejs\\\\data\\\\test.json'; //也可以用这种方式指定路径\n\n//读取json文件\nfs.readFile(file, 'utf-8', function(err, data) {\n    if (err) {\n        res.send('文件读取失败');\n    } else {\n        res.send(data);\n        console.log('数据读取成功');\n    }\n});\n});\n```\n\n### 5. 运行端口\n\n```bash\nvar server = app.listen(8080, function () {\n\n    var host = server.address().address\n    var port = server.address().port\n      \n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n})\n```\n\n","slug":"后台部署","published":1,"updated":"2021-05-17T05:18:58.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5w002ta09k5t774pzk","content":"<h1 id=\"NodeJS后台环境部署\"><a href=\"#NodeJS后台环境部署\" class=\"headerlink\" title=\"NodeJS后台环境部署\"></a>NodeJS后台环境部署</h1><h3 id=\"1-建立环境\"><a href=\"#1-建立环境\" class=\"headerlink\" title=\"1. 建立环境\"></a>1. 建立环境</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\"># 建立nodejs后台环境\nnode create 项目名称\nvar express = require('express'); //express框架模块\nvar path = require('path'); //系统路径模块\nvar fs = require('fs'); //文件模块\nvar bodyParser = require('body-parser'); //对post请求的请求体进行解析模块\nvar app = express();\nvar mysql = require('mysql');  //导入mysql包\nvar cors = require(\"cors\"); // 解决跨域问题.npm install cors 装一下\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-连接mysql数据库\"><a href=\"#2-连接mysql数据库\" class=\"headerlink\" title=\"2. 连接mysql数据库\"></a>2. 连接mysql数据库</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">//连接mysql数据库\nvar connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'lgn970722',\n    port: '3306',\n    database: 'mySpider',\n    useConnectionPooling: true,\n    timezone: '08:00'\n  });\nconnection.connect();\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"3-分页complex-table-data-mysql数据\"><a href=\"#3-分页complex-table-data-mysql数据\" class=\"headerlink\" title=\"3. 分页complex_table_data mysql数据\"></a>3. 分页complex_table_data mysql数据</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">app.get('/complex-table_data', function (req, res) {\n    var response = {\n        \"page\":req.query.page,\n        \"limit\":req.query.limit,\n    };\n    console.log(req.query.page)\n    //  var selectSQL = \"SELECT * from alarmData\";\n    //\n    a = (response.page - 1) * req.query.limit;\n    console.log('a:' + a);\n    var selectSQL = \"select * from complex_table_data limit \"+  req.query.limit +\" offset \" + a;\n\nconnection.query(selectSQL, function (err, result) {\n  if (err) {\n    console.log('[data ERROR] - ', err.message);\n    return;\n  }\n  //console.log(result);\n  if (result == '') {\n    console.log(\"数据没了\");\n    res.end(\"0\");//如果登录失败就给客户端返回0，\n  }\n  else {\n    // console.log(selectSQL);\n    console.log(result);\n    // res.json({success_code: 200, message: '获取分页数据成功', data: results })\n    // for (var i = 0; i < result.length; i++) {\n    //   result[i].alarmGrade = +result[i].alarmGrade\n\n    // };\n    console.log(result);\n    //解决中文乱码，加入头文件\n    // res.writeHead(200, { 'Content-Type': 'text/html;charset=utf-8' })\n    res.end(JSON.stringify({\n        code :20000,\n        data: {\n            total: 100,\n            items: result\n        }\n    }));\n    // res.json(data:result)\n\n  }\n});\n//  console.log(result);\n//res.end(JSON.stringify(response));\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"4-创建get接口，获取本地json数据，以便用于测试\"><a href=\"#4-创建get接口，获取本地json数据，以便用于测试\" class=\"headerlink\" title=\"4. 创建get接口，获取本地json数据，以便用于测试\"></a>4. 创建get接口，获取本地json数据，以便用于测试</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">//创建get接口\napp.get('/api', function(req, res) {\n    //console.log(req.body); //获取请求参数\n\nvar file = path.join(__dirname, 'data/test.json'); //文件路径，__dirname为当前运行js文件的目录\n//var file = 'f:\\\\nodejs\\\\data\\\\test.json'; //也可以用这种方式指定路径\n\n//读取json文件\nfs.readFile(file, 'utf-8', function(err, data) {\n    if (err) {\n        res.send('文件读取失败');\n    } else {\n        res.send(data);\n        console.log('数据读取成功');\n    }\n});\n});\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"5-运行端口\"><a href=\"#5-运行端口\" class=\"headerlink\" title=\"5. 运行端口\"></a>5. 运行端口</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">var server = app.listen(8080, function () {\n\n    var host = server.address().address\n    var port = server.address().port\n\n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n})\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"NodeJS后台环境部署\"><a href=\"#NodeJS后台环境部署\" class=\"headerlink\" title=\"NodeJS后台环境部署\"></a>NodeJS后台环境部署</h1><h3 id=\"1-建立环境\"><a href=\"#1-建立环境\" class=\"headerlink\" title=\"1. 建立环境\"></a>1. 建立环境</h3><pre><code class=\"lang-bash\"># 建立nodejs后台环境\nnode create 项目名称\nvar express = require(&#39;express&#39;); //express框架模块\nvar path = require(&#39;path&#39;); //系统路径模块\nvar fs = require(&#39;fs&#39;); //文件模块\nvar bodyParser = require(&#39;body-parser&#39;); //对post请求的请求体进行解析模块\nvar app = express();\nvar mysql = require(&#39;mysql&#39;);  //导入mysql包\nvar cors = require(&quot;cors&quot;); // 解决跨域问题.npm install cors 装一下\n</code></pre>\n<h3 id=\"2-连接mysql数据库\"><a href=\"#2-连接mysql数据库\" class=\"headerlink\" title=\"2. 连接mysql数据库\"></a>2. 连接mysql数据库</h3><pre><code class=\"lang-bash\">//连接mysql数据库\nvar connection = mysql.createConnection({\n    host: &#39;localhost&#39;,\n    user: &#39;root&#39;,\n    password: &#39;lgn970722&#39;,\n    port: &#39;3306&#39;,\n    database: &#39;mySpider&#39;,\n    useConnectionPooling: true,\n    timezone: &#39;08:00&#39;\n  });\nconnection.connect();\n</code></pre>\n<h3 id=\"3-分页complex-table-data-mysql数据\"><a href=\"#3-分页complex-table-data-mysql数据\" class=\"headerlink\" title=\"3. 分页complex_table_data mysql数据\"></a>3. 分页complex_table_data mysql数据</h3><pre><code class=\"lang-bash\">app.get(&#39;/complex-table_data&#39;, function (req, res) {\n    var response = {\n        &quot;page&quot;:req.query.page,\n        &quot;limit&quot;:req.query.limit,\n    };\n    console.log(req.query.page)\n    //  var selectSQL = &quot;SELECT * from alarmData&quot;;\n    //\n    a = (response.page - 1) * req.query.limit;\n    console.log(&#39;a:&#39; + a);\n    var selectSQL = &quot;select * from complex_table_data limit &quot;+  req.query.limit +&quot; offset &quot; + a;\n\nconnection.query(selectSQL, function (err, result) {\n  if (err) {\n    console.log(&#39;[data ERROR] - &#39;, err.message);\n    return;\n  }\n  //console.log(result);\n  if (result == &#39;&#39;) {\n    console.log(&quot;数据没了&quot;);\n    res.end(&quot;0&quot;);//如果登录失败就给客户端返回0，\n  }\n  else {\n    // console.log(selectSQL);\n    console.log(result);\n    // res.json({success_code: 200, message: &#39;获取分页数据成功&#39;, data: results })\n    // for (var i = 0; i &lt; result.length; i++) {\n    //   result[i].alarmGrade = +result[i].alarmGrade\n\n    // };\n    console.log(result);\n    //解决中文乱码，加入头文件\n    // res.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html;charset=utf-8&#39; })\n    res.end(JSON.stringify({\n        code :20000,\n        data: {\n            total: 100,\n            items: result\n        }\n    }));\n    // res.json(data:result)\n\n  }\n});\n//  console.log(result);\n//res.end(JSON.stringify(response));\n</code></pre>\n<h3 id=\"4-创建get接口，获取本地json数据，以便用于测试\"><a href=\"#4-创建get接口，获取本地json数据，以便用于测试\" class=\"headerlink\" title=\"4. 创建get接口，获取本地json数据，以便用于测试\"></a>4. 创建get接口，获取本地json数据，以便用于测试</h3><pre><code class=\"lang-bash\">//创建get接口\napp.get(&#39;/api&#39;, function(req, res) {\n    //console.log(req.body); //获取请求参数\n\nvar file = path.join(__dirname, &#39;data/test.json&#39;); //文件路径，__dirname为当前运行js文件的目录\n//var file = &#39;f:\\\\nodejs\\\\data\\\\test.json&#39;; //也可以用这种方式指定路径\n\n//读取json文件\nfs.readFile(file, &#39;utf-8&#39;, function(err, data) {\n    if (err) {\n        res.send(&#39;文件读取失败&#39;);\n    } else {\n        res.send(data);\n        console.log(&#39;数据读取成功&#39;);\n    }\n});\n});\n</code></pre>\n<h3 id=\"5-运行端口\"><a href=\"#5-运行端口\" class=\"headerlink\" title=\"5. 运行端口\"></a>5. 运行端口</h3><pre><code class=\"lang-bash\">var server = app.listen(8080, function () {\n\n    var host = server.address().address\n    var port = server.address().port\n\n    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)\n})\n</code></pre>\n"},{"title":"图相关代码","top":false,"cover":false,"toc":false,"mathjax":false,"summary":"图代码整理","abbrlink":"ad5b","date":"2020-09-08T12:24:21.000Z","password":null,"_content":"## 图相关代码\n\n> #### 1.邻接矩阵存储结构定义\n\n```c\n#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef char VertexType;                   //顶点的数据类型\ntypedef int EdgeType;                      //带权图中边上权值的数据类型\ntypedef struct{\n    char Vex[MaxVertexNum];                //顶点表\n    int Edge[MaxVertexNum][MaxVertexNum];  //邻接矩阵，边表\n    int vexnum,arcnum;                     //图的当前顶点数和弧数\n}MGraph;\n```\n\n> #### 2.邻接表存储结构定义\n\n```c\n#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef struct ArcNode{                    //边表结点\n    int adjvex;                            //邻接顶点\n    struct ArcNode *nextarc;                  //指向下一条边\n    //InfoType info;                       //网的边权值\n}ArcNode;//邻接表的边类型\ntypedef struct VNode{                      //顶点表结点\n    char data;                             //顶点信息\n    ArcNode *firstarc;                        //指向第一条邻接边的指针\n}VNode;//邻接表的顶点类型\ntypedef struct{\n    VNode vexset[MaxSize];   //顶点集，每个顶点都有指向第一条边的指针，所以不用定义边集\n    int vexnum,arcnum;                     //顶点数和边数\n}ALGraph;                                  //ALGraph是以邻接表存储的图类型\n```\n\n> #### 3.广度优先搜索（BFS）\n\n```c\nbool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid BFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(i=0;i<G.vexnum;++i){\n        visited[i] = FALSE;          //访问标记数组初始化\n    }\n    InitQueue(Q);                    //初始化辅助队列Q\n    for(i=0;i<G.vexnum;==i){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            BFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid BFS(Graph G,int v){             //从定点v出发，广度优先遍历图G\n    visit(v);                        //访问初始顶点v\n    visited[v] = TRUE;               //对v做已访问标记\n    Enqueue(Q,v);                    //顶点v入队列Q\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);                //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n```\n\n> #### 4.BFS算法求解单元最短路径\n\n```c\nvoid BFS_MIN_Distance(Graph G,int u){\n    int d[G.vexnum];\n    //d[i]表示从u到i的最短路径\n    for(int i=0;i<G.vexnum;i++){\n        d[i] = 1000000;              //初始化路径长度\n    }\n    visited[u] = TRUE;\n    d[u] = 0;\n    EnQueue(Q,u);\n    while(!IsEmpty(Q)){              //BFS算法主过程\n        Dequeue(Q,u);                //对头元素u出队\n        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w)){\n                                     //检测u所有邻接点\n            if(!visited[w]){         //w为u的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                d[w] = d[u] + 1;     //路径长度加1\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n```\n\n> #### 5.深度优先搜索（DFS）递归\n\n```c\nbool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid DFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(v=0;v<G.vexnum;++v){\n        visited[v] = FALSE;          //访问标记数组初始化\n    }\n    for(v=0;v<G.vexnum;++v){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            DFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid DFS(Graph G,int v){\n    visit(v);                        //访问顶点v\n    visited[v] = TRUE;               //设已访问标记\n    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                DFS(G,w);\n            }//if\n        }\n}\n```\n\n> #### 6.深度优先搜索（DFS）非递归\n\n- 因为使用了栈，使得遍历的方式从右到左进行，但仍然是深度优先遍历\n\n```c\nvoid DFS_Non_Rc(Graph G,int v){\n    //从顶点v开始进行深度优先搜索，一次遍历一个连通分量的所有顶点\n    int w;                             //顶点序号\n    InitStack(S);                      //初始化栈S\n    for(int i=0;i<G.vexnum;i++){\n        visited[i] = FALSE;            //初始化visited\n    }\n    push(S,v);                         //v入栈\n    visited[v] = TRUE;                 //并且置visited[v]为真\n    while(!IsEmpty(S)){\n        k = Pop(S);                    //栈中退出一个顶点\n        visit(k);                      //先访问，再将其子结点入栈\n        for(w=FirstNeighbor(G,k);w>=0;w=NextNeighbor(G,k,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                Push(S,w);             //访问顶点w\n                visited[w] = TRUE;     //对w做已访问标记\n            }//if\n        }\n    }//while\n}//DFS_Non_Rc\n```\n\n> #### 7.判断图是否为一棵树\n\n- 如果有环，则失败，不是一棵树\n\n```c\nbool BFS(Graph G,int v){\n    visit(v);//\n    visited[v] = TRUE;//\n    Enqueue(Q,v);//\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);//\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                visited[w] = TRUE;     //对w做已访问标记\n                Enqueue(Q,w);//\n            }else{\n                return false;\n            }\n        }\n    }//while\n    return true;\n}\n```\n\n> #### 8.找出u结点到v结点的所有路径\n\n- 基于深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。\n- 为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。\n\n```c\nvoid FindPath(Graph G,int u,int v,int path[],int d){\n    int w,i;\n    ArcNode *p;                   //邻接表定义方法\n    d++;                          //路径长度加一\n    path[d] = u;                  //写入路径数组\n    visited[u] = 1;               //已访问过标记\n    if(u == v){\n        print(path[]);            //输出路径\n    }\n    p = G->adjlist[u].firstarc;   //找到相邻接点\n    while(p!=NULL){\n        w = p->adjvex;            //w未被访问，则递归访问\n        if(visited[w] == 0){\n            FindPath(G,w,V,path,d);\n        }\n        p = p->nextarc;           //指向u的下一个结点\n    }\n    visited[u] = 0;               //恢复环境，使该顶点可重新使用\n    \n}\n```\n\n","source":"_posts/图相关代码.md","raw":"---\ntitle: 图相关代码\ntop: false\ncover: false\ntoc: false\nmathjax: false\ntags:\n  - 代码\n  - 考研\n  - 图\ncategories:\n  - 代码\nsummary: 图代码整理\nabbrlink: ad5b\ndate: 2020-09-08 20:24:21\npassword:\n---\n## 图相关代码\n\n> #### 1.邻接矩阵存储结构定义\n\n```c\n#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef char VertexType;                   //顶点的数据类型\ntypedef int EdgeType;                      //带权图中边上权值的数据类型\ntypedef struct{\n    char Vex[MaxVertexNum];                //顶点表\n    int Edge[MaxVertexNum][MaxVertexNum];  //邻接矩阵，边表\n    int vexnum,arcnum;                     //图的当前顶点数和弧数\n}MGraph;\n```\n\n> #### 2.邻接表存储结构定义\n\n```c\n#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef struct ArcNode{                    //边表结点\n    int adjvex;                            //邻接顶点\n    struct ArcNode *nextarc;                  //指向下一条边\n    //InfoType info;                       //网的边权值\n}ArcNode;//邻接表的边类型\ntypedef struct VNode{                      //顶点表结点\n    char data;                             //顶点信息\n    ArcNode *firstarc;                        //指向第一条邻接边的指针\n}VNode;//邻接表的顶点类型\ntypedef struct{\n    VNode vexset[MaxSize];   //顶点集，每个顶点都有指向第一条边的指针，所以不用定义边集\n    int vexnum,arcnum;                     //顶点数和边数\n}ALGraph;                                  //ALGraph是以邻接表存储的图类型\n```\n\n> #### 3.广度优先搜索（BFS）\n\n```c\nbool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid BFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(i=0;i<G.vexnum;++i){\n        visited[i] = FALSE;          //访问标记数组初始化\n    }\n    InitQueue(Q);                    //初始化辅助队列Q\n    for(i=0;i<G.vexnum;==i){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            BFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid BFS(Graph G,int v){             //从定点v出发，广度优先遍历图G\n    visit(v);                        //访问初始顶点v\n    visited[v] = TRUE;               //对v做已访问标记\n    Enqueue(Q,v);                    //顶点v入队列Q\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);                //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n```\n\n> #### 4.BFS算法求解单元最短路径\n\n```c\nvoid BFS_MIN_Distance(Graph G,int u){\n    int d[G.vexnum];\n    //d[i]表示从u到i的最短路径\n    for(int i=0;i<G.vexnum;i++){\n        d[i] = 1000000;              //初始化路径长度\n    }\n    visited[u] = TRUE;\n    d[u] = 0;\n    EnQueue(Q,u);\n    while(!IsEmpty(Q)){              //BFS算法主过程\n        Dequeue(Q,u);                //对头元素u出队\n        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w)){\n                                     //检测u所有邻接点\n            if(!visited[w]){         //w为u的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                d[w] = d[u] + 1;     //路径长度加1\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n```\n\n> #### 5.深度优先搜索（DFS）递归\n\n```c\nbool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid DFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(v=0;v<G.vexnum;++v){\n        visited[v] = FALSE;          //访问标记数组初始化\n    }\n    for(v=0;v<G.vexnum;++v){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            DFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid DFS(Graph G,int v){\n    visit(v);                        //访问顶点v\n    visited[v] = TRUE;               //设已访问标记\n    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                DFS(G,w);\n            }//if\n        }\n}\n```\n\n> #### 6.深度优先搜索（DFS）非递归\n\n- 因为使用了栈，使得遍历的方式从右到左进行，但仍然是深度优先遍历\n\n```c\nvoid DFS_Non_Rc(Graph G,int v){\n    //从顶点v开始进行深度优先搜索，一次遍历一个连通分量的所有顶点\n    int w;                             //顶点序号\n    InitStack(S);                      //初始化栈S\n    for(int i=0;i<G.vexnum;i++){\n        visited[i] = FALSE;            //初始化visited\n    }\n    push(S,v);                         //v入栈\n    visited[v] = TRUE;                 //并且置visited[v]为真\n    while(!IsEmpty(S)){\n        k = Pop(S);                    //栈中退出一个顶点\n        visit(k);                      //先访问，再将其子结点入栈\n        for(w=FirstNeighbor(G,k);w>=0;w=NextNeighbor(G,k,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                Push(S,w);             //访问顶点w\n                visited[w] = TRUE;     //对w做已访问标记\n            }//if\n        }\n    }//while\n}//DFS_Non_Rc\n```\n\n> #### 7.判断图是否为一棵树\n\n- 如果有环，则失败，不是一棵树\n\n```c\nbool BFS(Graph G,int v){\n    visit(v);//\n    visited[v] = TRUE;//\n    Enqueue(Q,v);//\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);//\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                visited[w] = TRUE;     //对w做已访问标记\n                Enqueue(Q,w);//\n            }else{\n                return false;\n            }\n        }\n    }//while\n    return true;\n}\n```\n\n> #### 8.找出u结点到v结点的所有路径\n\n- 基于深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。\n- 为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。\n\n```c\nvoid FindPath(Graph G,int u,int v,int path[],int d){\n    int w,i;\n    ArcNode *p;                   //邻接表定义方法\n    d++;                          //路径长度加一\n    path[d] = u;                  //写入路径数组\n    visited[u] = 1;               //已访问过标记\n    if(u == v){\n        print(path[]);            //输出路径\n    }\n    p = G->adjlist[u].firstarc;   //找到相邻接点\n    while(p!=NULL){\n        w = p->adjvex;            //w未被访问，则递归访问\n        if(visited[w] == 0){\n            FindPath(G,w,V,path,d);\n        }\n        p = p->nextarc;           //指向u的下一个结点\n    }\n    visited[u] = 0;               //恢复环境，使该顶点可重新使用\n    \n}\n```\n\n","slug":"图相关代码","published":1,"updated":"2020-10-07T11:12:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5w002wa09k9uq6gx7h","content":"<h2 id=\"图相关代码\"><a href=\"#图相关代码\" class=\"headerlink\" title=\"图相关代码\"></a>图相关代码</h2><blockquote>\n<h4 id=\"1-邻接矩阵存储结构定义\"><a href=\"#1-邻接矩阵存储结构定义\" class=\"headerlink\" title=\"1.邻接矩阵存储结构定义\"></a>1.邻接矩阵存储结构定义</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef char VertexType;                   //顶点的数据类型\ntypedef int EdgeType;                      //带权图中边上权值的数据类型\ntypedef struct{\n    char Vex[MaxVertexNum];                //顶点表\n    int Edge[MaxVertexNum][MaxVertexNum];  //邻接矩阵，边表\n    int vexnum,arcnum;                     //图的当前顶点数和弧数\n}MGraph;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"2-邻接表存储结构定义\"><a href=\"#2-邻接表存储结构定义\" class=\"headerlink\" title=\"2.邻接表存储结构定义\"></a>2.邻接表存储结构定义</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef struct ArcNode{                    //边表结点\n    int adjvex;                            //邻接顶点\n    struct ArcNode *nextarc;                  //指向下一条边\n    //InfoType info;                       //网的边权值\n}ArcNode;//邻接表的边类型\ntypedef struct VNode{                      //顶点表结点\n    char data;                             //顶点信息\n    ArcNode *firstarc;                        //指向第一条邻接边的指针\n}VNode;//邻接表的顶点类型\ntypedef struct{\n    VNode vexset[MaxSize];   //顶点集，每个顶点都有指向第一条边的指针，所以不用定义边集\n    int vexnum,arcnum;                     //顶点数和边数\n}ALGraph;                                  //ALGraph是以邻接表存储的图类型\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"3-广度优先搜索（BFS）\"><a href=\"#3-广度优先搜索（BFS）\" class=\"headerlink\" title=\"3.广度优先搜索（BFS）\"></a>3.广度优先搜索（BFS）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid BFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(i=0;i<G.vexnum;++i){\n        visited[i] = FALSE;          //访问标记数组初始化\n    }\n    InitQueue(Q);                    //初始化辅助队列Q\n    for(i=0;i<G.vexnum;==i){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            BFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid BFS(Graph G,int v){             //从定点v出发，广度优先遍历图G\n    visit(v);                        //访问初始顶点v\n    visited[v] = TRUE;               //对v做已访问标记\n    Enqueue(Q,v);                    //顶点v入队列Q\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);                //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"4-BFS算法求解单元最短路径\"><a href=\"#4-BFS算法求解单元最短路径\" class=\"headerlink\" title=\"4.BFS算法求解单元最短路径\"></a>4.BFS算法求解单元最短路径</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void BFS_MIN_Distance(Graph G,int u){\n    int d[G.vexnum];\n    //d[i]表示从u到i的最短路径\n    for(int i=0;i<G.vexnum;i++){\n        d[i] = 1000000;              //初始化路径长度\n    }\n    visited[u] = TRUE;\n    d[u] = 0;\n    EnQueue(Q,u);\n    while(!IsEmpty(Q)){              //BFS算法主过程\n        Dequeue(Q,u);                //对头元素u出队\n        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w)){\n                                     //检测u所有邻接点\n            if(!visited[w]){         //w为u的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                d[w] = d[u] + 1;     //路径长度加1\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"5-深度优先搜索（DFS）递归\"><a href=\"#5-深度优先搜索（DFS）递归\" class=\"headerlink\" title=\"5.深度优先搜索（DFS）递归\"></a>5.深度优先搜索（DFS）递归</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid DFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(v=0;v<G.vexnum;++v){\n        visited[v] = FALSE;          //访问标记数组初始化\n    }\n    for(v=0;v<G.vexnum;++v){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            DFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid DFS(Graph G,int v){\n    visit(v);                        //访问顶点v\n    visited[v] = TRUE;               //设已访问标记\n    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                DFS(G,w);\n            }//if\n        }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"6-深度优先搜索（DFS）非递归\"><a href=\"#6-深度优先搜索（DFS）非递归\" class=\"headerlink\" title=\"6.深度优先搜索（DFS）非递归\"></a>6.深度优先搜索（DFS）非递归</h4></blockquote>\n<ul>\n<li>因为使用了栈，使得遍历的方式从右到左进行，但仍然是深度优先遍历</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void DFS_Non_Rc(Graph G,int v){\n    //从顶点v开始进行深度优先搜索，一次遍历一个连通分量的所有顶点\n    int w;                             //顶点序号\n    InitStack(S);                      //初始化栈S\n    for(int i=0;i<G.vexnum;i++){\n        visited[i] = FALSE;            //初始化visited\n    }\n    push(S,v);                         //v入栈\n    visited[v] = TRUE;                 //并且置visited[v]为真\n    while(!IsEmpty(S)){\n        k = Pop(S);                    //栈中退出一个顶点\n        visit(k);                      //先访问，再将其子结点入栈\n        for(w=FirstNeighbor(G,k);w>=0;w=NextNeighbor(G,k,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                Push(S,w);             //访问顶点w\n                visited[w] = TRUE;     //对w做已访问标记\n            }//if\n        }\n    }//while\n}//DFS_Non_Rc\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"7-判断图是否为一棵树\"><a href=\"#7-判断图是否为一棵树\" class=\"headerlink\" title=\"7.判断图是否为一棵树\"></a>7.判断图是否为一棵树</h4></blockquote>\n<ul>\n<li>如果有环，则失败，不是一棵树</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool BFS(Graph G,int v){\n    visit(v);//\n    visited[v] = TRUE;//\n    Enqueue(Q,v);//\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);//\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                visited[w] = TRUE;     //对w做已访问标记\n                Enqueue(Q,w);//\n            }else{\n                return false;\n            }\n        }\n    }//while\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"8-找出u结点到v结点的所有路径\"><a href=\"#8-找出u结点到v结点的所有路径\" class=\"headerlink\" title=\"8.找出u结点到v结点的所有路径\"></a>8.找出u结点到v结点的所有路径</h4></blockquote>\n<ul>\n<li>基于深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。</li>\n<li>为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void FindPath(Graph G,int u,int v,int path[],int d){\n    int w,i;\n    ArcNode *p;                   //邻接表定义方法\n    d++;                          //路径长度加一\n    path[d] = u;                  //写入路径数组\n    visited[u] = 1;               //已访问过标记\n    if(u == v){\n        print(path[]);            //输出路径\n    }\n    p = G->adjlist[u].firstarc;   //找到相邻接点\n    while(p!=NULL){\n        w = p->adjvex;            //w未被访问，则递归访问\n        if(visited[w] == 0){\n            FindPath(G,w,V,path,d);\n        }\n        p = p->nextarc;           //指向u的下一个结点\n    }\n    visited[u] = 0;               //恢复环境，使该顶点可重新使用\n\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"图相关代码\"><a href=\"#图相关代码\" class=\"headerlink\" title=\"图相关代码\"></a>图相关代码</h2><blockquote>\n<h4 id=\"1-邻接矩阵存储结构定义\"><a href=\"#1-邻接矩阵存储结构定义\" class=\"headerlink\" title=\"1.邻接矩阵存储结构定义\"></a>1.邻接矩阵存储结构定义</h4></blockquote>\n<pre><code class=\"lang-c\">#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef char VertexType;                   //顶点的数据类型\ntypedef int EdgeType;                      //带权图中边上权值的数据类型\ntypedef struct{\n    char Vex[MaxVertexNum];                //顶点表\n    int Edge[MaxVertexNum][MaxVertexNum];  //邻接矩阵，边表\n    int vexnum,arcnum;                     //图的当前顶点数和弧数\n}MGraph;\n</code></pre>\n<blockquote>\n<h4 id=\"2-邻接表存储结构定义\"><a href=\"#2-邻接表存储结构定义\" class=\"headerlink\" title=\"2.邻接表存储结构定义\"></a>2.邻接表存储结构定义</h4></blockquote>\n<pre><code class=\"lang-c\">#define MaxVertexNum 100                   //顶点数目的最大值\ntypedef struct ArcNode{                    //边表结点\n    int adjvex;                            //邻接顶点\n    struct ArcNode *nextarc;                  //指向下一条边\n    //InfoType info;                       //网的边权值\n}ArcNode;//邻接表的边类型\ntypedef struct VNode{                      //顶点表结点\n    char data;                             //顶点信息\n    ArcNode *firstarc;                        //指向第一条邻接边的指针\n}VNode;//邻接表的顶点类型\ntypedef struct{\n    VNode vexset[MaxSize];   //顶点集，每个顶点都有指向第一条边的指针，所以不用定义边集\n    int vexnum,arcnum;                     //顶点数和边数\n}ALGraph;                                  //ALGraph是以邻接表存储的图类型\n</code></pre>\n<blockquote>\n<h4 id=\"3-广度优先搜索（BFS）\"><a href=\"#3-广度优先搜索（BFS）\" class=\"headerlink\" title=\"3.广度优先搜索（BFS）\"></a>3.广度优先搜索（BFS）</h4></blockquote>\n<pre><code class=\"lang-c\">bool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid BFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(i=0;i&lt;G.vexnum;++i){\n        visited[i] = FALSE;          //访问标记数组初始化\n    }\n    InitQueue(Q);                    //初始化辅助队列Q\n    for(i=0;i&lt;G.vexnum;==i){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            BFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid BFS(Graph G,int v){             //从定点v出发，广度优先遍历图G\n    visit(v);                        //访问初始顶点v\n    visited[v] = TRUE;               //对v做已访问标记\n    Enqueue(Q,v);                    //顶点v入队列Q\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);                //顶点v出队列\n        for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n</code></pre>\n<blockquote>\n<h4 id=\"4-BFS算法求解单元最短路径\"><a href=\"#4-BFS算法求解单元最短路径\" class=\"headerlink\" title=\"4.BFS算法求解单元最短路径\"></a>4.BFS算法求解单元最短路径</h4></blockquote>\n<pre><code class=\"lang-c\">void BFS_MIN_Distance(Graph G,int u){\n    int d[G.vexnum];\n    //d[i]表示从u到i的最短路径\n    for(int i=0;i&lt;G.vexnum;i++){\n        d[i] = 1000000;              //初始化路径长度\n    }\n    visited[u] = TRUE;\n    d[u] = 0;\n    EnQueue(Q,u);\n    while(!IsEmpty(Q)){              //BFS算法主过程\n        Dequeue(Q,u);                //对头元素u出队\n        for(w=FirstNeighbor(G,u);w&gt;=0;w=NextNeighbor(G,u,w)){\n                                     //检测u所有邻接点\n            if(!visited[w]){         //w为u的尚未访问的邻接结点\n                visit(w);            //访问顶点w\n                visited[w] = TRUE;   //对w做已访问标记\n                d[w] = d[u] + 1;     //路径长度加1\n                Enqueue(Q,w);        //顶点w入队列\n            }//if\n        }\n    }//while\n}\n</code></pre>\n<blockquote>\n<h4 id=\"5-深度优先搜索（DFS）递归\"><a href=\"#5-深度优先搜索（DFS）递归\" class=\"headerlink\" title=\"5.深度优先搜索（DFS）递归\"></a>5.深度优先搜索（DFS）递归</h4></blockquote>\n<pre><code class=\"lang-c\">bool visited[MAX_VERTEX_NUM];        //标记访问数组\nvoid DFSTraverse(Graph G){           //对图G进行广度优先遍历\n    for(v=0;v&lt;G.vexnum;++v){\n        visited[v] = FALSE;          //访问标记数组初始化\n    }\n    for(v=0;v&lt;G.vexnum;++v){         //从0号顶点开始遍历\n        if(!visited[i]){             //对每个连通分量调用一次BFS\n            DFS(G,i);                //vi从未被访问过，从vi开始BFS\n        }\n    }\n}\nvoid DFS(Graph G,int v){\n    visit(v);                        //访问顶点v\n    visited[v] = TRUE;               //设已访问标记\n    for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)){\n                                     //检测v所有邻接点\n            if(!visited[w]){         //w为v的尚未访问的邻接结点\n                DFS(G,w);\n            }//if\n        }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"6-深度优先搜索（DFS）非递归\"><a href=\"#6-深度优先搜索（DFS）非递归\" class=\"headerlink\" title=\"6.深度优先搜索（DFS）非递归\"></a>6.深度优先搜索（DFS）非递归</h4></blockquote>\n<ul>\n<li>因为使用了栈，使得遍历的方式从右到左进行，但仍然是深度优先遍历</li>\n</ul>\n<pre><code class=\"lang-c\">void DFS_Non_Rc(Graph G,int v){\n    //从顶点v开始进行深度优先搜索，一次遍历一个连通分量的所有顶点\n    int w;                             //顶点序号\n    InitStack(S);                      //初始化栈S\n    for(int i=0;i&lt;G.vexnum;i++){\n        visited[i] = FALSE;            //初始化visited\n    }\n    push(S,v);                         //v入栈\n    visited[v] = TRUE;                 //并且置visited[v]为真\n    while(!IsEmpty(S)){\n        k = Pop(S);                    //栈中退出一个顶点\n        visit(k);                      //先访问，再将其子结点入栈\n        for(w=FirstNeighbor(G,k);w&gt;=0;w=NextNeighbor(G,k,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                Push(S,w);             //访问顶点w\n                visited[w] = TRUE;     //对w做已访问标记\n            }//if\n        }\n    }//while\n}//DFS_Non_Rc\n</code></pre>\n<blockquote>\n<h4 id=\"7-判断图是否为一棵树\"><a href=\"#7-判断图是否为一棵树\" class=\"headerlink\" title=\"7.判断图是否为一棵树\"></a>7.判断图是否为一棵树</h4></blockquote>\n<ul>\n<li>如果有环，则失败，不是一棵树</li>\n</ul>\n<pre><code class=\"lang-c\">bool BFS(Graph G,int v){\n    visit(v);//\n    visited[v] = TRUE;//\n    Enqueue(Q,v);//\n    while(!IsEmpty(Q)){\n        Dequeue(Q,v);//\n        for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)){\n                                       //检测k所有邻接点\n            if(!visited[w]){           //w为k的尚未访问的邻接结点\n                visited[w] = TRUE;     //对w做已访问标记\n                Enqueue(Q,w);//\n            }else{\n                return false;\n            }\n        }\n    }//while\n    return true;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"8-找出u结点到v结点的所有路径\"><a href=\"#8-找出u结点到v结点的所有路径\" class=\"headerlink\" title=\"8.找出u结点到v结点的所有路径\"></a>8.找出u结点到v结点的所有路径</h4></blockquote>\n<ul>\n<li>基于深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。</li>\n<li>为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。</li>\n</ul>\n<pre><code class=\"lang-c\">void FindPath(Graph G,int u,int v,int path[],int d){\n    int w,i;\n    ArcNode *p;                   //邻接表定义方法\n    d++;                          //路径长度加一\n    path[d] = u;                  //写入路径数组\n    visited[u] = 1;               //已访问过标记\n    if(u == v){\n        print(path[]);            //输出路径\n    }\n    p = G-&gt;adjlist[u].firstarc;   //找到相邻接点\n    while(p!=NULL){\n        w = p-&gt;adjvex;            //w未被访问，则递归访问\n        if(visited[w] == 0){\n            FindPath(G,w,V,path,d);\n        }\n        p = p-&gt;nextarc;           //指向u的下一个结点\n    }\n    visited[u] = 0;               //恢复环境，使该顶点可重新使用\n\n}\n</code></pre>\n"},{"title":"计网第二章 数据基础通信","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"第二章 数据通信基础","abbrlink":"6b05","date":"2020-07-23T11:36:00.000Z","password":null,"_content":"## 第二章　数据通信基础\n\n1. 数据通信系统的组成：[信源、发送设备]（源系统）、传输系统、[接收设备和信宿]（目的系统）\n2. 比特间隙：发送一比特所用时间\n3. 比特率：每秒发送的比特数（单位：bps），与比特间隙的关系为**倒数关系**\n4. 数字编码\n   - 单极性编码：高电平代表1，低电平代表0\n   - 极化编码\n     - 非归零编码：高电平是1，低电平是0\n     - 非归零反向编码：电平翻转是1，电平不变是0\n     - 双相位编码\n       - 曼彻斯特编码：负电平到正电平为1，正电平到负电平为0\n       \n       - 差分曼彻斯特编码：每个比特的间隙，有跳变为0，没有跳变为1\n       \n\n5. 传输模式\n   - 单工通信：通信是单向的，只有一个可以进行传输，另一个只能接收\n   - 半双工通信：每个站点都可以发送和接收数据，但是不能同时发送和接收数据\n   - 全双工通信：两个站点可以同时发送和接收数据\n   \n6. 并行和串行\n   - 并行：可以同时发送多个比特，每个比特使用单独的一条线路，一次8位，价格贵，距离短\n   - 串行：一次一位传输，速度慢，价格便宜\n\n7. 多路复用技术\n\n   - 频分多路复用FDM：用于模拟信号\n\n   - 时分多路复用TDM：用于数字信号\n\n   - 波分多路复用WDM：光的频分多路复用，用于模拟信号\n\n   - **码分多路复用CDM**：也称码分多址复用CDMA\n\n    - 每个比特被分为m个码片，每个站点被指定一个唯一指定的m位码片（码型）。当发送比特1时，就发送其码片。想发送0时，就发送码片的反码\n  \n    - 所有码片是正交的\n  \n    - 任何码片序列与自己的标乘积为1\n  \n    - 多个站点同时传输，信号线性加强\n  \n    - 要从信号还原站点比特流，通过计算站点码片和信息码片的内标识\n\n8. 数据交换技术\n   - 电路交换：再两个设备之间创建一条临时的物理连接。步骤为电路建立、数据传输和电路拆除\n   - 报文交换：又称存储转发或消息交换。原理为在报文传输过程中，网络的中间节点先将报文暂时储存起来，检查正确性和完整性，然后再发往下一个结点。报文交换技术已被淘汰\n   - 分组交换：又称包交换，可以在中间节点存储，只要信息包到达后就可以转发，不用等到全部报文到达，缩短了信息传输过程的延时时间。**可工作于广播和多播的方式**\n     - 数据报：每个包都独立于其他包处理，任何一条链路可以同时为多对设备之间的通信服务。一次传输的数据报可能不是有次序的到达。重新排序的任务由传输层来完成\n     - 虚电路：路径在数据传输的开始之前就已经确定。仅在建立虚电路时需要目的地址，在数据传送时，每个包不需要携带完整的目的地址，仅需要一个虚电路的号码标志\n\n9. 错误检测和控制\n   - 循环冗余校验码：在待发送信息后加上多项式最高阶个0，用这个数字除以多项式**（同0异1）**，最终余数为多项式最高阶数位，即为循环校验码","source":"_posts/基础通信.md","raw":"---\ntitle: 计网第二章 数据基础通信\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\n  - 男男\ncategories:\n  - 计网\nsummary: 第二章 数据通信基础\nabbrlink: 6b05\ndate: 2020-07-23 19:36:00\npassword:\n---\n## 第二章　数据通信基础\n\n1. 数据通信系统的组成：[信源、发送设备]（源系统）、传输系统、[接收设备和信宿]（目的系统）\n2. 比特间隙：发送一比特所用时间\n3. 比特率：每秒发送的比特数（单位：bps），与比特间隙的关系为**倒数关系**\n4. 数字编码\n   - 单极性编码：高电平代表1，低电平代表0\n   - 极化编码\n     - 非归零编码：高电平是1，低电平是0\n     - 非归零反向编码：电平翻转是1，电平不变是0\n     - 双相位编码\n       - 曼彻斯特编码：负电平到正电平为1，正电平到负电平为0\n       \n       - 差分曼彻斯特编码：每个比特的间隙，有跳变为0，没有跳变为1\n       \n\n5. 传输模式\n   - 单工通信：通信是单向的，只有一个可以进行传输，另一个只能接收\n   - 半双工通信：每个站点都可以发送和接收数据，但是不能同时发送和接收数据\n   - 全双工通信：两个站点可以同时发送和接收数据\n   \n6. 并行和串行\n   - 并行：可以同时发送多个比特，每个比特使用单独的一条线路，一次8位，价格贵，距离短\n   - 串行：一次一位传输，速度慢，价格便宜\n\n7. 多路复用技术\n\n   - 频分多路复用FDM：用于模拟信号\n\n   - 时分多路复用TDM：用于数字信号\n\n   - 波分多路复用WDM：光的频分多路复用，用于模拟信号\n\n   - **码分多路复用CDM**：也称码分多址复用CDMA\n\n    - 每个比特被分为m个码片，每个站点被指定一个唯一指定的m位码片（码型）。当发送比特1时，就发送其码片。想发送0时，就发送码片的反码\n  \n    - 所有码片是正交的\n  \n    - 任何码片序列与自己的标乘积为1\n  \n    - 多个站点同时传输，信号线性加强\n  \n    - 要从信号还原站点比特流，通过计算站点码片和信息码片的内标识\n\n8. 数据交换技术\n   - 电路交换：再两个设备之间创建一条临时的物理连接。步骤为电路建立、数据传输和电路拆除\n   - 报文交换：又称存储转发或消息交换。原理为在报文传输过程中，网络的中间节点先将报文暂时储存起来，检查正确性和完整性，然后再发往下一个结点。报文交换技术已被淘汰\n   - 分组交换：又称包交换，可以在中间节点存储，只要信息包到达后就可以转发，不用等到全部报文到达，缩短了信息传输过程的延时时间。**可工作于广播和多播的方式**\n     - 数据报：每个包都独立于其他包处理，任何一条链路可以同时为多对设备之间的通信服务。一次传输的数据报可能不是有次序的到达。重新排序的任务由传输层来完成\n     - 虚电路：路径在数据传输的开始之前就已经确定。仅在建立虚电路时需要目的地址，在数据传送时，每个包不需要携带完整的目的地址，仅需要一个虚电路的号码标志\n\n9. 错误检测和控制\n   - 循环冗余校验码：在待发送信息后加上多项式最高阶个0，用这个数字除以多项式**（同0异1）**，最终余数为多项式最高阶数位，即为循环校验码","slug":"基础通信","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5x0031a09kd75uh4yt","content":"<h2 id=\"第二章-数据通信基础\"><a href=\"#第二章-数据通信基础\" class=\"headerlink\" title=\"第二章　数据通信基础\"></a>第二章　数据通信基础</h2><ol>\n<li>数据通信系统的组成：[信源、发送设备]（源系统）、传输系统、[接收设备和信宿]（目的系统）</li>\n<li>比特间隙：发送一比特所用时间</li>\n<li>比特率：每秒发送的比特数（单位：bps），与比特间隙的关系为<strong>倒数关系</strong></li>\n<li><p>数字编码</p>\n<ul>\n<li>单极性编码：高电平代表1，低电平代表0</li>\n<li><p>极化编码</p>\n<ul>\n<li>非归零编码：高电平是1，低电平是0</li>\n<li>非归零反向编码：电平翻转是1，电平不变是0</li>\n<li><p>双相位编码</p>\n<ul>\n<li><p>曼彻斯特编码：负电平到正电平为1，正电平到负电平为0</p>\n</li>\n<li><p>差分曼彻斯特编码：每个比特的间隙，有跳变为0，没有跳变为1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>传输模式</p>\n<ul>\n<li>单工通信：通信是单向的，只有一个可以进行传输，另一个只能接收</li>\n<li>半双工通信：每个站点都可以发送和接收数据，但是不能同时发送和接收数据</li>\n<li>全双工通信：两个站点可以同时发送和接收数据</li>\n</ul>\n</li>\n<li><p>并行和串行</p>\n<ul>\n<li>并行：可以同时发送多个比特，每个比特使用单独的一条线路，一次8位，价格贵，距离短</li>\n<li>串行：一次一位传输，速度慢，价格便宜</li>\n</ul>\n</li>\n<li><p>多路复用技术</p>\n<ul>\n<li><p>频分多路复用FDM：用于模拟信号</p>\n</li>\n<li><p>时分多路复用TDM：用于数字信号</p>\n</li>\n<li><p>波分多路复用WDM：光的频分多路复用，用于模拟信号</p>\n</li>\n<li><p><strong>码分多路复用CDM</strong>：也称码分多址复用CDMA</p>\n<ul>\n<li><p>每个比特被分为m个码片，每个站点被指定一个唯一指定的m位码片（码型）。当发送比特1时，就发送其码片。想发送0时，就发送码片的反码</p>\n</li>\n<li><p>所有码片是正交的</p>\n</li>\n<li><p>任何码片序列与自己的标乘积为1</p>\n</li>\n<li><p>多个站点同时传输，信号线性加强</p>\n</li>\n<li><p>要从信号还原站点比特流，通过计算站点码片和信息码片的内标识</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据交换技术</p>\n<ul>\n<li>电路交换：再两个设备之间创建一条临时的物理连接。步骤为电路建立、数据传输和电路拆除</li>\n<li>报文交换：又称存储转发或消息交换。原理为在报文传输过程中，网络的中间节点先将报文暂时储存起来，检查正确性和完整性，然后再发往下一个结点。报文交换技术已被淘汰</li>\n<li>分组交换：又称包交换，可以在中间节点存储，只要信息包到达后就可以转发，不用等到全部报文到达，缩短了信息传输过程的延时时间。<strong>可工作于广播和多播的方式</strong><ul>\n<li>数据报：每个包都独立于其他包处理，任何一条链路可以同时为多对设备之间的通信服务。一次传输的数据报可能不是有次序的到达。重新排序的任务由传输层来完成</li>\n<li>虚电路：路径在数据传输的开始之前就已经确定。仅在建立虚电路时需要目的地址，在数据传送时，每个包不需要携带完整的目的地址，仅需要一个虚电路的号码标志</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>错误检测和控制</p>\n<ul>\n<li>循环冗余校验码：在待发送信息后加上多项式最高阶个0，用这个数字除以多项式<strong>（同0异1）</strong>，最终余数为多项式最高阶数位，即为循环校验码</li>\n</ul>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第二章-数据通信基础\"><a href=\"#第二章-数据通信基础\" class=\"headerlink\" title=\"第二章　数据通信基础\"></a>第二章　数据通信基础</h2><ol>\n<li>数据通信系统的组成：[信源、发送设备]（源系统）、传输系统、[接收设备和信宿]（目的系统）</li>\n<li>比特间隙：发送一比特所用时间</li>\n<li>比特率：每秒发送的比特数（单位：bps），与比特间隙的关系为<strong>倒数关系</strong></li>\n<li><p>数字编码</p>\n<ul>\n<li>单极性编码：高电平代表1，低电平代表0</li>\n<li><p>极化编码</p>\n<ul>\n<li>非归零编码：高电平是1，低电平是0</li>\n<li>非归零反向编码：电平翻转是1，电平不变是0</li>\n<li><p>双相位编码</p>\n<ul>\n<li><p>曼彻斯特编码：负电平到正电平为1，正电平到负电平为0</p>\n</li>\n<li><p>差分曼彻斯特编码：每个比特的间隙，有跳变为0，没有跳变为1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>传输模式</p>\n<ul>\n<li>单工通信：通信是单向的，只有一个可以进行传输，另一个只能接收</li>\n<li>半双工通信：每个站点都可以发送和接收数据，但是不能同时发送和接收数据</li>\n<li>全双工通信：两个站点可以同时发送和接收数据</li>\n</ul>\n</li>\n<li><p>并行和串行</p>\n<ul>\n<li>并行：可以同时发送多个比特，每个比特使用单独的一条线路，一次8位，价格贵，距离短</li>\n<li>串行：一次一位传输，速度慢，价格便宜</li>\n</ul>\n</li>\n<li><p>多路复用技术</p>\n<ul>\n<li><p>频分多路复用FDM：用于模拟信号</p>\n</li>\n<li><p>时分多路复用TDM：用于数字信号</p>\n</li>\n<li><p>波分多路复用WDM：光的频分多路复用，用于模拟信号</p>\n</li>\n<li><p><strong>码分多路复用CDM</strong>：也称码分多址复用CDMA</p>\n<ul>\n<li><p>每个比特被分为m个码片，每个站点被指定一个唯一指定的m位码片（码型）。当发送比特1时，就发送其码片。想发送0时，就发送码片的反码</p>\n</li>\n<li><p>所有码片是正交的</p>\n</li>\n<li><p>任何码片序列与自己的标乘积为1</p>\n</li>\n<li><p>多个站点同时传输，信号线性加强</p>\n</li>\n<li><p>要从信号还原站点比特流，通过计算站点码片和信息码片的内标识</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据交换技术</p>\n<ul>\n<li>电路交换：再两个设备之间创建一条临时的物理连接。步骤为电路建立、数据传输和电路拆除</li>\n<li>报文交换：又称存储转发或消息交换。原理为在报文传输过程中，网络的中间节点先将报文暂时储存起来，检查正确性和完整性，然后再发往下一个结点。报文交换技术已被淘汰</li>\n<li>分组交换：又称包交换，可以在中间节点存储，只要信息包到达后就可以转发，不用等到全部报文到达，缩短了信息传输过程的延时时间。<strong>可工作于广播和多播的方式</strong><ul>\n<li>数据报：每个包都独立于其他包处理，任何一条链路可以同时为多对设备之间的通信服务。一次传输的数据报可能不是有次序的到达。重新排序的任务由传输层来完成</li>\n<li>虚电路：路径在数据传输的开始之前就已经确定。仅在建立虚电路时需要目的地址，在数据传送时，每个包不需要携带完整的目的地址，仅需要一个虚电路的号码标志</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>错误检测和控制</p>\n<ul>\n<li>循环冗余校验码：在待发送信息后加上多项式最高阶个0，用这个数字除以多项式<strong>（同0异1）</strong>，最终余数为多项式最高阶数位，即为循环校验码</li>\n</ul>\n</li>\n</ol>\n"},{"title":"6月份学习计划","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"学习计划","abbrlink":"b0c7","date":"2020-06-04T02:51:50.000Z","password":null,"_content":"<center> <h2>6月份学习计划<h2></center>\n\n| 6月份 | 数学                                                 | 专业课                                                       | 英语                                                         | 政治            | 完成度                           |\n| ----- | ---------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- | -------------------------------- |\n| 6.9   | 1000题高数第8讲BC                                    | 1.2016年数据结构真题   <br>2.计算机网络王道第五章传输层      | 1.恋恋有词Unit5   Lesson2 <br>2.田静、长难句、特殊句式 <br>3.背所学课程单词 | 导论            | **完成**                         |\n| 6.10  | 1000题高数第9讲BC                                    | 1.2015年数据结构真题                                         | 1.恋恋有词Unit5   Lesson3 <br>2.田静、长难句分析、标点与连接词 <br>3.背所学课程单词 | 唯物论          | **数学未完成**                   |\n| 6.11  | 休息一天                                             | 休息一天                                                     | 休息一天                                                     | 休息一天        | **休息一天**                     |\n| 6.12  | 剩余第9讲BC题                                        | 1.2014年数据结构真题                                         | 1.恋恋有词Unit5   Lesson4 <br>2.田静、长难句分析、分析主谓 <br>3.背所学课程单词 | 唯物论-物质观   | **完成**                         |\n| 6.13  | 1000题高数第10讲BC                                   | 1.2013年数据结构真题      <br>2.计算机网络常青藤5、6章对照书复习 | 1.恋恋有词Unit5   Lesson5 <br>2.田静、长难句分析、简化长难句 <br>3.背恋恋有词Unit01单词表   <br>4.背所学课程单词 | 唯物论-意识观   | **完成**                         |\n| 6.14  | 1000题高数第11、12讲BC                               | 1.2012年数据结构真题      <br>2.重点对照常青藤和课本复习计算机网络第五章 | 1.恋恋有词Unit6   Lesson1 <br>2.田静、长难句分析、分裂结构 <br>3.背所学课程单词 | 辩证法两大特征  | **完成**                         |\n| 6.15  | 1.1000题高数第13讲BC                                 | 1.2011年数据结构真题                                         | 1.恋恋有词Unit6   Lesson2 <br>2.田静、长难句分析、嵌套结构 <br>3.背所学课程单词 | 辩证法五对范畴1 | **政治少看一课、恋恋有词未完成** |\n| 6.16  | 1.1000题高数剩余第13讲BC      <br>2.看第四章BC组讲解 | 1.2009年计学数据结构                                         | 1.恋恋有词Unit6   Lesson3 <br>2.田静、长难句分析、平行结构 <br>3.背所学课程单词 | 辩证法五对范畴2 | **完成**                         |\n| 6.17  | 1.1000题高数第14讲BC      <br>2.看第五章BC组讲解     | 1.2008年计学数据结构      <br>2.2018计算机学硕两道代码      <br>3.对照常青藤复习计算机网络第七、八章 | 1.恋恋有词Unit6   Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词 | 对立统一        |                                  |\n| 6.18  | 1.1000题高数第15讲BC                                 | 1.2018年软学数据结构                                         | 1.恋恋有词Unit7   Lesson1 <br>2.李旭、阅读基础、论点论据题 <br>3.背所学课程单词 | 质量互变定律    |                                  |\n| 6.19  | 1.1000题高数第16讲BC                                 | 1.2017年软学数据结构                                         | 1.恋恋有词Unit7   Lesson2 <br>2.李旭、阅读基础、文章续写题 <br>3.背所学课程单词 | 否定之否定定律  |                                  |\n| 6.20  | 1.1000题高数第17讲BC                                 | 1.2018年计专数据结构                                         | 1.恋恋有词Unit7   Lesson3 <br>2.李旭、阅读基础、总结点睛 <br>3.背所学课程单词 | 认识论          |                                  |\n| 6.21  | 1.1000题线代第1、2讲BC                               | 1.2017年计专数据结构                                         | 1.恋恋有词Unit7   Lesson4 <br>2.做真题2010.1并看李旭相应视频 <br>3.背所学课程单词 | 认识的本质      |                                  |\n| 6.22  | 1000题线代第3讲BC                                    | 1.2016年计专数据结构                                         | 1.恋恋有词Unit7   Lesson5 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词 | 真理与价值      |                                  |\n| 6.23  | 1000题线代第4讲BC                                    | 1.2015年计专数据结构                                         | 1.恋恋有词Unit8   Lesson1 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词 | 社会基本矛盾    |                                  |\n| 6.24  | 1000题线代第5讲BC                                    | 1.2014年计专数据结构                                         | 1.恋恋有词Unit8   Lesson2 <br>2.做真题2010.4并看李旭相应视频 <br>3.背所学课程单词 | 社会形态        |                                  |\n| 6.25  | 1000题线代第6讲BC                                    | 1.2013年计专数据结构                                         | 1.恋恋有词Unit8   Lesson3 <br>2.做真题2011.1并看李旭相应视频 <br>3.背所学课程单词 | 商品的两因素    |                                  |\n| 6.26  | 1000题线代第7讲BC                                    | 1.2012年计专数据结构                                         | 1.恋恋有词Unit8   Lesson4 <br>2.做真题2011.2并看李旭相应视频 <br>3.背所学课程单词 | 价值规律        |                                  |\n| 6.27  | 1000题线代第8讲BC                                    | 1.2011年计专数据结构                                         | 1.恋恋有词Unit9   Lesson1 <br>2.做真题2011.3并看李旭相应视频 <br>3.背所学课程单词 | 剩余价值生产    |                                  |\n| 6.28  | 1000题线代第9讲BC                                    | 1.2018年软专数据结构                                         | 1.恋恋有词Unit9   Lesson2 <br>2.做真题2011.4并看李旭相应视频 <br>3.背所学课程单词 | 剩余价值流转    |                                  |\n| 6.29  | 1000题概率第1讲BC                                    | 1.2017年软专数据结构                                         | 1.恋恋有词Unit9   Lesson3 <br>2.做真题2012.1并看李旭相应视频 <br>3.背所学课程单词 | 垄断资本主义    |                                  |\n| 6.30  | 1000题概率第2讲BC                                    | 1.2016年软专数据结构                                         | 1.恋恋有词Unit9   Lesson4 <br>2.做真题2012.2并看李旭相应视频 <br>3.背所学课程单词 | 社会主义        |                                  |\n| 6.31  | 1000题概率第3讲BC                                    | 2018-2007软专                                                | 1.恋恋有词Unit10   Lesson1 <br>2.做真题2012.3并看李旭相应视频 <br>3.背所学课程单词 | 人生的青春      |                                  |\n| 7.1   | 1000题概率第4讲BC                                    |                                                              |                                                              | 人生理想        |                                  |","source":"_posts/学习计划.md","raw":"---\ntitle: 6月份学习计划\ntop: false\ncover: false\ntoc: false\nmathjax: true\nsummary: 学习计划\ntags:\n  - 考研\n  - 计划\ncategories:\n  - 男男\nabbrlink: b0c7\ndate: 2020-06-04 10:51:50\npassword:\n---\n<center> <h2>6月份学习计划<h2></center>\n\n| 6月份 | 数学                                                 | 专业课                                                       | 英语                                                         | 政治            | 完成度                           |\n| ----- | ---------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- | -------------------------------- |\n| 6.9   | 1000题高数第8讲BC                                    | 1.2016年数据结构真题   <br>2.计算机网络王道第五章传输层      | 1.恋恋有词Unit5   Lesson2 <br>2.田静、长难句、特殊句式 <br>3.背所学课程单词 | 导论            | **完成**                         |\n| 6.10  | 1000题高数第9讲BC                                    | 1.2015年数据结构真题                                         | 1.恋恋有词Unit5   Lesson3 <br>2.田静、长难句分析、标点与连接词 <br>3.背所学课程单词 | 唯物论          | **数学未完成**                   |\n| 6.11  | 休息一天                                             | 休息一天                                                     | 休息一天                                                     | 休息一天        | **休息一天**                     |\n| 6.12  | 剩余第9讲BC题                                        | 1.2014年数据结构真题                                         | 1.恋恋有词Unit5   Lesson4 <br>2.田静、长难句分析、分析主谓 <br>3.背所学课程单词 | 唯物论-物质观   | **完成**                         |\n| 6.13  | 1000题高数第10讲BC                                   | 1.2013年数据结构真题      <br>2.计算机网络常青藤5、6章对照书复习 | 1.恋恋有词Unit5   Lesson5 <br>2.田静、长难句分析、简化长难句 <br>3.背恋恋有词Unit01单词表   <br>4.背所学课程单词 | 唯物论-意识观   | **完成**                         |\n| 6.14  | 1000题高数第11、12讲BC                               | 1.2012年数据结构真题      <br>2.重点对照常青藤和课本复习计算机网络第五章 | 1.恋恋有词Unit6   Lesson1 <br>2.田静、长难句分析、分裂结构 <br>3.背所学课程单词 | 辩证法两大特征  | **完成**                         |\n| 6.15  | 1.1000题高数第13讲BC                                 | 1.2011年数据结构真题                                         | 1.恋恋有词Unit6   Lesson2 <br>2.田静、长难句分析、嵌套结构 <br>3.背所学课程单词 | 辩证法五对范畴1 | **政治少看一课、恋恋有词未完成** |\n| 6.16  | 1.1000题高数剩余第13讲BC      <br>2.看第四章BC组讲解 | 1.2009年计学数据结构                                         | 1.恋恋有词Unit6   Lesson3 <br>2.田静、长难句分析、平行结构 <br>3.背所学课程单词 | 辩证法五对范畴2 | **完成**                         |\n| 6.17  | 1.1000题高数第14讲BC      <br>2.看第五章BC组讲解     | 1.2008年计学数据结构      <br>2.2018计算机学硕两道代码      <br>3.对照常青藤复习计算机网络第七、八章 | 1.恋恋有词Unit6   Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词 | 对立统一        |                                  |\n| 6.18  | 1.1000题高数第15讲BC                                 | 1.2018年软学数据结构                                         | 1.恋恋有词Unit7   Lesson1 <br>2.李旭、阅读基础、论点论据题 <br>3.背所学课程单词 | 质量互变定律    |                                  |\n| 6.19  | 1.1000题高数第16讲BC                                 | 1.2017年软学数据结构                                         | 1.恋恋有词Unit7   Lesson2 <br>2.李旭、阅读基础、文章续写题 <br>3.背所学课程单词 | 否定之否定定律  |                                  |\n| 6.20  | 1.1000题高数第17讲BC                                 | 1.2018年计专数据结构                                         | 1.恋恋有词Unit7   Lesson3 <br>2.李旭、阅读基础、总结点睛 <br>3.背所学课程单词 | 认识论          |                                  |\n| 6.21  | 1.1000题线代第1、2讲BC                               | 1.2017年计专数据结构                                         | 1.恋恋有词Unit7   Lesson4 <br>2.做真题2010.1并看李旭相应视频 <br>3.背所学课程单词 | 认识的本质      |                                  |\n| 6.22  | 1000题线代第3讲BC                                    | 1.2016年计专数据结构                                         | 1.恋恋有词Unit7   Lesson5 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词 | 真理与价值      |                                  |\n| 6.23  | 1000题线代第4讲BC                                    | 1.2015年计专数据结构                                         | 1.恋恋有词Unit8   Lesson1 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词 | 社会基本矛盾    |                                  |\n| 6.24  | 1000题线代第5讲BC                                    | 1.2014年计专数据结构                                         | 1.恋恋有词Unit8   Lesson2 <br>2.做真题2010.4并看李旭相应视频 <br>3.背所学课程单词 | 社会形态        |                                  |\n| 6.25  | 1000题线代第6讲BC                                    | 1.2013年计专数据结构                                         | 1.恋恋有词Unit8   Lesson3 <br>2.做真题2011.1并看李旭相应视频 <br>3.背所学课程单词 | 商品的两因素    |                                  |\n| 6.26  | 1000题线代第7讲BC                                    | 1.2012年计专数据结构                                         | 1.恋恋有词Unit8   Lesson4 <br>2.做真题2011.2并看李旭相应视频 <br>3.背所学课程单词 | 价值规律        |                                  |\n| 6.27  | 1000题线代第8讲BC                                    | 1.2011年计专数据结构                                         | 1.恋恋有词Unit9   Lesson1 <br>2.做真题2011.3并看李旭相应视频 <br>3.背所学课程单词 | 剩余价值生产    |                                  |\n| 6.28  | 1000题线代第9讲BC                                    | 1.2018年软专数据结构                                         | 1.恋恋有词Unit9   Lesson2 <br>2.做真题2011.4并看李旭相应视频 <br>3.背所学课程单词 | 剩余价值流转    |                                  |\n| 6.29  | 1000题概率第1讲BC                                    | 1.2017年软专数据结构                                         | 1.恋恋有词Unit9   Lesson3 <br>2.做真题2012.1并看李旭相应视频 <br>3.背所学课程单词 | 垄断资本主义    |                                  |\n| 6.30  | 1000题概率第2讲BC                                    | 1.2016年软专数据结构                                         | 1.恋恋有词Unit9   Lesson4 <br>2.做真题2012.2并看李旭相应视频 <br>3.背所学课程单词 | 社会主义        |                                  |\n| 6.31  | 1000题概率第3讲BC                                    | 2018-2007软专                                                | 1.恋恋有词Unit10   Lesson1 <br>2.做真题2012.3并看李旭相应视频 <br>3.背所学课程单词 | 人生的青春      |                                  |\n| 7.1   | 1000题概率第4讲BC                                    |                                                              |                                                              | 人生理想        |                                  |","slug":"学习计划","published":1,"updated":"2020-08-10T12:34:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5x0033a09k18zq1hf1","content":"<center> <h2>6月份学习计划</h2><h2></h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>6月份</th>\n<th>数学</th>\n<th>专业课</th>\n<th>英语</th>\n<th>政治</th>\n<th>完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6.9</td>\n<td>1000题高数第8讲BC</td>\n<td>1.2016年数据结构真题   <br>2.计算机网络王道第五章传输层</td>\n<td>1.恋恋有词Unit5   Lesson2 <br>2.田静、长难句、特殊句式 <br>3.背所学课程单词</td>\n<td>导论</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.10</td>\n<td>1000题高数第9讲BC</td>\n<td>1.2015年数据结构真题</td>\n<td>1.恋恋有词Unit5   Lesson3 <br>2.田静、长难句分析、标点与连接词 <br>3.背所学课程单词</td>\n<td>唯物论</td>\n<td><strong>数学未完成</strong></td>\n</tr>\n<tr>\n<td>6.11</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><strong>休息一天</strong></td>\n</tr>\n<tr>\n<td>6.12</td>\n<td>剩余第9讲BC题</td>\n<td>1.2014年数据结构真题</td>\n<td>1.恋恋有词Unit5   Lesson4 <br>2.田静、长难句分析、分析主谓 <br>3.背所学课程单词</td>\n<td>唯物论-物质观</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.13</td>\n<td>1000题高数第10讲BC</td>\n<td>1.2013年数据结构真题      <br>2.计算机网络常青藤5、6章对照书复习</td>\n<td>1.恋恋有词Unit5   Lesson5 <br>2.田静、长难句分析、简化长难句 <br>3.背恋恋有词Unit01单词表   <br>4.背所学课程单词</td>\n<td>唯物论-意识观</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.14</td>\n<td>1000题高数第11、12讲BC</td>\n<td>1.2012年数据结构真题      <br>2.重点对照常青藤和课本复习计算机网络第五章</td>\n<td>1.恋恋有词Unit6   Lesson1 <br>2.田静、长难句分析、分裂结构 <br>3.背所学课程单词</td>\n<td>辩证法两大特征</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.15</td>\n<td>1.1000题高数第13讲BC</td>\n<td>1.2011年数据结构真题</td>\n<td>1.恋恋有词Unit6   Lesson2 <br>2.田静、长难句分析、嵌套结构 <br>3.背所学课程单词</td>\n<td>辩证法五对范畴1</td>\n<td><strong>政治少看一课、恋恋有词未完成</strong></td>\n</tr>\n<tr>\n<td>6.16</td>\n<td>1.1000题高数剩余第13讲BC      <br>2.看第四章BC组讲解</td>\n<td>1.2009年计学数据结构</td>\n<td>1.恋恋有词Unit6   Lesson3 <br>2.田静、长难句分析、平行结构 <br>3.背所学课程单词</td>\n<td>辩证法五对范畴2</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.17</td>\n<td>1.1000题高数第14讲BC      <br>2.看第五章BC组讲解</td>\n<td>1.2008年计学数据结构      <br>2.2018计算机学硕两道代码      <br>3.对照常青藤复习计算机网络第七、八章</td>\n<td>1.恋恋有词Unit6   Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词</td>\n<td>对立统一</td>\n<td></td>\n</tr>\n<tr>\n<td>6.18</td>\n<td>1.1000题高数第15讲BC</td>\n<td>1.2018年软学数据结构</td>\n<td>1.恋恋有词Unit7   Lesson1 <br>2.李旭、阅读基础、论点论据题 <br>3.背所学课程单词</td>\n<td>质量互变定律</td>\n<td></td>\n</tr>\n<tr>\n<td>6.19</td>\n<td>1.1000题高数第16讲BC</td>\n<td>1.2017年软学数据结构</td>\n<td>1.恋恋有词Unit7   Lesson2 <br>2.李旭、阅读基础、文章续写题 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td></td>\n</tr>\n<tr>\n<td>6.20</td>\n<td>1.1000题高数第17讲BC</td>\n<td>1.2018年计专数据结构</td>\n<td>1.恋恋有词Unit7   Lesson3 <br>2.李旭、阅读基础、总结点睛 <br>3.背所学课程单词</td>\n<td>认识论</td>\n<td></td>\n</tr>\n<tr>\n<td>6.21</td>\n<td>1.1000题线代第1、2讲BC</td>\n<td>1.2017年计专数据结构</td>\n<td>1.恋恋有词Unit7   Lesson4 <br>2.做真题2010.1并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>认识的本质</td>\n<td></td>\n</tr>\n<tr>\n<td>6.22</td>\n<td>1000题线代第3讲BC</td>\n<td>1.2016年计专数据结构</td>\n<td>1.恋恋有词Unit7   Lesson5 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>真理与价值</td>\n<td></td>\n</tr>\n<tr>\n<td>6.23</td>\n<td>1000题线代第4讲BC</td>\n<td>1.2015年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson1 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>社会基本矛盾</td>\n<td></td>\n</tr>\n<tr>\n<td>6.24</td>\n<td>1000题线代第5讲BC</td>\n<td>1.2014年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson2 <br>2.做真题2010.4并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>社会形态</td>\n<td></td>\n</tr>\n<tr>\n<td>6.25</td>\n<td>1000题线代第6讲BC</td>\n<td>1.2013年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson3 <br>2.做真题2011.1并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>商品的两因素</td>\n<td></td>\n</tr>\n<tr>\n<td>6.26</td>\n<td>1000题线代第7讲BC</td>\n<td>1.2012年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson4 <br>2.做真题2011.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>价值规律</td>\n<td></td>\n</tr>\n<tr>\n<td>6.27</td>\n<td>1000题线代第8讲BC</td>\n<td>1.2011年计专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson1 <br>2.做真题2011.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>剩余价值生产</td>\n<td></td>\n</tr>\n<tr>\n<td>6.28</td>\n<td>1000题线代第9讲BC</td>\n<td>1.2018年软专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson2 <br>2.做真题2011.4并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>剩余价值流转</td>\n<td></td>\n</tr>\n<tr>\n<td>6.29</td>\n<td>1000题概率第1讲BC</td>\n<td>1.2017年软专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson3 <br>2.做真题2012.1并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>垄断资本主义</td>\n<td></td>\n</tr>\n<tr>\n<td>6.30</td>\n<td>1000题概率第2讲BC</td>\n<td>1.2016年软专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson4 <br>2.做真题2012.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>社会主义</td>\n<td></td>\n</tr>\n<tr>\n<td>6.31</td>\n<td>1000题概率第3讲BC</td>\n<td>2018-2007软专</td>\n<td>1.恋恋有词Unit10   Lesson1 <br>2.做真题2012.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>人生的青春</td>\n<td></td>\n</tr>\n<tr>\n<td>7.1</td>\n<td>1000题概率第4讲BC</td>\n<td></td>\n<td></td>\n<td>人生理想</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<center> <h2>6月份学习计划<h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>6月份</th>\n<th>数学</th>\n<th>专业课</th>\n<th>英语</th>\n<th>政治</th>\n<th>完成度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6.9</td>\n<td>1000题高数第8讲BC</td>\n<td>1.2016年数据结构真题   <br>2.计算机网络王道第五章传输层</td>\n<td>1.恋恋有词Unit5   Lesson2 <br>2.田静、长难句、特殊句式 <br>3.背所学课程单词</td>\n<td>导论</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.10</td>\n<td>1000题高数第9讲BC</td>\n<td>1.2015年数据结构真题</td>\n<td>1.恋恋有词Unit5   Lesson3 <br>2.田静、长难句分析、标点与连接词 <br>3.背所学课程单词</td>\n<td>唯物论</td>\n<td><strong>数学未完成</strong></td>\n</tr>\n<tr>\n<td>6.11</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td>休息一天</td>\n<td><strong>休息一天</strong></td>\n</tr>\n<tr>\n<td>6.12</td>\n<td>剩余第9讲BC题</td>\n<td>1.2014年数据结构真题</td>\n<td>1.恋恋有词Unit5   Lesson4 <br>2.田静、长难句分析、分析主谓 <br>3.背所学课程单词</td>\n<td>唯物论-物质观</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.13</td>\n<td>1000题高数第10讲BC</td>\n<td>1.2013年数据结构真题      <br>2.计算机网络常青藤5、6章对照书复习</td>\n<td>1.恋恋有词Unit5   Lesson5 <br>2.田静、长难句分析、简化长难句 <br>3.背恋恋有词Unit01单词表   <br>4.背所学课程单词</td>\n<td>唯物论-意识观</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.14</td>\n<td>1000题高数第11、12讲BC</td>\n<td>1.2012年数据结构真题      <br>2.重点对照常青藤和课本复习计算机网络第五章</td>\n<td>1.恋恋有词Unit6   Lesson1 <br>2.田静、长难句分析、分裂结构 <br>3.背所学课程单词</td>\n<td>辩证法两大特征</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.15</td>\n<td>1.1000题高数第13讲BC</td>\n<td>1.2011年数据结构真题</td>\n<td>1.恋恋有词Unit6   Lesson2 <br>2.田静、长难句分析、嵌套结构 <br>3.背所学课程单词</td>\n<td>辩证法五对范畴1</td>\n<td><strong>政治少看一课、恋恋有词未完成</strong></td>\n</tr>\n<tr>\n<td>6.16</td>\n<td>1.1000题高数剩余第13讲BC      <br>2.看第四章BC组讲解</td>\n<td>1.2009年计学数据结构</td>\n<td>1.恋恋有词Unit6   Lesson3 <br>2.田静、长难句分析、平行结构 <br>3.背所学课程单词</td>\n<td>辩证法五对范畴2</td>\n<td><strong>完成</strong></td>\n</tr>\n<tr>\n<td>6.17</td>\n<td>1.1000题高数第14讲BC      <br>2.看第五章BC组讲解</td>\n<td>1.2008年计学数据结构      <br>2.2018计算机学硕两道代码      <br>3.对照常青藤复习计算机网络第七、八章</td>\n<td>1.恋恋有词Unit6   Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词</td>\n<td>对立统一</td>\n<td></td>\n</tr>\n<tr>\n<td>6.18</td>\n<td>1.1000题高数第15讲BC</td>\n<td>1.2018年软学数据结构</td>\n<td>1.恋恋有词Unit7   Lesson1 <br>2.李旭、阅读基础、论点论据题 <br>3.背所学课程单词</td>\n<td>质量互变定律</td>\n<td></td>\n</tr>\n<tr>\n<td>6.19</td>\n<td>1.1000题高数第16讲BC</td>\n<td>1.2017年软学数据结构</td>\n<td>1.恋恋有词Unit7   Lesson2 <br>2.李旭、阅读基础、文章续写题 <br>3.背所学课程单词</td>\n<td>否定之否定定律</td>\n<td></td>\n</tr>\n<tr>\n<td>6.20</td>\n<td>1.1000题高数第17讲BC</td>\n<td>1.2018年计专数据结构</td>\n<td>1.恋恋有词Unit7   Lesson3 <br>2.李旭、阅读基础、总结点睛 <br>3.背所学课程单词</td>\n<td>认识论</td>\n<td></td>\n</tr>\n<tr>\n<td>6.21</td>\n<td>1.1000题线代第1、2讲BC</td>\n<td>1.2017年计专数据结构</td>\n<td>1.恋恋有词Unit7   Lesson4 <br>2.做真题2010.1并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>认识的本质</td>\n<td></td>\n</tr>\n<tr>\n<td>6.22</td>\n<td>1000题线代第3讲BC</td>\n<td>1.2016年计专数据结构</td>\n<td>1.恋恋有词Unit7   Lesson5 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>真理与价值</td>\n<td></td>\n</tr>\n<tr>\n<td>6.23</td>\n<td>1000题线代第4讲BC</td>\n<td>1.2015年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson1 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>社会基本矛盾</td>\n<td></td>\n</tr>\n<tr>\n<td>6.24</td>\n<td>1000题线代第5讲BC</td>\n<td>1.2014年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson2 <br>2.做真题2010.4并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>社会形态</td>\n<td></td>\n</tr>\n<tr>\n<td>6.25</td>\n<td>1000题线代第6讲BC</td>\n<td>1.2013年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson3 <br>2.做真题2011.1并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>商品的两因素</td>\n<td></td>\n</tr>\n<tr>\n<td>6.26</td>\n<td>1000题线代第7讲BC</td>\n<td>1.2012年计专数据结构</td>\n<td>1.恋恋有词Unit8   Lesson4 <br>2.做真题2011.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>价值规律</td>\n<td></td>\n</tr>\n<tr>\n<td>6.27</td>\n<td>1000题线代第8讲BC</td>\n<td>1.2011年计专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson1 <br>2.做真题2011.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>剩余价值生产</td>\n<td></td>\n</tr>\n<tr>\n<td>6.28</td>\n<td>1000题线代第9讲BC</td>\n<td>1.2018年软专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson2 <br>2.做真题2011.4并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>剩余价值流转</td>\n<td></td>\n</tr>\n<tr>\n<td>6.29</td>\n<td>1000题概率第1讲BC</td>\n<td>1.2017年软专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson3 <br>2.做真题2012.1并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>垄断资本主义</td>\n<td></td>\n</tr>\n<tr>\n<td>6.30</td>\n<td>1000题概率第2讲BC</td>\n<td>1.2016年软专数据结构</td>\n<td>1.恋恋有词Unit9   Lesson4 <br>2.做真题2012.2并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>社会主义</td>\n<td></td>\n</tr>\n<tr>\n<td>6.31</td>\n<td>1000题概率第3讲BC</td>\n<td>2018-2007软专</td>\n<td>1.恋恋有词Unit10   Lesson1 <br>2.做真题2012.3并看李旭相应视频 <br>3.背所学课程单词</td>\n<td>人生的青春</td>\n<td></td>\n</tr>\n<tr>\n<td>7.1</td>\n<td>1000题概率第4讲BC</td>\n<td></td>\n<td></td>\n<td>人生理想</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"强化-计网第三章-数据链路层","top":false,"cover":false,"toc":true,"mathjax":true,"keywords":"吉林大学，考研，计算机网络，数据链路层","description":"吉林大学，考研，计算机网络，数据链路层","summary":"强化-计网第三章-数据链路层","abbrlink":"2fcb","date":"2020-09-23T11:29:11.000Z","password":null,"_content":"## 强化 计网第三章 数据链路层\n\n### 1.线路规划\n\n#### 1.1询问/应答（ENQ/ACK）\n\n- 一条链路两端的**设备级别相同**，任意一个设备都可以启动一个会话过程（**点对点**）\n- 工作方式\n- 启动方首先发送一个**询问帧（ENQ）**询问接收方是否可以接收数据\n- 接收方如果已经**准备好接收**，必须应答一个**确认帧（ACK）**\n- 如果没用做好准备，就必须应答一个否定帧（NAK）\n\n#### 1.2轮询（Poll）/选择（Select）方式\n\n- 有一个设备为主设备，其他设备为从设备的拓补结构中采用（**多点系统**）\n- 每个设备都有一个地址标识自身\n- 信息传输必须通过主设备\n\n##### 1.2.1轮询\n\n- 如果主设备希望**接收**数据，它将逐个询问从设备是否有数据发送，这个功能称为轮询\n\n##### 1.2.2选择\n\n- 如果主设备希望**发送**数据，它告知目标从设备准备好接收数据，这个功能称为选择\n\n### 2.流量控制与差错控制\n\n- 两者是结合在一起实现的，共有两种技术：停止等待协议和滑动窗口协议\n\n#### 2.1差错控制\n\n- 差错控制主要指错误检测和重传方法\n\n#### 2.2自动重复请求（ARQ）\n\n- 在一个帧中出现任何一个错误，接收方就返回一个否认帧，出错的帧就被发送方重新传送。这个过程被称为自动重复请求（ARQ）\n\n#### 2.3停止等待协议\n\n- 发送方每发送一帧后就等待一个确认帧。**只有当接收到确认帧后，发送方才发送下一帧**，这种过程不断交替，直到发送方发送一个传输结束帧（EOT）\n- 优点：简单\n- 缺点：效率低，每次都要等待\n\n##### 2.3.1信道利用率\n\n- 无差错的情况下完成一帧的发送时间为一个**窗口时间WT**:\n\n$$\nWT=t_I+2t_p+2t_{Proc}+t_s\n$$\n\n- **$t_I$是发送一个数据帧的时间**，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒\n\n- **$t_S$是确认帧的发送时间**，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒\n- **$ t_P $是电信号在物理链路上的传播延迟**\n\n- **$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间**\n\n- 无差错信道利用率：\n\n$$\nF=(t_I+t_p)/WT\n$$\n\n- 有效数据传送速率：\n\n$$\nS=N/WT,N:一帧的有效数据位数\n$$\n\n- $t_W \\approx t_I+2t_P$\n\n##### 2.3.2差错控制\n\n###### 2.3.2.1帧破坏\n\n- 自动重复请求（ARQ）\n\n###### 2.3.2.2帧丢失\n\n- 定时器，判断数据帧在传输中丢失，超时自动重发\n\n###### 2.3.2.3应答帧丢失\n\n- 先重传数据帧\n- 数据帧和应答帧以交替的标识0和1出现在数据帧中，每次发送一个新的数据帧，编号信息和上次发送的不一样。这样就可以区分重复的数据帧\n- 丢弃重复帧\n\n#### 2.4滑动窗口协议\n\n##### 2.4.1流量控制\n\n- 在滑动窗口协议中，发送方在收到确认消息前可以发送若干帧。帧可以直接依次发送\n- 接收方使用一个应答帧来对多个数据帧的接收进行确认\n- 在发送方，只要窗口未填满就可以在未收到确认帧的情况下继续发送数据帧\n- **发送方窗口用于存放已经发送但未确认的数据帧和在收到确认帧之前可以发送的数据帧**\n- 例如：\n- 接收方发送了一个编号为5的确认帧，表示接收方收到了5号帧以前的所有帧，希望发送方发送5号帧\n\n##### 2.4.2差错控制\n\n###### 2.4.2.1回退N自动重复请求\n\n- 如果有一帧丢失或者损坏了，未被确认帧确认的帧都必须进行重传\n- <font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸为$n-1$\n\n###### 2.4.2.2选择拒绝自动重复请求\n\n- 只有特定的丢失或损坏帧被重发。接收方收到的数据帧可以是不按顺序到达的\n- 与回退n协议自动重传请求有以下不同：\n- 接收设备必须具有排序的逻辑功能\n- <font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸小于等于$n/2$\n\n##### 2.4.3滑动窗口协议的效率\n\n##### 2.4.4窗口大小的选择\n\n$$\nnt_I>2(t_I+t_P)\n$$\n\n- $t_I$：一个帧的发送时间\n- $t_P$：传播时间\n\n### 3.HDLC高级数据链路控制协议\n\n#### 3.1HDLC帧格式\n\n- 信息帧（I-帧）：用来传输用户数据以及与用户数据有关的控制信息\n- 监控帧（S-帧）：用来传输控制信息，主要是数据链路层流量控制和错误控制信息\n- 无编号帧（U-帧）：用来进行链路管理服务的\n\n##### 3.1.1标志字段\n\n- 标志字段为一个字节（8位），其位模式为01111110\n- 它用来**表示一个帧的开始和结束，并且为接收方提供同步手段**\n\n##### 3.1.2地址字段\n\n- 可以有1个或几个字节的长度\n\n##### 3.1.2控制字段\n\n- 有一个或两个字节\n- 用来进行**流量管理**\n\n### 4.数据链路层网络互联\n\n#### 4.1网桥\n\n- 网桥是一种存储转发设备，用于连接局域网\n- 网桥常用于局域网之间的互联\n- 是数据链路层上的互连设备，网桥同时作用在$OSI$的物理层和数据链路层\n- 网桥具有隔离通信的功能\n\n#### 4.2网桥路由算法\n\n##### 4.2.1固定路由策略 --- 固定路由网桥\n\n##### 4.2.2路由学习策略 --- 透明网桥\n\n###### 4.2.2.1生成树算法\n\n##### 4.2.3源路由策略 --- 源路由网桥","source":"_posts/强化-计网第三章-数据链路层.md","raw":"---\ntitle: 强化-计网第三章-数据链路层\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 计网\n  - 数据链路层\n  - 强化\n  - 总结\n  - 考研\ncategories:\n  - 计网\nkeywords: 吉林大学，考研，计算机网络，数据链路层\ndescription: 吉林大学，考研，计算机网络，数据链路层\nsummary: 强化-计网第三章-数据链路层\nabbrlink: 2fcb\ndate: 2020-09-23 19:29:11\npassword:\n---\n## 强化 计网第三章 数据链路层\n\n### 1.线路规划\n\n#### 1.1询问/应答（ENQ/ACK）\n\n- 一条链路两端的**设备级别相同**，任意一个设备都可以启动一个会话过程（**点对点**）\n- 工作方式\n- 启动方首先发送一个**询问帧（ENQ）**询问接收方是否可以接收数据\n- 接收方如果已经**准备好接收**，必须应答一个**确认帧（ACK）**\n- 如果没用做好准备，就必须应答一个否定帧（NAK）\n\n#### 1.2轮询（Poll）/选择（Select）方式\n\n- 有一个设备为主设备，其他设备为从设备的拓补结构中采用（**多点系统**）\n- 每个设备都有一个地址标识自身\n- 信息传输必须通过主设备\n\n##### 1.2.1轮询\n\n- 如果主设备希望**接收**数据，它将逐个询问从设备是否有数据发送，这个功能称为轮询\n\n##### 1.2.2选择\n\n- 如果主设备希望**发送**数据，它告知目标从设备准备好接收数据，这个功能称为选择\n\n### 2.流量控制与差错控制\n\n- 两者是结合在一起实现的，共有两种技术：停止等待协议和滑动窗口协议\n\n#### 2.1差错控制\n\n- 差错控制主要指错误检测和重传方法\n\n#### 2.2自动重复请求（ARQ）\n\n- 在一个帧中出现任何一个错误，接收方就返回一个否认帧，出错的帧就被发送方重新传送。这个过程被称为自动重复请求（ARQ）\n\n#### 2.3停止等待协议\n\n- 发送方每发送一帧后就等待一个确认帧。**只有当接收到确认帧后，发送方才发送下一帧**，这种过程不断交替，直到发送方发送一个传输结束帧（EOT）\n- 优点：简单\n- 缺点：效率低，每次都要等待\n\n##### 2.3.1信道利用率\n\n- 无差错的情况下完成一帧的发送时间为一个**窗口时间WT**:\n\n$$\nWT=t_I+2t_p+2t_{Proc}+t_s\n$$\n\n- **$t_I$是发送一个数据帧的时间**，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒\n\n- **$t_S$是确认帧的发送时间**，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒\n- **$ t_P $是电信号在物理链路上的传播延迟**\n\n- **$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间**\n\n- 无差错信道利用率：\n\n$$\nF=(t_I+t_p)/WT\n$$\n\n- 有效数据传送速率：\n\n$$\nS=N/WT,N:一帧的有效数据位数\n$$\n\n- $t_W \\approx t_I+2t_P$\n\n##### 2.3.2差错控制\n\n###### 2.3.2.1帧破坏\n\n- 自动重复请求（ARQ）\n\n###### 2.3.2.2帧丢失\n\n- 定时器，判断数据帧在传输中丢失，超时自动重发\n\n###### 2.3.2.3应答帧丢失\n\n- 先重传数据帧\n- 数据帧和应答帧以交替的标识0和1出现在数据帧中，每次发送一个新的数据帧，编号信息和上次发送的不一样。这样就可以区分重复的数据帧\n- 丢弃重复帧\n\n#### 2.4滑动窗口协议\n\n##### 2.4.1流量控制\n\n- 在滑动窗口协议中，发送方在收到确认消息前可以发送若干帧。帧可以直接依次发送\n- 接收方使用一个应答帧来对多个数据帧的接收进行确认\n- 在发送方，只要窗口未填满就可以在未收到确认帧的情况下继续发送数据帧\n- **发送方窗口用于存放已经发送但未确认的数据帧和在收到确认帧之前可以发送的数据帧**\n- 例如：\n- 接收方发送了一个编号为5的确认帧，表示接收方收到了5号帧以前的所有帧，希望发送方发送5号帧\n\n##### 2.4.2差错控制\n\n###### 2.4.2.1回退N自动重复请求\n\n- 如果有一帧丢失或者损坏了，未被确认帧确认的帧都必须进行重传\n- <font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸为$n-1$\n\n###### 2.4.2.2选择拒绝自动重复请求\n\n- 只有特定的丢失或损坏帧被重发。接收方收到的数据帧可以是不按顺序到达的\n- 与回退n协议自动重传请求有以下不同：\n- 接收设备必须具有排序的逻辑功能\n- <font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸小于等于$n/2$\n\n##### 2.4.3滑动窗口协议的效率\n\n##### 2.4.4窗口大小的选择\n\n$$\nnt_I>2(t_I+t_P)\n$$\n\n- $t_I$：一个帧的发送时间\n- $t_P$：传播时间\n\n### 3.HDLC高级数据链路控制协议\n\n#### 3.1HDLC帧格式\n\n- 信息帧（I-帧）：用来传输用户数据以及与用户数据有关的控制信息\n- 监控帧（S-帧）：用来传输控制信息，主要是数据链路层流量控制和错误控制信息\n- 无编号帧（U-帧）：用来进行链路管理服务的\n\n##### 3.1.1标志字段\n\n- 标志字段为一个字节（8位），其位模式为01111110\n- 它用来**表示一个帧的开始和结束，并且为接收方提供同步手段**\n\n##### 3.1.2地址字段\n\n- 可以有1个或几个字节的长度\n\n##### 3.1.2控制字段\n\n- 有一个或两个字节\n- 用来进行**流量管理**\n\n### 4.数据链路层网络互联\n\n#### 4.1网桥\n\n- 网桥是一种存储转发设备，用于连接局域网\n- 网桥常用于局域网之间的互联\n- 是数据链路层上的互连设备，网桥同时作用在$OSI$的物理层和数据链路层\n- 网桥具有隔离通信的功能\n\n#### 4.2网桥路由算法\n\n##### 4.2.1固定路由策略 --- 固定路由网桥\n\n##### 4.2.2路由学习策略 --- 透明网桥\n\n###### 4.2.2.1生成树算法\n\n##### 4.2.3源路由策略 --- 源路由网桥","slug":"强化-计网第三章-数据链路层","published":1,"updated":"2020-09-25T14:34:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5y0037a09k6g2a6jeb","content":"<h2 id=\"强化-计网第三章-数据链路层\"><a href=\"#强化-计网第三章-数据链路层\" class=\"headerlink\" title=\"强化 计网第三章 数据链路层\"></a>强化 计网第三章 数据链路层</h2><h3 id=\"1-线路规划\"><a href=\"#1-线路规划\" class=\"headerlink\" title=\"1.线路规划\"></a>1.线路规划</h3><h4 id=\"1-1询问-应答（ENQ-ACK）\"><a href=\"#1-1询问-应答（ENQ-ACK）\" class=\"headerlink\" title=\"1.1询问/应答（ENQ/ACK）\"></a>1.1询问/应答（ENQ/ACK）</h4><ul>\n<li>一条链路两端的<strong>设备级别相同</strong>，任意一个设备都可以启动一个会话过程（<strong>点对点</strong>）</li>\n<li>工作方式</li>\n<li>启动方首先发送一个<strong>询问帧（ENQ）</strong>询问接收方是否可以接收数据</li>\n<li>接收方如果已经<strong>准备好接收</strong>，必须应答一个<strong>确认帧（ACK）</strong></li>\n<li>如果没用做好准备，就必须应答一个否定帧（NAK）</li>\n</ul>\n<h4 id=\"1-2轮询（Poll）-选择（Select）方式\"><a href=\"#1-2轮询（Poll）-选择（Select）方式\" class=\"headerlink\" title=\"1.2轮询（Poll）/选择（Select）方式\"></a>1.2轮询（Poll）/选择（Select）方式</h4><ul>\n<li>有一个设备为主设备，其他设备为从设备的拓补结构中采用（<strong>多点系统</strong>）</li>\n<li>每个设备都有一个地址标识自身</li>\n<li>信息传输必须通过主设备</li>\n</ul>\n<h5 id=\"1-2-1轮询\"><a href=\"#1-2-1轮询\" class=\"headerlink\" title=\"1.2.1轮询\"></a>1.2.1轮询</h5><ul>\n<li>如果主设备希望<strong>接收</strong>数据，它将逐个询问从设备是否有数据发送，这个功能称为轮询</li>\n</ul>\n<h5 id=\"1-2-2选择\"><a href=\"#1-2-2选择\" class=\"headerlink\" title=\"1.2.2选择\"></a>1.2.2选择</h5><ul>\n<li>如果主设备希望<strong>发送</strong>数据，它告知目标从设备准备好接收数据，这个功能称为选择</li>\n</ul>\n<h3 id=\"2-流量控制与差错控制\"><a href=\"#2-流量控制与差错控制\" class=\"headerlink\" title=\"2.流量控制与差错控制\"></a>2.流量控制与差错控制</h3><ul>\n<li>两者是结合在一起实现的，共有两种技术：停止等待协议和滑动窗口协议</li>\n</ul>\n<h4 id=\"2-1差错控制\"><a href=\"#2-1差错控制\" class=\"headerlink\" title=\"2.1差错控制\"></a>2.1差错控制</h4><ul>\n<li>差错控制主要指错误检测和重传方法</li>\n</ul>\n<h4 id=\"2-2自动重复请求（ARQ）\"><a href=\"#2-2自动重复请求（ARQ）\" class=\"headerlink\" title=\"2.2自动重复请求（ARQ）\"></a>2.2自动重复请求（ARQ）</h4><ul>\n<li>在一个帧中出现任何一个错误，接收方就返回一个否认帧，出错的帧就被发送方重新传送。这个过程被称为自动重复请求（ARQ）</li>\n</ul>\n<h4 id=\"2-3停止等待协议\"><a href=\"#2-3停止等待协议\" class=\"headerlink\" title=\"2.3停止等待协议\"></a>2.3停止等待协议</h4><ul>\n<li>发送方每发送一帧后就等待一个确认帧。<strong>只有当接收到确认帧后，发送方才发送下一帧</strong>，这种过程不断交替，直到发送方发送一个传输结束帧（EOT）</li>\n<li>优点：简单</li>\n<li>缺点：效率低，每次都要等待</li>\n</ul>\n<h5 id=\"2-3-1信道利用率\"><a href=\"#2-3-1信道利用率\" class=\"headerlink\" title=\"2.3.1信道利用率\"></a>2.3.1信道利用率</h5><ul>\n<li>无差错的情况下完成一帧的发送时间为一个<strong>窗口时间WT</strong>:</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nWT=t_I+2t_p+2t_{Proc}+t_s</script><ul>\n<li><p><strong>$t_I$是发送一个数据帧的时间</strong>，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒</p>\n</li>\n<li><p><strong>$t_S$是确认帧的发送时间</strong>，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒</p>\n</li>\n<li><p><strong>$ t_P $是电信号在物理链路上的传播延迟</strong></p>\n</li>\n<li><p><strong>$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间</strong></p>\n</li>\n<li><p>无差错信道利用率：</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nF=(t_I+t_p)/WT</script><ul>\n<li>有效数据传送速率：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nS=N/WT,N:一帧的有效数据位数</script><ul>\n<li>$t_W \\approx t_I+2t_P$</li>\n</ul>\n<h5 id=\"2-3-2差错控制\"><a href=\"#2-3-2差错控制\" class=\"headerlink\" title=\"2.3.2差错控制\"></a>2.3.2差错控制</h5><h6 id=\"2-3-2-1帧破坏\"><a href=\"#2-3-2-1帧破坏\" class=\"headerlink\" title=\"2.3.2.1帧破坏\"></a>2.3.2.1帧破坏</h6><ul>\n<li>自动重复请求（ARQ）</li>\n</ul>\n<h6 id=\"2-3-2-2帧丢失\"><a href=\"#2-3-2-2帧丢失\" class=\"headerlink\" title=\"2.3.2.2帧丢失\"></a>2.3.2.2帧丢失</h6><ul>\n<li>定时器，判断数据帧在传输中丢失，超时自动重发</li>\n</ul>\n<h6 id=\"2-3-2-3应答帧丢失\"><a href=\"#2-3-2-3应答帧丢失\" class=\"headerlink\" title=\"2.3.2.3应答帧丢失\"></a>2.3.2.3应答帧丢失</h6><ul>\n<li>先重传数据帧</li>\n<li>数据帧和应答帧以交替的标识0和1出现在数据帧中，每次发送一个新的数据帧，编号信息和上次发送的不一样。这样就可以区分重复的数据帧</li>\n<li>丢弃重复帧</li>\n</ul>\n<h4 id=\"2-4滑动窗口协议\"><a href=\"#2-4滑动窗口协议\" class=\"headerlink\" title=\"2.4滑动窗口协议\"></a>2.4滑动窗口协议</h4><h5 id=\"2-4-1流量控制\"><a href=\"#2-4-1流量控制\" class=\"headerlink\" title=\"2.4.1流量控制\"></a>2.4.1流量控制</h5><ul>\n<li>在滑动窗口协议中，发送方在收到确认消息前可以发送若干帧。帧可以直接依次发送</li>\n<li>接收方使用一个应答帧来对多个数据帧的接收进行确认</li>\n<li>在发送方，只要窗口未填满就可以在未收到确认帧的情况下继续发送数据帧</li>\n<li><strong>发送方窗口用于存放已经发送但未确认的数据帧和在收到确认帧之前可以发送的数据帧</strong></li>\n<li>例如：</li>\n<li>接收方发送了一个编号为5的确认帧，表示接收方收到了5号帧以前的所有帧，希望发送方发送5号帧</li>\n</ul>\n<h5 id=\"2-4-2差错控制\"><a href=\"#2-4-2差错控制\" class=\"headerlink\" title=\"2.4.2差错控制\"></a>2.4.2差错控制</h5><h6 id=\"2-4-2-1回退N自动重复请求\"><a href=\"#2-4-2-1回退N自动重复请求\" class=\"headerlink\" title=\"2.4.2.1回退N自动重复请求\"></a>2.4.2.1回退N自动重复请求</h6><ul>\n<li>如果有一帧丢失或者损坏了，未被确认帧确认的帧都必须进行重传</li>\n<li><font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸为$n-1$</li>\n</ul>\n<h6 id=\"2-4-2-2选择拒绝自动重复请求\"><a href=\"#2-4-2-2选择拒绝自动重复请求\" class=\"headerlink\" title=\"2.4.2.2选择拒绝自动重复请求\"></a>2.4.2.2选择拒绝自动重复请求</h6><ul>\n<li>只有特定的丢失或损坏帧被重发。接收方收到的数据帧可以是不按顺序到达的</li>\n<li>与回退n协议自动重传请求有以下不同：</li>\n<li>接收设备必须具有排序的逻辑功能</li>\n<li><font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸小于等于$n/2$</li>\n</ul>\n<h5 id=\"2-4-3滑动窗口协议的效率\"><a href=\"#2-4-3滑动窗口协议的效率\" class=\"headerlink\" title=\"2.4.3滑动窗口协议的效率\"></a>2.4.3滑动窗口协议的效率</h5><h5 id=\"2-4-4窗口大小的选择\"><a href=\"#2-4-4窗口大小的选择\" class=\"headerlink\" title=\"2.4.4窗口大小的选择\"></a>2.4.4窗口大小的选择</h5><script type=\"math/tex; mode=display\">\nnt_I>2(t_I+t_P)</script><ul>\n<li>$t_I$：一个帧的发送时间</li>\n<li>$t_P$：传播时间</li>\n</ul>\n<h3 id=\"3-HDLC高级数据链路控制协议\"><a href=\"#3-HDLC高级数据链路控制协议\" class=\"headerlink\" title=\"3.HDLC高级数据链路控制协议\"></a>3.HDLC高级数据链路控制协议</h3><h4 id=\"3-1HDLC帧格式\"><a href=\"#3-1HDLC帧格式\" class=\"headerlink\" title=\"3.1HDLC帧格式\"></a>3.1HDLC帧格式</h4><ul>\n<li>信息帧（I-帧）：用来传输用户数据以及与用户数据有关的控制信息</li>\n<li>监控帧（S-帧）：用来传输控制信息，主要是数据链路层流量控制和错误控制信息</li>\n<li>无编号帧（U-帧）：用来进行链路管理服务的</li>\n</ul>\n<h5 id=\"3-1-1标志字段\"><a href=\"#3-1-1标志字段\" class=\"headerlink\" title=\"3.1.1标志字段\"></a>3.1.1标志字段</h5><ul>\n<li>标志字段为一个字节（8位），其位模式为01111110</li>\n<li>它用来<strong>表示一个帧的开始和结束，并且为接收方提供同步手段</strong></li>\n</ul>\n<h5 id=\"3-1-2地址字段\"><a href=\"#3-1-2地址字段\" class=\"headerlink\" title=\"3.1.2地址字段\"></a>3.1.2地址字段</h5><ul>\n<li>可以有1个或几个字节的长度</li>\n</ul>\n<h5 id=\"3-1-2控制字段\"><a href=\"#3-1-2控制字段\" class=\"headerlink\" title=\"3.1.2控制字段\"></a>3.1.2控制字段</h5><ul>\n<li>有一个或两个字节</li>\n<li>用来进行<strong>流量管理</strong></li>\n</ul>\n<h3 id=\"4-数据链路层网络互联\"><a href=\"#4-数据链路层网络互联\" class=\"headerlink\" title=\"4.数据链路层网络互联\"></a>4.数据链路层网络互联</h3><h4 id=\"4-1网桥\"><a href=\"#4-1网桥\" class=\"headerlink\" title=\"4.1网桥\"></a>4.1网桥</h4><ul>\n<li>网桥是一种存储转发设备，用于连接局域网</li>\n<li>网桥常用于局域网之间的互联</li>\n<li>是数据链路层上的互连设备，网桥同时作用在$OSI$的物理层和数据链路层</li>\n<li>网桥具有隔离通信的功能</li>\n</ul>\n<h4 id=\"4-2网桥路由算法\"><a href=\"#4-2网桥路由算法\" class=\"headerlink\" title=\"4.2网桥路由算法\"></a>4.2网桥路由算法</h4><h5 id=\"4-2-1固定路由策略-—-固定路由网桥\"><a href=\"#4-2-1固定路由策略-—-固定路由网桥\" class=\"headerlink\" title=\"4.2.1固定路由策略 —- 固定路由网桥\"></a>4.2.1固定路由策略 —- 固定路由网桥</h5><h5 id=\"4-2-2路由学习策略-—-透明网桥\"><a href=\"#4-2-2路由学习策略-—-透明网桥\" class=\"headerlink\" title=\"4.2.2路由学习策略 —- 透明网桥\"></a>4.2.2路由学习策略 —- 透明网桥</h5><h6 id=\"4-2-2-1生成树算法\"><a href=\"#4-2-2-1生成树算法\" class=\"headerlink\" title=\"4.2.2.1生成树算法\"></a>4.2.2.1生成树算法</h6><h5 id=\"4-2-3源路由策略-—-源路由网桥\"><a href=\"#4-2-3源路由策略-—-源路由网桥\" class=\"headerlink\" title=\"4.2.3源路由策略 —- 源路由网桥\"></a>4.2.3源路由策略 —- 源路由网桥</h5><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"强化-计网第三章-数据链路层\"><a href=\"#强化-计网第三章-数据链路层\" class=\"headerlink\" title=\"强化 计网第三章 数据链路层\"></a>强化 计网第三章 数据链路层</h2><h3 id=\"1-线路规划\"><a href=\"#1-线路规划\" class=\"headerlink\" title=\"1.线路规划\"></a>1.线路规划</h3><h4 id=\"1-1询问-应答（ENQ-ACK）\"><a href=\"#1-1询问-应答（ENQ-ACK）\" class=\"headerlink\" title=\"1.1询问/应答（ENQ/ACK）\"></a>1.1询问/应答（ENQ/ACK）</h4><ul>\n<li>一条链路两端的<strong>设备级别相同</strong>，任意一个设备都可以启动一个会话过程（<strong>点对点</strong>）</li>\n<li>工作方式</li>\n<li>启动方首先发送一个<strong>询问帧（ENQ）</strong>询问接收方是否可以接收数据</li>\n<li>接收方如果已经<strong>准备好接收</strong>，必须应答一个<strong>确认帧（ACK）</strong></li>\n<li>如果没用做好准备，就必须应答一个否定帧（NAK）</li>\n</ul>\n<h4 id=\"1-2轮询（Poll）-选择（Select）方式\"><a href=\"#1-2轮询（Poll）-选择（Select）方式\" class=\"headerlink\" title=\"1.2轮询（Poll）/选择（Select）方式\"></a>1.2轮询（Poll）/选择（Select）方式</h4><ul>\n<li>有一个设备为主设备，其他设备为从设备的拓补结构中采用（<strong>多点系统</strong>）</li>\n<li>每个设备都有一个地址标识自身</li>\n<li>信息传输必须通过主设备</li>\n</ul>\n<h5 id=\"1-2-1轮询\"><a href=\"#1-2-1轮询\" class=\"headerlink\" title=\"1.2.1轮询\"></a>1.2.1轮询</h5><ul>\n<li>如果主设备希望<strong>接收</strong>数据，它将逐个询问从设备是否有数据发送，这个功能称为轮询</li>\n</ul>\n<h5 id=\"1-2-2选择\"><a href=\"#1-2-2选择\" class=\"headerlink\" title=\"1.2.2选择\"></a>1.2.2选择</h5><ul>\n<li>如果主设备希望<strong>发送</strong>数据，它告知目标从设备准备好接收数据，这个功能称为选择</li>\n</ul>\n<h3 id=\"2-流量控制与差错控制\"><a href=\"#2-流量控制与差错控制\" class=\"headerlink\" title=\"2.流量控制与差错控制\"></a>2.流量控制与差错控制</h3><ul>\n<li>两者是结合在一起实现的，共有两种技术：停止等待协议和滑动窗口协议</li>\n</ul>\n<h4 id=\"2-1差错控制\"><a href=\"#2-1差错控制\" class=\"headerlink\" title=\"2.1差错控制\"></a>2.1差错控制</h4><ul>\n<li>差错控制主要指错误检测和重传方法</li>\n</ul>\n<h4 id=\"2-2自动重复请求（ARQ）\"><a href=\"#2-2自动重复请求（ARQ）\" class=\"headerlink\" title=\"2.2自动重复请求（ARQ）\"></a>2.2自动重复请求（ARQ）</h4><ul>\n<li>在一个帧中出现任何一个错误，接收方就返回一个否认帧，出错的帧就被发送方重新传送。这个过程被称为自动重复请求（ARQ）</li>\n</ul>\n<h4 id=\"2-3停止等待协议\"><a href=\"#2-3停止等待协议\" class=\"headerlink\" title=\"2.3停止等待协议\"></a>2.3停止等待协议</h4><ul>\n<li>发送方每发送一帧后就等待一个确认帧。<strong>只有当接收到确认帧后，发送方才发送下一帧</strong>，这种过程不断交替，直到发送方发送一个传输结束帧（EOT）</li>\n<li>优点：简单</li>\n<li>缺点：效率低，每次都要等待</li>\n</ul>\n<h5 id=\"2-3-1信道利用率\"><a href=\"#2-3-1信道利用率\" class=\"headerlink\" title=\"2.3.1信道利用率\"></a>2.3.1信道利用率</h5><ul>\n<li>无差错的情况下完成一帧的发送时间为一个<strong>窗口时间WT</strong>:</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nWT=t_I+2t_p+2t_{Proc}+t_s</script><ul>\n<li><p><strong>$t_I$是发送一个数据帧的时间</strong>，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒</p>\n</li>\n<li><p><strong>$t_S$是确认帧的发送时间</strong>，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒</p>\n</li>\n<li><p><strong>$ t_P $是电信号在物理链路上的传播延迟</strong></p>\n</li>\n<li><p><strong>$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间</strong></p>\n</li>\n<li><p>无差错信道利用率：</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nF=(t_I+t_p)/WT</script><ul>\n<li>有效数据传送速率：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nS=N/WT,N:一帧的有效数据位数</script><ul>\n<li>$t_W \\approx t_I+2t_P$</li>\n</ul>\n<h5 id=\"2-3-2差错控制\"><a href=\"#2-3-2差错控制\" class=\"headerlink\" title=\"2.3.2差错控制\"></a>2.3.2差错控制</h5><h6 id=\"2-3-2-1帧破坏\"><a href=\"#2-3-2-1帧破坏\" class=\"headerlink\" title=\"2.3.2.1帧破坏\"></a>2.3.2.1帧破坏</h6><ul>\n<li>自动重复请求（ARQ）</li>\n</ul>\n<h6 id=\"2-3-2-2帧丢失\"><a href=\"#2-3-2-2帧丢失\" class=\"headerlink\" title=\"2.3.2.2帧丢失\"></a>2.3.2.2帧丢失</h6><ul>\n<li>定时器，判断数据帧在传输中丢失，超时自动重发</li>\n</ul>\n<h6 id=\"2-3-2-3应答帧丢失\"><a href=\"#2-3-2-3应答帧丢失\" class=\"headerlink\" title=\"2.3.2.3应答帧丢失\"></a>2.3.2.3应答帧丢失</h6><ul>\n<li>先重传数据帧</li>\n<li>数据帧和应答帧以交替的标识0和1出现在数据帧中，每次发送一个新的数据帧，编号信息和上次发送的不一样。这样就可以区分重复的数据帧</li>\n<li>丢弃重复帧</li>\n</ul>\n<h4 id=\"2-4滑动窗口协议\"><a href=\"#2-4滑动窗口协议\" class=\"headerlink\" title=\"2.4滑动窗口协议\"></a>2.4滑动窗口协议</h4><h5 id=\"2-4-1流量控制\"><a href=\"#2-4-1流量控制\" class=\"headerlink\" title=\"2.4.1流量控制\"></a>2.4.1流量控制</h5><ul>\n<li>在滑动窗口协议中，发送方在收到确认消息前可以发送若干帧。帧可以直接依次发送</li>\n<li>接收方使用一个应答帧来对多个数据帧的接收进行确认</li>\n<li>在发送方，只要窗口未填满就可以在未收到确认帧的情况下继续发送数据帧</li>\n<li><strong>发送方窗口用于存放已经发送但未确认的数据帧和在收到确认帧之前可以发送的数据帧</strong></li>\n<li>例如：</li>\n<li>接收方发送了一个编号为5的确认帧，表示接收方收到了5号帧以前的所有帧，希望发送方发送5号帧</li>\n</ul>\n<h5 id=\"2-4-2差错控制\"><a href=\"#2-4-2差错控制\" class=\"headerlink\" title=\"2.4.2差错控制\"></a>2.4.2差错控制</h5><h6 id=\"2-4-2-1回退N自动重复请求\"><a href=\"#2-4-2-1回退N自动重复请求\" class=\"headerlink\" title=\"2.4.2.1回退N自动重复请求\"></a>2.4.2.1回退N自动重复请求</h6><ul>\n<li>如果有一帧丢失或者损坏了，未被确认帧确认的帧都必须进行重传</li>\n<li><font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸为$n-1$</li>\n</ul>\n<h6 id=\"2-4-2-2选择拒绝自动重复请求\"><a href=\"#2-4-2-2选择拒绝自动重复请求\" class=\"headerlink\" title=\"2.4.2.2选择拒绝自动重复请求\"></a>2.4.2.2选择拒绝自动重复请求</h6><ul>\n<li>只有特定的丢失或损坏帧被重发。接收方收到的数据帧可以是不按顺序到达的</li>\n<li>与回退n协议自动重传请求有以下不同：</li>\n<li>接收设备必须具有排序的逻辑功能</li>\n<li><font color=\"red\">窗口大小：</font>如果帧的编号范围是$0 \\sim n-1$，则窗口尺寸小于等于$n/2$</li>\n</ul>\n<h5 id=\"2-4-3滑动窗口协议的效率\"><a href=\"#2-4-3滑动窗口协议的效率\" class=\"headerlink\" title=\"2.4.3滑动窗口协议的效率\"></a>2.4.3滑动窗口协议的效率</h5><h5 id=\"2-4-4窗口大小的选择\"><a href=\"#2-4-4窗口大小的选择\" class=\"headerlink\" title=\"2.4.4窗口大小的选择\"></a>2.4.4窗口大小的选择</h5><script type=\"math/tex; mode=display\">\nnt_I>2(t_I+t_P)</script><ul>\n<li>$t_I$：一个帧的发送时间</li>\n<li>$t_P$：传播时间</li>\n</ul>\n<h3 id=\"3-HDLC高级数据链路控制协议\"><a href=\"#3-HDLC高级数据链路控制协议\" class=\"headerlink\" title=\"3.HDLC高级数据链路控制协议\"></a>3.HDLC高级数据链路控制协议</h3><h4 id=\"3-1HDLC帧格式\"><a href=\"#3-1HDLC帧格式\" class=\"headerlink\" title=\"3.1HDLC帧格式\"></a>3.1HDLC帧格式</h4><ul>\n<li>信息帧（I-帧）：用来传输用户数据以及与用户数据有关的控制信息</li>\n<li>监控帧（S-帧）：用来传输控制信息，主要是数据链路层流量控制和错误控制信息</li>\n<li>无编号帧（U-帧）：用来进行链路管理服务的</li>\n</ul>\n<h5 id=\"3-1-1标志字段\"><a href=\"#3-1-1标志字段\" class=\"headerlink\" title=\"3.1.1标志字段\"></a>3.1.1标志字段</h5><ul>\n<li>标志字段为一个字节（8位），其位模式为01111110</li>\n<li>它用来<strong>表示一个帧的开始和结束，并且为接收方提供同步手段</strong></li>\n</ul>\n<h5 id=\"3-1-2地址字段\"><a href=\"#3-1-2地址字段\" class=\"headerlink\" title=\"3.1.2地址字段\"></a>3.1.2地址字段</h5><ul>\n<li>可以有1个或几个字节的长度</li>\n</ul>\n<h5 id=\"3-1-2控制字段\"><a href=\"#3-1-2控制字段\" class=\"headerlink\" title=\"3.1.2控制字段\"></a>3.1.2控制字段</h5><ul>\n<li>有一个或两个字节</li>\n<li>用来进行<strong>流量管理</strong></li>\n</ul>\n<h3 id=\"4-数据链路层网络互联\"><a href=\"#4-数据链路层网络互联\" class=\"headerlink\" title=\"4.数据链路层网络互联\"></a>4.数据链路层网络互联</h3><h4 id=\"4-1网桥\"><a href=\"#4-1网桥\" class=\"headerlink\" title=\"4.1网桥\"></a>4.1网桥</h4><ul>\n<li>网桥是一种存储转发设备，用于连接局域网</li>\n<li>网桥常用于局域网之间的互联</li>\n<li>是数据链路层上的互连设备，网桥同时作用在$OSI$的物理层和数据链路层</li>\n<li>网桥具有隔离通信的功能</li>\n</ul>\n<h4 id=\"4-2网桥路由算法\"><a href=\"#4-2网桥路由算法\" class=\"headerlink\" title=\"4.2网桥路由算法\"></a>4.2网桥路由算法</h4><h5 id=\"4-2-1固定路由策略-—-固定路由网桥\"><a href=\"#4-2-1固定路由策略-—-固定路由网桥\" class=\"headerlink\" title=\"4.2.1固定路由策略 —- 固定路由网桥\"></a>4.2.1固定路由策略 —- 固定路由网桥</h5><h5 id=\"4-2-2路由学习策略-—-透明网桥\"><a href=\"#4-2-2路由学习策略-—-透明网桥\" class=\"headerlink\" title=\"4.2.2路由学习策略 —- 透明网桥\"></a>4.2.2路由学习策略 —- 透明网桥</h5><h6 id=\"4-2-2-1生成树算法\"><a href=\"#4-2-2-1生成树算法\" class=\"headerlink\" title=\"4.2.2.1生成树算法\"></a>4.2.2.1生成树算法</h6><h5 id=\"4-2-3源路由策略-—-源路由网桥\"><a href=\"#4-2-3源路由策略-—-源路由网桥\" class=\"headerlink\" title=\"4.2.3源路由策略 —- 源路由网桥\"></a>4.2.3源路由策略 —- 源路由网桥</h5>"},{"title":"强化-计网第二章-物理层","top":false,"cover":false,"toc":true,"mathjax":true,"keywords":"吉林大学，考研，计算机网络，物理层","description":"吉林大学，考研，计算机网络，物理层","summary":"强化-计网第二章-物理层","abbrlink":"f655","date":"2020-09-16T09:41:32.000Z","password":null,"_content":"## 强化 计网第二章 物理层\n\n### 1.通信系统\n\n#### 1.1组成\n\n##### 1.1.1信源\n\n- 产生要发送数据的设备\n\n##### 1.1.2发送设备\n\n- 对数据信息编码的设备\n\n##### 1.1.3传输系统\n\n- 传输线路或网络\n\n##### 1.1.4接收设备\n\n- 将接受的信号变成数据\n\n##### 1.1.5信宿\n\n- 从接收设备接收数据信息。就是目的系统\n\n### 2.编码与调制\n\n#### 2.1信号类型\n\n##### 2.1.1模拟信号\n\n- 随时间连续变化的电磁波形式（信号）\n\n###### 2.1.1.1波特率\n\n- 每秒发送的波数\n\n##### 2.1.2数字信号\n\n- 离散的，数值的变化是瞬时的\n\n###### 2.1.2.1比特间隙\n\n- 发送一比特所需要的时间\n\n###### 2.1.2.2比特率\n\n- 一秒钟内的比特间隙个数，是每秒发送的比特数，单位是bps（位每秒）\n\n###### 2.1.2.3有效带宽\n\n- 数字信号的频谱包括不同振幅的无数多个频率，如果根据一定的门限，只传输那些具有重要振幅的分量，仍然可以以合理的精度在接收端还原出数字信号，则数字信号频谱中的这一部分称作有效频谱，有效频谱的带宽称为有效带宽\n\n#### 2.2信道数据传输率\n\n##### 2.2.1奈奎斯特定理（奈氏准则）\n\n##### 2.2.2香农定理\n\n#### 2.3数字-数字编码\n\n##### 2.3.1单极性编码\n\n- 电压只有一极，高电平表示1，低电平表示0\n\n<img src=\"单极性编码.png\" alt=\"单极性编码\" style=\"zoom: 67%;\" />\n\n##### 2.3.2极化编码\n\n- 一个正电压，一个负电压。通过使用两个电压，减轻了单极性编码中的直流分量问题\n\n###### 2.3.2.1非归零编码\n\n- 正电压为1，负电压为0\n\n###### 2.3.2.2归零编码\n\n- 电平翻转一次为1，没有电平变化为0\n- 电平的翻转能提供一种同步机制\n\n<img src=\"非归零编码.png\" alt=\"非归零编码\" style=\"zoom:67%;\" />\n\n###### 2.3.2.3双相位编码\n\n- 曼彻斯特编码：一个**负电平到正电平**的跳边**代表1**，由**正到负代表0**\n- 差分曼彻斯特编码：每个比特间隙的开始位置**有跳变代表0**，**没有跳变代表1**\n\n#### 2.4数字-模拟编码\n\n##### 2.4.1幅移键控（ASK）\n\n<img src=\"ASK.png\" alt=\"ASK\" style=\"zoom:67%;\" />\n\n##### 2.4.2频移键控（FSK）\n\n<img src=\"FSK.png\" alt=\"FSK\" style=\"zoom:67%;\" />\n\n##### 2.4.3相移键控（PSK）\n\n<img src=\"PSK.png\" alt=\"PSK\" style=\"zoom:67%;\" />\n\n##### 2.4.4正交调幅（QAM）\n\n- ASK和PSK结合起来的编码方式\n\n<img src=\"QAM.png\" alt=\"QAM\" style=\"zoom: 67%;\" />\n\n### 3.线路配置与传输模式\n\n#### 3.1传输模式\n\n##### 3.1.1点到点连接\n\n- 提供了两个设备之间的专用链路。整个信道的容量都被用于这两个设备之间的传输\n\n##### 3.1.2多点连接\n\n- 两个以上的设备共享一条链路的配置方式。信道的容量是通过某种途径共享的\n- 实现**信道共享**的技术称为**复用技术**\n\n##### 3.1.3单工、半双工、双工\n\n- 单工：**通信单向进行**，两个站点中只有一个可以进行传输，另一个只能接收\n- 半双工：每个站点都可以发送和接收数据，但是**不能同时发送和接收数据**。\n- 双工：两个站点**都可以同时发送和接收数据**\n\n##### 3.1.4串行、并行\n\n- 并行：在每个时钟脉冲到来时，多个比特被同时发送，每个比特使用单独的一条线路\n- 串行：每个时钟脉冲只发送一个比特，它只使用一条线路，逐个传送\n\n##### 3.1.5同步、异步\n\n- 异步：比特流划分成多个小组独立传送。随时发，有开始位，终止位，用于低速设备。开销大，先发开始位0，发送一个字节，在发送终止位1，如此循环\n- 同步：成块的发送比特流，字符之间不加开始位和停止位。先二进制同步（法一：接收端和发送端之间单设一条线传送时钟脉冲；法二：采用自同步编码，曼彻斯特编码等），再数据帧同步，在数据帧前后加上起始和结束标志\n\n#### 3.2多路复用\n\n##### 3.2.1频分多路复用（FDM）\n\n- **模拟信号**\n\n##### 3.2.1时分多路复用（TDM）\n\n- **数字信号**\n\n##### 3.2.1波分多路复用（WDM）\n\n- **模拟信号**\n- 光纤\n\n##### 3.2.1码分多路复用（CDM）/码分多址复用（CDMA）\n\n- 根据码型结构的不同来实现信号分割\n- 在CDMA每个比特被分成m个不同码片，每个站点被指定一个唯一的m位码片（码型）。当发送比特1时，站点就发送其码片，想发送0时，站点就发送其码片的补码\n\n#### 3.3数据交换技术\n\n##### 3.3.1电路交换\n\n- 在两个设备之间创建一条临时的物理连接\n- 通讯过程：电路建立、数据传输、电路拆除\n\n##### 3.3.2报文交换（存储转发）\n\n- 在报文的传输过程中，由网络的中间结点将报文暂时存储起来，检查它的正确性和完整性，然后再发往下一个结点\n\n##### 3.3.3分组交换\n\n- 在分组交换中，较长的报文被分为较短的数据单元，然后每个数据单元被加上一些通信控制信息等内容，形成一个信息包（packet）。通信时以包为单位发送、存储和转发。信息包包含数据和包头，包头由通信控制信息、差错控制信息等组成\n- 信息包比报文短得多，因此可以在中间结点存储，不必访问外存。而且只要整个信息包到达后就可以转发，不必等待很长的报文全部到达，大大缩短了信息传输过程中的延迟时间\n\n###### 3.3.3.1数据报\n\n- 数据报方法中，包被称为数据报，在传输中每个包都将独立于其他包进行处理\n- **到达的顺序可能不同**，对数据报进行重排的任务可以由网络层的上层（传输层）来完成\n\n###### 3.3.3.2虚电路\n\n- 虚电路方法中，属于同一次通信的所有包之间的关系得以维持。当数据开始时，将按照预定好的路线一个接一个的传送\n- 任何一条链路可以同时为多对设备之间的通信服务\n- 在需要的时候被创建、通信传输、拆除\n- 仅在建立虚电路时需要目的地址，在进行数据传送时，每个包不需要携带完整的目的地址，只需要一个虚电路的号码标识。减少了包的控制信息长度，从而减少了额外开销\n\n#### 3.4错误检验和控制\n\n- 见题型即可\n\n##### 3.4.1奇偶校验码\n\n###### 3.4.1.1垂直（纵向）奇偶校验\n\n###### 3.4.1.2水平（横向）奇偶校验\n\n##### 3.4.1循环校验码CRC\n\n##### 3.4.2校验和\n\n### 4.传输介质\n\n#### 4.1有线介质\n\n##### 4.1.1双绞线\n\n- 由扭在一起的两根绝缘铜线组成\n- 用于传输平衡信号\n\n##### 4.1.2同轴电缆\n\n##### 4.1.3光纤\n\n- 光的速度依赖于它所穿越的传输介质的密度，密度越大，速度越低\n\n###### 4.1.3.1多模传播\n\n- 多束光线在芯材中通过不同的路径\n\n- 多模阶跃：密度突变，不同角度，速度不同，\n- 多模渐变：密度渐变，速度相同，中心密度最大，并向外逐步变小\n\n###### 4.1.3.2单模传播\n\n- 单模光纤采用阶跃材质和高度集中的光源。芯材直径比多模光纤小得多\n\n#### 4.2无线介质\n\n##### 4.2.1卫星、微波、红外线\n\n### 5.物理连接\n\n- 在数据通信中涉及4个基本功能单元：两端各有一个数据终端设备（DTE）和一个数据电路终接设备\n\n#### 5.1数据终端设备（DTE）\n\n- DTE是具有数据处理能力及发送和接收数据信息能力的设备\n- DTE一般不直接连接网络，它通过一台DCE进行通信。\n- 我们把DTE和DCE的连接称为DTE-DCE接口\n- 在DTE-DCE接口上既有数据信息又有控制信息，为了**使各个计算机公司生产的DTE可以方便的和DCE连接**，就**必须对DTE-DCE接口进行标准化**，这些就是**物理层的协议**\n\n#### 5.2数据电路终接设备（DCE）\n\n- DCE是能够通过网络发送和接收模拟或数字信号形式数据的设备\n- **总结**\n- 数据从上层数据链路层传来\n- DTE处理数据，并交给DCE转换成能通过传输介质的电磁信号\n- 电磁信号通过传输介质传输\n- 各端的DCE接收这些电磁信号形成数据交给DTE处理\n- DTE处理完数据，交给上层的数据链路层\n\n### 6.物理层协议\n\n#### 6.1EIA232\n\n##### 6.1.1机械特性\n\n##### 6.1.2电气特性\n\n##### 6.1.3功能特性\n\n##### 6.1.4规程特性\n\n#### 6.2X.21\n\n### 7.工作的设备\n\n#### 7.1中继器或转发器\n\n- 中继器是一个再生器，不是一个增幅器，只是将受损的信号重新还原成原始的形式，会导致局域网性能下降\n\n#### 7.2集线器\n\n- 多端口中继器，建立星状、树状网络结构\n\n### 8.考题类型\n\n#### 8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？\n\n#### 8.2 CRC校验码\n\n- 是x的几次多项式，就在带传送数据后加几个0\n- <font color=\"red\">**同0异1**</font>\n- 做除法，得出来的余数，加到带传输的数据后即可\n\n#### 8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？\n\n#### 8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\n\n- **W**：理想低通信信道的**带宽**，单位为Hz\n\n- **V**：表示每个码元离散电平的数目\n\n- 则理想低通信道下的极限数据传输率 = **$2Wlog_2V$**\n\n- $1*10^6=2H*1*4, H=1*10^6/8=125000Hz$\n\n","source":"_posts/强化-计网第二章-物理层.md","raw":"---\ntitle: 强化-计网第二章-物理层\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 计网\n  - 强化\n  - 总结\n  - 考研\ncategories:\n  - 计网\nkeywords: 吉林大学，考研，计算机网络，物理层\ndescription: 吉林大学，考研，计算机网络，物理层\nsummary: 强化-计网第二章-物理层\nabbrlink: f655\ndate: 2020-09-16 17:41:32\npassword:\n---\n## 强化 计网第二章 物理层\n\n### 1.通信系统\n\n#### 1.1组成\n\n##### 1.1.1信源\n\n- 产生要发送数据的设备\n\n##### 1.1.2发送设备\n\n- 对数据信息编码的设备\n\n##### 1.1.3传输系统\n\n- 传输线路或网络\n\n##### 1.1.4接收设备\n\n- 将接受的信号变成数据\n\n##### 1.1.5信宿\n\n- 从接收设备接收数据信息。就是目的系统\n\n### 2.编码与调制\n\n#### 2.1信号类型\n\n##### 2.1.1模拟信号\n\n- 随时间连续变化的电磁波形式（信号）\n\n###### 2.1.1.1波特率\n\n- 每秒发送的波数\n\n##### 2.1.2数字信号\n\n- 离散的，数值的变化是瞬时的\n\n###### 2.1.2.1比特间隙\n\n- 发送一比特所需要的时间\n\n###### 2.1.2.2比特率\n\n- 一秒钟内的比特间隙个数，是每秒发送的比特数，单位是bps（位每秒）\n\n###### 2.1.2.3有效带宽\n\n- 数字信号的频谱包括不同振幅的无数多个频率，如果根据一定的门限，只传输那些具有重要振幅的分量，仍然可以以合理的精度在接收端还原出数字信号，则数字信号频谱中的这一部分称作有效频谱，有效频谱的带宽称为有效带宽\n\n#### 2.2信道数据传输率\n\n##### 2.2.1奈奎斯特定理（奈氏准则）\n\n##### 2.2.2香农定理\n\n#### 2.3数字-数字编码\n\n##### 2.3.1单极性编码\n\n- 电压只有一极，高电平表示1，低电平表示0\n\n<img src=\"单极性编码.png\" alt=\"单极性编码\" style=\"zoom: 67%;\" />\n\n##### 2.3.2极化编码\n\n- 一个正电压，一个负电压。通过使用两个电压，减轻了单极性编码中的直流分量问题\n\n###### 2.3.2.1非归零编码\n\n- 正电压为1，负电压为0\n\n###### 2.3.2.2归零编码\n\n- 电平翻转一次为1，没有电平变化为0\n- 电平的翻转能提供一种同步机制\n\n<img src=\"非归零编码.png\" alt=\"非归零编码\" style=\"zoom:67%;\" />\n\n###### 2.3.2.3双相位编码\n\n- 曼彻斯特编码：一个**负电平到正电平**的跳边**代表1**，由**正到负代表0**\n- 差分曼彻斯特编码：每个比特间隙的开始位置**有跳变代表0**，**没有跳变代表1**\n\n#### 2.4数字-模拟编码\n\n##### 2.4.1幅移键控（ASK）\n\n<img src=\"ASK.png\" alt=\"ASK\" style=\"zoom:67%;\" />\n\n##### 2.4.2频移键控（FSK）\n\n<img src=\"FSK.png\" alt=\"FSK\" style=\"zoom:67%;\" />\n\n##### 2.4.3相移键控（PSK）\n\n<img src=\"PSK.png\" alt=\"PSK\" style=\"zoom:67%;\" />\n\n##### 2.4.4正交调幅（QAM）\n\n- ASK和PSK结合起来的编码方式\n\n<img src=\"QAM.png\" alt=\"QAM\" style=\"zoom: 67%;\" />\n\n### 3.线路配置与传输模式\n\n#### 3.1传输模式\n\n##### 3.1.1点到点连接\n\n- 提供了两个设备之间的专用链路。整个信道的容量都被用于这两个设备之间的传输\n\n##### 3.1.2多点连接\n\n- 两个以上的设备共享一条链路的配置方式。信道的容量是通过某种途径共享的\n- 实现**信道共享**的技术称为**复用技术**\n\n##### 3.1.3单工、半双工、双工\n\n- 单工：**通信单向进行**，两个站点中只有一个可以进行传输，另一个只能接收\n- 半双工：每个站点都可以发送和接收数据，但是**不能同时发送和接收数据**。\n- 双工：两个站点**都可以同时发送和接收数据**\n\n##### 3.1.4串行、并行\n\n- 并行：在每个时钟脉冲到来时，多个比特被同时发送，每个比特使用单独的一条线路\n- 串行：每个时钟脉冲只发送一个比特，它只使用一条线路，逐个传送\n\n##### 3.1.5同步、异步\n\n- 异步：比特流划分成多个小组独立传送。随时发，有开始位，终止位，用于低速设备。开销大，先发开始位0，发送一个字节，在发送终止位1，如此循环\n- 同步：成块的发送比特流，字符之间不加开始位和停止位。先二进制同步（法一：接收端和发送端之间单设一条线传送时钟脉冲；法二：采用自同步编码，曼彻斯特编码等），再数据帧同步，在数据帧前后加上起始和结束标志\n\n#### 3.2多路复用\n\n##### 3.2.1频分多路复用（FDM）\n\n- **模拟信号**\n\n##### 3.2.1时分多路复用（TDM）\n\n- **数字信号**\n\n##### 3.2.1波分多路复用（WDM）\n\n- **模拟信号**\n- 光纤\n\n##### 3.2.1码分多路复用（CDM）/码分多址复用（CDMA）\n\n- 根据码型结构的不同来实现信号分割\n- 在CDMA每个比特被分成m个不同码片，每个站点被指定一个唯一的m位码片（码型）。当发送比特1时，站点就发送其码片，想发送0时，站点就发送其码片的补码\n\n#### 3.3数据交换技术\n\n##### 3.3.1电路交换\n\n- 在两个设备之间创建一条临时的物理连接\n- 通讯过程：电路建立、数据传输、电路拆除\n\n##### 3.3.2报文交换（存储转发）\n\n- 在报文的传输过程中，由网络的中间结点将报文暂时存储起来，检查它的正确性和完整性，然后再发往下一个结点\n\n##### 3.3.3分组交换\n\n- 在分组交换中，较长的报文被分为较短的数据单元，然后每个数据单元被加上一些通信控制信息等内容，形成一个信息包（packet）。通信时以包为单位发送、存储和转发。信息包包含数据和包头，包头由通信控制信息、差错控制信息等组成\n- 信息包比报文短得多，因此可以在中间结点存储，不必访问外存。而且只要整个信息包到达后就可以转发，不必等待很长的报文全部到达，大大缩短了信息传输过程中的延迟时间\n\n###### 3.3.3.1数据报\n\n- 数据报方法中，包被称为数据报，在传输中每个包都将独立于其他包进行处理\n- **到达的顺序可能不同**，对数据报进行重排的任务可以由网络层的上层（传输层）来完成\n\n###### 3.3.3.2虚电路\n\n- 虚电路方法中，属于同一次通信的所有包之间的关系得以维持。当数据开始时，将按照预定好的路线一个接一个的传送\n- 任何一条链路可以同时为多对设备之间的通信服务\n- 在需要的时候被创建、通信传输、拆除\n- 仅在建立虚电路时需要目的地址，在进行数据传送时，每个包不需要携带完整的目的地址，只需要一个虚电路的号码标识。减少了包的控制信息长度，从而减少了额外开销\n\n#### 3.4错误检验和控制\n\n- 见题型即可\n\n##### 3.4.1奇偶校验码\n\n###### 3.4.1.1垂直（纵向）奇偶校验\n\n###### 3.4.1.2水平（横向）奇偶校验\n\n##### 3.4.1循环校验码CRC\n\n##### 3.4.2校验和\n\n### 4.传输介质\n\n#### 4.1有线介质\n\n##### 4.1.1双绞线\n\n- 由扭在一起的两根绝缘铜线组成\n- 用于传输平衡信号\n\n##### 4.1.2同轴电缆\n\n##### 4.1.3光纤\n\n- 光的速度依赖于它所穿越的传输介质的密度，密度越大，速度越低\n\n###### 4.1.3.1多模传播\n\n- 多束光线在芯材中通过不同的路径\n\n- 多模阶跃：密度突变，不同角度，速度不同，\n- 多模渐变：密度渐变，速度相同，中心密度最大，并向外逐步变小\n\n###### 4.1.3.2单模传播\n\n- 单模光纤采用阶跃材质和高度集中的光源。芯材直径比多模光纤小得多\n\n#### 4.2无线介质\n\n##### 4.2.1卫星、微波、红外线\n\n### 5.物理连接\n\n- 在数据通信中涉及4个基本功能单元：两端各有一个数据终端设备（DTE）和一个数据电路终接设备\n\n#### 5.1数据终端设备（DTE）\n\n- DTE是具有数据处理能力及发送和接收数据信息能力的设备\n- DTE一般不直接连接网络，它通过一台DCE进行通信。\n- 我们把DTE和DCE的连接称为DTE-DCE接口\n- 在DTE-DCE接口上既有数据信息又有控制信息，为了**使各个计算机公司生产的DTE可以方便的和DCE连接**，就**必须对DTE-DCE接口进行标准化**，这些就是**物理层的协议**\n\n#### 5.2数据电路终接设备（DCE）\n\n- DCE是能够通过网络发送和接收模拟或数字信号形式数据的设备\n- **总结**\n- 数据从上层数据链路层传来\n- DTE处理数据，并交给DCE转换成能通过传输介质的电磁信号\n- 电磁信号通过传输介质传输\n- 各端的DCE接收这些电磁信号形成数据交给DTE处理\n- DTE处理完数据，交给上层的数据链路层\n\n### 6.物理层协议\n\n#### 6.1EIA232\n\n##### 6.1.1机械特性\n\n##### 6.1.2电气特性\n\n##### 6.1.3功能特性\n\n##### 6.1.4规程特性\n\n#### 6.2X.21\n\n### 7.工作的设备\n\n#### 7.1中继器或转发器\n\n- 中继器是一个再生器，不是一个增幅器，只是将受损的信号重新还原成原始的形式，会导致局域网性能下降\n\n#### 7.2集线器\n\n- 多端口中继器，建立星状、树状网络结构\n\n### 8.考题类型\n\n#### 8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？\n\n#### 8.2 CRC校验码\n\n- 是x的几次多项式，就在带传送数据后加几个0\n- <font color=\"red\">**同0异1**</font>\n- 做除法，得出来的余数，加到带传输的数据后即可\n\n#### 8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？\n\n#### 8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\n\n- **W**：理想低通信信道的**带宽**，单位为Hz\n\n- **V**：表示每个码元离散电平的数目\n\n- 则理想低通信道下的极限数据传输率 = **$2Wlog_2V$**\n\n- $1*10^6=2H*1*4, H=1*10^6/8=125000Hz$\n\n","slug":"强化-计网第二章-物理层","published":1,"updated":"2020-09-21T11:42:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5y003aa09k8f673dsj","content":"<h2 id=\"强化-计网第二章-物理层\"><a href=\"#强化-计网第二章-物理层\" class=\"headerlink\" title=\"强化 计网第二章 物理层\"></a>强化 计网第二章 物理层</h2><h3 id=\"1-通信系统\"><a href=\"#1-通信系统\" class=\"headerlink\" title=\"1.通信系统\"></a>1.通信系统</h3><h4 id=\"1-1组成\"><a href=\"#1-1组成\" class=\"headerlink\" title=\"1.1组成\"></a>1.1组成</h4><h5 id=\"1-1-1信源\"><a href=\"#1-1-1信源\" class=\"headerlink\" title=\"1.1.1信源\"></a>1.1.1信源</h5><ul>\n<li>产生要发送数据的设备</li>\n</ul>\n<h5 id=\"1-1-2发送设备\"><a href=\"#1-1-2发送设备\" class=\"headerlink\" title=\"1.1.2发送设备\"></a>1.1.2发送设备</h5><ul>\n<li>对数据信息编码的设备</li>\n</ul>\n<h5 id=\"1-1-3传输系统\"><a href=\"#1-1-3传输系统\" class=\"headerlink\" title=\"1.1.3传输系统\"></a>1.1.3传输系统</h5><ul>\n<li>传输线路或网络</li>\n</ul>\n<h5 id=\"1-1-4接收设备\"><a href=\"#1-1-4接收设备\" class=\"headerlink\" title=\"1.1.4接收设备\"></a>1.1.4接收设备</h5><ul>\n<li>将接受的信号变成数据</li>\n</ul>\n<h5 id=\"1-1-5信宿\"><a href=\"#1-1-5信宿\" class=\"headerlink\" title=\"1.1.5信宿\"></a>1.1.5信宿</h5><ul>\n<li>从接收设备接收数据信息。就是目的系统</li>\n</ul>\n<h3 id=\"2-编码与调制\"><a href=\"#2-编码与调制\" class=\"headerlink\" title=\"2.编码与调制\"></a>2.编码与调制</h3><h4 id=\"2-1信号类型\"><a href=\"#2-1信号类型\" class=\"headerlink\" title=\"2.1信号类型\"></a>2.1信号类型</h4><h5 id=\"2-1-1模拟信号\"><a href=\"#2-1-1模拟信号\" class=\"headerlink\" title=\"2.1.1模拟信号\"></a>2.1.1模拟信号</h5><ul>\n<li>随时间连续变化的电磁波形式（信号）</li>\n</ul>\n<h6 id=\"2-1-1-1波特率\"><a href=\"#2-1-1-1波特率\" class=\"headerlink\" title=\"2.1.1.1波特率\"></a>2.1.1.1波特率</h6><ul>\n<li>每秒发送的波数</li>\n</ul>\n<h5 id=\"2-1-2数字信号\"><a href=\"#2-1-2数字信号\" class=\"headerlink\" title=\"2.1.2数字信号\"></a>2.1.2数字信号</h5><ul>\n<li>离散的，数值的变化是瞬时的</li>\n</ul>\n<h6 id=\"2-1-2-1比特间隙\"><a href=\"#2-1-2-1比特间隙\" class=\"headerlink\" title=\"2.1.2.1比特间隙\"></a>2.1.2.1比特间隙</h6><ul>\n<li>发送一比特所需要的时间</li>\n</ul>\n<h6 id=\"2-1-2-2比特率\"><a href=\"#2-1-2-2比特率\" class=\"headerlink\" title=\"2.1.2.2比特率\"></a>2.1.2.2比特率</h6><ul>\n<li>一秒钟内的比特间隙个数，是每秒发送的比特数，单位是bps（位每秒）</li>\n</ul>\n<h6 id=\"2-1-2-3有效带宽\"><a href=\"#2-1-2-3有效带宽\" class=\"headerlink\" title=\"2.1.2.3有效带宽\"></a>2.1.2.3有效带宽</h6><ul>\n<li>数字信号的频谱包括不同振幅的无数多个频率，如果根据一定的门限，只传输那些具有重要振幅的分量，仍然可以以合理的精度在接收端还原出数字信号，则数字信号频谱中的这一部分称作有效频谱，有效频谱的带宽称为有效带宽</li>\n</ul>\n<h4 id=\"2-2信道数据传输率\"><a href=\"#2-2信道数据传输率\" class=\"headerlink\" title=\"2.2信道数据传输率\"></a>2.2信道数据传输率</h4><h5 id=\"2-2-1奈奎斯特定理（奈氏准则）\"><a href=\"#2-2-1奈奎斯特定理（奈氏准则）\" class=\"headerlink\" title=\"2.2.1奈奎斯特定理（奈氏准则）\"></a>2.2.1奈奎斯特定理（奈氏准则）</h5><h5 id=\"2-2-2香农定理\"><a href=\"#2-2-2香农定理\" class=\"headerlink\" title=\"2.2.2香农定理\"></a>2.2.2香农定理</h5><h4 id=\"2-3数字-数字编码\"><a href=\"#2-3数字-数字编码\" class=\"headerlink\" title=\"2.3数字-数字编码\"></a>2.3数字-数字编码</h4><h5 id=\"2-3-1单极性编码\"><a href=\"#2-3-1单极性编码\" class=\"headerlink\" title=\"2.3.1单极性编码\"></a>2.3.1单极性编码</h5><ul>\n<li>电压只有一极，高电平表示1，低电平表示0</li>\n</ul>\n<p><img src=\"单极性编码.png\" alt=\"单极性编码\" style=\"zoom: 67%;\"></p>\n<h5 id=\"2-3-2极化编码\"><a href=\"#2-3-2极化编码\" class=\"headerlink\" title=\"2.3.2极化编码\"></a>2.3.2极化编码</h5><ul>\n<li>一个正电压，一个负电压。通过使用两个电压，减轻了单极性编码中的直流分量问题</li>\n</ul>\n<h6 id=\"2-3-2-1非归零编码\"><a href=\"#2-3-2-1非归零编码\" class=\"headerlink\" title=\"2.3.2.1非归零编码\"></a>2.3.2.1非归零编码</h6><ul>\n<li>正电压为1，负电压为0</li>\n</ul>\n<h6 id=\"2-3-2-2归零编码\"><a href=\"#2-3-2-2归零编码\" class=\"headerlink\" title=\"2.3.2.2归零编码\"></a>2.3.2.2归零编码</h6><ul>\n<li>电平翻转一次为1，没有电平变化为0</li>\n<li>电平的翻转能提供一种同步机制</li>\n</ul>\n<p><img src=\"非归零编码.png\" alt=\"非归零编码\" style=\"zoom:67%;\"></p>\n<h6 id=\"2-3-2-3双相位编码\"><a href=\"#2-3-2-3双相位编码\" class=\"headerlink\" title=\"2.3.2.3双相位编码\"></a>2.3.2.3双相位编码</h6><ul>\n<li>曼彻斯特编码：一个<strong>负电平到正电平</strong>的跳边<strong>代表1</strong>，由<strong>正到负代表0</strong></li>\n<li>差分曼彻斯特编码：每个比特间隙的开始位置<strong>有跳变代表0</strong>，<strong>没有跳变代表1</strong></li>\n</ul>\n<h4 id=\"2-4数字-模拟编码\"><a href=\"#2-4数字-模拟编码\" class=\"headerlink\" title=\"2.4数字-模拟编码\"></a>2.4数字-模拟编码</h4><h5 id=\"2-4-1幅移键控（ASK）\"><a href=\"#2-4-1幅移键控（ASK）\" class=\"headerlink\" title=\"2.4.1幅移键控（ASK）\"></a>2.4.1幅移键控（ASK）</h5><p><img src=\"ASK.png\" alt=\"ASK\" style=\"zoom:67%;\"></p>\n<h5 id=\"2-4-2频移键控（FSK）\"><a href=\"#2-4-2频移键控（FSK）\" class=\"headerlink\" title=\"2.4.2频移键控（FSK）\"></a>2.4.2频移键控（FSK）</h5><p><img src=\"FSK.png\" alt=\"FSK\" style=\"zoom:67%;\"></p>\n<h5 id=\"2-4-3相移键控（PSK）\"><a href=\"#2-4-3相移键控（PSK）\" class=\"headerlink\" title=\"2.4.3相移键控（PSK）\"></a>2.4.3相移键控（PSK）</h5><p><img src=\"PSK.png\" alt=\"PSK\" style=\"zoom:67%;\"></p>\n<h5 id=\"2-4-4正交调幅（QAM）\"><a href=\"#2-4-4正交调幅（QAM）\" class=\"headerlink\" title=\"2.4.4正交调幅（QAM）\"></a>2.4.4正交调幅（QAM）</h5><ul>\n<li>ASK和PSK结合起来的编码方式</li>\n</ul>\n<p><img src=\"QAM.png\" alt=\"QAM\" style=\"zoom: 67%;\"></p>\n<h3 id=\"3-线路配置与传输模式\"><a href=\"#3-线路配置与传输模式\" class=\"headerlink\" title=\"3.线路配置与传输模式\"></a>3.线路配置与传输模式</h3><h4 id=\"3-1传输模式\"><a href=\"#3-1传输模式\" class=\"headerlink\" title=\"3.1传输模式\"></a>3.1传输模式</h4><h5 id=\"3-1-1点到点连接\"><a href=\"#3-1-1点到点连接\" class=\"headerlink\" title=\"3.1.1点到点连接\"></a>3.1.1点到点连接</h5><ul>\n<li>提供了两个设备之间的专用链路。整个信道的容量都被用于这两个设备之间的传输</li>\n</ul>\n<h5 id=\"3-1-2多点连接\"><a href=\"#3-1-2多点连接\" class=\"headerlink\" title=\"3.1.2多点连接\"></a>3.1.2多点连接</h5><ul>\n<li>两个以上的设备共享一条链路的配置方式。信道的容量是通过某种途径共享的</li>\n<li>实现<strong>信道共享</strong>的技术称为<strong>复用技术</strong></li>\n</ul>\n<h5 id=\"3-1-3单工、半双工、双工\"><a href=\"#3-1-3单工、半双工、双工\" class=\"headerlink\" title=\"3.1.3单工、半双工、双工\"></a>3.1.3单工、半双工、双工</h5><ul>\n<li>单工：<strong>通信单向进行</strong>，两个站点中只有一个可以进行传输，另一个只能接收</li>\n<li>半双工：每个站点都可以发送和接收数据，但是<strong>不能同时发送和接收数据</strong>。</li>\n<li>双工：两个站点<strong>都可以同时发送和接收数据</strong></li>\n</ul>\n<h5 id=\"3-1-4串行、并行\"><a href=\"#3-1-4串行、并行\" class=\"headerlink\" title=\"3.1.4串行、并行\"></a>3.1.4串行、并行</h5><ul>\n<li>并行：在每个时钟脉冲到来时，多个比特被同时发送，每个比特使用单独的一条线路</li>\n<li>串行：每个时钟脉冲只发送一个比特，它只使用一条线路，逐个传送</li>\n</ul>\n<h5 id=\"3-1-5同步、异步\"><a href=\"#3-1-5同步、异步\" class=\"headerlink\" title=\"3.1.5同步、异步\"></a>3.1.5同步、异步</h5><ul>\n<li>异步：比特流划分成多个小组独立传送。随时发，有开始位，终止位，用于低速设备。开销大，先发开始位0，发送一个字节，在发送终止位1，如此循环</li>\n<li>同步：成块的发送比特流，字符之间不加开始位和停止位。先二进制同步（法一：接收端和发送端之间单设一条线传送时钟脉冲；法二：采用自同步编码，曼彻斯特编码等），再数据帧同步，在数据帧前后加上起始和结束标志</li>\n</ul>\n<h4 id=\"3-2多路复用\"><a href=\"#3-2多路复用\" class=\"headerlink\" title=\"3.2多路复用\"></a>3.2多路复用</h4><h5 id=\"3-2-1频分多路复用（FDM）\"><a href=\"#3-2-1频分多路复用（FDM）\" class=\"headerlink\" title=\"3.2.1频分多路复用（FDM）\"></a>3.2.1频分多路复用（FDM）</h5><ul>\n<li><strong>模拟信号</strong></li>\n</ul>\n<h5 id=\"3-2-1时分多路复用（TDM）\"><a href=\"#3-2-1时分多路复用（TDM）\" class=\"headerlink\" title=\"3.2.1时分多路复用（TDM）\"></a>3.2.1时分多路复用（TDM）</h5><ul>\n<li><strong>数字信号</strong></li>\n</ul>\n<h5 id=\"3-2-1波分多路复用（WDM）\"><a href=\"#3-2-1波分多路复用（WDM）\" class=\"headerlink\" title=\"3.2.1波分多路复用（WDM）\"></a>3.2.1波分多路复用（WDM）</h5><ul>\n<li><strong>模拟信号</strong></li>\n<li>光纤</li>\n</ul>\n<h5 id=\"3-2-1码分多路复用（CDM）-码分多址复用（CDMA）\"><a href=\"#3-2-1码分多路复用（CDM）-码分多址复用（CDMA）\" class=\"headerlink\" title=\"3.2.1码分多路复用（CDM）/码分多址复用（CDMA）\"></a>3.2.1码分多路复用（CDM）/码分多址复用（CDMA）</h5><ul>\n<li>根据码型结构的不同来实现信号分割</li>\n<li>在CDMA每个比特被分成m个不同码片，每个站点被指定一个唯一的m位码片（码型）。当发送比特1时，站点就发送其码片，想发送0时，站点就发送其码片的补码</li>\n</ul>\n<h4 id=\"3-3数据交换技术\"><a href=\"#3-3数据交换技术\" class=\"headerlink\" title=\"3.3数据交换技术\"></a>3.3数据交换技术</h4><h5 id=\"3-3-1电路交换\"><a href=\"#3-3-1电路交换\" class=\"headerlink\" title=\"3.3.1电路交换\"></a>3.3.1电路交换</h5><ul>\n<li>在两个设备之间创建一条临时的物理连接</li>\n<li>通讯过程：电路建立、数据传输、电路拆除</li>\n</ul>\n<h5 id=\"3-3-2报文交换（存储转发）\"><a href=\"#3-3-2报文交换（存储转发）\" class=\"headerlink\" title=\"3.3.2报文交换（存储转发）\"></a>3.3.2报文交换（存储转发）</h5><ul>\n<li>在报文的传输过程中，由网络的中间结点将报文暂时存储起来，检查它的正确性和完整性，然后再发往下一个结点</li>\n</ul>\n<h5 id=\"3-3-3分组交换\"><a href=\"#3-3-3分组交换\" class=\"headerlink\" title=\"3.3.3分组交换\"></a>3.3.3分组交换</h5><ul>\n<li>在分组交换中，较长的报文被分为较短的数据单元，然后每个数据单元被加上一些通信控制信息等内容，形成一个信息包（packet）。通信时以包为单位发送、存储和转发。信息包包含数据和包头，包头由通信控制信息、差错控制信息等组成</li>\n<li>信息包比报文短得多，因此可以在中间结点存储，不必访问外存。而且只要整个信息包到达后就可以转发，不必等待很长的报文全部到达，大大缩短了信息传输过程中的延迟时间</li>\n</ul>\n<h6 id=\"3-3-3-1数据报\"><a href=\"#3-3-3-1数据报\" class=\"headerlink\" title=\"3.3.3.1数据报\"></a>3.3.3.1数据报</h6><ul>\n<li>数据报方法中，包被称为数据报，在传输中每个包都将独立于其他包进行处理</li>\n<li><strong>到达的顺序可能不同</strong>，对数据报进行重排的任务可以由网络层的上层（传输层）来完成</li>\n</ul>\n<h6 id=\"3-3-3-2虚电路\"><a href=\"#3-3-3-2虚电路\" class=\"headerlink\" title=\"3.3.3.2虚电路\"></a>3.3.3.2虚电路</h6><ul>\n<li>虚电路方法中，属于同一次通信的所有包之间的关系得以维持。当数据开始时，将按照预定好的路线一个接一个的传送</li>\n<li>任何一条链路可以同时为多对设备之间的通信服务</li>\n<li>在需要的时候被创建、通信传输、拆除</li>\n<li>仅在建立虚电路时需要目的地址，在进行数据传送时，每个包不需要携带完整的目的地址，只需要一个虚电路的号码标识。减少了包的控制信息长度，从而减少了额外开销</li>\n</ul>\n<h4 id=\"3-4错误检验和控制\"><a href=\"#3-4错误检验和控制\" class=\"headerlink\" title=\"3.4错误检验和控制\"></a>3.4错误检验和控制</h4><ul>\n<li>见题型即可</li>\n</ul>\n<h5 id=\"3-4-1奇偶校验码\"><a href=\"#3-4-1奇偶校验码\" class=\"headerlink\" title=\"3.4.1奇偶校验码\"></a>3.4.1奇偶校验码</h5><h6 id=\"3-4-1-1垂直（纵向）奇偶校验\"><a href=\"#3-4-1-1垂直（纵向）奇偶校验\" class=\"headerlink\" title=\"3.4.1.1垂直（纵向）奇偶校验\"></a>3.4.1.1垂直（纵向）奇偶校验</h6><h6 id=\"3-4-1-2水平（横向）奇偶校验\"><a href=\"#3-4-1-2水平（横向）奇偶校验\" class=\"headerlink\" title=\"3.4.1.2水平（横向）奇偶校验\"></a>3.4.1.2水平（横向）奇偶校验</h6><h5 id=\"3-4-1循环校验码CRC\"><a href=\"#3-4-1循环校验码CRC\" class=\"headerlink\" title=\"3.4.1循环校验码CRC\"></a>3.4.1循环校验码CRC</h5><h5 id=\"3-4-2校验和\"><a href=\"#3-4-2校验和\" class=\"headerlink\" title=\"3.4.2校验和\"></a>3.4.2校验和</h5><h3 id=\"4-传输介质\"><a href=\"#4-传输介质\" class=\"headerlink\" title=\"4.传输介质\"></a>4.传输介质</h3><h4 id=\"4-1有线介质\"><a href=\"#4-1有线介质\" class=\"headerlink\" title=\"4.1有线介质\"></a>4.1有线介质</h4><h5 id=\"4-1-1双绞线\"><a href=\"#4-1-1双绞线\" class=\"headerlink\" title=\"4.1.1双绞线\"></a>4.1.1双绞线</h5><ul>\n<li>由扭在一起的两根绝缘铜线组成</li>\n<li>用于传输平衡信号</li>\n</ul>\n<h5 id=\"4-1-2同轴电缆\"><a href=\"#4-1-2同轴电缆\" class=\"headerlink\" title=\"4.1.2同轴电缆\"></a>4.1.2同轴电缆</h5><h5 id=\"4-1-3光纤\"><a href=\"#4-1-3光纤\" class=\"headerlink\" title=\"4.1.3光纤\"></a>4.1.3光纤</h5><ul>\n<li>光的速度依赖于它所穿越的传输介质的密度，密度越大，速度越低</li>\n</ul>\n<h6 id=\"4-1-3-1多模传播\"><a href=\"#4-1-3-1多模传播\" class=\"headerlink\" title=\"4.1.3.1多模传播\"></a>4.1.3.1多模传播</h6><ul>\n<li><p>多束光线在芯材中通过不同的路径</p>\n</li>\n<li><p>多模阶跃：密度突变，不同角度，速度不同，</p>\n</li>\n<li>多模渐变：密度渐变，速度相同，中心密度最大，并向外逐步变小</li>\n</ul>\n<h6 id=\"4-1-3-2单模传播\"><a href=\"#4-1-3-2单模传播\" class=\"headerlink\" title=\"4.1.3.2单模传播\"></a>4.1.3.2单模传播</h6><ul>\n<li>单模光纤采用阶跃材质和高度集中的光源。芯材直径比多模光纤小得多</li>\n</ul>\n<h4 id=\"4-2无线介质\"><a href=\"#4-2无线介质\" class=\"headerlink\" title=\"4.2无线介质\"></a>4.2无线介质</h4><h5 id=\"4-2-1卫星、微波、红外线\"><a href=\"#4-2-1卫星、微波、红外线\" class=\"headerlink\" title=\"4.2.1卫星、微波、红外线\"></a>4.2.1卫星、微波、红外线</h5><h3 id=\"5-物理连接\"><a href=\"#5-物理连接\" class=\"headerlink\" title=\"5.物理连接\"></a>5.物理连接</h3><ul>\n<li>在数据通信中涉及4个基本功能单元：两端各有一个数据终端设备（DTE）和一个数据电路终接设备</li>\n</ul>\n<h4 id=\"5-1数据终端设备（DTE）\"><a href=\"#5-1数据终端设备（DTE）\" class=\"headerlink\" title=\"5.1数据终端设备（DTE）\"></a>5.1数据终端设备（DTE）</h4><ul>\n<li>DTE是具有数据处理能力及发送和接收数据信息能力的设备</li>\n<li>DTE一般不直接连接网络，它通过一台DCE进行通信。</li>\n<li>我们把DTE和DCE的连接称为DTE-DCE接口</li>\n<li>在DTE-DCE接口上既有数据信息又有控制信息，为了<strong>使各个计算机公司生产的DTE可以方便的和DCE连接</strong>，就<strong>必须对DTE-DCE接口进行标准化</strong>，这些就是<strong>物理层的协议</strong></li>\n</ul>\n<h4 id=\"5-2数据电路终接设备（DCE）\"><a href=\"#5-2数据电路终接设备（DCE）\" class=\"headerlink\" title=\"5.2数据电路终接设备（DCE）\"></a>5.2数据电路终接设备（DCE）</h4><ul>\n<li>DCE是能够通过网络发送和接收模拟或数字信号形式数据的设备</li>\n<li><strong>总结</strong></li>\n<li>数据从上层数据链路层传来</li>\n<li>DTE处理数据，并交给DCE转换成能通过传输介质的电磁信号</li>\n<li>电磁信号通过传输介质传输</li>\n<li>各端的DCE接收这些电磁信号形成数据交给DTE处理</li>\n<li>DTE处理完数据，交给上层的数据链路层</li>\n</ul>\n<h3 id=\"6-物理层协议\"><a href=\"#6-物理层协议\" class=\"headerlink\" title=\"6.物理层协议\"></a>6.物理层协议</h3><h4 id=\"6-1EIA232\"><a href=\"#6-1EIA232\" class=\"headerlink\" title=\"6.1EIA232\"></a>6.1EIA232</h4><h5 id=\"6-1-1机械特性\"><a href=\"#6-1-1机械特性\" class=\"headerlink\" title=\"6.1.1机械特性\"></a>6.1.1机械特性</h5><h5 id=\"6-1-2电气特性\"><a href=\"#6-1-2电气特性\" class=\"headerlink\" title=\"6.1.2电气特性\"></a>6.1.2电气特性</h5><h5 id=\"6-1-3功能特性\"><a href=\"#6-1-3功能特性\" class=\"headerlink\" title=\"6.1.3功能特性\"></a>6.1.3功能特性</h5><h5 id=\"6-1-4规程特性\"><a href=\"#6-1-4规程特性\" class=\"headerlink\" title=\"6.1.4规程特性\"></a>6.1.4规程特性</h5><h4 id=\"6-2X-21\"><a href=\"#6-2X-21\" class=\"headerlink\" title=\"6.2X.21\"></a>6.2X.21</h4><h3 id=\"7-工作的设备\"><a href=\"#7-工作的设备\" class=\"headerlink\" title=\"7.工作的设备\"></a>7.工作的设备</h3><h4 id=\"7-1中继器或转发器\"><a href=\"#7-1中继器或转发器\" class=\"headerlink\" title=\"7.1中继器或转发器\"></a>7.1中继器或转发器</h4><ul>\n<li>中继器是一个再生器，不是一个增幅器，只是将受损的信号重新还原成原始的形式，会导致局域网性能下降</li>\n</ul>\n<h4 id=\"7-2集线器\"><a href=\"#7-2集线器\" class=\"headerlink\" title=\"7.2集线器\"></a>7.2集线器</h4><ul>\n<li>多端口中继器，建立星状、树状网络结构</li>\n</ul>\n<h3 id=\"8-考题类型\"><a href=\"#8-考题类型\" class=\"headerlink\" title=\"8.考题类型\"></a>8.考题类型</h3><h4 id=\"8-1-111000111000的曼彻斯特编码和差分曼彻斯特编码？\"><a href=\"#8-1-111000111000的曼彻斯特编码和差分曼彻斯特编码？\" class=\"headerlink\" title=\"8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？\"></a>8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？</h4><h4 id=\"8-2-CRC校验码\"><a href=\"#8-2-CRC校验码\" class=\"headerlink\" title=\"8.2 CRC校验码\"></a>8.2 CRC校验码</h4><ul>\n<li>是x的几次多项式，就在带传送数据后加几个0</li>\n<li><font color=\"red\">**同0异1**</font></li>\n<li>做除法，得出来的余数，加到带传输的数据后即可</li>\n</ul>\n<h4 id=\"8-3电路交换网络和包交换（分组交换）网络的主要区别是什么？\"><a href=\"#8-3电路交换网络和包交换（分组交换）网络的主要区别是什么？\" class=\"headerlink\" title=\"8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？\"></a>8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？</h4><h4 id=\"8-4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\"><a href=\"#8-4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\" class=\"headerlink\" title=\"8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\"></a>8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽</h4><ul>\n<li><p><strong>W</strong>：理想低通信信道的<strong>带宽</strong>，单位为Hz</p>\n</li>\n<li><p><strong>V</strong>：表示每个码元离散电平的数目</p>\n</li>\n<li><p>则理想低通信道下的极限数据传输率 = <strong>$2Wlog_2V$</strong></p>\n</li>\n<li><p>$1<em>10^6=2H</em>1<em>4, H=1</em>10^6/8=125000Hz$</p>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"强化-计网第二章-物理层\"><a href=\"#强化-计网第二章-物理层\" class=\"headerlink\" title=\"强化 计网第二章 物理层\"></a>强化 计网第二章 物理层</h2><h3 id=\"1-通信系统\"><a href=\"#1-通信系统\" class=\"headerlink\" title=\"1.通信系统\"></a>1.通信系统</h3><h4 id=\"1-1组成\"><a href=\"#1-1组成\" class=\"headerlink\" title=\"1.1组成\"></a>1.1组成</h4><h5 id=\"1-1-1信源\"><a href=\"#1-1-1信源\" class=\"headerlink\" title=\"1.1.1信源\"></a>1.1.1信源</h5><ul>\n<li>产生要发送数据的设备</li>\n</ul>\n<h5 id=\"1-1-2发送设备\"><a href=\"#1-1-2发送设备\" class=\"headerlink\" title=\"1.1.2发送设备\"></a>1.1.2发送设备</h5><ul>\n<li>对数据信息编码的设备</li>\n</ul>\n<h5 id=\"1-1-3传输系统\"><a href=\"#1-1-3传输系统\" class=\"headerlink\" title=\"1.1.3传输系统\"></a>1.1.3传输系统</h5><ul>\n<li>传输线路或网络</li>\n</ul>\n<h5 id=\"1-1-4接收设备\"><a href=\"#1-1-4接收设备\" class=\"headerlink\" title=\"1.1.4接收设备\"></a>1.1.4接收设备</h5><ul>\n<li>将接受的信号变成数据</li>\n</ul>\n<h5 id=\"1-1-5信宿\"><a href=\"#1-1-5信宿\" class=\"headerlink\" title=\"1.1.5信宿\"></a>1.1.5信宿</h5><ul>\n<li>从接收设备接收数据信息。就是目的系统</li>\n</ul>\n<h3 id=\"2-编码与调制\"><a href=\"#2-编码与调制\" class=\"headerlink\" title=\"2.编码与调制\"></a>2.编码与调制</h3><h4 id=\"2-1信号类型\"><a href=\"#2-1信号类型\" class=\"headerlink\" title=\"2.1信号类型\"></a>2.1信号类型</h4><h5 id=\"2-1-1模拟信号\"><a href=\"#2-1-1模拟信号\" class=\"headerlink\" title=\"2.1.1模拟信号\"></a>2.1.1模拟信号</h5><ul>\n<li>随时间连续变化的电磁波形式（信号）</li>\n</ul>\n<h6 id=\"2-1-1-1波特率\"><a href=\"#2-1-1-1波特率\" class=\"headerlink\" title=\"2.1.1.1波特率\"></a>2.1.1.1波特率</h6><ul>\n<li>每秒发送的波数</li>\n</ul>\n<h5 id=\"2-1-2数字信号\"><a href=\"#2-1-2数字信号\" class=\"headerlink\" title=\"2.1.2数字信号\"></a>2.1.2数字信号</h5><ul>\n<li>离散的，数值的变化是瞬时的</li>\n</ul>\n<h6 id=\"2-1-2-1比特间隙\"><a href=\"#2-1-2-1比特间隙\" class=\"headerlink\" title=\"2.1.2.1比特间隙\"></a>2.1.2.1比特间隙</h6><ul>\n<li>发送一比特所需要的时间</li>\n</ul>\n<h6 id=\"2-1-2-2比特率\"><a href=\"#2-1-2-2比特率\" class=\"headerlink\" title=\"2.1.2.2比特率\"></a>2.1.2.2比特率</h6><ul>\n<li>一秒钟内的比特间隙个数，是每秒发送的比特数，单位是bps（位每秒）</li>\n</ul>\n<h6 id=\"2-1-2-3有效带宽\"><a href=\"#2-1-2-3有效带宽\" class=\"headerlink\" title=\"2.1.2.3有效带宽\"></a>2.1.2.3有效带宽</h6><ul>\n<li>数字信号的频谱包括不同振幅的无数多个频率，如果根据一定的门限，只传输那些具有重要振幅的分量，仍然可以以合理的精度在接收端还原出数字信号，则数字信号频谱中的这一部分称作有效频谱，有效频谱的带宽称为有效带宽</li>\n</ul>\n<h4 id=\"2-2信道数据传输率\"><a href=\"#2-2信道数据传输率\" class=\"headerlink\" title=\"2.2信道数据传输率\"></a>2.2信道数据传输率</h4><h5 id=\"2-2-1奈奎斯特定理（奈氏准则）\"><a href=\"#2-2-1奈奎斯特定理（奈氏准则）\" class=\"headerlink\" title=\"2.2.1奈奎斯特定理（奈氏准则）\"></a>2.2.1奈奎斯特定理（奈氏准则）</h5><h5 id=\"2-2-2香农定理\"><a href=\"#2-2-2香农定理\" class=\"headerlink\" title=\"2.2.2香农定理\"></a>2.2.2香农定理</h5><h4 id=\"2-3数字-数字编码\"><a href=\"#2-3数字-数字编码\" class=\"headerlink\" title=\"2.3数字-数字编码\"></a>2.3数字-数字编码</h4><h5 id=\"2-3-1单极性编码\"><a href=\"#2-3-1单极性编码\" class=\"headerlink\" title=\"2.3.1单极性编码\"></a>2.3.1单极性编码</h5><ul>\n<li>电压只有一极，高电平表示1，低电平表示0</li>\n</ul>\n<p><img src=\"单极性编码.png\" alt=\"单极性编码\" style=\"zoom: 67%;\" /></p>\n<h5 id=\"2-3-2极化编码\"><a href=\"#2-3-2极化编码\" class=\"headerlink\" title=\"2.3.2极化编码\"></a>2.3.2极化编码</h5><ul>\n<li>一个正电压，一个负电压。通过使用两个电压，减轻了单极性编码中的直流分量问题</li>\n</ul>\n<h6 id=\"2-3-2-1非归零编码\"><a href=\"#2-3-2-1非归零编码\" class=\"headerlink\" title=\"2.3.2.1非归零编码\"></a>2.3.2.1非归零编码</h6><ul>\n<li>正电压为1，负电压为0</li>\n</ul>\n<h6 id=\"2-3-2-2归零编码\"><a href=\"#2-3-2-2归零编码\" class=\"headerlink\" title=\"2.3.2.2归零编码\"></a>2.3.2.2归零编码</h6><ul>\n<li>电平翻转一次为1，没有电平变化为0</li>\n<li>电平的翻转能提供一种同步机制</li>\n</ul>\n<p><img src=\"非归零编码.png\" alt=\"非归零编码\" style=\"zoom:67%;\" /></p>\n<h6 id=\"2-3-2-3双相位编码\"><a href=\"#2-3-2-3双相位编码\" class=\"headerlink\" title=\"2.3.2.3双相位编码\"></a>2.3.2.3双相位编码</h6><ul>\n<li>曼彻斯特编码：一个<strong>负电平到正电平</strong>的跳边<strong>代表1</strong>，由<strong>正到负代表0</strong></li>\n<li>差分曼彻斯特编码：每个比特间隙的开始位置<strong>有跳变代表0</strong>，<strong>没有跳变代表1</strong></li>\n</ul>\n<h4 id=\"2-4数字-模拟编码\"><a href=\"#2-4数字-模拟编码\" class=\"headerlink\" title=\"2.4数字-模拟编码\"></a>2.4数字-模拟编码</h4><h5 id=\"2-4-1幅移键控（ASK）\"><a href=\"#2-4-1幅移键控（ASK）\" class=\"headerlink\" title=\"2.4.1幅移键控（ASK）\"></a>2.4.1幅移键控（ASK）</h5><p><img src=\"ASK.png\" alt=\"ASK\" style=\"zoom:67%;\" /></p>\n<h5 id=\"2-4-2频移键控（FSK）\"><a href=\"#2-4-2频移键控（FSK）\" class=\"headerlink\" title=\"2.4.2频移键控（FSK）\"></a>2.4.2频移键控（FSK）</h5><p><img src=\"FSK.png\" alt=\"FSK\" style=\"zoom:67%;\" /></p>\n<h5 id=\"2-4-3相移键控（PSK）\"><a href=\"#2-4-3相移键控（PSK）\" class=\"headerlink\" title=\"2.4.3相移键控（PSK）\"></a>2.4.3相移键控（PSK）</h5><p><img src=\"PSK.png\" alt=\"PSK\" style=\"zoom:67%;\" /></p>\n<h5 id=\"2-4-4正交调幅（QAM）\"><a href=\"#2-4-4正交调幅（QAM）\" class=\"headerlink\" title=\"2.4.4正交调幅（QAM）\"></a>2.4.4正交调幅（QAM）</h5><ul>\n<li>ASK和PSK结合起来的编码方式</li>\n</ul>\n<p><img src=\"QAM.png\" alt=\"QAM\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"3-线路配置与传输模式\"><a href=\"#3-线路配置与传输模式\" class=\"headerlink\" title=\"3.线路配置与传输模式\"></a>3.线路配置与传输模式</h3><h4 id=\"3-1传输模式\"><a href=\"#3-1传输模式\" class=\"headerlink\" title=\"3.1传输模式\"></a>3.1传输模式</h4><h5 id=\"3-1-1点到点连接\"><a href=\"#3-1-1点到点连接\" class=\"headerlink\" title=\"3.1.1点到点连接\"></a>3.1.1点到点连接</h5><ul>\n<li>提供了两个设备之间的专用链路。整个信道的容量都被用于这两个设备之间的传输</li>\n</ul>\n<h5 id=\"3-1-2多点连接\"><a href=\"#3-1-2多点连接\" class=\"headerlink\" title=\"3.1.2多点连接\"></a>3.1.2多点连接</h5><ul>\n<li>两个以上的设备共享一条链路的配置方式。信道的容量是通过某种途径共享的</li>\n<li>实现<strong>信道共享</strong>的技术称为<strong>复用技术</strong></li>\n</ul>\n<h5 id=\"3-1-3单工、半双工、双工\"><a href=\"#3-1-3单工、半双工、双工\" class=\"headerlink\" title=\"3.1.3单工、半双工、双工\"></a>3.1.3单工、半双工、双工</h5><ul>\n<li>单工：<strong>通信单向进行</strong>，两个站点中只有一个可以进行传输，另一个只能接收</li>\n<li>半双工：每个站点都可以发送和接收数据，但是<strong>不能同时发送和接收数据</strong>。</li>\n<li>双工：两个站点<strong>都可以同时发送和接收数据</strong></li>\n</ul>\n<h5 id=\"3-1-4串行、并行\"><a href=\"#3-1-4串行、并行\" class=\"headerlink\" title=\"3.1.4串行、并行\"></a>3.1.4串行、并行</h5><ul>\n<li>并行：在每个时钟脉冲到来时，多个比特被同时发送，每个比特使用单独的一条线路</li>\n<li>串行：每个时钟脉冲只发送一个比特，它只使用一条线路，逐个传送</li>\n</ul>\n<h5 id=\"3-1-5同步、异步\"><a href=\"#3-1-5同步、异步\" class=\"headerlink\" title=\"3.1.5同步、异步\"></a>3.1.5同步、异步</h5><ul>\n<li>异步：比特流划分成多个小组独立传送。随时发，有开始位，终止位，用于低速设备。开销大，先发开始位0，发送一个字节，在发送终止位1，如此循环</li>\n<li>同步：成块的发送比特流，字符之间不加开始位和停止位。先二进制同步（法一：接收端和发送端之间单设一条线传送时钟脉冲；法二：采用自同步编码，曼彻斯特编码等），再数据帧同步，在数据帧前后加上起始和结束标志</li>\n</ul>\n<h4 id=\"3-2多路复用\"><a href=\"#3-2多路复用\" class=\"headerlink\" title=\"3.2多路复用\"></a>3.2多路复用</h4><h5 id=\"3-2-1频分多路复用（FDM）\"><a href=\"#3-2-1频分多路复用（FDM）\" class=\"headerlink\" title=\"3.2.1频分多路复用（FDM）\"></a>3.2.1频分多路复用（FDM）</h5><ul>\n<li><strong>模拟信号</strong></li>\n</ul>\n<h5 id=\"3-2-1时分多路复用（TDM）\"><a href=\"#3-2-1时分多路复用（TDM）\" class=\"headerlink\" title=\"3.2.1时分多路复用（TDM）\"></a>3.2.1时分多路复用（TDM）</h5><ul>\n<li><strong>数字信号</strong></li>\n</ul>\n<h5 id=\"3-2-1波分多路复用（WDM）\"><a href=\"#3-2-1波分多路复用（WDM）\" class=\"headerlink\" title=\"3.2.1波分多路复用（WDM）\"></a>3.2.1波分多路复用（WDM）</h5><ul>\n<li><strong>模拟信号</strong></li>\n<li>光纤</li>\n</ul>\n<h5 id=\"3-2-1码分多路复用（CDM）-码分多址复用（CDMA）\"><a href=\"#3-2-1码分多路复用（CDM）-码分多址复用（CDMA）\" class=\"headerlink\" title=\"3.2.1码分多路复用（CDM）/码分多址复用（CDMA）\"></a>3.2.1码分多路复用（CDM）/码分多址复用（CDMA）</h5><ul>\n<li>根据码型结构的不同来实现信号分割</li>\n<li>在CDMA每个比特被分成m个不同码片，每个站点被指定一个唯一的m位码片（码型）。当发送比特1时，站点就发送其码片，想发送0时，站点就发送其码片的补码</li>\n</ul>\n<h4 id=\"3-3数据交换技术\"><a href=\"#3-3数据交换技术\" class=\"headerlink\" title=\"3.3数据交换技术\"></a>3.3数据交换技术</h4><h5 id=\"3-3-1电路交换\"><a href=\"#3-3-1电路交换\" class=\"headerlink\" title=\"3.3.1电路交换\"></a>3.3.1电路交换</h5><ul>\n<li>在两个设备之间创建一条临时的物理连接</li>\n<li>通讯过程：电路建立、数据传输、电路拆除</li>\n</ul>\n<h5 id=\"3-3-2报文交换（存储转发）\"><a href=\"#3-3-2报文交换（存储转发）\" class=\"headerlink\" title=\"3.3.2报文交换（存储转发）\"></a>3.3.2报文交换（存储转发）</h5><ul>\n<li>在报文的传输过程中，由网络的中间结点将报文暂时存储起来，检查它的正确性和完整性，然后再发往下一个结点</li>\n</ul>\n<h5 id=\"3-3-3分组交换\"><a href=\"#3-3-3分组交换\" class=\"headerlink\" title=\"3.3.3分组交换\"></a>3.3.3分组交换</h5><ul>\n<li>在分组交换中，较长的报文被分为较短的数据单元，然后每个数据单元被加上一些通信控制信息等内容，形成一个信息包（packet）。通信时以包为单位发送、存储和转发。信息包包含数据和包头，包头由通信控制信息、差错控制信息等组成</li>\n<li>信息包比报文短得多，因此可以在中间结点存储，不必访问外存。而且只要整个信息包到达后就可以转发，不必等待很长的报文全部到达，大大缩短了信息传输过程中的延迟时间</li>\n</ul>\n<h6 id=\"3-3-3-1数据报\"><a href=\"#3-3-3-1数据报\" class=\"headerlink\" title=\"3.3.3.1数据报\"></a>3.3.3.1数据报</h6><ul>\n<li>数据报方法中，包被称为数据报，在传输中每个包都将独立于其他包进行处理</li>\n<li><strong>到达的顺序可能不同</strong>，对数据报进行重排的任务可以由网络层的上层（传输层）来完成</li>\n</ul>\n<h6 id=\"3-3-3-2虚电路\"><a href=\"#3-3-3-2虚电路\" class=\"headerlink\" title=\"3.3.3.2虚电路\"></a>3.3.3.2虚电路</h6><ul>\n<li>虚电路方法中，属于同一次通信的所有包之间的关系得以维持。当数据开始时，将按照预定好的路线一个接一个的传送</li>\n<li>任何一条链路可以同时为多对设备之间的通信服务</li>\n<li>在需要的时候被创建、通信传输、拆除</li>\n<li>仅在建立虚电路时需要目的地址，在进行数据传送时，每个包不需要携带完整的目的地址，只需要一个虚电路的号码标识。减少了包的控制信息长度，从而减少了额外开销</li>\n</ul>\n<h4 id=\"3-4错误检验和控制\"><a href=\"#3-4错误检验和控制\" class=\"headerlink\" title=\"3.4错误检验和控制\"></a>3.4错误检验和控制</h4><ul>\n<li>见题型即可</li>\n</ul>\n<h5 id=\"3-4-1奇偶校验码\"><a href=\"#3-4-1奇偶校验码\" class=\"headerlink\" title=\"3.4.1奇偶校验码\"></a>3.4.1奇偶校验码</h5><h6 id=\"3-4-1-1垂直（纵向）奇偶校验\"><a href=\"#3-4-1-1垂直（纵向）奇偶校验\" class=\"headerlink\" title=\"3.4.1.1垂直（纵向）奇偶校验\"></a>3.4.1.1垂直（纵向）奇偶校验</h6><h6 id=\"3-4-1-2水平（横向）奇偶校验\"><a href=\"#3-4-1-2水平（横向）奇偶校验\" class=\"headerlink\" title=\"3.4.1.2水平（横向）奇偶校验\"></a>3.4.1.2水平（横向）奇偶校验</h6><h5 id=\"3-4-1循环校验码CRC\"><a href=\"#3-4-1循环校验码CRC\" class=\"headerlink\" title=\"3.4.1循环校验码CRC\"></a>3.4.1循环校验码CRC</h5><h5 id=\"3-4-2校验和\"><a href=\"#3-4-2校验和\" class=\"headerlink\" title=\"3.4.2校验和\"></a>3.4.2校验和</h5><h3 id=\"4-传输介质\"><a href=\"#4-传输介质\" class=\"headerlink\" title=\"4.传输介质\"></a>4.传输介质</h3><h4 id=\"4-1有线介质\"><a href=\"#4-1有线介质\" class=\"headerlink\" title=\"4.1有线介质\"></a>4.1有线介质</h4><h5 id=\"4-1-1双绞线\"><a href=\"#4-1-1双绞线\" class=\"headerlink\" title=\"4.1.1双绞线\"></a>4.1.1双绞线</h5><ul>\n<li>由扭在一起的两根绝缘铜线组成</li>\n<li>用于传输平衡信号</li>\n</ul>\n<h5 id=\"4-1-2同轴电缆\"><a href=\"#4-1-2同轴电缆\" class=\"headerlink\" title=\"4.1.2同轴电缆\"></a>4.1.2同轴电缆</h5><h5 id=\"4-1-3光纤\"><a href=\"#4-1-3光纤\" class=\"headerlink\" title=\"4.1.3光纤\"></a>4.1.3光纤</h5><ul>\n<li>光的速度依赖于它所穿越的传输介质的密度，密度越大，速度越低</li>\n</ul>\n<h6 id=\"4-1-3-1多模传播\"><a href=\"#4-1-3-1多模传播\" class=\"headerlink\" title=\"4.1.3.1多模传播\"></a>4.1.3.1多模传播</h6><ul>\n<li><p>多束光线在芯材中通过不同的路径</p>\n</li>\n<li><p>多模阶跃：密度突变，不同角度，速度不同，</p>\n</li>\n<li>多模渐变：密度渐变，速度相同，中心密度最大，并向外逐步变小</li>\n</ul>\n<h6 id=\"4-1-3-2单模传播\"><a href=\"#4-1-3-2单模传播\" class=\"headerlink\" title=\"4.1.3.2单模传播\"></a>4.1.3.2单模传播</h6><ul>\n<li>单模光纤采用阶跃材质和高度集中的光源。芯材直径比多模光纤小得多</li>\n</ul>\n<h4 id=\"4-2无线介质\"><a href=\"#4-2无线介质\" class=\"headerlink\" title=\"4.2无线介质\"></a>4.2无线介质</h4><h5 id=\"4-2-1卫星、微波、红外线\"><a href=\"#4-2-1卫星、微波、红外线\" class=\"headerlink\" title=\"4.2.1卫星、微波、红外线\"></a>4.2.1卫星、微波、红外线</h5><h3 id=\"5-物理连接\"><a href=\"#5-物理连接\" class=\"headerlink\" title=\"5.物理连接\"></a>5.物理连接</h3><ul>\n<li>在数据通信中涉及4个基本功能单元：两端各有一个数据终端设备（DTE）和一个数据电路终接设备</li>\n</ul>\n<h4 id=\"5-1数据终端设备（DTE）\"><a href=\"#5-1数据终端设备（DTE）\" class=\"headerlink\" title=\"5.1数据终端设备（DTE）\"></a>5.1数据终端设备（DTE）</h4><ul>\n<li>DTE是具有数据处理能力及发送和接收数据信息能力的设备</li>\n<li>DTE一般不直接连接网络，它通过一台DCE进行通信。</li>\n<li>我们把DTE和DCE的连接称为DTE-DCE接口</li>\n<li>在DTE-DCE接口上既有数据信息又有控制信息，为了<strong>使各个计算机公司生产的DTE可以方便的和DCE连接</strong>，就<strong>必须对DTE-DCE接口进行标准化</strong>，这些就是<strong>物理层的协议</strong></li>\n</ul>\n<h4 id=\"5-2数据电路终接设备（DCE）\"><a href=\"#5-2数据电路终接设备（DCE）\" class=\"headerlink\" title=\"5.2数据电路终接设备（DCE）\"></a>5.2数据电路终接设备（DCE）</h4><ul>\n<li>DCE是能够通过网络发送和接收模拟或数字信号形式数据的设备</li>\n<li><strong>总结</strong></li>\n<li>数据从上层数据链路层传来</li>\n<li>DTE处理数据，并交给DCE转换成能通过传输介质的电磁信号</li>\n<li>电磁信号通过传输介质传输</li>\n<li>各端的DCE接收这些电磁信号形成数据交给DTE处理</li>\n<li>DTE处理完数据，交给上层的数据链路层</li>\n</ul>\n<h3 id=\"6-物理层协议\"><a href=\"#6-物理层协议\" class=\"headerlink\" title=\"6.物理层协议\"></a>6.物理层协议</h3><h4 id=\"6-1EIA232\"><a href=\"#6-1EIA232\" class=\"headerlink\" title=\"6.1EIA232\"></a>6.1EIA232</h4><h5 id=\"6-1-1机械特性\"><a href=\"#6-1-1机械特性\" class=\"headerlink\" title=\"6.1.1机械特性\"></a>6.1.1机械特性</h5><h5 id=\"6-1-2电气特性\"><a href=\"#6-1-2电气特性\" class=\"headerlink\" title=\"6.1.2电气特性\"></a>6.1.2电气特性</h5><h5 id=\"6-1-3功能特性\"><a href=\"#6-1-3功能特性\" class=\"headerlink\" title=\"6.1.3功能特性\"></a>6.1.3功能特性</h5><h5 id=\"6-1-4规程特性\"><a href=\"#6-1-4规程特性\" class=\"headerlink\" title=\"6.1.4规程特性\"></a>6.1.4规程特性</h5><h4 id=\"6-2X-21\"><a href=\"#6-2X-21\" class=\"headerlink\" title=\"6.2X.21\"></a>6.2X.21</h4><h3 id=\"7-工作的设备\"><a href=\"#7-工作的设备\" class=\"headerlink\" title=\"7.工作的设备\"></a>7.工作的设备</h3><h4 id=\"7-1中继器或转发器\"><a href=\"#7-1中继器或转发器\" class=\"headerlink\" title=\"7.1中继器或转发器\"></a>7.1中继器或转发器</h4><ul>\n<li>中继器是一个再生器，不是一个增幅器，只是将受损的信号重新还原成原始的形式，会导致局域网性能下降</li>\n</ul>\n<h4 id=\"7-2集线器\"><a href=\"#7-2集线器\" class=\"headerlink\" title=\"7.2集线器\"></a>7.2集线器</h4><ul>\n<li>多端口中继器，建立星状、树状网络结构</li>\n</ul>\n<h3 id=\"8-考题类型\"><a href=\"#8-考题类型\" class=\"headerlink\" title=\"8.考题类型\"></a>8.考题类型</h3><h4 id=\"8-1-111000111000的曼彻斯特编码和差分曼彻斯特编码？\"><a href=\"#8-1-111000111000的曼彻斯特编码和差分曼彻斯特编码？\" class=\"headerlink\" title=\"8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？\"></a>8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？</h4><h4 id=\"8-2-CRC校验码\"><a href=\"#8-2-CRC校验码\" class=\"headerlink\" title=\"8.2 CRC校验码\"></a>8.2 CRC校验码</h4><ul>\n<li>是x的几次多项式，就在带传送数据后加几个0</li>\n<li><font color=\"red\">**同0异1**</font></li>\n<li>做除法，得出来的余数，加到带传输的数据后即可</li>\n</ul>\n<h4 id=\"8-3电路交换网络和包交换（分组交换）网络的主要区别是什么？\"><a href=\"#8-3电路交换网络和包交换（分组交换）网络的主要区别是什么？\" class=\"headerlink\" title=\"8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？\"></a>8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？</h4><h4 id=\"8-4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\"><a href=\"#8-4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\" class=\"headerlink\" title=\"8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽\"></a>8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽</h4><ul>\n<li><p><strong>W</strong>：理想低通信信道的<strong>带宽</strong>，单位为Hz</p>\n</li>\n<li><p><strong>V</strong>：表示每个码元离散电平的数目</p>\n</li>\n<li><p>则理想低通信道下的极限数据传输率 = <strong>$2Wlog_2V$</strong></p>\n</li>\n<li><p>$1<em>10^6=2H</em>1<em>4, H=1</em>10^6/8=125000Hz$</p>\n</li>\n</ul>\n"},{"title":"每日一题(一) 7.27","top":false,"cover":false,"toc":false,"mathjax":false,"summary":"判断子序列","abbrlink":"b23c","date":"2020-07-27T12:42:34.000Z","password":null,"_content":"## 每日一题 7.27\n\n### 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n**示例 1:**\ns = \"abc\", t = \"ahbgdc\"\n\n返回 true.\n\n**示例 2:**\ns = \"axc\", t = \"ahbgdc\"\n\n返回 false.\n\n##### 思路：\n\n​\t我们初始化两个指针 i 和 j ，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。\n​\t最终如果 i 移动到 s的末尾，就说明 s 是 t 的子序列。\n\n##### 代码：\n\n```c\n#include <stdio.h> \n#include <string.h>//字符串所需包\n#include <stdbool.h>//bool所需包\n\nbool isSubsequence(char *s, char *t) {    \n    int n = strlen(s), m = strlen(t);    \n    int i = 0, j = 0;//定义两个指针\n    while (i < n && j < m) {        \n        if (s[i] == t[j]) {            \n            i++;        \n        }        \n        j++;    \n    }    \n    printf(\"%d\",i==n);//%d指十进制数字\n}\n\nint main() {    \n    isSubsequence(\"abcdc\", \"asdabcd\");\n}\n```\n\n##### 复杂度分析：\n\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(1)\n\n","source":"_posts/每日一题7-27.md","raw":"---\ntitle: 每日一题(一) 7.27\ntop: false\ncover: false\ntoc: false\nmathjax: false\ntags:\n  - 代码\n  - 每日一题\n  - 考研\ncategories:\n  - 每日一题\nsummary: 判断子序列\nabbrlink: b23c\ndate: 2020-07-27 20:42:34\npassword:\n---\n## 每日一题 7.27\n\n### 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n**示例 1:**\ns = \"abc\", t = \"ahbgdc\"\n\n返回 true.\n\n**示例 2:**\ns = \"axc\", t = \"ahbgdc\"\n\n返回 false.\n\n##### 思路：\n\n​\t我们初始化两个指针 i 和 j ，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。\n​\t最终如果 i 移动到 s的末尾，就说明 s 是 t 的子序列。\n\n##### 代码：\n\n```c\n#include <stdio.h> \n#include <string.h>//字符串所需包\n#include <stdbool.h>//bool所需包\n\nbool isSubsequence(char *s, char *t) {    \n    int n = strlen(s), m = strlen(t);    \n    int i = 0, j = 0;//定义两个指针\n    while (i < n && j < m) {        \n        if (s[i] == t[j]) {            \n            i++;        \n        }        \n        j++;    \n    }    \n    printf(\"%d\",i==n);//%d指十进制数字\n}\n\nint main() {    \n    isSubsequence(\"abcdc\", \"asdabcd\");\n}\n```\n\n##### 复杂度分析：\n\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(1)\n\n","slug":"每日一题7-27","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5z003fa09kexb5bpi1","content":"<h2 id=\"每日一题-7-27\"><a href=\"#每日一题-7-27\" class=\"headerlink\" title=\"每日一题 7.27\"></a>每日一题 7.27</h2><h3 id=\"给定字符串-s-和-t-，判断-s-是否为-t-的子序列。\"><a href=\"#给定字符串-s-和-t-，判断-s-是否为-t-的子序列。\" class=\"headerlink\" title=\"给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\"></a>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</h3><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>\n<p><strong>示例 1:</strong><br>s = “abc”, t = “ahbgdc”</p>\n<p>返回 true.</p>\n<p><strong>示例 2:</strong><br>s = “axc”, t = “ahbgdc”</p>\n<p>返回 false.</p>\n<h5 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h5><p>​    我们初始化两个指针 i 和 j ，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。<br>​    最终如果 i 移动到 s的末尾，就说明 s 是 t 的子序列。</p>\n<h5 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h5><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#include <stdio.h> \n#include <string.h>//字符串所需包\n#include <stdbool.h>//bool所需包\n\nbool isSubsequence(char *s, char *t) {    \n    int n = strlen(s), m = strlen(t);    \n    int i = 0, j = 0;//定义两个指针\n    while (i < n && j < m) {        \n        if (s[i] == t[j]) {            \n            i++;        \n        }        \n        j++;    \n    }    \n    printf(\"%d\",i==n);//%d指十进制数字\n}\n\nint main() {    \n    isSubsequence(\"abcdc\", \"asdabcd\");\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"复杂度分析：\"><a href=\"#复杂度分析：\" class=\"headerlink\" title=\"复杂度分析：\"></a>复杂度分析：</h5><ul>\n<li>时间复杂度：O(m + n)</li>\n<li>空间复杂度：O(1)</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"每日一题-7-27\"><a href=\"#每日一题-7-27\" class=\"headerlink\" title=\"每日一题 7.27\"></a>每日一题 7.27</h2><h3 id=\"给定字符串-s-和-t-，判断-s-是否为-t-的子序列。\"><a href=\"#给定字符串-s-和-t-，判断-s-是否为-t-的子序列。\" class=\"headerlink\" title=\"给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\"></a>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</h3><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>\n<p><strong>示例 1:</strong><br>s = “abc”, t = “ahbgdc”</p>\n<p>返回 true.</p>\n<p><strong>示例 2:</strong><br>s = “axc”, t = “ahbgdc”</p>\n<p>返回 false.</p>\n<h5 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h5><p>​    我们初始化两个指针 i 和 j ，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。<br>​    最终如果 i 移动到 s的末尾，就说明 s 是 t 的子序列。</p>\n<h5 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h5><pre><code class=\"lang-c\">#include &lt;stdio.h&gt; \n#include &lt;string.h&gt;//字符串所需包\n#include &lt;stdbool.h&gt;//bool所需包\n\nbool isSubsequence(char *s, char *t) {    \n    int n = strlen(s), m = strlen(t);    \n    int i = 0, j = 0;//定义两个指针\n    while (i &lt; n &amp;&amp; j &lt; m) {        \n        if (s[i] == t[j]) {            \n            i++;        \n        }        \n        j++;    \n    }    \n    printf(&quot;%d&quot;,i==n);//%d指十进制数字\n}\n\nint main() {    \n    isSubsequence(&quot;abcdc&quot;, &quot;asdabcd&quot;);\n}\n</code></pre>\n<h5 id=\"复杂度分析：\"><a href=\"#复杂度分析：\" class=\"headerlink\" title=\"复杂度分析：\"></a>复杂度分析：</h5><ul>\n<li>时间复杂度：O(m + n)</li>\n<li>空间复杂度：O(1)</li>\n</ul>\n"},{"title":"强化计网第一章-概述","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":"3689","date":"2020-08-27T08:23:11.000Z","password":null,"summary":"(强化)第一章 绪论","keywords":"计算机网络概述大纲","_content":"## （强化）计网第一章 绪论\n\n> **计算机网络：是由多个独立的计算机通过通信线路和通信设备互联起来的系统，以便实现彼此交换信息和共享资源的目的**。\n\n#### 1. 功能\n\n##### 1.1数据通信\n\n- 网络系统中相连的计算机能够相互传送数据信息，使相距很远的用户之间能够直接交换数据\n\n##### 1.2资源共享\n\n- 网络中的软件和硬件资源，如外部设备、文件系统和数据等可分为多个用户所共享\n\n#### 2. 组成\n\n##### 2.1资源子网\n\n- 负责全网的信息处理，向网络用户提供各种网络资源与网络服务\n\n##### 2.2通信子网\n\n- 完成数据传输和转发等通讯业务\n\n#### 3.网络拓扑结构（<font color=red>背！</font>）\n\n##### 3.1网状拓扑（全连接拓扑）\n\n- 避免拥塞问题\n- 具有很好的健壮性\n- 具有私有性和安全性\n- 便于管理\n- 安装费用高\n\n##### 3.2星状拓扑\n\n- 拓扑结构简单\n- 具有较好的健壮性\n- 便于管理\n- 中央控制器是整个网络性能的瓶颈\n\n##### 3.3树状拓扑\n\n- 允许更多的设备相连并且增加了在设备间的传输距离\n- 允许网络隔离不同计算机的通信\n\n##### 3.4总线型拓扑\n\n- 信息传输不存在路由和转发的问题\n- 易安装\n- 故障隔离和重新配置困难\n- 总线长度和连接的设备数会受到限制\n\n##### 3.5环形拓扑\n\n- 易安装和重新配置\n- 故障隔离比较简单\n- 对于最大长度和设备的数量有一定的限制\n- 一个故障就会引起整个网络瘫痪\n\n##### 3.6混合型拓扑\n\n#### 4.网络分类\n\n##### 4.1按作用范围分类\n\n- 局域网（一般为私有的）、城域网和广域网\n\n##### 4.2按通讯介质分类\n\n- 有线网（同轴电缆、双绞线和光纤）和无线网\n\n##### 4.3按通信传播方式分类\n\n- 点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）\n\n##### 4.4按通信速率分类\n\n- 低速网、中速网和高速网\n\n##### 4.5按使用范围分类\n\n- 公用网和专用网\n\n##### 4.6按网络控制方式分类\n\n- 集中式网络和分布式网络（无处理中心，每个结点地位平等）\n\n##### 4.7按网络环境分类\n\n- 部门网、企业网和校园网\n\n#### 5. 分层体系结构\n\n##### 5.1网络协议\n\n- 通信双方必须需遵守的规则、标准和约定\n\n##### 5.2语法\n\n- 数据与控制信息的结构或格式\n\n##### 5.3语义\n\n- 控制信息的功能和动作\n\n##### 5.4时序\n\n- 信息的同步，速度匹配\n\n##### 5.5体系结构\n\n- 计算机网络的各个层次及其相关协议的集合\n\n#### 6. OSI ISO（**七层**）\n\n##### 6.1 物理层（比特）\n\n- 设备：中继器、集线器\n\n##### 6.2 数据链路层（帧）\n\n- 可靠通信\n\n##### 6.3 网络层（分组或包）\n\n- 选择路由、交换结点、拥塞控制、网络互联\n\n##### 6.4 传输层（报文）\n\n- 实现了端到端的通信\n\n##### 6.5 会话层\n\n- 提供同步点机制\n\n##### 6.6 表示层\n\n- 解决用户信息的语法表示问题\n\n##### 6.7 应用层\n\n- 处理用户的数据和信息\n\n#### 7. TCP/IP\n\n<font color=red>必须掌握TCP，UDP报文要熟记</font>\n\n##### 7.1 物理层和数据链路层\n\n##### 7.2 网络层\n\n- 寻址、数据打包和路由选择\n- 核心协议：IP协议\n- IP协议是无连接的，不保证传输的可靠性\n\n##### 7.3 传输层\n\n- 核心协议：传输控制协议TCP和用户数据报协议UDP（<font color=red>TCP，UDP报文要熟记</font>）\n- TCP是一个可靠的面向连接的传输层协议\n- UDP是一个不可靠的面向无连接的传输层协议，适用于延迟较小的场合\n\n##### 7.4 应用层\n\n- 各种协议\n\n#### 8. 实体间通信与服务\n\n##### 8.1通信\n\n###### 8.1.1 层间通信\n\n- 同一个网络结点上相邻层次中实体之间的通信称为层间通信\n\n###### 8.1.2 对等层间通信\n\n- 不同的网络结点上对等层实体间的通信称为对等层间通信\n\n###### 8.1.3 实通信\n\n- 层间通信以及物理层之间的通信叫做实通信\n\n###### 8.1.4虚通信\n\n- 除物理层外，对等层之间的通信叫做虚通信\n\n##### 8.2服务于数据单元\n\n###### 8.2.1服务访问点SAP（Service Access Point）\n\n- 层间接口处提供服务的地方\n\n###### 8.2.2服务数据单元SDU（Service Data Unit）\n\n- 相邻层在提供服务的过程中要传递的信息\n\n###### 8.2.3协议数据单元PDU（Protocol Data Unit）\n\n- 对等层间交换的信息单位\n\n###### 8.2.4协议控制信息PCI\n\n- N层的PDU = N层的SDU加上该层的PCI\n\n##### 8.3服务原语\n\n###### 8.3.1请求原语\n\n- 由N+1层实体向N层实体发出，要求这个N层实体向它提供指定的N层服务，如进行一次数据传送\n\n###### 8.3.2指示原语\n\n- 由N层实体向N+1层实体发出，通知这个N+1层实体某个特定的N层服务已经开始\n\n###### 8.3.3响应原语\n\n- 由N+1层实体向N层实体发出，表示对这个N层实体送来的指示原语的响应\n\n###### 8.3.4证实原语\n\n- 由N层实体向N+1层实体发出，表示它请求的N层服务已经完成\n\n###### 8.3.5证实性服务\n\n- \n\n###### 8.3.6非证实性服务\n\n- \n\n###### 8.3.7面向连接的服务\n\n- 建立连接阶段\n- 数据交换阶段\n- 释放连接阶段\n\n###### 8.3.8面向无连接的服务\n\n- 数据报\n- 证实交付，又称可靠地数据报\n- 请求/响应\n\n##### 8.4性能指标\n\n###### 8.4.1吞吐量\n\n- 信道吞吐量是信道上单位时间成功发送的信息量，用bps（位每秒）表示\n\n###### 8.4.2信道利用率\n\n- 是除去全部控制信息后的数据率与信道吞吐量之比。控制部分开销越大，利用率越低\n\n###### 8.4.3延迟时间\n\n###### 8.4.4**排队时间**\n\n###### 8.4.5**访问延时**\n\n###### 8.4.6**发送时延**\n\n- 数据块长度（b）\n- 信道带宽（s）\n\n###### 8.4.7**传输延时**\n\n- 信道长度（m）\n- 信号在信道上的传播速率（m/s）\n\n#### 9.考题类型\n\n##### 9.1计算机网络系统的主要通信性能指标有哪些？\n\n##### 9.2网络延迟的4个主要原因是什么？\n","source":"_posts/强化计网第一章-概述.md","raw":"---\ntitle: 强化计网第一章-概述\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 计网\n  - 强化\n  - 总结\n  - 考研\ncategories:\n  - 计网\nabbrlink: '3689'\ndate: 2020-08-27 16:23:11\npassword:\nsummary: (强化)第一章 绪论\nkeywords: 计算机网络概述大纲\n---\n## （强化）计网第一章 绪论\n\n> **计算机网络：是由多个独立的计算机通过通信线路和通信设备互联起来的系统，以便实现彼此交换信息和共享资源的目的**。\n\n#### 1. 功能\n\n##### 1.1数据通信\n\n- 网络系统中相连的计算机能够相互传送数据信息，使相距很远的用户之间能够直接交换数据\n\n##### 1.2资源共享\n\n- 网络中的软件和硬件资源，如外部设备、文件系统和数据等可分为多个用户所共享\n\n#### 2. 组成\n\n##### 2.1资源子网\n\n- 负责全网的信息处理，向网络用户提供各种网络资源与网络服务\n\n##### 2.2通信子网\n\n- 完成数据传输和转发等通讯业务\n\n#### 3.网络拓扑结构（<font color=red>背！</font>）\n\n##### 3.1网状拓扑（全连接拓扑）\n\n- 避免拥塞问题\n- 具有很好的健壮性\n- 具有私有性和安全性\n- 便于管理\n- 安装费用高\n\n##### 3.2星状拓扑\n\n- 拓扑结构简单\n- 具有较好的健壮性\n- 便于管理\n- 中央控制器是整个网络性能的瓶颈\n\n##### 3.3树状拓扑\n\n- 允许更多的设备相连并且增加了在设备间的传输距离\n- 允许网络隔离不同计算机的通信\n\n##### 3.4总线型拓扑\n\n- 信息传输不存在路由和转发的问题\n- 易安装\n- 故障隔离和重新配置困难\n- 总线长度和连接的设备数会受到限制\n\n##### 3.5环形拓扑\n\n- 易安装和重新配置\n- 故障隔离比较简单\n- 对于最大长度和设备的数量有一定的限制\n- 一个故障就会引起整个网络瘫痪\n\n##### 3.6混合型拓扑\n\n#### 4.网络分类\n\n##### 4.1按作用范围分类\n\n- 局域网（一般为私有的）、城域网和广域网\n\n##### 4.2按通讯介质分类\n\n- 有线网（同轴电缆、双绞线和光纤）和无线网\n\n##### 4.3按通信传播方式分类\n\n- 点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）\n\n##### 4.4按通信速率分类\n\n- 低速网、中速网和高速网\n\n##### 4.5按使用范围分类\n\n- 公用网和专用网\n\n##### 4.6按网络控制方式分类\n\n- 集中式网络和分布式网络（无处理中心，每个结点地位平等）\n\n##### 4.7按网络环境分类\n\n- 部门网、企业网和校园网\n\n#### 5. 分层体系结构\n\n##### 5.1网络协议\n\n- 通信双方必须需遵守的规则、标准和约定\n\n##### 5.2语法\n\n- 数据与控制信息的结构或格式\n\n##### 5.3语义\n\n- 控制信息的功能和动作\n\n##### 5.4时序\n\n- 信息的同步，速度匹配\n\n##### 5.5体系结构\n\n- 计算机网络的各个层次及其相关协议的集合\n\n#### 6. OSI ISO（**七层**）\n\n##### 6.1 物理层（比特）\n\n- 设备：中继器、集线器\n\n##### 6.2 数据链路层（帧）\n\n- 可靠通信\n\n##### 6.3 网络层（分组或包）\n\n- 选择路由、交换结点、拥塞控制、网络互联\n\n##### 6.4 传输层（报文）\n\n- 实现了端到端的通信\n\n##### 6.5 会话层\n\n- 提供同步点机制\n\n##### 6.6 表示层\n\n- 解决用户信息的语法表示问题\n\n##### 6.7 应用层\n\n- 处理用户的数据和信息\n\n#### 7. TCP/IP\n\n<font color=red>必须掌握TCP，UDP报文要熟记</font>\n\n##### 7.1 物理层和数据链路层\n\n##### 7.2 网络层\n\n- 寻址、数据打包和路由选择\n- 核心协议：IP协议\n- IP协议是无连接的，不保证传输的可靠性\n\n##### 7.3 传输层\n\n- 核心协议：传输控制协议TCP和用户数据报协议UDP（<font color=red>TCP，UDP报文要熟记</font>）\n- TCP是一个可靠的面向连接的传输层协议\n- UDP是一个不可靠的面向无连接的传输层协议，适用于延迟较小的场合\n\n##### 7.4 应用层\n\n- 各种协议\n\n#### 8. 实体间通信与服务\n\n##### 8.1通信\n\n###### 8.1.1 层间通信\n\n- 同一个网络结点上相邻层次中实体之间的通信称为层间通信\n\n###### 8.1.2 对等层间通信\n\n- 不同的网络结点上对等层实体间的通信称为对等层间通信\n\n###### 8.1.3 实通信\n\n- 层间通信以及物理层之间的通信叫做实通信\n\n###### 8.1.4虚通信\n\n- 除物理层外，对等层之间的通信叫做虚通信\n\n##### 8.2服务于数据单元\n\n###### 8.2.1服务访问点SAP（Service Access Point）\n\n- 层间接口处提供服务的地方\n\n###### 8.2.2服务数据单元SDU（Service Data Unit）\n\n- 相邻层在提供服务的过程中要传递的信息\n\n###### 8.2.3协议数据单元PDU（Protocol Data Unit）\n\n- 对等层间交换的信息单位\n\n###### 8.2.4协议控制信息PCI\n\n- N层的PDU = N层的SDU加上该层的PCI\n\n##### 8.3服务原语\n\n###### 8.3.1请求原语\n\n- 由N+1层实体向N层实体发出，要求这个N层实体向它提供指定的N层服务，如进行一次数据传送\n\n###### 8.3.2指示原语\n\n- 由N层实体向N+1层实体发出，通知这个N+1层实体某个特定的N层服务已经开始\n\n###### 8.3.3响应原语\n\n- 由N+1层实体向N层实体发出，表示对这个N层实体送来的指示原语的响应\n\n###### 8.3.4证实原语\n\n- 由N层实体向N+1层实体发出，表示它请求的N层服务已经完成\n\n###### 8.3.5证实性服务\n\n- \n\n###### 8.3.6非证实性服务\n\n- \n\n###### 8.3.7面向连接的服务\n\n- 建立连接阶段\n- 数据交换阶段\n- 释放连接阶段\n\n###### 8.3.8面向无连接的服务\n\n- 数据报\n- 证实交付，又称可靠地数据报\n- 请求/响应\n\n##### 8.4性能指标\n\n###### 8.4.1吞吐量\n\n- 信道吞吐量是信道上单位时间成功发送的信息量，用bps（位每秒）表示\n\n###### 8.4.2信道利用率\n\n- 是除去全部控制信息后的数据率与信道吞吐量之比。控制部分开销越大，利用率越低\n\n###### 8.4.3延迟时间\n\n###### 8.4.4**排队时间**\n\n###### 8.4.5**访问延时**\n\n###### 8.4.6**发送时延**\n\n- 数据块长度（b）\n- 信道带宽（s）\n\n###### 8.4.7**传输延时**\n\n- 信道长度（m）\n- 信号在信道上的传播速率（m/s）\n\n#### 9.考题类型\n\n##### 9.1计算机网络系统的主要通信性能指标有哪些？\n\n##### 9.2网络延迟的4个主要原因是什么？\n","slug":"强化计网第一章-概述","published":1,"updated":"2020-09-15T11:19:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q5z003ia09k7zv99on1","content":"<h2 id=\"（强化）计网第一章-绪论\"><a href=\"#（强化）计网第一章-绪论\" class=\"headerlink\" title=\"（强化）计网第一章 绪论\"></a>（强化）计网第一章 绪论</h2><blockquote>\n<p><strong>计算机网络：是由多个独立的计算机通过通信线路和通信设备互联起来的系统，以便实现彼此交换信息和共享资源的目的</strong>。</p>\n</blockquote>\n<h4 id=\"1-功能\"><a href=\"#1-功能\" class=\"headerlink\" title=\"1. 功能\"></a>1. 功能</h4><h5 id=\"1-1数据通信\"><a href=\"#1-1数据通信\" class=\"headerlink\" title=\"1.1数据通信\"></a>1.1数据通信</h5><ul>\n<li>网络系统中相连的计算机能够相互传送数据信息，使相距很远的用户之间能够直接交换数据</li>\n</ul>\n<h5 id=\"1-2资源共享\"><a href=\"#1-2资源共享\" class=\"headerlink\" title=\"1.2资源共享\"></a>1.2资源共享</h5><ul>\n<li>网络中的软件和硬件资源，如外部设备、文件系统和数据等可分为多个用户所共享</li>\n</ul>\n<h4 id=\"2-组成\"><a href=\"#2-组成\" class=\"headerlink\" title=\"2. 组成\"></a>2. 组成</h4><h5 id=\"2-1资源子网\"><a href=\"#2-1资源子网\" class=\"headerlink\" title=\"2.1资源子网\"></a>2.1资源子网</h5><ul>\n<li>负责全网的信息处理，向网络用户提供各种网络资源与网络服务</li>\n</ul>\n<h5 id=\"2-2通信子网\"><a href=\"#2-2通信子网\" class=\"headerlink\" title=\"2.2通信子网\"></a>2.2通信子网</h5><ul>\n<li>完成数据传输和转发等通讯业务</li>\n</ul>\n<h4 id=\"3-网络拓扑结构（背！）\"><a href=\"#3-网络拓扑结构（背！）\" class=\"headerlink\" title=\"3.网络拓扑结构（背！）\"></a>3.网络拓扑结构（<font color=\"red\">背！</font>）</h4><h5 id=\"3-1网状拓扑（全连接拓扑）\"><a href=\"#3-1网状拓扑（全连接拓扑）\" class=\"headerlink\" title=\"3.1网状拓扑（全连接拓扑）\"></a>3.1网状拓扑（全连接拓扑）</h5><ul>\n<li>避免拥塞问题</li>\n<li>具有很好的健壮性</li>\n<li>具有私有性和安全性</li>\n<li>便于管理</li>\n<li>安装费用高</li>\n</ul>\n<h5 id=\"3-2星状拓扑\"><a href=\"#3-2星状拓扑\" class=\"headerlink\" title=\"3.2星状拓扑\"></a>3.2星状拓扑</h5><ul>\n<li>拓扑结构简单</li>\n<li>具有较好的健壮性</li>\n<li>便于管理</li>\n<li>中央控制器是整个网络性能的瓶颈</li>\n</ul>\n<h5 id=\"3-3树状拓扑\"><a href=\"#3-3树状拓扑\" class=\"headerlink\" title=\"3.3树状拓扑\"></a>3.3树状拓扑</h5><ul>\n<li>允许更多的设备相连并且增加了在设备间的传输距离</li>\n<li>允许网络隔离不同计算机的通信</li>\n</ul>\n<h5 id=\"3-4总线型拓扑\"><a href=\"#3-4总线型拓扑\" class=\"headerlink\" title=\"3.4总线型拓扑\"></a>3.4总线型拓扑</h5><ul>\n<li>信息传输不存在路由和转发的问题</li>\n<li>易安装</li>\n<li>故障隔离和重新配置困难</li>\n<li>总线长度和连接的设备数会受到限制</li>\n</ul>\n<h5 id=\"3-5环形拓扑\"><a href=\"#3-5环形拓扑\" class=\"headerlink\" title=\"3.5环形拓扑\"></a>3.5环形拓扑</h5><ul>\n<li>易安装和重新配置</li>\n<li>故障隔离比较简单</li>\n<li>对于最大长度和设备的数量有一定的限制</li>\n<li>一个故障就会引起整个网络瘫痪</li>\n</ul>\n<h5 id=\"3-6混合型拓扑\"><a href=\"#3-6混合型拓扑\" class=\"headerlink\" title=\"3.6混合型拓扑\"></a>3.6混合型拓扑</h5><h4 id=\"4-网络分类\"><a href=\"#4-网络分类\" class=\"headerlink\" title=\"4.网络分类\"></a>4.网络分类</h4><h5 id=\"4-1按作用范围分类\"><a href=\"#4-1按作用范围分类\" class=\"headerlink\" title=\"4.1按作用范围分类\"></a>4.1按作用范围分类</h5><ul>\n<li>局域网（一般为私有的）、城域网和广域网</li>\n</ul>\n<h5 id=\"4-2按通讯介质分类\"><a href=\"#4-2按通讯介质分类\" class=\"headerlink\" title=\"4.2按通讯介质分类\"></a>4.2按通讯介质分类</h5><ul>\n<li>有线网（同轴电缆、双绞线和光纤）和无线网</li>\n</ul>\n<h5 id=\"4-3按通信传播方式分类\"><a href=\"#4-3按通信传播方式分类\" class=\"headerlink\" title=\"4.3按通信传播方式分类\"></a>4.3按通信传播方式分类</h5><ul>\n<li>点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）</li>\n</ul>\n<h5 id=\"4-4按通信速率分类\"><a href=\"#4-4按通信速率分类\" class=\"headerlink\" title=\"4.4按通信速率分类\"></a>4.4按通信速率分类</h5><ul>\n<li>低速网、中速网和高速网</li>\n</ul>\n<h5 id=\"4-5按使用范围分类\"><a href=\"#4-5按使用范围分类\" class=\"headerlink\" title=\"4.5按使用范围分类\"></a>4.5按使用范围分类</h5><ul>\n<li>公用网和专用网</li>\n</ul>\n<h5 id=\"4-6按网络控制方式分类\"><a href=\"#4-6按网络控制方式分类\" class=\"headerlink\" title=\"4.6按网络控制方式分类\"></a>4.6按网络控制方式分类</h5><ul>\n<li>集中式网络和分布式网络（无处理中心，每个结点地位平等）</li>\n</ul>\n<h5 id=\"4-7按网络环境分类\"><a href=\"#4-7按网络环境分类\" class=\"headerlink\" title=\"4.7按网络环境分类\"></a>4.7按网络环境分类</h5><ul>\n<li>部门网、企业网和校园网</li>\n</ul>\n<h4 id=\"5-分层体系结构\"><a href=\"#5-分层体系结构\" class=\"headerlink\" title=\"5. 分层体系结构\"></a>5. 分层体系结构</h4><h5 id=\"5-1网络协议\"><a href=\"#5-1网络协议\" class=\"headerlink\" title=\"5.1网络协议\"></a>5.1网络协议</h5><ul>\n<li>通信双方必须需遵守的规则、标准和约定</li>\n</ul>\n<h5 id=\"5-2语法\"><a href=\"#5-2语法\" class=\"headerlink\" title=\"5.2语法\"></a>5.2语法</h5><ul>\n<li>数据与控制信息的结构或格式</li>\n</ul>\n<h5 id=\"5-3语义\"><a href=\"#5-3语义\" class=\"headerlink\" title=\"5.3语义\"></a>5.3语义</h5><ul>\n<li>控制信息的功能和动作</li>\n</ul>\n<h5 id=\"5-4时序\"><a href=\"#5-4时序\" class=\"headerlink\" title=\"5.4时序\"></a>5.4时序</h5><ul>\n<li>信息的同步，速度匹配</li>\n</ul>\n<h5 id=\"5-5体系结构\"><a href=\"#5-5体系结构\" class=\"headerlink\" title=\"5.5体系结构\"></a>5.5体系结构</h5><ul>\n<li>计算机网络的各个层次及其相关协议的集合</li>\n</ul>\n<h4 id=\"6-OSI-ISO（七层）\"><a href=\"#6-OSI-ISO（七层）\" class=\"headerlink\" title=\"6. OSI ISO（七层）\"></a>6. OSI ISO（<strong>七层</strong>）</h4><h5 id=\"6-1-物理层（比特）\"><a href=\"#6-1-物理层（比特）\" class=\"headerlink\" title=\"6.1 物理层（比特）\"></a>6.1 物理层（比特）</h5><ul>\n<li>设备：中继器、集线器</li>\n</ul>\n<h5 id=\"6-2-数据链路层（帧）\"><a href=\"#6-2-数据链路层（帧）\" class=\"headerlink\" title=\"6.2 数据链路层（帧）\"></a>6.2 数据链路层（帧）</h5><ul>\n<li>可靠通信</li>\n</ul>\n<h5 id=\"6-3-网络层（分组或包）\"><a href=\"#6-3-网络层（分组或包）\" class=\"headerlink\" title=\"6.3 网络层（分组或包）\"></a>6.3 网络层（分组或包）</h5><ul>\n<li>选择路由、交换结点、拥塞控制、网络互联</li>\n</ul>\n<h5 id=\"6-4-传输层（报文）\"><a href=\"#6-4-传输层（报文）\" class=\"headerlink\" title=\"6.4 传输层（报文）\"></a>6.4 传输层（报文）</h5><ul>\n<li>实现了端到端的通信</li>\n</ul>\n<h5 id=\"6-5-会话层\"><a href=\"#6-5-会话层\" class=\"headerlink\" title=\"6.5 会话层\"></a>6.5 会话层</h5><ul>\n<li>提供同步点机制</li>\n</ul>\n<h5 id=\"6-6-表示层\"><a href=\"#6-6-表示层\" class=\"headerlink\" title=\"6.6 表示层\"></a>6.6 表示层</h5><ul>\n<li>解决用户信息的语法表示问题</li>\n</ul>\n<h5 id=\"6-7-应用层\"><a href=\"#6-7-应用层\" class=\"headerlink\" title=\"6.7 应用层\"></a>6.7 应用层</h5><ul>\n<li>处理用户的数据和信息</li>\n</ul>\n<h4 id=\"7-TCP-IP\"><a href=\"#7-TCP-IP\" class=\"headerlink\" title=\"7. TCP/IP\"></a>7. TCP/IP</h4><font color=\"red\">必须掌握TCP，UDP报文要熟记</font>\n\n<h5 id=\"7-1-物理层和数据链路层\"><a href=\"#7-1-物理层和数据链路层\" class=\"headerlink\" title=\"7.1 物理层和数据链路层\"></a>7.1 物理层和数据链路层</h5><h5 id=\"7-2-网络层\"><a href=\"#7-2-网络层\" class=\"headerlink\" title=\"7.2 网络层\"></a>7.2 网络层</h5><ul>\n<li>寻址、数据打包和路由选择</li>\n<li>核心协议：IP协议</li>\n<li>IP协议是无连接的，不保证传输的可靠性</li>\n</ul>\n<h5 id=\"7-3-传输层\"><a href=\"#7-3-传输层\" class=\"headerlink\" title=\"7.3 传输层\"></a>7.3 传输层</h5><ul>\n<li>核心协议：传输控制协议TCP和用户数据报协议UDP（<font color=\"red\">TCP，UDP报文要熟记</font>）</li>\n<li>TCP是一个可靠的面向连接的传输层协议</li>\n<li>UDP是一个不可靠的面向无连接的传输层协议，适用于延迟较小的场合</li>\n</ul>\n<h5 id=\"7-4-应用层\"><a href=\"#7-4-应用层\" class=\"headerlink\" title=\"7.4 应用层\"></a>7.4 应用层</h5><ul>\n<li>各种协议</li>\n</ul>\n<h4 id=\"8-实体间通信与服务\"><a href=\"#8-实体间通信与服务\" class=\"headerlink\" title=\"8. 实体间通信与服务\"></a>8. 实体间通信与服务</h4><h5 id=\"8-1通信\"><a href=\"#8-1通信\" class=\"headerlink\" title=\"8.1通信\"></a>8.1通信</h5><h6 id=\"8-1-1-层间通信\"><a href=\"#8-1-1-层间通信\" class=\"headerlink\" title=\"8.1.1 层间通信\"></a>8.1.1 层间通信</h6><ul>\n<li>同一个网络结点上相邻层次中实体之间的通信称为层间通信</li>\n</ul>\n<h6 id=\"8-1-2-对等层间通信\"><a href=\"#8-1-2-对等层间通信\" class=\"headerlink\" title=\"8.1.2 对等层间通信\"></a>8.1.2 对等层间通信</h6><ul>\n<li>不同的网络结点上对等层实体间的通信称为对等层间通信</li>\n</ul>\n<h6 id=\"8-1-3-实通信\"><a href=\"#8-1-3-实通信\" class=\"headerlink\" title=\"8.1.3 实通信\"></a>8.1.3 实通信</h6><ul>\n<li>层间通信以及物理层之间的通信叫做实通信</li>\n</ul>\n<h6 id=\"8-1-4虚通信\"><a href=\"#8-1-4虚通信\" class=\"headerlink\" title=\"8.1.4虚通信\"></a>8.1.4虚通信</h6><ul>\n<li>除物理层外，对等层之间的通信叫做虚通信</li>\n</ul>\n<h5 id=\"8-2服务于数据单元\"><a href=\"#8-2服务于数据单元\" class=\"headerlink\" title=\"8.2服务于数据单元\"></a>8.2服务于数据单元</h5><h6 id=\"8-2-1服务访问点SAP（Service-Access-Point）\"><a href=\"#8-2-1服务访问点SAP（Service-Access-Point）\" class=\"headerlink\" title=\"8.2.1服务访问点SAP（Service Access Point）\"></a>8.2.1服务访问点SAP（Service Access Point）</h6><ul>\n<li>层间接口处提供服务的地方</li>\n</ul>\n<h6 id=\"8-2-2服务数据单元SDU（Service-Data-Unit）\"><a href=\"#8-2-2服务数据单元SDU（Service-Data-Unit）\" class=\"headerlink\" title=\"8.2.2服务数据单元SDU（Service Data Unit）\"></a>8.2.2服务数据单元SDU（Service Data Unit）</h6><ul>\n<li>相邻层在提供服务的过程中要传递的信息</li>\n</ul>\n<h6 id=\"8-2-3协议数据单元PDU（Protocol-Data-Unit）\"><a href=\"#8-2-3协议数据单元PDU（Protocol-Data-Unit）\" class=\"headerlink\" title=\"8.2.3协议数据单元PDU（Protocol Data Unit）\"></a>8.2.3协议数据单元PDU（Protocol Data Unit）</h6><ul>\n<li>对等层间交换的信息单位</li>\n</ul>\n<h6 id=\"8-2-4协议控制信息PCI\"><a href=\"#8-2-4协议控制信息PCI\" class=\"headerlink\" title=\"8.2.4协议控制信息PCI\"></a>8.2.4协议控制信息PCI</h6><ul>\n<li>N层的PDU = N层的SDU加上该层的PCI</li>\n</ul>\n<h5 id=\"8-3服务原语\"><a href=\"#8-3服务原语\" class=\"headerlink\" title=\"8.3服务原语\"></a>8.3服务原语</h5><h6 id=\"8-3-1请求原语\"><a href=\"#8-3-1请求原语\" class=\"headerlink\" title=\"8.3.1请求原语\"></a>8.3.1请求原语</h6><ul>\n<li>由N+1层实体向N层实体发出，要求这个N层实体向它提供指定的N层服务，如进行一次数据传送</li>\n</ul>\n<h6 id=\"8-3-2指示原语\"><a href=\"#8-3-2指示原语\" class=\"headerlink\" title=\"8.3.2指示原语\"></a>8.3.2指示原语</h6><ul>\n<li>由N层实体向N+1层实体发出，通知这个N+1层实体某个特定的N层服务已经开始</li>\n</ul>\n<h6 id=\"8-3-3响应原语\"><a href=\"#8-3-3响应原语\" class=\"headerlink\" title=\"8.3.3响应原语\"></a>8.3.3响应原语</h6><ul>\n<li>由N+1层实体向N层实体发出，表示对这个N层实体送来的指示原语的响应</li>\n</ul>\n<h6 id=\"8-3-4证实原语\"><a href=\"#8-3-4证实原语\" class=\"headerlink\" title=\"8.3.4证实原语\"></a>8.3.4证实原语</h6><ul>\n<li>由N层实体向N+1层实体发出，表示它请求的N层服务已经完成</li>\n</ul>\n<h6 id=\"8-3-5证实性服务\"><a href=\"#8-3-5证实性服务\" class=\"headerlink\" title=\"8.3.5证实性服务\"></a>8.3.5证实性服务</h6><ul>\n<li><h6 id=\"8-3-6非证实性服务\"><a href=\"#8-3-6非证实性服务\" class=\"headerlink\" title=\"8.3.6非证实性服务\"></a>8.3.6非证实性服务</h6></li>\n<li></li>\n</ul>\n<h6 id=\"8-3-7面向连接的服务\"><a href=\"#8-3-7面向连接的服务\" class=\"headerlink\" title=\"8.3.7面向连接的服务\"></a>8.3.7面向连接的服务</h6><ul>\n<li>建立连接阶段</li>\n<li>数据交换阶段</li>\n<li>释放连接阶段</li>\n</ul>\n<h6 id=\"8-3-8面向无连接的服务\"><a href=\"#8-3-8面向无连接的服务\" class=\"headerlink\" title=\"8.3.8面向无连接的服务\"></a>8.3.8面向无连接的服务</h6><ul>\n<li>数据报</li>\n<li>证实交付，又称可靠地数据报</li>\n<li>请求/响应</li>\n</ul>\n<h5 id=\"8-4性能指标\"><a href=\"#8-4性能指标\" class=\"headerlink\" title=\"8.4性能指标\"></a>8.4性能指标</h5><h6 id=\"8-4-1吞吐量\"><a href=\"#8-4-1吞吐量\" class=\"headerlink\" title=\"8.4.1吞吐量\"></a>8.4.1吞吐量</h6><ul>\n<li>信道吞吐量是信道上单位时间成功发送的信息量，用bps（位每秒）表示</li>\n</ul>\n<h6 id=\"8-4-2信道利用率\"><a href=\"#8-4-2信道利用率\" class=\"headerlink\" title=\"8.4.2信道利用率\"></a>8.4.2信道利用率</h6><ul>\n<li>是除去全部控制信息后的数据率与信道吞吐量之比。控制部分开销越大，利用率越低</li>\n</ul>\n<h6 id=\"8-4-3延迟时间\"><a href=\"#8-4-3延迟时间\" class=\"headerlink\" title=\"8.4.3延迟时间\"></a>8.4.3延迟时间</h6><h6 id=\"8-4-4排队时间\"><a href=\"#8-4-4排队时间\" class=\"headerlink\" title=\"8.4.4排队时间\"></a>8.4.4<strong>排队时间</strong></h6><h6 id=\"8-4-5访问延时\"><a href=\"#8-4-5访问延时\" class=\"headerlink\" title=\"8.4.5访问延时\"></a>8.4.5<strong>访问延时</strong></h6><h6 id=\"8-4-6发送时延\"><a href=\"#8-4-6发送时延\" class=\"headerlink\" title=\"8.4.6发送时延\"></a>8.4.6<strong>发送时延</strong></h6><ul>\n<li>数据块长度（b）</li>\n<li>信道带宽（s）</li>\n</ul>\n<h6 id=\"8-4-7传输延时\"><a href=\"#8-4-7传输延时\" class=\"headerlink\" title=\"8.4.7传输延时\"></a>8.4.7<strong>传输延时</strong></h6><ul>\n<li>信道长度（m）</li>\n<li>信号在信道上的传播速率（m/s）</li>\n</ul>\n<h4 id=\"9-考题类型\"><a href=\"#9-考题类型\" class=\"headerlink\" title=\"9.考题类型\"></a>9.考题类型</h4><h5 id=\"9-1计算机网络系统的主要通信性能指标有哪些？\"><a href=\"#9-1计算机网络系统的主要通信性能指标有哪些？\" class=\"headerlink\" title=\"9.1计算机网络系统的主要通信性能指标有哪些？\"></a>9.1计算机网络系统的主要通信性能指标有哪些？</h5><h5 id=\"9-2网络延迟的4个主要原因是什么？\"><a href=\"#9-2网络延迟的4个主要原因是什么？\" class=\"headerlink\" title=\"9.2网络延迟的4个主要原因是什么？\"></a>9.2网络延迟的4个主要原因是什么？</h5><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"（强化）计网第一章-绪论\"><a href=\"#（强化）计网第一章-绪论\" class=\"headerlink\" title=\"（强化）计网第一章 绪论\"></a>（强化）计网第一章 绪论</h2><blockquote>\n<p><strong>计算机网络：是由多个独立的计算机通过通信线路和通信设备互联起来的系统，以便实现彼此交换信息和共享资源的目的</strong>。</p>\n</blockquote>\n<h4 id=\"1-功能\"><a href=\"#1-功能\" class=\"headerlink\" title=\"1. 功能\"></a>1. 功能</h4><h5 id=\"1-1数据通信\"><a href=\"#1-1数据通信\" class=\"headerlink\" title=\"1.1数据通信\"></a>1.1数据通信</h5><ul>\n<li>网络系统中相连的计算机能够相互传送数据信息，使相距很远的用户之间能够直接交换数据</li>\n</ul>\n<h5 id=\"1-2资源共享\"><a href=\"#1-2资源共享\" class=\"headerlink\" title=\"1.2资源共享\"></a>1.2资源共享</h5><ul>\n<li>网络中的软件和硬件资源，如外部设备、文件系统和数据等可分为多个用户所共享</li>\n</ul>\n<h4 id=\"2-组成\"><a href=\"#2-组成\" class=\"headerlink\" title=\"2. 组成\"></a>2. 组成</h4><h5 id=\"2-1资源子网\"><a href=\"#2-1资源子网\" class=\"headerlink\" title=\"2.1资源子网\"></a>2.1资源子网</h5><ul>\n<li>负责全网的信息处理，向网络用户提供各种网络资源与网络服务</li>\n</ul>\n<h5 id=\"2-2通信子网\"><a href=\"#2-2通信子网\" class=\"headerlink\" title=\"2.2通信子网\"></a>2.2通信子网</h5><ul>\n<li>完成数据传输和转发等通讯业务</li>\n</ul>\n<h4 id=\"3-网络拓扑结构（背！）\"><a href=\"#3-网络拓扑结构（背！）\" class=\"headerlink\" title=\"3.网络拓扑结构（背！）\"></a>3.网络拓扑结构（<font color=red>背！</font>）</h4><h5 id=\"3-1网状拓扑（全连接拓扑）\"><a href=\"#3-1网状拓扑（全连接拓扑）\" class=\"headerlink\" title=\"3.1网状拓扑（全连接拓扑）\"></a>3.1网状拓扑（全连接拓扑）</h5><ul>\n<li>避免拥塞问题</li>\n<li>具有很好的健壮性</li>\n<li>具有私有性和安全性</li>\n<li>便于管理</li>\n<li>安装费用高</li>\n</ul>\n<h5 id=\"3-2星状拓扑\"><a href=\"#3-2星状拓扑\" class=\"headerlink\" title=\"3.2星状拓扑\"></a>3.2星状拓扑</h5><ul>\n<li>拓扑结构简单</li>\n<li>具有较好的健壮性</li>\n<li>便于管理</li>\n<li>中央控制器是整个网络性能的瓶颈</li>\n</ul>\n<h5 id=\"3-3树状拓扑\"><a href=\"#3-3树状拓扑\" class=\"headerlink\" title=\"3.3树状拓扑\"></a>3.3树状拓扑</h5><ul>\n<li>允许更多的设备相连并且增加了在设备间的传输距离</li>\n<li>允许网络隔离不同计算机的通信</li>\n</ul>\n<h5 id=\"3-4总线型拓扑\"><a href=\"#3-4总线型拓扑\" class=\"headerlink\" title=\"3.4总线型拓扑\"></a>3.4总线型拓扑</h5><ul>\n<li>信息传输不存在路由和转发的问题</li>\n<li>易安装</li>\n<li>故障隔离和重新配置困难</li>\n<li>总线长度和连接的设备数会受到限制</li>\n</ul>\n<h5 id=\"3-5环形拓扑\"><a href=\"#3-5环形拓扑\" class=\"headerlink\" title=\"3.5环形拓扑\"></a>3.5环形拓扑</h5><ul>\n<li>易安装和重新配置</li>\n<li>故障隔离比较简单</li>\n<li>对于最大长度和设备的数量有一定的限制</li>\n<li>一个故障就会引起整个网络瘫痪</li>\n</ul>\n<h5 id=\"3-6混合型拓扑\"><a href=\"#3-6混合型拓扑\" class=\"headerlink\" title=\"3.6混合型拓扑\"></a>3.6混合型拓扑</h5><h4 id=\"4-网络分类\"><a href=\"#4-网络分类\" class=\"headerlink\" title=\"4.网络分类\"></a>4.网络分类</h4><h5 id=\"4-1按作用范围分类\"><a href=\"#4-1按作用范围分类\" class=\"headerlink\" title=\"4.1按作用范围分类\"></a>4.1按作用范围分类</h5><ul>\n<li>局域网（一般为私有的）、城域网和广域网</li>\n</ul>\n<h5 id=\"4-2按通讯介质分类\"><a href=\"#4-2按通讯介质分类\" class=\"headerlink\" title=\"4.2按通讯介质分类\"></a>4.2按通讯介质分类</h5><ul>\n<li>有线网（同轴电缆、双绞线和光纤）和无线网</li>\n</ul>\n<h5 id=\"4-3按通信传播方式分类\"><a href=\"#4-3按通信传播方式分类\" class=\"headerlink\" title=\"4.3按通信传播方式分类\"></a>4.3按通信传播方式分类</h5><ul>\n<li>点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）</li>\n</ul>\n<h5 id=\"4-4按通信速率分类\"><a href=\"#4-4按通信速率分类\" class=\"headerlink\" title=\"4.4按通信速率分类\"></a>4.4按通信速率分类</h5><ul>\n<li>低速网、中速网和高速网</li>\n</ul>\n<h5 id=\"4-5按使用范围分类\"><a href=\"#4-5按使用范围分类\" class=\"headerlink\" title=\"4.5按使用范围分类\"></a>4.5按使用范围分类</h5><ul>\n<li>公用网和专用网</li>\n</ul>\n<h5 id=\"4-6按网络控制方式分类\"><a href=\"#4-6按网络控制方式分类\" class=\"headerlink\" title=\"4.6按网络控制方式分类\"></a>4.6按网络控制方式分类</h5><ul>\n<li>集中式网络和分布式网络（无处理中心，每个结点地位平等）</li>\n</ul>\n<h5 id=\"4-7按网络环境分类\"><a href=\"#4-7按网络环境分类\" class=\"headerlink\" title=\"4.7按网络环境分类\"></a>4.7按网络环境分类</h5><ul>\n<li>部门网、企业网和校园网</li>\n</ul>\n<h4 id=\"5-分层体系结构\"><a href=\"#5-分层体系结构\" class=\"headerlink\" title=\"5. 分层体系结构\"></a>5. 分层体系结构</h4><h5 id=\"5-1网络协议\"><a href=\"#5-1网络协议\" class=\"headerlink\" title=\"5.1网络协议\"></a>5.1网络协议</h5><ul>\n<li>通信双方必须需遵守的规则、标准和约定</li>\n</ul>\n<h5 id=\"5-2语法\"><a href=\"#5-2语法\" class=\"headerlink\" title=\"5.2语法\"></a>5.2语法</h5><ul>\n<li>数据与控制信息的结构或格式</li>\n</ul>\n<h5 id=\"5-3语义\"><a href=\"#5-3语义\" class=\"headerlink\" title=\"5.3语义\"></a>5.3语义</h5><ul>\n<li>控制信息的功能和动作</li>\n</ul>\n<h5 id=\"5-4时序\"><a href=\"#5-4时序\" class=\"headerlink\" title=\"5.4时序\"></a>5.4时序</h5><ul>\n<li>信息的同步，速度匹配</li>\n</ul>\n<h5 id=\"5-5体系结构\"><a href=\"#5-5体系结构\" class=\"headerlink\" title=\"5.5体系结构\"></a>5.5体系结构</h5><ul>\n<li>计算机网络的各个层次及其相关协议的集合</li>\n</ul>\n<h4 id=\"6-OSI-ISO（七层）\"><a href=\"#6-OSI-ISO（七层）\" class=\"headerlink\" title=\"6. OSI ISO（七层）\"></a>6. OSI ISO（<strong>七层</strong>）</h4><h5 id=\"6-1-物理层（比特）\"><a href=\"#6-1-物理层（比特）\" class=\"headerlink\" title=\"6.1 物理层（比特）\"></a>6.1 物理层（比特）</h5><ul>\n<li>设备：中继器、集线器</li>\n</ul>\n<h5 id=\"6-2-数据链路层（帧）\"><a href=\"#6-2-数据链路层（帧）\" class=\"headerlink\" title=\"6.2 数据链路层（帧）\"></a>6.2 数据链路层（帧）</h5><ul>\n<li>可靠通信</li>\n</ul>\n<h5 id=\"6-3-网络层（分组或包）\"><a href=\"#6-3-网络层（分组或包）\" class=\"headerlink\" title=\"6.3 网络层（分组或包）\"></a>6.3 网络层（分组或包）</h5><ul>\n<li>选择路由、交换结点、拥塞控制、网络互联</li>\n</ul>\n<h5 id=\"6-4-传输层（报文）\"><a href=\"#6-4-传输层（报文）\" class=\"headerlink\" title=\"6.4 传输层（报文）\"></a>6.4 传输层（报文）</h5><ul>\n<li>实现了端到端的通信</li>\n</ul>\n<h5 id=\"6-5-会话层\"><a href=\"#6-5-会话层\" class=\"headerlink\" title=\"6.5 会话层\"></a>6.5 会话层</h5><ul>\n<li>提供同步点机制</li>\n</ul>\n<h5 id=\"6-6-表示层\"><a href=\"#6-6-表示层\" class=\"headerlink\" title=\"6.6 表示层\"></a>6.6 表示层</h5><ul>\n<li>解决用户信息的语法表示问题</li>\n</ul>\n<h5 id=\"6-7-应用层\"><a href=\"#6-7-应用层\" class=\"headerlink\" title=\"6.7 应用层\"></a>6.7 应用层</h5><ul>\n<li>处理用户的数据和信息</li>\n</ul>\n<h4 id=\"7-TCP-IP\"><a href=\"#7-TCP-IP\" class=\"headerlink\" title=\"7. TCP/IP\"></a>7. TCP/IP</h4><font color=red>必须掌握TCP，UDP报文要熟记</font>\n\n<h5 id=\"7-1-物理层和数据链路层\"><a href=\"#7-1-物理层和数据链路层\" class=\"headerlink\" title=\"7.1 物理层和数据链路层\"></a>7.1 物理层和数据链路层</h5><h5 id=\"7-2-网络层\"><a href=\"#7-2-网络层\" class=\"headerlink\" title=\"7.2 网络层\"></a>7.2 网络层</h5><ul>\n<li>寻址、数据打包和路由选择</li>\n<li>核心协议：IP协议</li>\n<li>IP协议是无连接的，不保证传输的可靠性</li>\n</ul>\n<h5 id=\"7-3-传输层\"><a href=\"#7-3-传输层\" class=\"headerlink\" title=\"7.3 传输层\"></a>7.3 传输层</h5><ul>\n<li>核心协议：传输控制协议TCP和用户数据报协议UDP（<font color=red>TCP，UDP报文要熟记</font>）</li>\n<li>TCP是一个可靠的面向连接的传输层协议</li>\n<li>UDP是一个不可靠的面向无连接的传输层协议，适用于延迟较小的场合</li>\n</ul>\n<h5 id=\"7-4-应用层\"><a href=\"#7-4-应用层\" class=\"headerlink\" title=\"7.4 应用层\"></a>7.4 应用层</h5><ul>\n<li>各种协议</li>\n</ul>\n<h4 id=\"8-实体间通信与服务\"><a href=\"#8-实体间通信与服务\" class=\"headerlink\" title=\"8. 实体间通信与服务\"></a>8. 实体间通信与服务</h4><h5 id=\"8-1通信\"><a href=\"#8-1通信\" class=\"headerlink\" title=\"8.1通信\"></a>8.1通信</h5><h6 id=\"8-1-1-层间通信\"><a href=\"#8-1-1-层间通信\" class=\"headerlink\" title=\"8.1.1 层间通信\"></a>8.1.1 层间通信</h6><ul>\n<li>同一个网络结点上相邻层次中实体之间的通信称为层间通信</li>\n</ul>\n<h6 id=\"8-1-2-对等层间通信\"><a href=\"#8-1-2-对等层间通信\" class=\"headerlink\" title=\"8.1.2 对等层间通信\"></a>8.1.2 对等层间通信</h6><ul>\n<li>不同的网络结点上对等层实体间的通信称为对等层间通信</li>\n</ul>\n<h6 id=\"8-1-3-实通信\"><a href=\"#8-1-3-实通信\" class=\"headerlink\" title=\"8.1.3 实通信\"></a>8.1.3 实通信</h6><ul>\n<li>层间通信以及物理层之间的通信叫做实通信</li>\n</ul>\n<h6 id=\"8-1-4虚通信\"><a href=\"#8-1-4虚通信\" class=\"headerlink\" title=\"8.1.4虚通信\"></a>8.1.4虚通信</h6><ul>\n<li>除物理层外，对等层之间的通信叫做虚通信</li>\n</ul>\n<h5 id=\"8-2服务于数据单元\"><a href=\"#8-2服务于数据单元\" class=\"headerlink\" title=\"8.2服务于数据单元\"></a>8.2服务于数据单元</h5><h6 id=\"8-2-1服务访问点SAP（Service-Access-Point）\"><a href=\"#8-2-1服务访问点SAP（Service-Access-Point）\" class=\"headerlink\" title=\"8.2.1服务访问点SAP（Service Access Point）\"></a>8.2.1服务访问点SAP（Service Access Point）</h6><ul>\n<li>层间接口处提供服务的地方</li>\n</ul>\n<h6 id=\"8-2-2服务数据单元SDU（Service-Data-Unit）\"><a href=\"#8-2-2服务数据单元SDU（Service-Data-Unit）\" class=\"headerlink\" title=\"8.2.2服务数据单元SDU（Service Data Unit）\"></a>8.2.2服务数据单元SDU（Service Data Unit）</h6><ul>\n<li>相邻层在提供服务的过程中要传递的信息</li>\n</ul>\n<h6 id=\"8-2-3协议数据单元PDU（Protocol-Data-Unit）\"><a href=\"#8-2-3协议数据单元PDU（Protocol-Data-Unit）\" class=\"headerlink\" title=\"8.2.3协议数据单元PDU（Protocol Data Unit）\"></a>8.2.3协议数据单元PDU（Protocol Data Unit）</h6><ul>\n<li>对等层间交换的信息单位</li>\n</ul>\n<h6 id=\"8-2-4协议控制信息PCI\"><a href=\"#8-2-4协议控制信息PCI\" class=\"headerlink\" title=\"8.2.4协议控制信息PCI\"></a>8.2.4协议控制信息PCI</h6><ul>\n<li>N层的PDU = N层的SDU加上该层的PCI</li>\n</ul>\n<h5 id=\"8-3服务原语\"><a href=\"#8-3服务原语\" class=\"headerlink\" title=\"8.3服务原语\"></a>8.3服务原语</h5><h6 id=\"8-3-1请求原语\"><a href=\"#8-3-1请求原语\" class=\"headerlink\" title=\"8.3.1请求原语\"></a>8.3.1请求原语</h6><ul>\n<li>由N+1层实体向N层实体发出，要求这个N层实体向它提供指定的N层服务，如进行一次数据传送</li>\n</ul>\n<h6 id=\"8-3-2指示原语\"><a href=\"#8-3-2指示原语\" class=\"headerlink\" title=\"8.3.2指示原语\"></a>8.3.2指示原语</h6><ul>\n<li>由N层实体向N+1层实体发出，通知这个N+1层实体某个特定的N层服务已经开始</li>\n</ul>\n<h6 id=\"8-3-3响应原语\"><a href=\"#8-3-3响应原语\" class=\"headerlink\" title=\"8.3.3响应原语\"></a>8.3.3响应原语</h6><ul>\n<li>由N+1层实体向N层实体发出，表示对这个N层实体送来的指示原语的响应</li>\n</ul>\n<h6 id=\"8-3-4证实原语\"><a href=\"#8-3-4证实原语\" class=\"headerlink\" title=\"8.3.4证实原语\"></a>8.3.4证实原语</h6><ul>\n<li>由N层实体向N+1层实体发出，表示它请求的N层服务已经完成</li>\n</ul>\n<h6 id=\"8-3-5证实性服务\"><a href=\"#8-3-5证实性服务\" class=\"headerlink\" title=\"8.3.5证实性服务\"></a>8.3.5证实性服务</h6><ul>\n<li><h6 id=\"8-3-6非证实性服务\"><a href=\"#8-3-6非证实性服务\" class=\"headerlink\" title=\"8.3.6非证实性服务\"></a>8.3.6非证实性服务</h6></li>\n<li></li>\n</ul>\n<h6 id=\"8-3-7面向连接的服务\"><a href=\"#8-3-7面向连接的服务\" class=\"headerlink\" title=\"8.3.7面向连接的服务\"></a>8.3.7面向连接的服务</h6><ul>\n<li>建立连接阶段</li>\n<li>数据交换阶段</li>\n<li>释放连接阶段</li>\n</ul>\n<h6 id=\"8-3-8面向无连接的服务\"><a href=\"#8-3-8面向无连接的服务\" class=\"headerlink\" title=\"8.3.8面向无连接的服务\"></a>8.3.8面向无连接的服务</h6><ul>\n<li>数据报</li>\n<li>证实交付，又称可靠地数据报</li>\n<li>请求/响应</li>\n</ul>\n<h5 id=\"8-4性能指标\"><a href=\"#8-4性能指标\" class=\"headerlink\" title=\"8.4性能指标\"></a>8.4性能指标</h5><h6 id=\"8-4-1吞吐量\"><a href=\"#8-4-1吞吐量\" class=\"headerlink\" title=\"8.4.1吞吐量\"></a>8.4.1吞吐量</h6><ul>\n<li>信道吞吐量是信道上单位时间成功发送的信息量，用bps（位每秒）表示</li>\n</ul>\n<h6 id=\"8-4-2信道利用率\"><a href=\"#8-4-2信道利用率\" class=\"headerlink\" title=\"8.4.2信道利用率\"></a>8.4.2信道利用率</h6><ul>\n<li>是除去全部控制信息后的数据率与信道吞吐量之比。控制部分开销越大，利用率越低</li>\n</ul>\n<h6 id=\"8-4-3延迟时间\"><a href=\"#8-4-3延迟时间\" class=\"headerlink\" title=\"8.4.3延迟时间\"></a>8.4.3延迟时间</h6><h6 id=\"8-4-4排队时间\"><a href=\"#8-4-4排队时间\" class=\"headerlink\" title=\"8.4.4排队时间\"></a>8.4.4<strong>排队时间</strong></h6><h6 id=\"8-4-5访问延时\"><a href=\"#8-4-5访问延时\" class=\"headerlink\" title=\"8.4.5访问延时\"></a>8.4.5<strong>访问延时</strong></h6><h6 id=\"8-4-6发送时延\"><a href=\"#8-4-6发送时延\" class=\"headerlink\" title=\"8.4.6发送时延\"></a>8.4.6<strong>发送时延</strong></h6><ul>\n<li>数据块长度（b）</li>\n<li>信道带宽（s）</li>\n</ul>\n<h6 id=\"8-4-7传输延时\"><a href=\"#8-4-7传输延时\" class=\"headerlink\" title=\"8.4.7传输延时\"></a>8.4.7<strong>传输延时</strong></h6><ul>\n<li>信道长度（m）</li>\n<li>信号在信道上的传播速率（m/s）</li>\n</ul>\n<h4 id=\"9-考题类型\"><a href=\"#9-考题类型\" class=\"headerlink\" title=\"9.考题类型\"></a>9.考题类型</h4><h5 id=\"9-1计算机网络系统的主要通信性能指标有哪些？\"><a href=\"#9-1计算机网络系统的主要通信性能指标有哪些？\" class=\"headerlink\" title=\"9.1计算机网络系统的主要通信性能指标有哪些？\"></a>9.1计算机网络系统的主要通信性能指标有哪些？</h5><h5 id=\"9-2网络延迟的4个主要原因是什么？\"><a href=\"#9-2网络延迟的4个主要原因是什么？\" class=\"headerlink\" title=\"9.2网络延迟的4个主要原因是什么？\"></a>9.2网络延迟的4个主要原因是什么？</h5>"},{"title":"微博爬虫功能","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"微博爬虫功能","abbrlink":"5774","date":"2021-05-17T05:13:56.000Z","password":null,"keywords":null,"description":null,"_content":" \n\n\n## 微博爬虫功能\n\n连续获取一个或多个**微博关键词搜索**结果，并将结果写入文件（可选）、数据库（可选）等。所谓微博关键词搜索即：**搜索正文中包含指定关键词的微博**，可以指定搜索的时间范围。<br>\n本程序可以获得几乎全部的微博信息，如微博正文、发布者等。支持输出多种文件类型，具体如下：\n\n- 写入**csv文件**（默认）\n- 写入**MySQL数据库**（可选）\n- 下载微博中的**图片**（可选），还未测试储存路径\n- 下载微博中的**视频**（可选），还未测试储存路径\n\n## 输出\n\n- 微博id：微博的id，为一串数字形式\n- 微博bid：微博的bid\n- 微博内容：微博正文\n- 头条文章url：微博中头条文章的url\n- 原始图片url：原创微博图片和转发微博转发理由中图片的url，若某条微博存在多张图片，则每个url以英文逗号分隔\n- 视频url: 微博中的视频url和Live Photo中的视频url，若某条微博存在多个视频，则每个url以英文分号分隔\n- 微博发布位置：位置微博中的发布位置\n- 微博发布时间：微博发布时的时间，精确到天\n- 点赞数：微博被赞的数量\n- 转发数：微博被转发的数量\n- 评论数：微博被评论的数量\n- 微博发布工具：微博的发布工具，如iPhone客户端、HUAWEI Mate 20 Pro等，若没有则值为''\n- 话题：微博话题，即两个#中的内容，若存在多个话题，每个url以英文逗号分隔，若没有则值为''\n- @用户：微博@的用户，若存在多个@用户，每个url以英文逗号分隔，若没有则值为''\n- 原始微博id：为转发微博所特有，是转发微博中那条被转发微博的id，那条被转发的微博也会存储，字段和原创微博一样，只是它的本字段为空\n- 结果文件：保存在当前目录“结果文件”文件夹下以关键词为名的文件夹里\n- 微博图片：微博中的图片，保存在以关键词为名的文件夹下的images文件夹里\n- 微博视频：微博中的视频，保存在以关键词为名的文件夹下的videos文件夹里\n\n## 使用说明\n\n本程序的所有配置都在setting.py文件中完成，该文件位于“weibo-search\\weibo\\settings.py”。\n\n### 1.下载Python\n\n官网安装稳定版本LTS\n\n### 2.安装Scrapy\n\n本程序依赖Scrapy，要想运行程序，需要安装Scrapy。如果系统中没有安装Scrapy，请根据自己的系统安装Scrapy，以Ubuntu为例，可以使用如下命令：\n\n```bash\n$ pip install scrapy\n```\n\n### 3.安装依赖\n\n```bash\n$ pip install -r requirements.txt\n```\n\n### 4.设置cookie\n\nDEFAULT_REQUEST_HEADERS中的cookie是我们需要填的值，如何获取cookie详见最后，获取后将\"your cookie\"替换成真实的cookie即可。\n\n### 5.设置搜索关键词\n\n修改setting.py文件夹中的KEYWORD_LIST参数。\n如果你想搜索一个关键词，如“迪丽热巴”：\n**目前只实现一个关键词的爬取**\n\n```\nKEYWORD_LIST = ['迪丽热巴']\n```\n\n如果你想分别搜索多个关键词，如想要分别获得“迪丽热巴”和“杨幂”的搜索结果：\n\n```\nKEYWORD_LIST = ['迪丽热巴', '杨幂']\n```\n\n如果你想搜索同时包含多个关键词的微博，如同时包含“迪丽热巴”和“杨幂”微博的搜索结果：\n\n```\nKEYWORD_LIST = ['迪丽热巴 杨幂']\n```\n\n如果你想搜索微博话题，即包含#的内容，如“#迪丽热巴#”：\n\n```\nKEYWORD_LIST = ['#迪丽热巴#']\n```\n\n### 6.设置搜索时间范围\n\nSTART_DATE代表搜索的起始日期，END_DATE代表搜索的结束日期，值为“yyyy-mm-dd”形式，程序会搜索包含关键词且发布时间在起始日期和结束日期之间的微博（包含边界）。比如我想筛选发布时间在2021-05-01到2021-05-07这两天的微博：\n\n```\nSTART_DATE = '2021-05-01'\nEND_DATE = '2021-05-07'\n```\n\n### 7.设置等待时间（可选）\n\nDOWNLOAD_DELAY代表访问完一个页面再访问下一个时需要等待的时间，默认为10秒。如我想设置等待15秒左右，可以修改setting.py文件的DOWNLOAD_DELAY参数：\n\n```\nDOWNLOAD_DELAY = 15\n```\n\n### 8.设置微博类型（可选）\n\nWEIBO_TYPE筛选要搜索的微博类型，0代表搜索全部微博，1代表搜索全部原创微博，2代表热门微博，3代表关注人微博，4代表认证用户微博，5代表媒体微博，6代表观点微博。比如我想要搜索全部原创微博，修改setting.py文件的WEIBO_TYPE参数：\n\n```\nWEIBO_TYPE = 1\n```\n\n### 9.设置包含内容（可选）\n\nCONTAIN_TYPE筛选结果微博中必需包含的内容，0代表不筛选，获取全部微博，1代表搜索包含图片的微博，2代表包含视频的微博，3代表包含音乐的微博，4代表包含短链接的微博。比如我想筛选包含图片的微博，修改setting.py文件的CONTAIN_TYPE参数：\n\n```\nCONTAIN_TYPE = 1\n```\n\n### 10.筛选微博发布地区（可选）\n\nREGION筛选微博的发布地区，精确到省或直辖市，值不应包含“省”或“市”等字，如想筛选北京市的微博请用“北京”而不是“北京市”，想要筛选安徽省的微博请用“安徽”而不是“安徽省”，可以写多个地区，具体支持的地名见region.py文件，注意只支持省或直辖市的名字，省下面的市名及直辖市下面的区县名不支持，不筛选请用”全部“。比如我想要筛选发布地在山东省的微博：\n\n```\nREGION = ['山东']\n```\n\n### 11.配置数据库（可选）\n\nMONGO_URI是MongoDB数据库的配置；<br>\nMYSQL开头的是MySQL数据库的配置。\n\n### 12.运行程序\n\n```bash\n$ scrapy crawl search -s JOBDIR=crawls/search\n```\n\n只运行“scrapy crawl search”也可以，只是上述方式在结束时可以保存进度，下次运行时会在程序上次的地方继续获取。注意，如果想要保存进度，请使用“Ctrl + C”**一次**，注意是**一次**。按下“Ctrl + C”一次后，程序会继续运行一会，主要用来保存获取的数据、保存进度等操作，请耐心等待。下次再运行时，只要再运行上面的指令就可以恢复上次的进度。\n\n- 但也不是很稳定，目前还需多次测试，先爬取数据再说，这个不急\n\n\n### 13. 待完成\n\n- 利用scrapyd部署，好像是可以形成API去操作，具体还需学习\n- 重新做一个小的网站demo爬取，测试scrappd部署环境，昨天主要做的事情，但还没成功\n- 需完善：多个参数同时存储数据库，**最后再搞**，目前可以实现单个关键词存入数据库，以满足任务要求\n\n## 如何获取cookie\n\n1.用Chrome打开<https://passport.weibo.cn/signin/login>；<br>\n2.输入微博的用户名、密码，登录，如图所示：\n![](https://picture.cognize.me/cognize/github/weibospider/cookie1.png)\n登录成功后会跳转到<https://m.weibo.cn>;<br>\n3.按F12键打开Chrome开发者工具，在地址栏输入并跳转到<https://weibo.cn>，跳转后会显示如下类似界面:\n![](https://picture.cognize.me/cognize/github/weibospider/cookie2.png)\n4.依此点击Chrome开发者工具中的Network->Name中的weibo.cn->Headers->Request Headers，\"Cookie:\"后的值即为我们要找的cookie值，复制即可，如图所示：\n![](https://picture.cognize.me/cognize/github/weibospider/cookie3.png)\n","source":"_posts/微博爬虫功能.md","raw":"---\ntitle: 微博爬虫功能\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - scrapy\n  - 微博\n  - 爬虫\n  - 项目\ncategories:\n  - 项目\nsummary: 微博爬虫功能\nabbrlink: '5774'\ndate: 2021-05-17 13:13:56\npassword:\nkeywords:\ndescription:\n---\n \n\n\n## 微博爬虫功能\n\n连续获取一个或多个**微博关键词搜索**结果，并将结果写入文件（可选）、数据库（可选）等。所谓微博关键词搜索即：**搜索正文中包含指定关键词的微博**，可以指定搜索的时间范围。<br>\n本程序可以获得几乎全部的微博信息，如微博正文、发布者等。支持输出多种文件类型，具体如下：\n\n- 写入**csv文件**（默认）\n- 写入**MySQL数据库**（可选）\n- 下载微博中的**图片**（可选），还未测试储存路径\n- 下载微博中的**视频**（可选），还未测试储存路径\n\n## 输出\n\n- 微博id：微博的id，为一串数字形式\n- 微博bid：微博的bid\n- 微博内容：微博正文\n- 头条文章url：微博中头条文章的url\n- 原始图片url：原创微博图片和转发微博转发理由中图片的url，若某条微博存在多张图片，则每个url以英文逗号分隔\n- 视频url: 微博中的视频url和Live Photo中的视频url，若某条微博存在多个视频，则每个url以英文分号分隔\n- 微博发布位置：位置微博中的发布位置\n- 微博发布时间：微博发布时的时间，精确到天\n- 点赞数：微博被赞的数量\n- 转发数：微博被转发的数量\n- 评论数：微博被评论的数量\n- 微博发布工具：微博的发布工具，如iPhone客户端、HUAWEI Mate 20 Pro等，若没有则值为''\n- 话题：微博话题，即两个#中的内容，若存在多个话题，每个url以英文逗号分隔，若没有则值为''\n- @用户：微博@的用户，若存在多个@用户，每个url以英文逗号分隔，若没有则值为''\n- 原始微博id：为转发微博所特有，是转发微博中那条被转发微博的id，那条被转发的微博也会存储，字段和原创微博一样，只是它的本字段为空\n- 结果文件：保存在当前目录“结果文件”文件夹下以关键词为名的文件夹里\n- 微博图片：微博中的图片，保存在以关键词为名的文件夹下的images文件夹里\n- 微博视频：微博中的视频，保存在以关键词为名的文件夹下的videos文件夹里\n\n## 使用说明\n\n本程序的所有配置都在setting.py文件中完成，该文件位于“weibo-search\\weibo\\settings.py”。\n\n### 1.下载Python\n\n官网安装稳定版本LTS\n\n### 2.安装Scrapy\n\n本程序依赖Scrapy，要想运行程序，需要安装Scrapy。如果系统中没有安装Scrapy，请根据自己的系统安装Scrapy，以Ubuntu为例，可以使用如下命令：\n\n```bash\n$ pip install scrapy\n```\n\n### 3.安装依赖\n\n```bash\n$ pip install -r requirements.txt\n```\n\n### 4.设置cookie\n\nDEFAULT_REQUEST_HEADERS中的cookie是我们需要填的值，如何获取cookie详见最后，获取后将\"your cookie\"替换成真实的cookie即可。\n\n### 5.设置搜索关键词\n\n修改setting.py文件夹中的KEYWORD_LIST参数。\n如果你想搜索一个关键词，如“迪丽热巴”：\n**目前只实现一个关键词的爬取**\n\n```\nKEYWORD_LIST = ['迪丽热巴']\n```\n\n如果你想分别搜索多个关键词，如想要分别获得“迪丽热巴”和“杨幂”的搜索结果：\n\n```\nKEYWORD_LIST = ['迪丽热巴', '杨幂']\n```\n\n如果你想搜索同时包含多个关键词的微博，如同时包含“迪丽热巴”和“杨幂”微博的搜索结果：\n\n```\nKEYWORD_LIST = ['迪丽热巴 杨幂']\n```\n\n如果你想搜索微博话题，即包含#的内容，如“#迪丽热巴#”：\n\n```\nKEYWORD_LIST = ['#迪丽热巴#']\n```\n\n### 6.设置搜索时间范围\n\nSTART_DATE代表搜索的起始日期，END_DATE代表搜索的结束日期，值为“yyyy-mm-dd”形式，程序会搜索包含关键词且发布时间在起始日期和结束日期之间的微博（包含边界）。比如我想筛选发布时间在2021-05-01到2021-05-07这两天的微博：\n\n```\nSTART_DATE = '2021-05-01'\nEND_DATE = '2021-05-07'\n```\n\n### 7.设置等待时间（可选）\n\nDOWNLOAD_DELAY代表访问完一个页面再访问下一个时需要等待的时间，默认为10秒。如我想设置等待15秒左右，可以修改setting.py文件的DOWNLOAD_DELAY参数：\n\n```\nDOWNLOAD_DELAY = 15\n```\n\n### 8.设置微博类型（可选）\n\nWEIBO_TYPE筛选要搜索的微博类型，0代表搜索全部微博，1代表搜索全部原创微博，2代表热门微博，3代表关注人微博，4代表认证用户微博，5代表媒体微博，6代表观点微博。比如我想要搜索全部原创微博，修改setting.py文件的WEIBO_TYPE参数：\n\n```\nWEIBO_TYPE = 1\n```\n\n### 9.设置包含内容（可选）\n\nCONTAIN_TYPE筛选结果微博中必需包含的内容，0代表不筛选，获取全部微博，1代表搜索包含图片的微博，2代表包含视频的微博，3代表包含音乐的微博，4代表包含短链接的微博。比如我想筛选包含图片的微博，修改setting.py文件的CONTAIN_TYPE参数：\n\n```\nCONTAIN_TYPE = 1\n```\n\n### 10.筛选微博发布地区（可选）\n\nREGION筛选微博的发布地区，精确到省或直辖市，值不应包含“省”或“市”等字，如想筛选北京市的微博请用“北京”而不是“北京市”，想要筛选安徽省的微博请用“安徽”而不是“安徽省”，可以写多个地区，具体支持的地名见region.py文件，注意只支持省或直辖市的名字，省下面的市名及直辖市下面的区县名不支持，不筛选请用”全部“。比如我想要筛选发布地在山东省的微博：\n\n```\nREGION = ['山东']\n```\n\n### 11.配置数据库（可选）\n\nMONGO_URI是MongoDB数据库的配置；<br>\nMYSQL开头的是MySQL数据库的配置。\n\n### 12.运行程序\n\n```bash\n$ scrapy crawl search -s JOBDIR=crawls/search\n```\n\n只运行“scrapy crawl search”也可以，只是上述方式在结束时可以保存进度，下次运行时会在程序上次的地方继续获取。注意，如果想要保存进度，请使用“Ctrl + C”**一次**，注意是**一次**。按下“Ctrl + C”一次后，程序会继续运行一会，主要用来保存获取的数据、保存进度等操作，请耐心等待。下次再运行时，只要再运行上面的指令就可以恢复上次的进度。\n\n- 但也不是很稳定，目前还需多次测试，先爬取数据再说，这个不急\n\n\n### 13. 待完成\n\n- 利用scrapyd部署，好像是可以形成API去操作，具体还需学习\n- 重新做一个小的网站demo爬取，测试scrappd部署环境，昨天主要做的事情，但还没成功\n- 需完善：多个参数同时存储数据库，**最后再搞**，目前可以实现单个关键词存入数据库，以满足任务要求\n\n## 如何获取cookie\n\n1.用Chrome打开<https://passport.weibo.cn/signin/login>；<br>\n2.输入微博的用户名、密码，登录，如图所示：\n![](https://picture.cognize.me/cognize/github/weibospider/cookie1.png)\n登录成功后会跳转到<https://m.weibo.cn>;<br>\n3.按F12键打开Chrome开发者工具，在地址栏输入并跳转到<https://weibo.cn>，跳转后会显示如下类似界面:\n![](https://picture.cognize.me/cognize/github/weibospider/cookie2.png)\n4.依此点击Chrome开发者工具中的Network->Name中的weibo.cn->Headers->Request Headers，\"Cookie:\"后的值即为我们要找的cookie值，复制即可，如图所示：\n![](https://picture.cognize.me/cognize/github/weibospider/cookie3.png)\n","slug":"微博爬虫功能","published":1,"updated":"2021-05-17T05:33:42.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q60003na09k2sq70ybp","content":"<h2 id=\"微博爬虫功能\"><a href=\"#微博爬虫功能\" class=\"headerlink\" title=\"微博爬虫功能\"></a>微博爬虫功能</h2><p>连续获取一个或多个<strong>微博关键词搜索</strong>结果，并将结果写入文件（可选）、数据库（可选）等。所谓微博关键词搜索即：<strong>搜索正文中包含指定关键词的微博</strong>，可以指定搜索的时间范围。<br><br>本程序可以获得几乎全部的微博信息，如微博正文、发布者等。支持输出多种文件类型，具体如下：</p>\n<ul>\n<li>写入<strong>csv文件</strong>（默认）</li>\n<li>写入<strong>MySQL数据库</strong>（可选）</li>\n<li>下载微博中的<strong>图片</strong>（可选），还未测试储存路径</li>\n<li>下载微博中的<strong>视频</strong>（可选），还未测试储存路径</li>\n</ul>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><ul>\n<li>微博id：微博的id，为一串数字形式</li>\n<li>微博bid：微博的bid</li>\n<li>微博内容：微博正文</li>\n<li>头条文章url：微博中头条文章的url</li>\n<li>原始图片url：原创微博图片和转发微博转发理由中图片的url，若某条微博存在多张图片，则每个url以英文逗号分隔</li>\n<li>视频url: 微博中的视频url和Live Photo中的视频url，若某条微博存在多个视频，则每个url以英文分号分隔</li>\n<li>微博发布位置：位置微博中的发布位置</li>\n<li>微博发布时间：微博发布时的时间，精确到天</li>\n<li>点赞数：微博被赞的数量</li>\n<li>转发数：微博被转发的数量</li>\n<li>评论数：微博被评论的数量</li>\n<li>微博发布工具：微博的发布工具，如iPhone客户端、HUAWEI Mate 20 Pro等，若没有则值为’’</li>\n<li>话题：微博话题，即两个#中的内容，若存在多个话题，每个url以英文逗号分隔，若没有则值为’’</li>\n<li>@用户：微博@的用户，若存在多个@用户，每个url以英文逗号分隔，若没有则值为’’</li>\n<li>原始微博id：为转发微博所特有，是转发微博中那条被转发微博的id，那条被转发的微博也会存储，字段和原创微博一样，只是它的本字段为空</li>\n<li>结果文件：保存在当前目录“结果文件”文件夹下以关键词为名的文件夹里</li>\n<li>微博图片：微博中的图片，保存在以关键词为名的文件夹下的images文件夹里</li>\n<li>微博视频：微博中的视频，保存在以关键词为名的文件夹下的videos文件夹里</li>\n</ul>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p>本程序的所有配置都在setting.py文件中完成，该文件位于“weibo-search\\weibo\\settings.py”。</p>\n<h3 id=\"1-下载Python\"><a href=\"#1-下载Python\" class=\"headerlink\" title=\"1.下载Python\"></a>1.下载Python</h3><p>官网安装稳定版本LTS</p>\n<h3 id=\"2-安装Scrapy\"><a href=\"#2-安装Scrapy\" class=\"headerlink\" title=\"2.安装Scrapy\"></a>2.安装Scrapy</h3><p>本程序依赖Scrapy，要想运行程序，需要安装Scrapy。如果系统中没有安装Scrapy，请根据自己的系统安装Scrapy，以Ubuntu为例，可以使用如下命令：</p>\n<pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">$ pip install scrapy\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"3-安装依赖\"><a href=\"#3-安装依赖\" class=\"headerlink\" title=\"3.安装依赖\"></a>3.安装依赖</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">$ pip install -r requirements.txt\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"4-设置cookie\"><a href=\"#4-设置cookie\" class=\"headerlink\" title=\"4.设置cookie\"></a>4.设置cookie</h3><p>DEFAULT_REQUEST_HEADERS中的cookie是我们需要填的值，如何获取cookie详见最后，获取后将”your cookie”替换成真实的cookie即可。</p>\n<h3 id=\"5-设置搜索关键词\"><a href=\"#5-设置搜索关键词\" class=\"headerlink\" title=\"5.设置搜索关键词\"></a>5.设置搜索关键词</h3><p>修改setting.py文件夹中的KEYWORD_LIST参数。<br>如果你想搜索一个关键词，如“迪丽热巴”：<br><strong>目前只实现一个关键词的爬取</strong></p>\n<pre><code>KEYWORD_LIST = ['迪丽热巴']\n</code></pre><p>如果你想分别搜索多个关键词，如想要分别获得“迪丽热巴”和“杨幂”的搜索结果：</p>\n<pre><code>KEYWORD_LIST = ['迪丽热巴', '杨幂']\n</code></pre><p>如果你想搜索同时包含多个关键词的微博，如同时包含“迪丽热巴”和“杨幂”微博的搜索结果：</p>\n<pre><code>KEYWORD_LIST = ['迪丽热巴 杨幂']\n</code></pre><p>如果你想搜索微博话题，即包含#的内容，如“#迪丽热巴#”：</p>\n<pre><code>KEYWORD_LIST = ['#迪丽热巴#']\n</code></pre><h3 id=\"6-设置搜索时间范围\"><a href=\"#6-设置搜索时间范围\" class=\"headerlink\" title=\"6.设置搜索时间范围\"></a>6.设置搜索时间范围</h3><p>START_DATE代表搜索的起始日期，END_DATE代表搜索的结束日期，值为“yyyy-mm-dd”形式，程序会搜索包含关键词且发布时间在起始日期和结束日期之间的微博（包含边界）。比如我想筛选发布时间在2021-05-01到2021-05-07这两天的微博：</p>\n<pre><code>START_DATE = '2021-05-01'\nEND_DATE = '2021-05-07'\n</code></pre><h3 id=\"7-设置等待时间（可选）\"><a href=\"#7-设置等待时间（可选）\" class=\"headerlink\" title=\"7.设置等待时间（可选）\"></a>7.设置等待时间（可选）</h3><p>DOWNLOAD_DELAY代表访问完一个页面再访问下一个时需要等待的时间，默认为10秒。如我想设置等待15秒左右，可以修改setting.py文件的DOWNLOAD_DELAY参数：</p>\n<pre><code>DOWNLOAD_DELAY = 15\n</code></pre><h3 id=\"8-设置微博类型（可选）\"><a href=\"#8-设置微博类型（可选）\" class=\"headerlink\" title=\"8.设置微博类型（可选）\"></a>8.设置微博类型（可选）</h3><p>WEIBO_TYPE筛选要搜索的微博类型，0代表搜索全部微博，1代表搜索全部原创微博，2代表热门微博，3代表关注人微博，4代表认证用户微博，5代表媒体微博，6代表观点微博。比如我想要搜索全部原创微博，修改setting.py文件的WEIBO_TYPE参数：</p>\n<pre><code>WEIBO_TYPE = 1\n</code></pre><h3 id=\"9-设置包含内容（可选）\"><a href=\"#9-设置包含内容（可选）\" class=\"headerlink\" title=\"9.设置包含内容（可选）\"></a>9.设置包含内容（可选）</h3><p>CONTAIN_TYPE筛选结果微博中必需包含的内容，0代表不筛选，获取全部微博，1代表搜索包含图片的微博，2代表包含视频的微博，3代表包含音乐的微博，4代表包含短链接的微博。比如我想筛选包含图片的微博，修改setting.py文件的CONTAIN_TYPE参数：</p>\n<pre><code>CONTAIN_TYPE = 1\n</code></pre><h3 id=\"10-筛选微博发布地区（可选）\"><a href=\"#10-筛选微博发布地区（可选）\" class=\"headerlink\" title=\"10.筛选微博发布地区（可选）\"></a>10.筛选微博发布地区（可选）</h3><p>REGION筛选微博的发布地区，精确到省或直辖市，值不应包含“省”或“市”等字，如想筛选北京市的微博请用“北京”而不是“北京市”，想要筛选安徽省的微博请用“安徽”而不是“安徽省”，可以写多个地区，具体支持的地名见region.py文件，注意只支持省或直辖市的名字，省下面的市名及直辖市下面的区县名不支持，不筛选请用”全部“。比如我想要筛选发布地在山东省的微博：</p>\n<pre><code>REGION = ['山东']\n</code></pre><h3 id=\"11-配置数据库（可选）\"><a href=\"#11-配置数据库（可选）\" class=\"headerlink\" title=\"11.配置数据库（可选）\"></a>11.配置数据库（可选）</h3><p>MONGO_URI是MongoDB数据库的配置；<br><br>MYSQL开头的是MySQL数据库的配置。</p>\n<h3 id=\"12-运行程序\"><a href=\"#12-运行程序\" class=\"headerlink\" title=\"12.运行程序\"></a>12.运行程序</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">$ scrapy crawl search -s JOBDIR=crawls/search\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>只运行“scrapy crawl search”也可以，只是上述方式在结束时可以保存进度，下次运行时会在程序上次的地方继续获取。注意，如果想要保存进度，请使用“Ctrl + C”<strong>一次</strong>，注意是<strong>一次</strong>。按下“Ctrl + C”一次后，程序会继续运行一会，主要用来保存获取的数据、保存进度等操作，请耐心等待。下次再运行时，只要再运行上面的指令就可以恢复上次的进度。</p>\n<ul>\n<li>但也不是很稳定，目前还需多次测试，先爬取数据再说，这个不急</li>\n</ul>\n<h3 id=\"13-待完成\"><a href=\"#13-待完成\" class=\"headerlink\" title=\"13. 待完成\"></a>13. 待完成</h3><ul>\n<li>利用scrapyd部署，好像是可以形成API去操作，具体还需学习</li>\n<li>重新做一个小的网站demo爬取，测试scrappd部署环境，昨天主要做的事情，但还没成功</li>\n<li>需完善：多个参数同时存储数据库，<strong>最后再搞</strong>，目前可以实现单个关键词存入数据库，以满足任务要求</li>\n</ul>\n<h2 id=\"如何获取cookie\"><a href=\"#如何获取cookie\" class=\"headerlink\" title=\"如何获取cookie\"></a>如何获取cookie</h2><p>1.用Chrome打开<a href=\"https://passport.weibo.cn/signin/login\" target=\"_blank\" rel=\"noopener\">https://passport.weibo.cn/signin/login</a>；<br><br>2.输入微博的用户名、密码，登录，如图所示：<br><img src=\"https://picture.cognize.me/cognize/github/weibospider/cookie1.png\" alt=\"\"><br>登录成功后会跳转到<a href=\"https://m.weibo.cn\" target=\"_blank\" rel=\"noopener\">https://m.weibo.cn</a>;<br><br>3.按F12键打开Chrome开发者工具，在地址栏输入并跳转到<a href=\"https://weibo.cn\" target=\"_blank\" rel=\"noopener\">https://weibo.cn</a>，跳转后会显示如下类似界面:<br><img src=\"https://picture.cognize.me/cognize/github/weibospider/cookie2.png\" alt=\"\"><br>4.依此点击Chrome开发者工具中的Network-&gt;Name中的weibo.cn-&gt;Headers-&gt;Request Headers，”Cookie:”后的值即为我们要找的cookie值，复制即可，如图所示：<br><img src=\"https://picture.cognize.me/cognize/github/weibospider/cookie3.png\" alt=\"\"></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"微博爬虫功能\"><a href=\"#微博爬虫功能\" class=\"headerlink\" title=\"微博爬虫功能\"></a>微博爬虫功能</h2><p>连续获取一个或多个<strong>微博关键词搜索</strong>结果，并将结果写入文件（可选）、数据库（可选）等。所谓微博关键词搜索即：<strong>搜索正文中包含指定关键词的微博</strong>，可以指定搜索的时间范围。<br><br>本程序可以获得几乎全部的微博信息，如微博正文、发布者等。支持输出多种文件类型，具体如下：</p>\n<ul>\n<li>写入<strong>csv文件</strong>（默认）</li>\n<li>写入<strong>MySQL数据库</strong>（可选）</li>\n<li>下载微博中的<strong>图片</strong>（可选），还未测试储存路径</li>\n<li>下载微博中的<strong>视频</strong>（可选），还未测试储存路径</li>\n</ul>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><ul>\n<li>微博id：微博的id，为一串数字形式</li>\n<li>微博bid：微博的bid</li>\n<li>微博内容：微博正文</li>\n<li>头条文章url：微博中头条文章的url</li>\n<li>原始图片url：原创微博图片和转发微博转发理由中图片的url，若某条微博存在多张图片，则每个url以英文逗号分隔</li>\n<li>视频url: 微博中的视频url和Live Photo中的视频url，若某条微博存在多个视频，则每个url以英文分号分隔</li>\n<li>微博发布位置：位置微博中的发布位置</li>\n<li>微博发布时间：微博发布时的时间，精确到天</li>\n<li>点赞数：微博被赞的数量</li>\n<li>转发数：微博被转发的数量</li>\n<li>评论数：微博被评论的数量</li>\n<li>微博发布工具：微博的发布工具，如iPhone客户端、HUAWEI Mate 20 Pro等，若没有则值为’’</li>\n<li>话题：微博话题，即两个#中的内容，若存在多个话题，每个url以英文逗号分隔，若没有则值为’’</li>\n<li>@用户：微博@的用户，若存在多个@用户，每个url以英文逗号分隔，若没有则值为’’</li>\n<li>原始微博id：为转发微博所特有，是转发微博中那条被转发微博的id，那条被转发的微博也会存储，字段和原创微博一样，只是它的本字段为空</li>\n<li>结果文件：保存在当前目录“结果文件”文件夹下以关键词为名的文件夹里</li>\n<li>微博图片：微博中的图片，保存在以关键词为名的文件夹下的images文件夹里</li>\n<li>微博视频：微博中的视频，保存在以关键词为名的文件夹下的videos文件夹里</li>\n</ul>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p>本程序的所有配置都在setting.py文件中完成，该文件位于“weibo-search\\weibo\\settings.py”。</p>\n<h3 id=\"1-下载Python\"><a href=\"#1-下载Python\" class=\"headerlink\" title=\"1.下载Python\"></a>1.下载Python</h3><p>官网安装稳定版本LTS</p>\n<h3 id=\"2-安装Scrapy\"><a href=\"#2-安装Scrapy\" class=\"headerlink\" title=\"2.安装Scrapy\"></a>2.安装Scrapy</h3><p>本程序依赖Scrapy，要想运行程序，需要安装Scrapy。如果系统中没有安装Scrapy，请根据自己的系统安装Scrapy，以Ubuntu为例，可以使用如下命令：</p>\n<pre><code class=\"lang-bash\">$ pip install scrapy\n</code></pre>\n<h3 id=\"3-安装依赖\"><a href=\"#3-安装依赖\" class=\"headerlink\" title=\"3.安装依赖\"></a>3.安装依赖</h3><pre><code class=\"lang-bash\">$ pip install -r requirements.txt\n</code></pre>\n<h3 id=\"4-设置cookie\"><a href=\"#4-设置cookie\" class=\"headerlink\" title=\"4.设置cookie\"></a>4.设置cookie</h3><p>DEFAULT_REQUEST_HEADERS中的cookie是我们需要填的值，如何获取cookie详见最后，获取后将”your cookie”替换成真实的cookie即可。</p>\n<h3 id=\"5-设置搜索关键词\"><a href=\"#5-设置搜索关键词\" class=\"headerlink\" title=\"5.设置搜索关键词\"></a>5.设置搜索关键词</h3><p>修改setting.py文件夹中的KEYWORD_LIST参数。<br>如果你想搜索一个关键词，如“迪丽热巴”：<br><strong>目前只实现一个关键词的爬取</strong></p>\n<pre><code>KEYWORD_LIST = [&#39;迪丽热巴&#39;]\n</code></pre><p>如果你想分别搜索多个关键词，如想要分别获得“迪丽热巴”和“杨幂”的搜索结果：</p>\n<pre><code>KEYWORD_LIST = [&#39;迪丽热巴&#39;, &#39;杨幂&#39;]\n</code></pre><p>如果你想搜索同时包含多个关键词的微博，如同时包含“迪丽热巴”和“杨幂”微博的搜索结果：</p>\n<pre><code>KEYWORD_LIST = [&#39;迪丽热巴 杨幂&#39;]\n</code></pre><p>如果你想搜索微博话题，即包含#的内容，如“#迪丽热巴#”：</p>\n<pre><code>KEYWORD_LIST = [&#39;#迪丽热巴#&#39;]\n</code></pre><h3 id=\"6-设置搜索时间范围\"><a href=\"#6-设置搜索时间范围\" class=\"headerlink\" title=\"6.设置搜索时间范围\"></a>6.设置搜索时间范围</h3><p>START_DATE代表搜索的起始日期，END_DATE代表搜索的结束日期，值为“yyyy-mm-dd”形式，程序会搜索包含关键词且发布时间在起始日期和结束日期之间的微博（包含边界）。比如我想筛选发布时间在2021-05-01到2021-05-07这两天的微博：</p>\n<pre><code>START_DATE = &#39;2021-05-01&#39;\nEND_DATE = &#39;2021-05-07&#39;\n</code></pre><h3 id=\"7-设置等待时间（可选）\"><a href=\"#7-设置等待时间（可选）\" class=\"headerlink\" title=\"7.设置等待时间（可选）\"></a>7.设置等待时间（可选）</h3><p>DOWNLOAD_DELAY代表访问完一个页面再访问下一个时需要等待的时间，默认为10秒。如我想设置等待15秒左右，可以修改setting.py文件的DOWNLOAD_DELAY参数：</p>\n<pre><code>DOWNLOAD_DELAY = 15\n</code></pre><h3 id=\"8-设置微博类型（可选）\"><a href=\"#8-设置微博类型（可选）\" class=\"headerlink\" title=\"8.设置微博类型（可选）\"></a>8.设置微博类型（可选）</h3><p>WEIBO_TYPE筛选要搜索的微博类型，0代表搜索全部微博，1代表搜索全部原创微博，2代表热门微博，3代表关注人微博，4代表认证用户微博，5代表媒体微博，6代表观点微博。比如我想要搜索全部原创微博，修改setting.py文件的WEIBO_TYPE参数：</p>\n<pre><code>WEIBO_TYPE = 1\n</code></pre><h3 id=\"9-设置包含内容（可选）\"><a href=\"#9-设置包含内容（可选）\" class=\"headerlink\" title=\"9.设置包含内容（可选）\"></a>9.设置包含内容（可选）</h3><p>CONTAIN_TYPE筛选结果微博中必需包含的内容，0代表不筛选，获取全部微博，1代表搜索包含图片的微博，2代表包含视频的微博，3代表包含音乐的微博，4代表包含短链接的微博。比如我想筛选包含图片的微博，修改setting.py文件的CONTAIN_TYPE参数：</p>\n<pre><code>CONTAIN_TYPE = 1\n</code></pre><h3 id=\"10-筛选微博发布地区（可选）\"><a href=\"#10-筛选微博发布地区（可选）\" class=\"headerlink\" title=\"10.筛选微博发布地区（可选）\"></a>10.筛选微博发布地区（可选）</h3><p>REGION筛选微博的发布地区，精确到省或直辖市，值不应包含“省”或“市”等字，如想筛选北京市的微博请用“北京”而不是“北京市”，想要筛选安徽省的微博请用“安徽”而不是“安徽省”，可以写多个地区，具体支持的地名见region.py文件，注意只支持省或直辖市的名字，省下面的市名及直辖市下面的区县名不支持，不筛选请用”全部“。比如我想要筛选发布地在山东省的微博：</p>\n<pre><code>REGION = [&#39;山东&#39;]\n</code></pre><h3 id=\"11-配置数据库（可选）\"><a href=\"#11-配置数据库（可选）\" class=\"headerlink\" title=\"11.配置数据库（可选）\"></a>11.配置数据库（可选）</h3><p>MONGO_URI是MongoDB数据库的配置；<br><br>MYSQL开头的是MySQL数据库的配置。</p>\n<h3 id=\"12-运行程序\"><a href=\"#12-运行程序\" class=\"headerlink\" title=\"12.运行程序\"></a>12.运行程序</h3><pre><code class=\"lang-bash\">$ scrapy crawl search -s JOBDIR=crawls/search\n</code></pre>\n<p>只运行“scrapy crawl search”也可以，只是上述方式在结束时可以保存进度，下次运行时会在程序上次的地方继续获取。注意，如果想要保存进度，请使用“Ctrl + C”<strong>一次</strong>，注意是<strong>一次</strong>。按下“Ctrl + C”一次后，程序会继续运行一会，主要用来保存获取的数据、保存进度等操作，请耐心等待。下次再运行时，只要再运行上面的指令就可以恢复上次的进度。</p>\n<ul>\n<li>但也不是很稳定，目前还需多次测试，先爬取数据再说，这个不急</li>\n</ul>\n<h3 id=\"13-待完成\"><a href=\"#13-待完成\" class=\"headerlink\" title=\"13. 待完成\"></a>13. 待完成</h3><ul>\n<li>利用scrapyd部署，好像是可以形成API去操作，具体还需学习</li>\n<li>重新做一个小的网站demo爬取，测试scrappd部署环境，昨天主要做的事情，但还没成功</li>\n<li>需完善：多个参数同时存储数据库，<strong>最后再搞</strong>，目前可以实现单个关键词存入数据库，以满足任务要求</li>\n</ul>\n<h2 id=\"如何获取cookie\"><a href=\"#如何获取cookie\" class=\"headerlink\" title=\"如何获取cookie\"></a>如何获取cookie</h2><p>1.用Chrome打开<a href=\"https://passport.weibo.cn/signin/login\" target=\"_blank\" rel=\"noopener\">https://passport.weibo.cn/signin/login</a>；<br><br>2.输入微博的用户名、密码，登录，如图所示：<br><img src=\"https://picture.cognize.me/cognize/github/weibospider/cookie1.png\" alt=\"\"><br>登录成功后会跳转到<a href=\"https://m.weibo.cn\" target=\"_blank\" rel=\"noopener\">https://m.weibo.cn</a>;<br><br>3.按F12键打开Chrome开发者工具，在地址栏输入并跳转到<a href=\"https://weibo.cn\" target=\"_blank\" rel=\"noopener\">https://weibo.cn</a>，跳转后会显示如下类似界面:<br><img src=\"https://picture.cognize.me/cognize/github/weibospider/cookie2.png\" alt=\"\"><br>4.依此点击Chrome开发者工具中的Network-&gt;Name中的weibo.cn-&gt;Headers-&gt;Request Headers，”Cookie:”后的值即为我们要找的cookie值，复制即可，如图所示：<br><img src=\"https://picture.cognize.me/cognize/github/weibospider/cookie3.png\" alt=\"\"></p>\n"},{"title":"排序算法","top":false,"cover":false,"toc":false,"mathjax":true,"keywords":"排序算法，快排，堆排序","description":"排序算法整理","summary":"排序算法整理","abbrlink":"232f","date":"2020-09-13T08:31:22.000Z","password":null,"_content":"## 排序问题整理\n\n> - 排序的时候能用快速排序尽量用快排\n>\n> - 整理排序算法的复杂度以及优缺点\n\n#### 1.快速排序（交换排序）\n\n- 需要一个递归栈来保存信息\n- 最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(n^{2})$\n- 空间复杂度：$O(log_2{n})$\n- 是否稳定：否（快的排序都不稳定）\n- 每排一次，枢轴被放入最终位置\n\n```c\nint Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low<high){\n        low++;\n        while(A[low]<=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]>pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low<high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n        \tA[low] = A[high];                //用临时变量w储存值，交换两个数\n        \tA[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &A[],int low,int high){   //开始快排\n    if(low<high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n```\n\n#### 2.冒泡排序（交换排序）\n\n> - 注意返回值类型以及函数以及flag的使用\n\n- 从后往前比较两两相邻元素的值，若为逆序，则交换他们，直到序列比较完成。这成为第一趟冒泡。\n- 结果是将最小的元素交换到待排序列的第一个位置\n- 下一趟冒泡时，前一趟确定的最小元素不再参与比较，这样最多$n-1$趟冒泡就能排好序\n- 最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$\n- 是否稳定：是\n\n```c\nvoid BubbleSort(int A[],int n){\n    for(int i = 0; i < n-1; i++){\n        bool flag = false;\n        for(int j = n-1; j>i; j--){    //从后往前\n            if(A[j-1] > A[j]){\n                swap(A[j-1],A[j]);     //交换两个元素\n                flag = true;\n            }\n        }\n        if(flag == false){\n            return;                    //没有发生交换，这说明有序\n        }\n    }\n}\n//网上找的swap函数，仅供参考\nvoid swap(int *a,int *b)\n{\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```\n\n#### 3.直接插入排序\n\n- 从前往后依次插入到前面的序列\n- 最好情况是表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素\n- 最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$\n- 是否稳定：是\n\n```c\nvoid InserSort(int A[],int n){\n    int i,j;\n    for(i=2;i<n;i++){                  //依次将A[2]~A[n]插入到前面已排序序列\n        if(A[i]<A[i-1]){               //若A[i]关键词小于其前驱，将A[i]插入有序表\n            A[0] = A[i];//复制为哨兵，A[0]不存放元素\n            for(j=i-1;A[0]<A[j];j--){//从后往前查找待插入位置\n                A[j+1] = A[j];//向后挪位\n            }\n            A[j+1] = A[0];//复制到插入位置\n        }\n    }\n}\n```\n\n#### 4.折半插入排序\n\n- 只适用于**顺序表**\n- 最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$\n- 是否稳定：是\n\n```c\nvoid InsertSort(int A[],int n){\n    int i,j,low,high,mid;\n    for(i=2;i<=n;i++){           //依次将A[2]~A[n]插入到前面的已排序序列\n        A[0] = A[i];             //将A[i]暂存到A[0]\n        low = 1;                 //设置折半查找的范围\n        high = i - 1;            //设置折半查找的范围\n        while(low<=high){        //折半查找（默认递增有序）\n            mid = (low+high)/2;  //取中间点\n            if(A[mid]>A[0]){\n                high = mid - 1;  //查找左半子表\n            }else{\n                low = mid + 1;   //查找右半子表\n            }\n        }\n        for(j=i-1;j>=high+1;--j){\n            A[j+1] = A[j];       //统一后移元素，空出插入位置\n        }\n        A[high+1] = A[0];        //插入操作\n    }\n}\n```\n\n#### 5.希尔排序\n\n- 只适用于**顺序表**\n- 是否稳定：否\n\n```c\nvoid ShellSort(int A[],int n){\n    int i,j,dk;\n    for(dk=n/2;dk>=1;dk=dk/2){       //步长变化 \n        for(i=dk+1;i<=n;++i){\n            if(A[i]<A[i-dk]){        //需将A[i]插入有序增量字表\n                A[0] = A[i];         //暂存A[0]\n                for(j=i-dk;j>0 && A[0]<A[j];j=j-dk){\n                    A[j+dk] = A[j];  //记录后移，查找插入位置\n                }\n                A[j+dk] = A[0];      //插入\n            }//if\n        }\n    }\n}\n```\n\n#### 6.堆排序\n\n- 每排列一次，都有一个正确结点\n- 最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(nlog_2{n})$\n- 是否稳定：否\n\n```c\nvoid BuildMaxHeap(int A[],int len){\n    for(int i=len/2;i>0;i--){//反复调整堆\n        HeadAdjust(A,i,len);\n    }\n}\nvoid HeadAdjust(int A[],int k,int len){\n    A[0] = A[k];//\n    for(int i=2*k;i<=len;i*=2){\n        if(i<len && A[i]<A[i+1]){\n            i++;//\n        }\n        if(A[0]>=A[i]){\n            break;//\n        }else{\n            A[k] = A[i];//\n            k = i;//\n        }\n    }\n    A[k] = A[0];//放入最终位置\n}\nvoid HeapSort(int A[],int len){\n    BuildMaxHeap(A,len);//建立初始堆\n    for(int i=len;i>1;i--){//n-1趟的交换和建堆\n        int temp = A[i];//堆顶和堆底元素交换\n        A[1] = A[i];\n        A[i] = temp;\n        HeadAdjust(A,1,i-1);//继续调整剩余元素\n    }\n}\n```\n","source":"_posts/排序算法.md","raw":"---\ntitle: 排序算法\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\n  - 排序\ncategories:\n  - 代码\nkeywords: 排序算法，快排，堆排序\ndescription: 排序算法整理\nsummary: 排序算法整理\nabbrlink: 232f\ndate: 2020-09-13 16:31:22\npassword:\n---\n## 排序问题整理\n\n> - 排序的时候能用快速排序尽量用快排\n>\n> - 整理排序算法的复杂度以及优缺点\n\n#### 1.快速排序（交换排序）\n\n- 需要一个递归栈来保存信息\n- 最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(n^{2})$\n- 空间复杂度：$O(log_2{n})$\n- 是否稳定：否（快的排序都不稳定）\n- 每排一次，枢轴被放入最终位置\n\n```c\nint Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low<high){\n        low++;\n        while(A[low]<=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]>pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low<high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n        \tA[low] = A[high];                //用临时变量w储存值，交换两个数\n        \tA[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &A[],int low,int high){   //开始快排\n    if(low<high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n```\n\n#### 2.冒泡排序（交换排序）\n\n> - 注意返回值类型以及函数以及flag的使用\n\n- 从后往前比较两两相邻元素的值，若为逆序，则交换他们，直到序列比较完成。这成为第一趟冒泡。\n- 结果是将最小的元素交换到待排序列的第一个位置\n- 下一趟冒泡时，前一趟确定的最小元素不再参与比较，这样最多$n-1$趟冒泡就能排好序\n- 最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$\n- 是否稳定：是\n\n```c\nvoid BubbleSort(int A[],int n){\n    for(int i = 0; i < n-1; i++){\n        bool flag = false;\n        for(int j = n-1; j>i; j--){    //从后往前\n            if(A[j-1] > A[j]){\n                swap(A[j-1],A[j]);     //交换两个元素\n                flag = true;\n            }\n        }\n        if(flag == false){\n            return;                    //没有发生交换，这说明有序\n        }\n    }\n}\n//网上找的swap函数，仅供参考\nvoid swap(int *a,int *b)\n{\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```\n\n#### 3.直接插入排序\n\n- 从前往后依次插入到前面的序列\n- 最好情况是表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素\n- 最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$\n- 是否稳定：是\n\n```c\nvoid InserSort(int A[],int n){\n    int i,j;\n    for(i=2;i<n;i++){                  //依次将A[2]~A[n]插入到前面已排序序列\n        if(A[i]<A[i-1]){               //若A[i]关键词小于其前驱，将A[i]插入有序表\n            A[0] = A[i];//复制为哨兵，A[0]不存放元素\n            for(j=i-1;A[0]<A[j];j--){//从后往前查找待插入位置\n                A[j+1] = A[j];//向后挪位\n            }\n            A[j+1] = A[0];//复制到插入位置\n        }\n    }\n}\n```\n\n#### 4.折半插入排序\n\n- 只适用于**顺序表**\n- 最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$\n- 是否稳定：是\n\n```c\nvoid InsertSort(int A[],int n){\n    int i,j,low,high,mid;\n    for(i=2;i<=n;i++){           //依次将A[2]~A[n]插入到前面的已排序序列\n        A[0] = A[i];             //将A[i]暂存到A[0]\n        low = 1;                 //设置折半查找的范围\n        high = i - 1;            //设置折半查找的范围\n        while(low<=high){        //折半查找（默认递增有序）\n            mid = (low+high)/2;  //取中间点\n            if(A[mid]>A[0]){\n                high = mid - 1;  //查找左半子表\n            }else{\n                low = mid + 1;   //查找右半子表\n            }\n        }\n        for(j=i-1;j>=high+1;--j){\n            A[j+1] = A[j];       //统一后移元素，空出插入位置\n        }\n        A[high+1] = A[0];        //插入操作\n    }\n}\n```\n\n#### 5.希尔排序\n\n- 只适用于**顺序表**\n- 是否稳定：否\n\n```c\nvoid ShellSort(int A[],int n){\n    int i,j,dk;\n    for(dk=n/2;dk>=1;dk=dk/2){       //步长变化 \n        for(i=dk+1;i<=n;++i){\n            if(A[i]<A[i-dk]){        //需将A[i]插入有序增量字表\n                A[0] = A[i];         //暂存A[0]\n                for(j=i-dk;j>0 && A[0]<A[j];j=j-dk){\n                    A[j+dk] = A[j];  //记录后移，查找插入位置\n                }\n                A[j+dk] = A[0];      //插入\n            }//if\n        }\n    }\n}\n```\n\n#### 6.堆排序\n\n- 每排列一次，都有一个正确结点\n- 最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(nlog_2{n})$\n- 是否稳定：否\n\n```c\nvoid BuildMaxHeap(int A[],int len){\n    for(int i=len/2;i>0;i--){//反复调整堆\n        HeadAdjust(A,i,len);\n    }\n}\nvoid HeadAdjust(int A[],int k,int len){\n    A[0] = A[k];//\n    for(int i=2*k;i<=len;i*=2){\n        if(i<len && A[i]<A[i+1]){\n            i++;//\n        }\n        if(A[0]>=A[i]){\n            break;//\n        }else{\n            A[k] = A[i];//\n            k = i;//\n        }\n    }\n    A[k] = A[0];//放入最终位置\n}\nvoid HeapSort(int A[],int len){\n    BuildMaxHeap(A,len);//建立初始堆\n    for(int i=len;i>1;i--){//n-1趟的交换和建堆\n        int temp = A[i];//堆顶和堆底元素交换\n        A[1] = A[i];\n        A[i] = temp;\n        HeadAdjust(A,1,i-1);//继续调整剩余元素\n    }\n}\n```\n","slug":"排序算法","published":1,"updated":"2020-09-18T09:44:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q60003qa09k7szff6hf","content":"<h2 id=\"排序问题整理\"><a href=\"#排序问题整理\" class=\"headerlink\" title=\"排序问题整理\"></a>排序问题整理</h2><blockquote>\n<ul>\n<li><p>排序的时候能用快速排序尽量用快排</p>\n</li>\n<li><p>整理排序算法的复杂度以及优缺点</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"1-快速排序（交换排序）\"><a href=\"#1-快速排序（交换排序）\" class=\"headerlink\" title=\"1.快速排序（交换排序）\"></a>1.快速排序（交换排序）</h4><ul>\n<li>需要一个递归栈来保存信息</li>\n<li>最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(n^{2})$</li>\n<li>空间复杂度：$O(log_2{n})$</li>\n<li>是否稳定：否（快的排序都不稳定）</li>\n<li>每排一次，枢轴被放入最终位置</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low<high){\n        low++;\n        while(A[low]<=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]>pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low<high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n            A[low] = A[high];                //用临时变量w储存值，交换两个数\n            A[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &A[],int low,int high){   //开始快排\n    if(low<high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-冒泡排序（交换排序）\"><a href=\"#2-冒泡排序（交换排序）\" class=\"headerlink\" title=\"2.冒泡排序（交换排序）\"></a>2.冒泡排序（交换排序）</h4><blockquote>\n<ul>\n<li>注意返回值类型以及函数以及flag的使用</li>\n</ul>\n</blockquote>\n<ul>\n<li>从后往前比较两两相邻元素的值，若为逆序，则交换他们，直到序列比较完成。这成为第一趟冒泡。</li>\n<li>结果是将最小的元素交换到待排序列的第一个位置</li>\n<li>下一趟冒泡时，前一趟确定的最小元素不再参与比较，这样最多$n-1$趟冒泡就能排好序</li>\n<li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li>\n<li>是否稳定：是</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void BubbleSort(int A[],int n){\n    for(int i = 0; i < n-1; i++){\n        bool flag = false;\n        for(int j = n-1; j>i; j--){    //从后往前\n            if(A[j-1] > A[j]){\n                swap(A[j-1],A[j]);     //交换两个元素\n                flag = true;\n            }\n        }\n        if(flag == false){\n            return;                    //没有发生交换，这说明有序\n        }\n    }\n}\n//网上找的swap函数，仅供参考\nvoid swap(int *a,int *b)\n{\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3-直接插入排序\"><a href=\"#3-直接插入排序\" class=\"headerlink\" title=\"3.直接插入排序\"></a>3.直接插入排序</h4><ul>\n<li>从前往后依次插入到前面的序列</li>\n<li>最好情况是表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素</li>\n<li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li>\n<li>是否稳定：是</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void InserSort(int A[],int n){\n    int i,j;\n    for(i=2;i<n;i++){                  //依次将A[2]~A[n]插入到前面已排序序列\n        if(A[i]<A[i-1]){               //若A[i]关键词小于其前驱，将A[i]插入有序表\n            A[0] = A[i];//复制为哨兵，A[0]不存放元素\n            for(j=i-1;A[0]<A[j];j--){//从后往前查找待插入位置\n                A[j+1] = A[j];//向后挪位\n            }\n            A[j+1] = A[0];//复制到插入位置\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4-折半插入排序\"><a href=\"#4-折半插入排序\" class=\"headerlink\" title=\"4.折半插入排序\"></a>4.折半插入排序</h4><ul>\n<li>只适用于<strong>顺序表</strong></li>\n<li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li>\n<li>是否稳定：是</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void InsertSort(int A[],int n){\n    int i,j,low,high,mid;\n    for(i=2;i<=n;i++){           //依次将A[2]~A[n]插入到前面的已排序序列\n        A[0] = A[i];             //将A[i]暂存到A[0]\n        low = 1;                 //设置折半查找的范围\n        high = i - 1;            //设置折半查找的范围\n        while(low<=high){        //折半查找（默认递增有序）\n            mid = (low+high)/2;  //取中间点\n            if(A[mid]>A[0]){\n                high = mid - 1;  //查找左半子表\n            }else{\n                low = mid + 1;   //查找右半子表\n            }\n        }\n        for(j=i-1;j>=high+1;--j){\n            A[j+1] = A[j];       //统一后移元素，空出插入位置\n        }\n        A[high+1] = A[0];        //插入操作\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"5-希尔排序\"><a href=\"#5-希尔排序\" class=\"headerlink\" title=\"5.希尔排序\"></a>5.希尔排序</h4><ul>\n<li>只适用于<strong>顺序表</strong></li>\n<li>是否稳定：否</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void ShellSort(int A[],int n){\n    int i,j,dk;\n    for(dk=n/2;dk>=1;dk=dk/2){       //步长变化 \n        for(i=dk+1;i<=n;++i){\n            if(A[i]<A[i-dk]){        //需将A[i]插入有序增量字表\n                A[0] = A[i];         //暂存A[0]\n                for(j=i-dk;j>0 && A[0]<A[j];j=j-dk){\n                    A[j+dk] = A[j];  //记录后移，查找插入位置\n                }\n                A[j+dk] = A[0];      //插入\n            }//if\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"6-堆排序\"><a href=\"#6-堆排序\" class=\"headerlink\" title=\"6.堆排序\"></a>6.堆排序</h4><ul>\n<li>每排列一次，都有一个正确结点</li>\n<li>最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(nlog_2{n})$</li>\n<li>是否稳定：否</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void BuildMaxHeap(int A[],int len){\n    for(int i=len/2;i>0;i--){//反复调整堆\n        HeadAdjust(A,i,len);\n    }\n}\nvoid HeadAdjust(int A[],int k,int len){\n    A[0] = A[k];//\n    for(int i=2*k;i<=len;i*=2){\n        if(i<len && A[i]<A[i+1]){\n            i++;//\n        }\n        if(A[0]>=A[i]){\n            break;//\n        }else{\n            A[k] = A[i];//\n            k = i;//\n        }\n    }\n    A[k] = A[0];//放入最终位置\n}\nvoid HeapSort(int A[],int len){\n    BuildMaxHeap(A,len);//建立初始堆\n    for(int i=len;i>1;i--){//n-1趟的交换和建堆\n        int temp = A[i];//堆顶和堆底元素交换\n        A[1] = A[i];\n        A[i] = temp;\n        HeadAdjust(A,1,i-1);//继续调整剩余元素\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"排序问题整理\"><a href=\"#排序问题整理\" class=\"headerlink\" title=\"排序问题整理\"></a>排序问题整理</h2><blockquote>\n<ul>\n<li><p>排序的时候能用快速排序尽量用快排</p>\n</li>\n<li><p>整理排序算法的复杂度以及优缺点</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"1-快速排序（交换排序）\"><a href=\"#1-快速排序（交换排序）\" class=\"headerlink\" title=\"1.快速排序（交换排序）\"></a>1.快速排序（交换排序）</h4><ul>\n<li>需要一个递归栈来保存信息</li>\n<li>最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(n^{2})$</li>\n<li>空间复杂度：$O(log_2{n})$</li>\n<li>是否稳定：否（快的排序都不稳定）</li>\n<li>每排一次，枢轴被放入最终位置</li>\n</ul>\n<pre><code class=\"lang-c\">int Partition(int A[],int low,int high){     //一趟划分\n    int pivot = A[low];                      //将当前表中第一个元素设为枢轴，对表进行划分\n    int t = low;\n    while(low&lt;high){\n        low++;\n        while(A[low]&lt;=pivot){                //从前往后找到一个比枢轴大的数\n            low++;\n        }\n        while(A[high]&gt;pivot){                //从后往前找到一个比枢轴小的数\n            high--;\n        }\n        if(low&lt;high){\n            int w = A[low];                  //用临时变量w储存值，交换两个数\n            A[low] = A[high];                //用临时变量w储存值，交换两个数\n            A[high] = w;                     //用临时变量w储存值，交换两个数\n        }\n    }\n    A[t] = A[high];                          //找到枢轴的正确位置，交换这两个元素\n    A[high] = pivot;\n    return high;                             //返回枢轴正确的位置\n}\nvoid QuickSort(int &amp;A[],int low,int high){   //开始快排\n    if(low&lt;high){\n        int mid = Partition(A,low,high);\n        QuickSort(A,low,mid-1);              //枢轴左半边继续快排\n        QuickSort(A,mid+1,high);\n    }\n}\n</code></pre>\n<h4 id=\"2-冒泡排序（交换排序）\"><a href=\"#2-冒泡排序（交换排序）\" class=\"headerlink\" title=\"2.冒泡排序（交换排序）\"></a>2.冒泡排序（交换排序）</h4><blockquote>\n<ul>\n<li>注意返回值类型以及函数以及flag的使用</li>\n</ul>\n</blockquote>\n<ul>\n<li>从后往前比较两两相邻元素的值，若为逆序，则交换他们，直到序列比较完成。这成为第一趟冒泡。</li>\n<li>结果是将最小的元素交换到待排序列的第一个位置</li>\n<li>下一趟冒泡时，前一趟确定的最小元素不再参与比较，这样最多$n-1$趟冒泡就能排好序</li>\n<li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li>\n<li>是否稳定：是</li>\n</ul>\n<pre><code class=\"lang-c\">void BubbleSort(int A[],int n){\n    for(int i = 0; i &lt; n-1; i++){\n        bool flag = false;\n        for(int j = n-1; j&gt;i; j--){    //从后往前\n            if(A[j-1] &gt; A[j]){\n                swap(A[j-1],A[j]);     //交换两个元素\n                flag = true;\n            }\n        }\n        if(flag == false){\n            return;                    //没有发生交换，这说明有序\n        }\n    }\n}\n//网上找的swap函数，仅供参考\nvoid swap(int *a,int *b)\n{\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n</code></pre>\n<h4 id=\"3-直接插入排序\"><a href=\"#3-直接插入排序\" class=\"headerlink\" title=\"3.直接插入排序\"></a>3.直接插入排序</h4><ul>\n<li>从前往后依次插入到前面的序列</li>\n<li>最好情况是表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素</li>\n<li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li>\n<li>是否稳定：是</li>\n</ul>\n<pre><code class=\"lang-c\">void InserSort(int A[],int n){\n    int i,j;\n    for(i=2;i&lt;n;i++){                  //依次将A[2]~A[n]插入到前面已排序序列\n        if(A[i]&lt;A[i-1]){               //若A[i]关键词小于其前驱，将A[i]插入有序表\n            A[0] = A[i];//复制为哨兵，A[0]不存放元素\n            for(j=i-1;A[0]&lt;A[j];j--){//从后往前查找待插入位置\n                A[j+1] = A[j];//向后挪位\n            }\n            A[j+1] = A[0];//复制到插入位置\n        }\n    }\n}\n</code></pre>\n<h4 id=\"4-折半插入排序\"><a href=\"#4-折半插入排序\" class=\"headerlink\" title=\"4.折半插入排序\"></a>4.折半插入排序</h4><ul>\n<li>只适用于<strong>顺序表</strong></li>\n<li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li>\n<li>是否稳定：是</li>\n</ul>\n<pre><code class=\"lang-c\">void InsertSort(int A[],int n){\n    int i,j,low,high,mid;\n    for(i=2;i&lt;=n;i++){           //依次将A[2]~A[n]插入到前面的已排序序列\n        A[0] = A[i];             //将A[i]暂存到A[0]\n        low = 1;                 //设置折半查找的范围\n        high = i - 1;            //设置折半查找的范围\n        while(low&lt;=high){        //折半查找（默认递增有序）\n            mid = (low+high)/2;  //取中间点\n            if(A[mid]&gt;A[0]){\n                high = mid - 1;  //查找左半子表\n            }else{\n                low = mid + 1;   //查找右半子表\n            }\n        }\n        for(j=i-1;j&gt;=high+1;--j){\n            A[j+1] = A[j];       //统一后移元素，空出插入位置\n        }\n        A[high+1] = A[0];        //插入操作\n    }\n}\n</code></pre>\n<h4 id=\"5-希尔排序\"><a href=\"#5-希尔排序\" class=\"headerlink\" title=\"5.希尔排序\"></a>5.希尔排序</h4><ul>\n<li>只适用于<strong>顺序表</strong></li>\n<li>是否稳定：否</li>\n</ul>\n<pre><code class=\"lang-c\">void ShellSort(int A[],int n){\n    int i,j,dk;\n    for(dk=n/2;dk&gt;=1;dk=dk/2){       //步长变化 \n        for(i=dk+1;i&lt;=n;++i){\n            if(A[i]&lt;A[i-dk]){        //需将A[i]插入有序增量字表\n                A[0] = A[i];         //暂存A[0]\n                for(j=i-dk;j&gt;0 &amp;&amp; A[0]&lt;A[j];j=j-dk){\n                    A[j+dk] = A[j];  //记录后移，查找插入位置\n                }\n                A[j+dk] = A[0];      //插入\n            }//if\n        }\n    }\n}\n</code></pre>\n<h4 id=\"6-堆排序\"><a href=\"#6-堆排序\" class=\"headerlink\" title=\"6.堆排序\"></a>6.堆排序</h4><ul>\n<li>每排列一次，都有一个正确结点</li>\n<li>最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(nlog_2{n})$</li>\n<li>是否稳定：否</li>\n</ul>\n<pre><code class=\"lang-c\">void BuildMaxHeap(int A[],int len){\n    for(int i=len/2;i&gt;0;i--){//反复调整堆\n        HeadAdjust(A,i,len);\n    }\n}\nvoid HeadAdjust(int A[],int k,int len){\n    A[0] = A[k];//\n    for(int i=2*k;i&lt;=len;i*=2){\n        if(i&lt;len &amp;&amp; A[i]&lt;A[i+1]){\n            i++;//\n        }\n        if(A[0]&gt;=A[i]){\n            break;//\n        }else{\n            A[k] = A[i];//\n            k = i;//\n        }\n    }\n    A[k] = A[0];//放入最终位置\n}\nvoid HeapSort(int A[],int len){\n    BuildMaxHeap(A,len);//建立初始堆\n    for(int i=len;i&gt;1;i--){//n-1趟的交换和建堆\n        int temp = A[i];//堆顶和堆底元素交换\n        A[1] = A[i];\n        A[i] = temp;\n        HeadAdjust(A,1,i-1);//继续调整剩余元素\n    }\n}\n</code></pre>\n"},{"title":"树相关代码","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"树代码整理","abbrlink":"3849","date":"2020-09-05T10:46:17.000Z","password":null,"keywords":["HEXO","HEXO SEO优化"],"description":"总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。","_content":"## 树相关代码\n\n> #### 1. 二叉树链式存储结构描述\n\n```c\ntypedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTree *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\n```\n\n> #### 2. 先序遍历\n\n```c\nvoid PreOrder(BiTree T){\n    if(T != NULL){\n        visit(T);             //访问根节点\n        PreOrder(T->lchild);  //递归遍历左子树\n        PreOrder(T->rchild);  //递归遍历左子树\n    }\n}\n```\n\n> #### 3. 中序遍历\n\n```c\nvoid PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T->lchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n        PreOrder(T->rchild);  //递归遍历左子树\n    }\n}\n```\n\n> #### 4. 后序遍历\n\n```c\nvoid PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T->lchild);  //递归遍历左子树\n        PreOrder(T->rchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n    }\n}\n```\n\n> #### 5. 层次遍历（层次遍历是利用**队列**作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\n\n```c\nvoid LevelOrder(BiTree T){\n    BiTree Queue[maxsize];              //初始化辅助队列\n    int front = -1, rear = -1;\n    BiTree p;                           //p用于遍历二叉树\n    Queue[++rear] = T;                  //将根节点入队Q\n    while(front!=rear){                 //队列不为空则循环\n        p = Queue[++front];             //队头结点出队\n        visit(p);                       //访问出队结点\n        if(p->lchild != NULL){\n            Queue[++rear] = p->lchild;  //左子树不为空，则左子树根结点入队\n        }\n        if(p->rchild != NULL){\n            Queue[++rear] = p->rchild;  //右子树不为空，则右子树根节点入队\n        }\n    }   \n}\n```\n\n> #### 6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\n\n```c\nvoid PreOrder(BiTree T){\n    BiTree Stack[maxsize];     //初始化辅助栈S\n    int top = -1;              //栈的下标\n    BiTree p = T;              //p是遍历指针\n    while(top!=-1 || p!=NULL){ //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            visit(p);          //访问当前结点\n            Stack[++top] = p;  //入栈元素\n            p = p -> lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            p = Stack[top--];  //栈顶元素出栈\n            p = p -> rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n```\n\n> #### 7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\n\n```c\nvoid InOrder(BiTree T){\n    InitStack(S);              //初始化栈S\n    BiTree p = T;              //p是遍历指针\n    while(p || !IsEmpty){      //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            Push(S,p);         //入栈元素\n            p = p -> lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            Pop(S,p);          //栈顶元素出栈\n            visit(p);          //访问出栈结点\n            p = p -> rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n```\n\n> #### 8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\n\n```c\nvoid PostOrder(BiTree T){\n    InitStack(S);\n    p = T;                                      //p是遍历指针\n    r = NULL;\n    while(p || !IsEmpty(S)){\n        if(p){                                  //走到最左边\n            push(S,p); \n            p = p -> lchild;\n        }else{                                  //向右\n            GetTop(T,p);                        //读栈顶结点（非出栈）\n            if(p->rchild && p->rchild != r){    //若右子树存在，且未被访问过\n                p = p -> rchild;                //向右转\n                push(S,p);                      //压入栈\n                p = p -> lchild;                //再走到最走\n            }else{                              //否则，弹出结点并访问\n                pop(S,p);                       //将结点弹出\n                visit(p->data);                 //访问该节点\n                r = p;                          //记录最近访问过的结点\n                p = NULL;                       //结点访问完后，重置p指针\n            }\n        }//else\n    }//while\n}\n```\n\n> #### 9.递归求树的高度\n\n- 写递归时首先需要考虑的便是递归运行到什么时候终止\n\n```c\nint Btdepth(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int ldep = Btdepth(T->lchild);\n    int rdep = Btdepth(T->rchild);\n    if(ldep > rdep){\n        return ldep + 1;\n    }else{\n        return rdep + 1;\n    }\n}\n```\n\n> #### 10.递归交换二叉树的左右子树\n\n- 此代码暗含着结点为递归出口\n\n```c\nvoid swap(BiTree b){\n//本算法递归的交换二叉树的左、右子树\n    if(b){\n        swap(b->lchild);\n        swap(b->rchild);\n        BiTree temp = b -> lchild;\n        b->lchild = b->rhcild;\n        b->rchild = temp;\n    }\n}\n```\n\n> #### 11.递归删除以某一结点为根节点的子树并释放其存储空间\n\n- 此代码暗含着节点为空时为递归出口\n\n```c\nvoid DeleteXTree(BiTree bt){\n    if(bt){\n        DeleteXTree(bt->lchild);\n        DeleteXTree(bt->rchild);\n        free(bt);\n    }\n}\n```\n\n> #### 12.利用层次遍历求树的高度（这里还没看）\n\n```c\nint LeverOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=-1,rear=-1,level=0,last=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front != rear){\n        p = Queue[++front];\n        if(p->lchild!=NULL){\n            Queue[++rear] = P->lchild;\n        }\n        if(p->lchild!=NULL){\n            Queue[++rear] = P->rchild;\n        }\n        if(front==last){\n            level++;\n            last = rear;\n        }\n    }\n}\n```\n\n> #### 13.利用层次遍历求树的宽度\n\n```c\nint LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,width=last=max=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        width++;\n        if(p->lchild!=NULL){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild!=NULL){\n            Queue[++rear] = p->rchild;\n        }\n        if(front == last){\n            if(max < width){\n                max = width;\n            }\n            last = rear;\n        }\n    }\n    return max;\n}\n```\n\n> #### 14.求二叉树中叶子结点的个数\n\n```c\nint LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,count=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p->lchild == NUll && p->rchild == NULL){\n            count++;\n        }\n        if(p->lchild != NUll){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild != NUll){\n            Queue[++rear] = p->rchild;\n        }\n    }\n    return count;\n}\n```\n\n> #### 15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）\n\n```c\nint LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1;\n    int num = 0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p->lchild != NUll && p->rchild == NULL){\n            if(p->lchild->lchild == NUll && p->lchild->rchild == NULL){\n                num++;\n            }\n        }\n        if(p->lchild == NUll && p->rchild != NULL){\n            if(p->rchild->lchild == NUll && p->rchild->rchild == NULL){\n                num++;\n            }\n        }\n        if(p->lchild != NUll){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild != NUll){\n            Queue[++rear] = p->rchild;\n        }\n    }\n    if(T->lchild == NULL && T-rchild == NULL){\n        num++\n    }\n    return num;\n}\n```\n\n> #### 16.求一棵二叉树是否为平衡二叉树\n\n```c\nint High(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int llen = High(T->lchild);\n    int rlen = High(T->rchild);\n    if(llen >= rlen){\n        return llen+1;\n    }else{\n        return rlen+1;\n    }\n}\n\nbool PostOrder1(BiTree T){\n    BiTree Stack[maxsize];\n    int top = -1;\n    BiTree p = T,r = NULL;//p为遍历二叉树指针，r指向最近访问结点\n    while(p!=NULL || top!=-1){\n        if(p!=NULL){\n            Stack[++top] = p;\n            p = p->lchild;\n        }else{\n            p = Stack[top];\n            if(p->rchild!=NULL && p->rchild!=r){//p的右孩子不为空，且未被访问过\n                p = p->rchild;\n                Stack[++top] = p;\n                p = p->lchild;\n            }else{\n                p = Stack[top--];\n                if(abs(High(p->lchild)-High(p->rchild))>1){\n                    return false;\n                }\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n    return true;\n}\n```\n\n> #### 17.给出二叉树的自下而上、从右到左的层次遍历算法\n\n```c\nvoid InverLevel(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=0;\n    BiTree Stack[maxsize];\n    int top=-1;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        Stack[++top] = p;\n        if(p->lchild！= NULL){\n            Queue[++rear] = p;\n        }\n        if(p->rchild！= NULL){\n            Queue[++rear] = p;\n        }\n    }\n    while(top!=-1){\n        p = Stack[top--];\n        Visit(p);\n    }\n}\n```\n\n> #### 18.线索二叉树的构造，结构描述\n\n- 对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左右指针域是否为空，若为空，讲他们改为指向前驱结点或后继结点的线索\n- ltag=0，lchild域指示结点的左孩子；ltag=1，lchild域指示结点的前驱\n- ltag=0，rchild域指示结点的右孩子；ltag=1，rchild域指示结点的后继\n\n```c\ntypedef struct ThreadNode{\n    int data;                            //数据元素\n    struct ThreadNode *lchild,*rchild;   //左、右孩子指针\n    int ltag,rtag;                       //左、右线索标志\n}ThreadNode,*ThreadTree;\n```\n\n> #### 19.中序二叉树线索化\n\n```c\nvoid InThread(ThreadTree &p, ThreadTree &pre){\n    if(p!=NULL){\n        Inthread(p->lchild,pre);\n        if(p->lchild == NULL){\n            p->lchild = pre;\n            p->ltag = 1;\n        }\n        if(pre!=NULL && pre->rchild == NULL){\n            pre->rchild = p;\n            pre->rtag = 1;\n        }\n        pre = p;\n        InThread(pre->rchild,pre);\n    }\n}\n```\n\n> #### 20.二叉排序树的查找\n\n- 二叉排序树：左＜根＜右\n\n```c\nBSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL && key!=T-data){\n        p = NULL;\n        if(key<T->data){\n            T = T->lchild;\n        }else{\n            T = T->rchild;\n        }\n    }\n    return T;\n}\n```\n\n> #### 21.二叉排序树的插入\n\n```c\nBSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL && key!=T-data){\n        p = NULL;\n        if(key<T->data){\n            T = T->lchild;\n        }else{\n            T = T->rchild;\n        }\n    }\n    BiTree Bt = (BiTree)malloc(sizeof(BSTNode));\n    if(key<p->data){\n        p->lchild = BT;\n    }\n    if(key>p->data){\n        p->rchild = BT;\n    }\n    return T;\n}\n```\n\n> #### 22.二叉排序树的构造\n\n```c\nvoid Creat_BST(BiTree &T,KeyType str[],int n){\n    T = NULL;\n    int i = 0;\n    while(i<n){\n        BST_Insert(T,str[i]);\n        i++;\n    }\n}\n```","source":"_posts/树相关代码.md","raw":"---\ntitle: 树相关代码\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\n  - 树\ncategories:\n  - 代码\nsummary: 树代码整理\nabbrlink: '3849'\ndate: 2020-09-05 18:46:17\npassword:\nkeywords: [HEXO,HEXO SEO优化]\ndescription: 总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。\n---\n## 树相关代码\n\n> #### 1. 二叉树链式存储结构描述\n\n```c\ntypedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTree *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\n```\n\n> #### 2. 先序遍历\n\n```c\nvoid PreOrder(BiTree T){\n    if(T != NULL){\n        visit(T);             //访问根节点\n        PreOrder(T->lchild);  //递归遍历左子树\n        PreOrder(T->rchild);  //递归遍历左子树\n    }\n}\n```\n\n> #### 3. 中序遍历\n\n```c\nvoid PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T->lchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n        PreOrder(T->rchild);  //递归遍历左子树\n    }\n}\n```\n\n> #### 4. 后序遍历\n\n```c\nvoid PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T->lchild);  //递归遍历左子树\n        PreOrder(T->rchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n    }\n}\n```\n\n> #### 5. 层次遍历（层次遍历是利用**队列**作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\n\n```c\nvoid LevelOrder(BiTree T){\n    BiTree Queue[maxsize];              //初始化辅助队列\n    int front = -1, rear = -1;\n    BiTree p;                           //p用于遍历二叉树\n    Queue[++rear] = T;                  //将根节点入队Q\n    while(front!=rear){                 //队列不为空则循环\n        p = Queue[++front];             //队头结点出队\n        visit(p);                       //访问出队结点\n        if(p->lchild != NULL){\n            Queue[++rear] = p->lchild;  //左子树不为空，则左子树根结点入队\n        }\n        if(p->rchild != NULL){\n            Queue[++rear] = p->rchild;  //右子树不为空，则右子树根节点入队\n        }\n    }   \n}\n```\n\n> #### 6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\n\n```c\nvoid PreOrder(BiTree T){\n    BiTree Stack[maxsize];     //初始化辅助栈S\n    int top = -1;              //栈的下标\n    BiTree p = T;              //p是遍历指针\n    while(top!=-1 || p!=NULL){ //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            visit(p);          //访问当前结点\n            Stack[++top] = p;  //入栈元素\n            p = p -> lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            p = Stack[top--];  //栈顶元素出栈\n            p = p -> rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n```\n\n> #### 7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\n\n```c\nvoid InOrder(BiTree T){\n    InitStack(S);              //初始化栈S\n    BiTree p = T;              //p是遍历指针\n    while(p || !IsEmpty){      //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            Push(S,p);         //入栈元素\n            p = p -> lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            Pop(S,p);          //栈顶元素出栈\n            visit(p);          //访问出栈结点\n            p = p -> rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n```\n\n> #### 8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\n\n```c\nvoid PostOrder(BiTree T){\n    InitStack(S);\n    p = T;                                      //p是遍历指针\n    r = NULL;\n    while(p || !IsEmpty(S)){\n        if(p){                                  //走到最左边\n            push(S,p); \n            p = p -> lchild;\n        }else{                                  //向右\n            GetTop(T,p);                        //读栈顶结点（非出栈）\n            if(p->rchild && p->rchild != r){    //若右子树存在，且未被访问过\n                p = p -> rchild;                //向右转\n                push(S,p);                      //压入栈\n                p = p -> lchild;                //再走到最走\n            }else{                              //否则，弹出结点并访问\n                pop(S,p);                       //将结点弹出\n                visit(p->data);                 //访问该节点\n                r = p;                          //记录最近访问过的结点\n                p = NULL;                       //结点访问完后，重置p指针\n            }\n        }//else\n    }//while\n}\n```\n\n> #### 9.递归求树的高度\n\n- 写递归时首先需要考虑的便是递归运行到什么时候终止\n\n```c\nint Btdepth(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int ldep = Btdepth(T->lchild);\n    int rdep = Btdepth(T->rchild);\n    if(ldep > rdep){\n        return ldep + 1;\n    }else{\n        return rdep + 1;\n    }\n}\n```\n\n> #### 10.递归交换二叉树的左右子树\n\n- 此代码暗含着结点为递归出口\n\n```c\nvoid swap(BiTree b){\n//本算法递归的交换二叉树的左、右子树\n    if(b){\n        swap(b->lchild);\n        swap(b->rchild);\n        BiTree temp = b -> lchild;\n        b->lchild = b->rhcild;\n        b->rchild = temp;\n    }\n}\n```\n\n> #### 11.递归删除以某一结点为根节点的子树并释放其存储空间\n\n- 此代码暗含着节点为空时为递归出口\n\n```c\nvoid DeleteXTree(BiTree bt){\n    if(bt){\n        DeleteXTree(bt->lchild);\n        DeleteXTree(bt->rchild);\n        free(bt);\n    }\n}\n```\n\n> #### 12.利用层次遍历求树的高度（这里还没看）\n\n```c\nint LeverOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=-1,rear=-1,level=0,last=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front != rear){\n        p = Queue[++front];\n        if(p->lchild!=NULL){\n            Queue[++rear] = P->lchild;\n        }\n        if(p->lchild!=NULL){\n            Queue[++rear] = P->rchild;\n        }\n        if(front==last){\n            level++;\n            last = rear;\n        }\n    }\n}\n```\n\n> #### 13.利用层次遍历求树的宽度\n\n```c\nint LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,width=last=max=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        width++;\n        if(p->lchild!=NULL){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild!=NULL){\n            Queue[++rear] = p->rchild;\n        }\n        if(front == last){\n            if(max < width){\n                max = width;\n            }\n            last = rear;\n        }\n    }\n    return max;\n}\n```\n\n> #### 14.求二叉树中叶子结点的个数\n\n```c\nint LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,count=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p->lchild == NUll && p->rchild == NULL){\n            count++;\n        }\n        if(p->lchild != NUll){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild != NUll){\n            Queue[++rear] = p->rchild;\n        }\n    }\n    return count;\n}\n```\n\n> #### 15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）\n\n```c\nint LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1;\n    int num = 0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p->lchild != NUll && p->rchild == NULL){\n            if(p->lchild->lchild == NUll && p->lchild->rchild == NULL){\n                num++;\n            }\n        }\n        if(p->lchild == NUll && p->rchild != NULL){\n            if(p->rchild->lchild == NUll && p->rchild->rchild == NULL){\n                num++;\n            }\n        }\n        if(p->lchild != NUll){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild != NUll){\n            Queue[++rear] = p->rchild;\n        }\n    }\n    if(T->lchild == NULL && T-rchild == NULL){\n        num++\n    }\n    return num;\n}\n```\n\n> #### 16.求一棵二叉树是否为平衡二叉树\n\n```c\nint High(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int llen = High(T->lchild);\n    int rlen = High(T->rchild);\n    if(llen >= rlen){\n        return llen+1;\n    }else{\n        return rlen+1;\n    }\n}\n\nbool PostOrder1(BiTree T){\n    BiTree Stack[maxsize];\n    int top = -1;\n    BiTree p = T,r = NULL;//p为遍历二叉树指针，r指向最近访问结点\n    while(p!=NULL || top!=-1){\n        if(p!=NULL){\n            Stack[++top] = p;\n            p = p->lchild;\n        }else{\n            p = Stack[top];\n            if(p->rchild!=NULL && p->rchild!=r){//p的右孩子不为空，且未被访问过\n                p = p->rchild;\n                Stack[++top] = p;\n                p = p->lchild;\n            }else{\n                p = Stack[top--];\n                if(abs(High(p->lchild)-High(p->rchild))>1){\n                    return false;\n                }\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n    return true;\n}\n```\n\n> #### 17.给出二叉树的自下而上、从右到左的层次遍历算法\n\n```c\nvoid InverLevel(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=0;\n    BiTree Stack[maxsize];\n    int top=-1;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        Stack[++top] = p;\n        if(p->lchild！= NULL){\n            Queue[++rear] = p;\n        }\n        if(p->rchild！= NULL){\n            Queue[++rear] = p;\n        }\n    }\n    while(top!=-1){\n        p = Stack[top--];\n        Visit(p);\n    }\n}\n```\n\n> #### 18.线索二叉树的构造，结构描述\n\n- 对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左右指针域是否为空，若为空，讲他们改为指向前驱结点或后继结点的线索\n- ltag=0，lchild域指示结点的左孩子；ltag=1，lchild域指示结点的前驱\n- ltag=0，rchild域指示结点的右孩子；ltag=1，rchild域指示结点的后继\n\n```c\ntypedef struct ThreadNode{\n    int data;                            //数据元素\n    struct ThreadNode *lchild,*rchild;   //左、右孩子指针\n    int ltag,rtag;                       //左、右线索标志\n}ThreadNode,*ThreadTree;\n```\n\n> #### 19.中序二叉树线索化\n\n```c\nvoid InThread(ThreadTree &p, ThreadTree &pre){\n    if(p!=NULL){\n        Inthread(p->lchild,pre);\n        if(p->lchild == NULL){\n            p->lchild = pre;\n            p->ltag = 1;\n        }\n        if(pre!=NULL && pre->rchild == NULL){\n            pre->rchild = p;\n            pre->rtag = 1;\n        }\n        pre = p;\n        InThread(pre->rchild,pre);\n    }\n}\n```\n\n> #### 20.二叉排序树的查找\n\n- 二叉排序树：左＜根＜右\n\n```c\nBSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL && key!=T-data){\n        p = NULL;\n        if(key<T->data){\n            T = T->lchild;\n        }else{\n            T = T->rchild;\n        }\n    }\n    return T;\n}\n```\n\n> #### 21.二叉排序树的插入\n\n```c\nBSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL && key!=T-data){\n        p = NULL;\n        if(key<T->data){\n            T = T->lchild;\n        }else{\n            T = T->rchild;\n        }\n    }\n    BiTree Bt = (BiTree)malloc(sizeof(BSTNode));\n    if(key<p->data){\n        p->lchild = BT;\n    }\n    if(key>p->data){\n        p->rchild = BT;\n    }\n    return T;\n}\n```\n\n> #### 22.二叉排序树的构造\n\n```c\nvoid Creat_BST(BiTree &T,KeyType str[],int n){\n    T = NULL;\n    int i = 0;\n    while(i<n){\n        BST_Insert(T,str[i]);\n        i++;\n    }\n}\n```","slug":"树相关代码","published":1,"updated":"2020-09-12T05:44:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q61003ua09kewyob7nv","content":"<h2 id=\"树相关代码\"><a href=\"#树相关代码\" class=\"headerlink\" title=\"树相关代码\"></a>树相关代码</h2><blockquote>\n<h4 id=\"1-二叉树链式存储结构描述\"><a href=\"#1-二叉树链式存储结构描述\" class=\"headerlink\" title=\"1. 二叉树链式存储结构描述\"></a>1. 二叉树链式存储结构描述</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">typedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTree *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"2-先序遍历\"><a href=\"#2-先序遍历\" class=\"headerlink\" title=\"2. 先序遍历\"></a>2. 先序遍历</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void PreOrder(BiTree T){\n    if(T != NULL){\n        visit(T);             //访问根节点\n        PreOrder(T->lchild);  //递归遍历左子树\n        PreOrder(T->rchild);  //递归遍历左子树\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"3-中序遍历\"><a href=\"#3-中序遍历\" class=\"headerlink\" title=\"3. 中序遍历\"></a>3. 中序遍历</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T->lchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n        PreOrder(T->rchild);  //递归遍历左子树\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"4-后序遍历\"><a href=\"#4-后序遍历\" class=\"headerlink\" title=\"4. 后序遍历\"></a>4. 后序遍历</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T->lchild);  //递归遍历左子树\n        PreOrder(T->rchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"5-层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\"><a href=\"#5-层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\" class=\"headerlink\" title=\"5. 层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\"></a>5. 层次遍历（层次遍历是利用<strong>队列</strong>作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void LevelOrder(BiTree T){\n    BiTree Queue[maxsize];              //初始化辅助队列\n    int front = -1, rear = -1;\n    BiTree p;                           //p用于遍历二叉树\n    Queue[++rear] = T;                  //将根节点入队Q\n    while(front!=rear){                 //队列不为空则循环\n        p = Queue[++front];             //队头结点出队\n        visit(p);                       //访问出队结点\n        if(p->lchild != NULL){\n            Queue[++rear] = p->lchild;  //左子树不为空，则左子树根结点入队\n        }\n        if(p->rchild != NULL){\n            Queue[++rear] = p->rchild;  //右子树不为空，则右子树根节点入队\n        }\n    }   \n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"6-先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\"><a href=\"#6-先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\" class=\"headerlink\" title=\"6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\"></a>6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void PreOrder(BiTree T){\n    BiTree Stack[maxsize];     //初始化辅助栈S\n    int top = -1;              //栈的下标\n    BiTree p = T;              //p是遍历指针\n    while(top!=-1 || p!=NULL){ //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            visit(p);          //访问当前结点\n            Stack[++top] = p;  //入栈元素\n            p = p -> lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            p = Stack[top--];  //栈顶元素出栈\n            p = p -> rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"7-中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\"><a href=\"#7-中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\" class=\"headerlink\" title=\"7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\"></a>7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void InOrder(BiTree T){\n    InitStack(S);              //初始化栈S\n    BiTree p = T;              //p是遍历指针\n    while(p || !IsEmpty){      //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            Push(S,p);         //入栈元素\n            p = p -> lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            Pop(S,p);          //栈顶元素出栈\n            visit(p);          //访问出栈结点\n            p = p -> rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"8-后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\"><a href=\"#8-后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\" class=\"headerlink\" title=\"8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\"></a>8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void PostOrder(BiTree T){\n    InitStack(S);\n    p = T;                                      //p是遍历指针\n    r = NULL;\n    while(p || !IsEmpty(S)){\n        if(p){                                  //走到最左边\n            push(S,p); \n            p = p -> lchild;\n        }else{                                  //向右\n            GetTop(T,p);                        //读栈顶结点（非出栈）\n            if(p->rchild && p->rchild != r){    //若右子树存在，且未被访问过\n                p = p -> rchild;                //向右转\n                push(S,p);                      //压入栈\n                p = p -> lchild;                //再走到最走\n            }else{                              //否则，弹出结点并访问\n                pop(S,p);                       //将结点弹出\n                visit(p->data);                 //访问该节点\n                r = p;                          //记录最近访问过的结点\n                p = NULL;                       //结点访问完后，重置p指针\n            }\n        }//else\n    }//while\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"9-递归求树的高度\"><a href=\"#9-递归求树的高度\" class=\"headerlink\" title=\"9.递归求树的高度\"></a>9.递归求树的高度</h4></blockquote>\n<ul>\n<li>写递归时首先需要考虑的便是递归运行到什么时候终止</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int Btdepth(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int ldep = Btdepth(T->lchild);\n    int rdep = Btdepth(T->rchild);\n    if(ldep > rdep){\n        return ldep + 1;\n    }else{\n        return rdep + 1;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"10-递归交换二叉树的左右子树\"><a href=\"#10-递归交换二叉树的左右子树\" class=\"headerlink\" title=\"10.递归交换二叉树的左右子树\"></a>10.递归交换二叉树的左右子树</h4></blockquote>\n<ul>\n<li>此代码暗含着结点为递归出口</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void swap(BiTree b){\n//本算法递归的交换二叉树的左、右子树\n    if(b){\n        swap(b->lchild);\n        swap(b->rchild);\n        BiTree temp = b -> lchild;\n        b->lchild = b->rhcild;\n        b->rchild = temp;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"11-递归删除以某一结点为根节点的子树并释放其存储空间\"><a href=\"#11-递归删除以某一结点为根节点的子树并释放其存储空间\" class=\"headerlink\" title=\"11.递归删除以某一结点为根节点的子树并释放其存储空间\"></a>11.递归删除以某一结点为根节点的子树并释放其存储空间</h4></blockquote>\n<ul>\n<li>此代码暗含着节点为空时为递归出口</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void DeleteXTree(BiTree bt){\n    if(bt){\n        DeleteXTree(bt->lchild);\n        DeleteXTree(bt->rchild);\n        free(bt);\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"12-利用层次遍历求树的高度（这里还没看）\"><a href=\"#12-利用层次遍历求树的高度（这里还没看）\" class=\"headerlink\" title=\"12.利用层次遍历求树的高度（这里还没看）\"></a>12.利用层次遍历求树的高度（这里还没看）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int LeverOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=-1,rear=-1,level=0,last=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front != rear){\n        p = Queue[++front];\n        if(p->lchild!=NULL){\n            Queue[++rear] = P->lchild;\n        }\n        if(p->lchild!=NULL){\n            Queue[++rear] = P->rchild;\n        }\n        if(front==last){\n            level++;\n            last = rear;\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"13-利用层次遍历求树的宽度\"><a href=\"#13-利用层次遍历求树的宽度\" class=\"headerlink\" title=\"13.利用层次遍历求树的宽度\"></a>13.利用层次遍历求树的宽度</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,width=last=max=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        width++;\n        if(p->lchild!=NULL){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild!=NULL){\n            Queue[++rear] = p->rchild;\n        }\n        if(front == last){\n            if(max < width){\n                max = width;\n            }\n            last = rear;\n        }\n    }\n    return max;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"14-求二叉树中叶子结点的个数\"><a href=\"#14-求二叉树中叶子结点的个数\" class=\"headerlink\" title=\"14.求二叉树中叶子结点的个数\"></a>14.求二叉树中叶子结点的个数</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,count=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p->lchild == NUll && p->rchild == NULL){\n            count++;\n        }\n        if(p->lchild != NUll){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild != NUll){\n            Queue[++rear] = p->rchild;\n        }\n    }\n    return count;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"15-求树中独生叶结点的个数（既是叶结点又无兄弟结点）\"><a href=\"#15-求树中独生叶结点的个数（既是叶结点又无兄弟结点）\" class=\"headerlink\" title=\"15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）\"></a>15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1;\n    int num = 0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p->lchild != NUll && p->rchild == NULL){\n            if(p->lchild->lchild == NUll && p->lchild->rchild == NULL){\n                num++;\n            }\n        }\n        if(p->lchild == NUll && p->rchild != NULL){\n            if(p->rchild->lchild == NUll && p->rchild->rchild == NULL){\n                num++;\n            }\n        }\n        if(p->lchild != NUll){\n            Queue[++rear] = p->lchild;\n        }\n        if(p->rchild != NUll){\n            Queue[++rear] = p->rchild;\n        }\n    }\n    if(T->lchild == NULL && T-rchild == NULL){\n        num++\n    }\n    return num;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"16-求一棵二叉树是否为平衡二叉树\"><a href=\"#16-求一棵二叉树是否为平衡二叉树\" class=\"headerlink\" title=\"16.求一棵二叉树是否为平衡二叉树\"></a>16.求一棵二叉树是否为平衡二叉树</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int High(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int llen = High(T->lchild);\n    int rlen = High(T->rchild);\n    if(llen >= rlen){\n        return llen+1;\n    }else{\n        return rlen+1;\n    }\n}\n\nbool PostOrder1(BiTree T){\n    BiTree Stack[maxsize];\n    int top = -1;\n    BiTree p = T,r = NULL;//p为遍历二叉树指针，r指向最近访问结点\n    while(p!=NULL || top!=-1){\n        if(p!=NULL){\n            Stack[++top] = p;\n            p = p->lchild;\n        }else{\n            p = Stack[top];\n            if(p->rchild!=NULL && p->rchild!=r){//p的右孩子不为空，且未被访问过\n                p = p->rchild;\n                Stack[++top] = p;\n                p = p->lchild;\n            }else{\n                p = Stack[top--];\n                if(abs(High(p->lchild)-High(p->rchild))>1){\n                    return false;\n                }\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"17-给出二叉树的自下而上、从右到左的层次遍历算法\"><a href=\"#17-给出二叉树的自下而上、从右到左的层次遍历算法\" class=\"headerlink\" title=\"17.给出二叉树的自下而上、从右到左的层次遍历算法\"></a>17.给出二叉树的自下而上、从右到左的层次遍历算法</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void InverLevel(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=0;\n    BiTree Stack[maxsize];\n    int top=-1;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        Stack[++top] = p;\n        if(p->lchild！= NULL){\n            Queue[++rear] = p;\n        }\n        if(p->rchild！= NULL){\n            Queue[++rear] = p;\n        }\n    }\n    while(top!=-1){\n        p = Stack[top--];\n        Visit(p);\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"18-线索二叉树的构造，结构描述\"><a href=\"#18-线索二叉树的构造，结构描述\" class=\"headerlink\" title=\"18.线索二叉树的构造，结构描述\"></a>18.线索二叉树的构造，结构描述</h4></blockquote>\n<ul>\n<li>对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左右指针域是否为空，若为空，讲他们改为指向前驱结点或后继结点的线索</li>\n<li>ltag=0，lchild域指示结点的左孩子；ltag=1，lchild域指示结点的前驱</li>\n<li>ltag=0，rchild域指示结点的右孩子；ltag=1，rchild域指示结点的后继</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">typedef struct ThreadNode{\n    int data;                            //数据元素\n    struct ThreadNode *lchild,*rchild;   //左、右孩子指针\n    int ltag,rtag;                       //左、右线索标志\n}ThreadNode,*ThreadTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"19-中序二叉树线索化\"><a href=\"#19-中序二叉树线索化\" class=\"headerlink\" title=\"19.中序二叉树线索化\"></a>19.中序二叉树线索化</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void InThread(ThreadTree &p, ThreadTree &pre){\n    if(p!=NULL){\n        Inthread(p->lchild,pre);\n        if(p->lchild == NULL){\n            p->lchild = pre;\n            p->ltag = 1;\n        }\n        if(pre!=NULL && pre->rchild == NULL){\n            pre->rchild = p;\n            pre->rtag = 1;\n        }\n        pre = p;\n        InThread(pre->rchild,pre);\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"20-二叉排序树的查找\"><a href=\"#20-二叉排序树的查找\" class=\"headerlink\" title=\"20.二叉排序树的查找\"></a>20.二叉排序树的查找</h4></blockquote>\n<ul>\n<li>二叉排序树：左＜根＜右</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">BSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL && key!=T-data){\n        p = NULL;\n        if(key<T->data){\n            T = T->lchild;\n        }else{\n            T = T->rchild;\n        }\n    }\n    return T;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"21-二叉排序树的插入\"><a href=\"#21-二叉排序树的插入\" class=\"headerlink\" title=\"21.二叉排序树的插入\"></a>21.二叉排序树的插入</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">BSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL && key!=T-data){\n        p = NULL;\n        if(key<T->data){\n            T = T->lchild;\n        }else{\n            T = T->rchild;\n        }\n    }\n    BiTree Bt = (BiTree)malloc(sizeof(BSTNode));\n    if(key<p->data){\n        p->lchild = BT;\n    }\n    if(key>p->data){\n        p->rchild = BT;\n    }\n    return T;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"22-二叉排序树的构造\"><a href=\"#22-二叉排序树的构造\" class=\"headerlink\" title=\"22.二叉排序树的构造\"></a>22.二叉排序树的构造</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void Creat_BST(BiTree &T,KeyType str[],int n){\n    T = NULL;\n    int i = 0;\n    while(i<n){\n        BST_Insert(T,str[i]);\n        i++;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"树相关代码\"><a href=\"#树相关代码\" class=\"headerlink\" title=\"树相关代码\"></a>树相关代码</h2><blockquote>\n<h4 id=\"1-二叉树链式存储结构描述\"><a href=\"#1-二叉树链式存储结构描述\" class=\"headerlink\" title=\"1. 二叉树链式存储结构描述\"></a>1. 二叉树链式存储结构描述</h4></blockquote>\n<pre><code class=\"lang-c\">typedef struct BiTNode{\n    int data;                        //数据域\n    struct BiTree *lchild, *rchild;  //左、右孩子指针\n}BiTNode, *BiTree;\n</code></pre>\n<blockquote>\n<h4 id=\"2-先序遍历\"><a href=\"#2-先序遍历\" class=\"headerlink\" title=\"2. 先序遍历\"></a>2. 先序遍历</h4></blockquote>\n<pre><code class=\"lang-c\">void PreOrder(BiTree T){\n    if(T != NULL){\n        visit(T);             //访问根节点\n        PreOrder(T-&gt;lchild);  //递归遍历左子树\n        PreOrder(T-&gt;rchild);  //递归遍历左子树\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"3-中序遍历\"><a href=\"#3-中序遍历\" class=\"headerlink\" title=\"3. 中序遍历\"></a>3. 中序遍历</h4></blockquote>\n<pre><code class=\"lang-c\">void PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T-&gt;lchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n        PreOrder(T-&gt;rchild);  //递归遍历左子树\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"4-后序遍历\"><a href=\"#4-后序遍历\" class=\"headerlink\" title=\"4. 后序遍历\"></a>4. 后序遍历</h4></blockquote>\n<pre><code class=\"lang-c\">void PreOrder(BiTree T){\n    if(T != NULL){\n        PreOrder(T-&gt;lchild);  //递归遍历左子树\n        PreOrder(T-&gt;rchild);  //递归遍历左子树\n        visit(T);             //访问根节点\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"5-层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\"><a href=\"#5-层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\" class=\"headerlink\" title=\"5. 层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）\"></a>5. 层次遍历（层次遍历是利用<strong>队列</strong>作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）</h4></blockquote>\n<pre><code class=\"lang-c\">void LevelOrder(BiTree T){\n    BiTree Queue[maxsize];              //初始化辅助队列\n    int front = -1, rear = -1;\n    BiTree p;                           //p用于遍历二叉树\n    Queue[++rear] = T;                  //将根节点入队Q\n    while(front!=rear){                 //队列不为空则循环\n        p = Queue[++front];             //队头结点出队\n        visit(p);                       //访问出队结点\n        if(p-&gt;lchild != NULL){\n            Queue[++rear] = p-&gt;lchild;  //左子树不为空，则左子树根结点入队\n        }\n        if(p-&gt;rchild != NULL){\n            Queue[++rear] = p-&gt;rchild;  //右子树不为空，则右子树根节点入队\n        }\n    }   \n}\n</code></pre>\n<blockquote>\n<h4 id=\"6-先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\"><a href=\"#6-先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\" class=\"headerlink\" title=\"6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）\"></a>6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）</h4></blockquote>\n<pre><code class=\"lang-c\">void PreOrder(BiTree T){\n    BiTree Stack[maxsize];     //初始化辅助栈S\n    int top = -1;              //栈的下标\n    BiTree p = T;              //p是遍历指针\n    while(top!=-1 || p!=NULL){ //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            visit(p);          //访问当前结点\n            Stack[++top] = p;  //入栈元素\n            p = p -&gt; lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            p = Stack[top--];  //栈顶元素出栈\n            p = p -&gt; rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"7-中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\"><a href=\"#7-中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\" class=\"headerlink\" title=\"7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）\"></a>7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）</h4></blockquote>\n<pre><code class=\"lang-c\">void InOrder(BiTree T){\n    InitStack(S);              //初始化栈S\n    BiTree p = T;              //p是遍历指针\n    while(p || !IsEmpty){      //栈不空或p不为空时，开始循环\n        if(p){                 //一路向左\n            Push(S,p);         //入栈元素\n            p = p -&gt; lchild;   //左孩子不为空，一直向左走\n        }else{                 //出栈，并转向出栈结点的右子树\n            Pop(S,p);          //栈顶元素出栈\n            visit(p);          //访问出栈结点\n            p = p -&gt; rchild;   //向右子树走，p赋值为当前结点的右孩子\n                               //返回while循环继续进入if-else语句\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"8-后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\"><a href=\"#8-后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\" class=\"headerlink\" title=\"8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）\"></a>8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）</h4></blockquote>\n<pre><code class=\"lang-c\">void PostOrder(BiTree T){\n    InitStack(S);\n    p = T;                                      //p是遍历指针\n    r = NULL;\n    while(p || !IsEmpty(S)){\n        if(p){                                  //走到最左边\n            push(S,p); \n            p = p -&gt; lchild;\n        }else{                                  //向右\n            GetTop(T,p);                        //读栈顶结点（非出栈）\n            if(p-&gt;rchild &amp;&amp; p-&gt;rchild != r){    //若右子树存在，且未被访问过\n                p = p -&gt; rchild;                //向右转\n                push(S,p);                      //压入栈\n                p = p -&gt; lchild;                //再走到最走\n            }else{                              //否则，弹出结点并访问\n                pop(S,p);                       //将结点弹出\n                visit(p-&gt;data);                 //访问该节点\n                r = p;                          //记录最近访问过的结点\n                p = NULL;                       //结点访问完后，重置p指针\n            }\n        }//else\n    }//while\n}\n</code></pre>\n<blockquote>\n<h4 id=\"9-递归求树的高度\"><a href=\"#9-递归求树的高度\" class=\"headerlink\" title=\"9.递归求树的高度\"></a>9.递归求树的高度</h4></blockquote>\n<ul>\n<li>写递归时首先需要考虑的便是递归运行到什么时候终止</li>\n</ul>\n<pre><code class=\"lang-c\">int Btdepth(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int ldep = Btdepth(T-&gt;lchild);\n    int rdep = Btdepth(T-&gt;rchild);\n    if(ldep &gt; rdep){\n        return ldep + 1;\n    }else{\n        return rdep + 1;\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"10-递归交换二叉树的左右子树\"><a href=\"#10-递归交换二叉树的左右子树\" class=\"headerlink\" title=\"10.递归交换二叉树的左右子树\"></a>10.递归交换二叉树的左右子树</h4></blockquote>\n<ul>\n<li>此代码暗含着结点为递归出口</li>\n</ul>\n<pre><code class=\"lang-c\">void swap(BiTree b){\n//本算法递归的交换二叉树的左、右子树\n    if(b){\n        swap(b-&gt;lchild);\n        swap(b-&gt;rchild);\n        BiTree temp = b -&gt; lchild;\n        b-&gt;lchild = b-&gt;rhcild;\n        b-&gt;rchild = temp;\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"11-递归删除以某一结点为根节点的子树并释放其存储空间\"><a href=\"#11-递归删除以某一结点为根节点的子树并释放其存储空间\" class=\"headerlink\" title=\"11.递归删除以某一结点为根节点的子树并释放其存储空间\"></a>11.递归删除以某一结点为根节点的子树并释放其存储空间</h4></blockquote>\n<ul>\n<li>此代码暗含着节点为空时为递归出口</li>\n</ul>\n<pre><code class=\"lang-c\">void DeleteXTree(BiTree bt){\n    if(bt){\n        DeleteXTree(bt-&gt;lchild);\n        DeleteXTree(bt-&gt;rchild);\n        free(bt);\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"12-利用层次遍历求树的高度（这里还没看）\"><a href=\"#12-利用层次遍历求树的高度（这里还没看）\" class=\"headerlink\" title=\"12.利用层次遍历求树的高度（这里还没看）\"></a>12.利用层次遍历求树的高度（这里还没看）</h4></blockquote>\n<pre><code class=\"lang-c\">int LeverOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=-1,rear=-1,level=0,last=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front != rear){\n        p = Queue[++front];\n        if(p-&gt;lchild!=NULL){\n            Queue[++rear] = P-&gt;lchild;\n        }\n        if(p-&gt;lchild!=NULL){\n            Queue[++rear] = P-&gt;rchild;\n        }\n        if(front==last){\n            level++;\n            last = rear;\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"13-利用层次遍历求树的宽度\"><a href=\"#13-利用层次遍历求树的宽度\" class=\"headerlink\" title=\"13.利用层次遍历求树的宽度\"></a>13.利用层次遍历求树的宽度</h4></blockquote>\n<pre><code class=\"lang-c\">int LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,width=last=max=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        width++;\n        if(p-&gt;lchild!=NULL){\n            Queue[++rear] = p-&gt;lchild;\n        }\n        if(p-&gt;rchild!=NULL){\n            Queue[++rear] = p-&gt;rchild;\n        }\n        if(front == last){\n            if(max &lt; width){\n                max = width;\n            }\n            last = rear;\n        }\n    }\n    return max;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"14-求二叉树中叶子结点的个数\"><a href=\"#14-求二叉树中叶子结点的个数\" class=\"headerlink\" title=\"14.求二叉树中叶子结点的个数\"></a>14.求二叉树中叶子结点的个数</h4></blockquote>\n<pre><code class=\"lang-c\">int LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1,count=0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p-&gt;lchild == NUll &amp;&amp; p-&gt;rchild == NULL){\n            count++;\n        }\n        if(p-&gt;lchild != NUll){\n            Queue[++rear] = p-&gt;lchild;\n        }\n        if(p-&gt;rchild != NUll){\n            Queue[++rear] = p-&gt;rchild;\n        }\n    }\n    return count;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"15-求树中独生叶结点的个数（既是叶结点又无兄弟结点）\"><a href=\"#15-求树中独生叶结点的个数（既是叶结点又无兄弟结点）\" class=\"headerlink\" title=\"15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）\"></a>15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）</h4></blockquote>\n<pre><code class=\"lang-c\">int LevelOrder(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=-1;\n    int num = 0;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        if(p-&gt;lchild != NUll &amp;&amp; p-&gt;rchild == NULL){\n            if(p-&gt;lchild-&gt;lchild == NUll &amp;&amp; p-&gt;lchild-&gt;rchild == NULL){\n                num++;\n            }\n        }\n        if(p-&gt;lchild == NUll &amp;&amp; p-&gt;rchild != NULL){\n            if(p-&gt;rchild-&gt;lchild == NUll &amp;&amp; p-&gt;rchild-&gt;rchild == NULL){\n                num++;\n            }\n        }\n        if(p-&gt;lchild != NUll){\n            Queue[++rear] = p-&gt;lchild;\n        }\n        if(p-&gt;rchild != NUll){\n            Queue[++rear] = p-&gt;rchild;\n        }\n    }\n    if(T-&gt;lchild == NULL &amp;&amp; T-rchild == NULL){\n        num++\n    }\n    return num;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"16-求一棵二叉树是否为平衡二叉树\"><a href=\"#16-求一棵二叉树是否为平衡二叉树\" class=\"headerlink\" title=\"16.求一棵二叉树是否为平衡二叉树\"></a>16.求一棵二叉树是否为平衡二叉树</h4></blockquote>\n<pre><code class=\"lang-c\">int High(BiTree T){\n    if(T == NULL){\n        return 0;\n    }\n    int llen = High(T-&gt;lchild);\n    int rlen = High(T-&gt;rchild);\n    if(llen &gt;= rlen){\n        return llen+1;\n    }else{\n        return rlen+1;\n    }\n}\n\nbool PostOrder1(BiTree T){\n    BiTree Stack[maxsize];\n    int top = -1;\n    BiTree p = T,r = NULL;//p为遍历二叉树指针，r指向最近访问结点\n    while(p!=NULL || top!=-1){\n        if(p!=NULL){\n            Stack[++top] = p;\n            p = p-&gt;lchild;\n        }else{\n            p = Stack[top];\n            if(p-&gt;rchild!=NULL &amp;&amp; p-&gt;rchild!=r){//p的右孩子不为空，且未被访问过\n                p = p-&gt;rchild;\n                Stack[++top] = p;\n                p = p-&gt;lchild;\n            }else{\n                p = Stack[top--];\n                if(abs(High(p-&gt;lchild)-High(p-&gt;rchild))&gt;1){\n                    return false;\n                }\n                r = p;\n                p = NULL;\n            }\n        }\n    }\n    return true;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"17-给出二叉树的自下而上、从右到左的层次遍历算法\"><a href=\"#17-给出二叉树的自下而上、从右到左的层次遍历算法\" class=\"headerlink\" title=\"17.给出二叉树的自下而上、从右到左的层次遍历算法\"></a>17.给出二叉树的自下而上、从右到左的层次遍历算法</h4></blockquote>\n<pre><code class=\"lang-c\">void InverLevel(BiTree T){\n    BiTree Queue[maxsize];\n    int front=rear=0;\n    BiTree Stack[maxsize];\n    int top=-1;\n    BiTree p;\n    Queue[++rear] = T;\n    while(front!=rear){\n        p = Queue[++front];\n        Stack[++top] = p;\n        if(p-&gt;lchild！= NULL){\n            Queue[++rear] = p;\n        }\n        if(p-&gt;rchild！= NULL){\n            Queue[++rear] = p;\n        }\n    }\n    while(top!=-1){\n        p = Stack[top--];\n        Visit(p);\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"18-线索二叉树的构造，结构描述\"><a href=\"#18-线索二叉树的构造，结构描述\" class=\"headerlink\" title=\"18.线索二叉树的构造，结构描述\"></a>18.线索二叉树的构造，结构描述</h4></blockquote>\n<ul>\n<li>对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左右指针域是否为空，若为空，讲他们改为指向前驱结点或后继结点的线索</li>\n<li>ltag=0，lchild域指示结点的左孩子；ltag=1，lchild域指示结点的前驱</li>\n<li>ltag=0，rchild域指示结点的右孩子；ltag=1，rchild域指示结点的后继</li>\n</ul>\n<pre><code class=\"lang-c\">typedef struct ThreadNode{\n    int data;                            //数据元素\n    struct ThreadNode *lchild,*rchild;   //左、右孩子指针\n    int ltag,rtag;                       //左、右线索标志\n}ThreadNode,*ThreadTree;\n</code></pre>\n<blockquote>\n<h4 id=\"19-中序二叉树线索化\"><a href=\"#19-中序二叉树线索化\" class=\"headerlink\" title=\"19.中序二叉树线索化\"></a>19.中序二叉树线索化</h4></blockquote>\n<pre><code class=\"lang-c\">void InThread(ThreadTree &amp;p, ThreadTree &amp;pre){\n    if(p!=NULL){\n        Inthread(p-&gt;lchild,pre);\n        if(p-&gt;lchild == NULL){\n            p-&gt;lchild = pre;\n            p-&gt;ltag = 1;\n        }\n        if(pre!=NULL &amp;&amp; pre-&gt;rchild == NULL){\n            pre-&gt;rchild = p;\n            pre-&gt;rtag = 1;\n        }\n        pre = p;\n        InThread(pre-&gt;rchild,pre);\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"20-二叉排序树的查找\"><a href=\"#20-二叉排序树的查找\" class=\"headerlink\" title=\"20.二叉排序树的查找\"></a>20.二叉排序树的查找</h4></blockquote>\n<ul>\n<li>二叉排序树：左＜根＜右</li>\n</ul>\n<pre><code class=\"lang-c\">BSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL &amp;&amp; key!=T-data){\n        p = NULL;\n        if(key&lt;T-&gt;data){\n            T = T-&gt;lchild;\n        }else{\n            T = T-&gt;rchild;\n        }\n    }\n    return T;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"21-二叉排序树的插入\"><a href=\"#21-二叉排序树的插入\" class=\"headerlink\" title=\"21.二叉排序树的插入\"></a>21.二叉排序树的插入</h4></blockquote>\n<pre><code class=\"lang-c\">BSTNode *BST_Search(BiTree T,int key){\n    p = NULL;\n    while(T!=NULL &amp;&amp; key!=T-data){\n        p = NULL;\n        if(key&lt;T-&gt;data){\n            T = T-&gt;lchild;\n        }else{\n            T = T-&gt;rchild;\n        }\n    }\n    BiTree Bt = (BiTree)malloc(sizeof(BSTNode));\n    if(key&lt;p-&gt;data){\n        p-&gt;lchild = BT;\n    }\n    if(key&gt;p-&gt;data){\n        p-&gt;rchild = BT;\n    }\n    return T;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"22-二叉排序树的构造\"><a href=\"#22-二叉排序树的构造\" class=\"headerlink\" title=\"22.二叉排序树的构造\"></a>22.二叉排序树的构造</h4></blockquote>\n<pre><code class=\"lang-c\">void Creat_BST(BiTree &amp;T,KeyType str[],int n){\n    T = NULL;\n    int i = 0;\n    while(i&lt;n){\n        BST_Insert(T,str[i]);\n        i++;\n    }\n}\n</code></pre>\n"},{"title":"每日一题(二) 7.28","top":false,"cover":false,"toc":false,"mathjax":false,"summary":"判断二叉树深度","abbrlink":"6f31","date":"2020-07-28T08:58:06.000Z","password":null,"_content":"## 每日一题 7.28\n\n#### 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n##### 思路：\n\n- 建立二叉树结构\n- 建立二叉树，创造结点\n- 递归求解二叉树深度\n- 释放结点\n\n##### 代码：\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n\n//二叉树结构\ntypedef struct tree //结构体的名字为tree\n{\n    char ch;\n    struct tree *lchild;//指向tree型变量的指针（指向自己结构体的指针）\n    struct tree *rchild;\n}tree;\n//按先序建立二叉树\ntree *CreateTree()  //创建树；\n{\n    tree *bt;  //定义节点的指针bt\n    char str;  //屏幕输入的字符\n    scanf(\"%c\",&str);  //把屏幕输入字符赋予str\n    if(str=='0')\n        return NULL;\n    else\n    {\n        bt=(tree *)malloc(sizeof(tree));//为指针bt申请内存空间\n        bt->ch=str;\n        bt->lchild=CreateTree();\n        bt->rchild=CreateTree();\n        return bt;\n    }\n}\n//先定义两个变量，初始化为0 int ld=0，int rd=0；分别表示左子树和右子树的深度；\n//先判断二叉树bt是否为空，为空直接return返回；\n//不为空，进入左子树的递归调用，此时ld=1，一直到某个结点的左子树为空，if条件不成立，返回上一层递归调用；\n//之后进入右子树的递归调用，再进入这个结点的左子树一直到左子树为空，返回上一层递归调用，继续进入右子树的递归调用；\n//一直循环判断使用哪个递归调用；\n//一直到某个结点的左右子树为空，返回ld和rd的最大值，并将所带回的值+1，重新赋给ld或者rd；\n//重复上述过程，直到根结点，说明bt为空，无法继续返回，所以结束调用函数；\n//返回main函数带回一个整型的值；\n\n\n//求二叉树的深度,递归实现；\nint DeepOrder(tree *bt)\n{\n    int ld=0,rd=0;\n    if(bt)\n    {\n        //先找到最左边的左右孩子为空的结点，之后找到相对位置靠近第一个结点的结点，依次类推；\n        ld=DeepOrder(bt->lchild)+1;\n        rd=DeepOrder(bt->rchild)+1;\n    }\n    return ld>=rd?ld:rd;\n}\n\n//释放树的结点；\nvoid DestroyTree(tree *bt)\n{\n    if(bt)\n    {\n        DestroyTree(bt->lchild);\n        DestroyTree(bt->rchild);\n        free(bt);\n    }\n}\n\nint main(void)\n{\n    tree *bt;\n    printf(\"请以先序输入二叉树(0表示该结点的子结点为空):\\n\");\n    bt=CreateTree();\n    printf(\"bt为： %s\",bt);\n    int deep=DeepOrder(bt);\n    printf(\"\\n二叉树的深度为:  %d\\n\",deep);\n    printf(\"\\n\");\n    DestroyTree(bt);  //释放树结点；\n    return 0;\n}\n```","source":"_posts/每日一题7-28.md","raw":"---\ntitle: 每日一题(二) 7.28\ntop: false\ncover: false\ntoc: false\nmathjax: false\ntags:\n  - 代码\n  - 每日一题\n  - 考研\ncategories:\n  - 每日一题\nsummary: 判断二叉树深度\nabbrlink: 6f31\ndate: 2020-07-28 16:58:06\npassword:\n---\n## 每日一题 7.28\n\n#### 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n##### 思路：\n\n- 建立二叉树结构\n- 建立二叉树，创造结点\n- 递归求解二叉树深度\n- 释放结点\n\n##### 代码：\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n\n//二叉树结构\ntypedef struct tree //结构体的名字为tree\n{\n    char ch;\n    struct tree *lchild;//指向tree型变量的指针（指向自己结构体的指针）\n    struct tree *rchild;\n}tree;\n//按先序建立二叉树\ntree *CreateTree()  //创建树；\n{\n    tree *bt;  //定义节点的指针bt\n    char str;  //屏幕输入的字符\n    scanf(\"%c\",&str);  //把屏幕输入字符赋予str\n    if(str=='0')\n        return NULL;\n    else\n    {\n        bt=(tree *)malloc(sizeof(tree));//为指针bt申请内存空间\n        bt->ch=str;\n        bt->lchild=CreateTree();\n        bt->rchild=CreateTree();\n        return bt;\n    }\n}\n//先定义两个变量，初始化为0 int ld=0，int rd=0；分别表示左子树和右子树的深度；\n//先判断二叉树bt是否为空，为空直接return返回；\n//不为空，进入左子树的递归调用，此时ld=1，一直到某个结点的左子树为空，if条件不成立，返回上一层递归调用；\n//之后进入右子树的递归调用，再进入这个结点的左子树一直到左子树为空，返回上一层递归调用，继续进入右子树的递归调用；\n//一直循环判断使用哪个递归调用；\n//一直到某个结点的左右子树为空，返回ld和rd的最大值，并将所带回的值+1，重新赋给ld或者rd；\n//重复上述过程，直到根结点，说明bt为空，无法继续返回，所以结束调用函数；\n//返回main函数带回一个整型的值；\n\n\n//求二叉树的深度,递归实现；\nint DeepOrder(tree *bt)\n{\n    int ld=0,rd=0;\n    if(bt)\n    {\n        //先找到最左边的左右孩子为空的结点，之后找到相对位置靠近第一个结点的结点，依次类推；\n        ld=DeepOrder(bt->lchild)+1;\n        rd=DeepOrder(bt->rchild)+1;\n    }\n    return ld>=rd?ld:rd;\n}\n\n//释放树的结点；\nvoid DestroyTree(tree *bt)\n{\n    if(bt)\n    {\n        DestroyTree(bt->lchild);\n        DestroyTree(bt->rchild);\n        free(bt);\n    }\n}\n\nint main(void)\n{\n    tree *bt;\n    printf(\"请以先序输入二叉树(0表示该结点的子结点为空):\\n\");\n    bt=CreateTree();\n    printf(\"bt为： %s\",bt);\n    int deep=DeepOrder(bt);\n    printf(\"\\n二叉树的深度为:  %d\\n\",deep);\n    printf(\"\\n\");\n    DestroyTree(bt);  //释放树结点；\n    return 0;\n}\n```","slug":"每日一题7-28","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q62003xa09kc6ycgb4j","content":"<h2 id=\"每日一题-7-28\"><a href=\"#每日一题-7-28\" class=\"headerlink\" title=\"每日一题 7.28\"></a>每日一题 7.28</h2><h4 id=\"给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\"><a href=\"#给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\" class=\"headerlink\" title=\"给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\"></a>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</h4><h5 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h5><ul>\n<li>建立二叉树结构</li>\n<li>建立二叉树，创造结点</li>\n<li>递归求解二叉树深度</li>\n<li>释放结点</li>\n</ul>\n<h5 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h5><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#include<stdio.h>\n#include<stdlib.h>\n\n//二叉树结构\ntypedef struct tree //结构体的名字为tree\n{\n    char ch;\n    struct tree *lchild;//指向tree型变量的指针（指向自己结构体的指针）\n    struct tree *rchild;\n}tree;\n//按先序建立二叉树\ntree *CreateTree()  //创建树；\n{\n    tree *bt;  //定义节点的指针bt\n    char str;  //屏幕输入的字符\n    scanf(\"%c\",&str);  //把屏幕输入字符赋予str\n    if(str=='0')\n        return NULL;\n    else\n    {\n        bt=(tree *)malloc(sizeof(tree));//为指针bt申请内存空间\n        bt->ch=str;\n        bt->lchild=CreateTree();\n        bt->rchild=CreateTree();\n        return bt;\n    }\n}\n//先定义两个变量，初始化为0 int ld=0，int rd=0；分别表示左子树和右子树的深度；\n//先判断二叉树bt是否为空，为空直接return返回；\n//不为空，进入左子树的递归调用，此时ld=1，一直到某个结点的左子树为空，if条件不成立，返回上一层递归调用；\n//之后进入右子树的递归调用，再进入这个结点的左子树一直到左子树为空，返回上一层递归调用，继续进入右子树的递归调用；\n//一直循环判断使用哪个递归调用；\n//一直到某个结点的左右子树为空，返回ld和rd的最大值，并将所带回的值+1，重新赋给ld或者rd；\n//重复上述过程，直到根结点，说明bt为空，无法继续返回，所以结束调用函数；\n//返回main函数带回一个整型的值；\n\n\n//求二叉树的深度,递归实现；\nint DeepOrder(tree *bt)\n{\n    int ld=0,rd=0;\n    if(bt)\n    {\n        //先找到最左边的左右孩子为空的结点，之后找到相对位置靠近第一个结点的结点，依次类推；\n        ld=DeepOrder(bt->lchild)+1;\n        rd=DeepOrder(bt->rchild)+1;\n    }\n    return ld>=rd?ld:rd;\n}\n\n//释放树的结点；\nvoid DestroyTree(tree *bt)\n{\n    if(bt)\n    {\n        DestroyTree(bt->lchild);\n        DestroyTree(bt->rchild);\n        free(bt);\n    }\n}\n\nint main(void)\n{\n    tree *bt;\n    printf(\"请以先序输入二叉树(0表示该结点的子结点为空):\\n\");\n    bt=CreateTree();\n    printf(\"bt为： %s\",bt);\n    int deep=DeepOrder(bt);\n    printf(\"\\n二叉树的深度为:  %d\\n\",deep);\n    printf(\"\\n\");\n    DestroyTree(bt);  //释放树结点；\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"每日一题-7-28\"><a href=\"#每日一题-7-28\" class=\"headerlink\" title=\"每日一题 7.28\"></a>每日一题 7.28</h2><h4 id=\"给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\"><a href=\"#给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\" class=\"headerlink\" title=\"给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\"></a>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</h4><h5 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h5><ul>\n<li>建立二叉树结构</li>\n<li>建立二叉树，创造结点</li>\n<li>递归求解二叉树深度</li>\n<li>释放结点</li>\n</ul>\n<h5 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h5><pre><code class=\"lang-c\">#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\n//二叉树结构\ntypedef struct tree //结构体的名字为tree\n{\n    char ch;\n    struct tree *lchild;//指向tree型变量的指针（指向自己结构体的指针）\n    struct tree *rchild;\n}tree;\n//按先序建立二叉树\ntree *CreateTree()  //创建树；\n{\n    tree *bt;  //定义节点的指针bt\n    char str;  //屏幕输入的字符\n    scanf(&quot;%c&quot;,&amp;str);  //把屏幕输入字符赋予str\n    if(str==&#39;0&#39;)\n        return NULL;\n    else\n    {\n        bt=(tree *)malloc(sizeof(tree));//为指针bt申请内存空间\n        bt-&gt;ch=str;\n        bt-&gt;lchild=CreateTree();\n        bt-&gt;rchild=CreateTree();\n        return bt;\n    }\n}\n//先定义两个变量，初始化为0 int ld=0，int rd=0；分别表示左子树和右子树的深度；\n//先判断二叉树bt是否为空，为空直接return返回；\n//不为空，进入左子树的递归调用，此时ld=1，一直到某个结点的左子树为空，if条件不成立，返回上一层递归调用；\n//之后进入右子树的递归调用，再进入这个结点的左子树一直到左子树为空，返回上一层递归调用，继续进入右子树的递归调用；\n//一直循环判断使用哪个递归调用；\n//一直到某个结点的左右子树为空，返回ld和rd的最大值，并将所带回的值+1，重新赋给ld或者rd；\n//重复上述过程，直到根结点，说明bt为空，无法继续返回，所以结束调用函数；\n//返回main函数带回一个整型的值；\n\n\n//求二叉树的深度,递归实现；\nint DeepOrder(tree *bt)\n{\n    int ld=0,rd=0;\n    if(bt)\n    {\n        //先找到最左边的左右孩子为空的结点，之后找到相对位置靠近第一个结点的结点，依次类推；\n        ld=DeepOrder(bt-&gt;lchild)+1;\n        rd=DeepOrder(bt-&gt;rchild)+1;\n    }\n    return ld&gt;=rd?ld:rd;\n}\n\n//释放树的结点；\nvoid DestroyTree(tree *bt)\n{\n    if(bt)\n    {\n        DestroyTree(bt-&gt;lchild);\n        DestroyTree(bt-&gt;rchild);\n        free(bt);\n    }\n}\n\nint main(void)\n{\n    tree *bt;\n    printf(&quot;请以先序输入二叉树(0表示该结点的子结点为空):\\n&quot;);\n    bt=CreateTree();\n    printf(&quot;bt为： %s&quot;,bt);\n    int deep=DeepOrder(bt);\n    printf(&quot;\\n二叉树的深度为:  %d\\n&quot;,deep);\n    printf(&quot;\\n&quot;);\n    DestroyTree(bt);  //释放树结点；\n    return 0;\n}\n</code></pre>\n"},{"title":"每日一题(三) 7.29","top":false,"cover":false,"toc":false,"mathjax":false,"summary":"判断有效括号","abbrlink":"7624","date":"2020-07-29T09:17:01.000Z","password":null,"_content":"## 每日一题(三) 7.29\n\n##### 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n##### 题解思路\n\n使用数组做栈，两个指针i和j，分别代表字符串和栈顶+1，先判断是否是({[,如果是进栈，不是则判断栈是否为空，空则返回false；如果栈顶是相对应字符，j--；否则，返回false。\n最后再判断栈中是否还有元素，没有元素则false，否则true。\n\n##### 代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\nbool isValid1(char * s){\n    int i=0,j=0;\n    char stack[100000];\n\n    while(s[i]!='\\0'){\n        if((s[i]==')' || s[i]==']' || s[i]=='}') && j==0){\n            return false;\n        }\n        if(s[i]=='(' || s[i]=='{' || s[i]=='['){\n            stack[j++] = s[i++];\n        }\n        else{\n            if(s[i]==')' && stack[j-1] != '('){\n                return false;\n            }\n            else if(s[i]=='}'&& stack[j-1] != '{'){\n                return false;\n            }\n            else if(s[i]==']' && stack[j-1] != '['){\n                return false;\n            }\n            i++;\n            j--;\n        }\n    }\n    if(j==0){\n        printf(\"chenggong\");\n        return true;\n\n    }else{\n        return false;\n    }\n}\n\nbool isValid(char * s){\n    int i = 0;\n    char str[10000] = {0} ;\n    int len = strlen(s);\n    if(len % 2 != 0){\n        printf(\"字符串长度为奇数：%s\",\"失败\\n\");\n        return false;\n    } else if (len == 0 ){\n        printf(\"字符串长度为0:%s\",\"成功\\n\");\n        return true;\n    }\n\n    for(int l = 0; l < strlen(s); l++){\n\n        printf(\"%s\\n\",\"进入循环\");\n        printf(\"第%d次循环\\n\",l+1);\n        if(s[l] == '(') {\n            printf(\"l为:%d\\n\", l);\n            printf(\"i为:%d\\n\", i);\n            str[i] = s[l];\n            printf(\"s[l]为:%c\\ts为:%s\\n\", s[l],s);\n            printf(\"str字符串为:%s\\n\", str);\n            i++;\n//            continue;\n        } else if (s[l] == '['){\n            printf(\"l为:%d\\n\", l);\n            printf(\"i为:%d\\n\", i);\n            str[i] = s[l];\n            printf(\"str字符串为:%s\\n\", str);\n            i++;\n        } else if (s[l] == '{'){\n            str[i] = s[l];\n            i++;\n        } else if (s[l] == ')'){\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\\n\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '('){\n\n                        str[j] = '\\0';\n                        printf(\"修改后的字符串为:%s\\n\", str);\n                        i--;\n                        break;\n                    }else if (str[j] != '('){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n                }\n            }\n        } else if (s[l] == ']'){\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '['  ){\n                        str[j] = '\\0';\n                        printf(\"修改后的字符串为:%s\\n\", str);\n                        i--;\n                        break;\n                    } else if (str[j] != '['){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n\n                }\n\n\n            }\n\n        } else if (s[l] == '}'){\n            printf(\"%s\\n\",\"进入\");\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\\n\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '{'){\n                        str[j] = '\\0';\n                        i--;\n                        break;\n\n\n                    }else if (str[j] == '{'){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n                }\n\n            }\n        }\n    }\n    if(strlen(str) == 0){\n        printf(\"%s\",\"成功\\n\");\n        return true;\n    }else{\n        printf(\"zheli%s\",\"失败\\n\");\n        return false;\n    }\n\n}\n\nint main() {\n//    isValid(\"{[]}\");\n    isValid1(\"{[]}\");\n    return 0;\n}\n\n```","source":"_posts/每日一题7-29.md","raw":"---\ntitle: 每日一题(三) 7.29\ntop: false\ncover: false\ntoc: false\nmathjax: false\ntags:\n  - 代码\n  - 每日一题\n  - 考研\ncategories:\n  - 每日一题\nsummary: 判断有效括号\nabbrlink: '7624'\ndate: 2020-07-29 17:17:01\npassword:\n---\n## 每日一题(三) 7.29\n\n##### 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n##### 题解思路\n\n使用数组做栈，两个指针i和j，分别代表字符串和栈顶+1，先判断是否是({[,如果是进栈，不是则判断栈是否为空，空则返回false；如果栈顶是相对应字符，j--；否则，返回false。\n最后再判断栈中是否还有元素，没有元素则false，否则true。\n\n##### 代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\nbool isValid1(char * s){\n    int i=0,j=0;\n    char stack[100000];\n\n    while(s[i]!='\\0'){\n        if((s[i]==')' || s[i]==']' || s[i]=='}') && j==0){\n            return false;\n        }\n        if(s[i]=='(' || s[i]=='{' || s[i]=='['){\n            stack[j++] = s[i++];\n        }\n        else{\n            if(s[i]==')' && stack[j-1] != '('){\n                return false;\n            }\n            else if(s[i]=='}'&& stack[j-1] != '{'){\n                return false;\n            }\n            else if(s[i]==']' && stack[j-1] != '['){\n                return false;\n            }\n            i++;\n            j--;\n        }\n    }\n    if(j==0){\n        printf(\"chenggong\");\n        return true;\n\n    }else{\n        return false;\n    }\n}\n\nbool isValid(char * s){\n    int i = 0;\n    char str[10000] = {0} ;\n    int len = strlen(s);\n    if(len % 2 != 0){\n        printf(\"字符串长度为奇数：%s\",\"失败\\n\");\n        return false;\n    } else if (len == 0 ){\n        printf(\"字符串长度为0:%s\",\"成功\\n\");\n        return true;\n    }\n\n    for(int l = 0; l < strlen(s); l++){\n\n        printf(\"%s\\n\",\"进入循环\");\n        printf(\"第%d次循环\\n\",l+1);\n        if(s[l] == '(') {\n            printf(\"l为:%d\\n\", l);\n            printf(\"i为:%d\\n\", i);\n            str[i] = s[l];\n            printf(\"s[l]为:%c\\ts为:%s\\n\", s[l],s);\n            printf(\"str字符串为:%s\\n\", str);\n            i++;\n//            continue;\n        } else if (s[l] == '['){\n            printf(\"l为:%d\\n\", l);\n            printf(\"i为:%d\\n\", i);\n            str[i] = s[l];\n            printf(\"str字符串为:%s\\n\", str);\n            i++;\n        } else if (s[l] == '{'){\n            str[i] = s[l];\n            i++;\n        } else if (s[l] == ')'){\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\\n\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '('){\n\n                        str[j] = '\\0';\n                        printf(\"修改后的字符串为:%s\\n\", str);\n                        i--;\n                        break;\n                    }else if (str[j] != '('){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n                }\n            }\n        } else if (s[l] == ']'){\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '['  ){\n                        str[j] = '\\0';\n                        printf(\"修改后的字符串为:%s\\n\", str);\n                        i--;\n                        break;\n                    } else if (str[j] != '['){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n\n                }\n\n\n            }\n\n        } else if (s[l] == '}'){\n            printf(\"%s\\n\",\"进入\");\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\\n\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '{'){\n                        str[j] = '\\0';\n                        i--;\n                        break;\n\n\n                    }else if (str[j] == '{'){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n                }\n\n            }\n        }\n    }\n    if(strlen(str) == 0){\n        printf(\"%s\",\"成功\\n\");\n        return true;\n    }else{\n        printf(\"zheli%s\",\"失败\\n\");\n        return false;\n    }\n\n}\n\nint main() {\n//    isValid(\"{[]}\");\n    isValid1(\"{[]}\");\n    return 0;\n}\n\n```","slug":"每日一题7-29","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q620041a09kct4zga6r","content":"<h2 id=\"每日一题-三-7-29\"><a href=\"#每日一题-三-7-29\" class=\"headerlink\" title=\"每日一题(三) 7.29\"></a>每日一题(三) 7.29</h2><h5 id=\"给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效。\"><a href=\"#给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效。\" class=\"headerlink\" title=\"给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。\"></a>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</h5><p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n<h5 id=\"题解思路\"><a href=\"#题解思路\" class=\"headerlink\" title=\"题解思路\"></a>题解思路</h5><p>使用数组做栈，两个指针i和j，分别代表字符串和栈顶+1，先判断是否是({[,如果是进栈，不是则判断栈是否为空，空则返回false；如果栈顶是相对应字符，j—；否则，返回false。<br>最后再判断栈中是否还有元素，没有元素则false，否则true。</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\nbool isValid1(char * s){\n    int i=0,j=0;\n    char stack[100000];\n\n    while(s[i]!='\\0'){\n        if((s[i]==')' || s[i]==']' || s[i]=='}') && j==0){\n            return false;\n        }\n        if(s[i]=='(' || s[i]=='{' || s[i]=='['){\n            stack[j++] = s[i++];\n        }\n        else{\n            if(s[i]==')' && stack[j-1] != '('){\n                return false;\n            }\n            else if(s[i]=='}'&& stack[j-1] != '{'){\n                return false;\n            }\n            else if(s[i]==']' && stack[j-1] != '['){\n                return false;\n            }\n            i++;\n            j--;\n        }\n    }\n    if(j==0){\n        printf(\"chenggong\");\n        return true;\n\n    }else{\n        return false;\n    }\n}\n\nbool isValid(char * s){\n    int i = 0;\n    char str[10000] = {0} ;\n    int len = strlen(s);\n    if(len % 2 != 0){\n        printf(\"字符串长度为奇数：%s\",\"失败\\n\");\n        return false;\n    } else if (len == 0 ){\n        printf(\"字符串长度为0:%s\",\"成功\\n\");\n        return true;\n    }\n\n    for(int l = 0; l < strlen(s); l++){\n\n        printf(\"%s\\n\",\"进入循环\");\n        printf(\"第%d次循环\\n\",l+1);\n        if(s[l] == '(') {\n            printf(\"l为:%d\\n\", l);\n            printf(\"i为:%d\\n\", i);\n            str[i] = s[l];\n            printf(\"s[l]为:%c\\ts为:%s\\n\", s[l],s);\n            printf(\"str字符串为:%s\\n\", str);\n            i++;\n//            continue;\n        } else if (s[l] == '['){\n            printf(\"l为:%d\\n\", l);\n            printf(\"i为:%d\\n\", i);\n            str[i] = s[l];\n            printf(\"str字符串为:%s\\n\", str);\n            i++;\n        } else if (s[l] == '{'){\n            str[i] = s[l];\n            i++;\n        } else if (s[l] == ')'){\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\\n\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '('){\n\n                        str[j] = '\\0';\n                        printf(\"修改后的字符串为:%s\\n\", str);\n                        i--;\n                        break;\n                    }else if (str[j] != '('){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n                }\n            }\n        } else if (s[l] == ']'){\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '['  ){\n                        str[j] = '\\0';\n                        printf(\"修改后的字符串为:%s\\n\", str);\n                        i--;\n                        break;\n                    } else if (str[j] != '['){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n\n                }\n\n\n            }\n\n        } else if (s[l] == '}'){\n            printf(\"%s\\n\",\"进入\");\n            if(strlen(str) == 0){\n                printf(\"%s\",\"失败\\n\");\n                return false;\n            } else{\n                for (int j = i-1; j >= 0; --j) {\n                    printf(\"i为:%d\\n\", i);\n                    printf(\"j为:%d\\n\", j);\n                    printf(\"str字符串为:%s\\n\", str);\n                    if (str[j] == '{'){\n                        str[j] = '\\0';\n                        i--;\n                        break;\n\n\n                    }else if (str[j] == '{'){\n                        printf(\"%s\",\"失败\");\n                        return false;\n\n                    }\n                    else{\n                        printf(\"%s\",\"失败\");\n                        return false;\n                    }\n                }\n\n            }\n        }\n    }\n    if(strlen(str) == 0){\n        printf(\"%s\",\"成功\\n\");\n        return true;\n    }else{\n        printf(\"zheli%s\",\"失败\\n\");\n        return false;\n    }\n\n}\n\nint main() {\n//    isValid(\"{[]}\");\n    isValid1(\"{[]}\");\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"每日一题-三-7-29\"><a href=\"#每日一题-三-7-29\" class=\"headerlink\" title=\"每日一题(三) 7.29\"></a>每日一题(三) 7.29</h2><h5 id=\"给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效。\"><a href=\"#给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效。\" class=\"headerlink\" title=\"给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。\"></a>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</h5><p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n<h5 id=\"题解思路\"><a href=\"#题解思路\" class=\"headerlink\" title=\"题解思路\"></a>题解思路</h5><p>使用数组做栈，两个指针i和j，分别代表字符串和栈顶+1，先判断是否是({[,如果是进栈，不是则判断栈是否为空，空则返回false；如果栈顶是相对应字符，j—；否则，返回false。<br>最后再判断栈中是否还有元素，没有元素则false，否则true。</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><pre><code class=\"lang-c\">#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;string.h&gt;\nbool isValid1(char * s){\n    int i=0,j=0;\n    char stack[100000];\n\n    while(s[i]!=&#39;\\0&#39;){\n        if((s[i]==&#39;)&#39; || s[i]==&#39;]&#39; || s[i]==&#39;}&#39;) &amp;&amp; j==0){\n            return false;\n        }\n        if(s[i]==&#39;(&#39; || s[i]==&#39;{&#39; || s[i]==&#39;[&#39;){\n            stack[j++] = s[i++];\n        }\n        else{\n            if(s[i]==&#39;)&#39; &amp;&amp; stack[j-1] != &#39;(&#39;){\n                return false;\n            }\n            else if(s[i]==&#39;}&#39;&amp;&amp; stack[j-1] != &#39;{&#39;){\n                return false;\n            }\n            else if(s[i]==&#39;]&#39; &amp;&amp; stack[j-1] != &#39;[&#39;){\n                return false;\n            }\n            i++;\n            j--;\n        }\n    }\n    if(j==0){\n        printf(&quot;chenggong&quot;);\n        return true;\n\n    }else{\n        return false;\n    }\n}\n\nbool isValid(char * s){\n    int i = 0;\n    char str[10000] = {0} ;\n    int len = strlen(s);\n    if(len % 2 != 0){\n        printf(&quot;字符串长度为奇数：%s&quot;,&quot;失败\\n&quot;);\n        return false;\n    } else if (len == 0 ){\n        printf(&quot;字符串长度为0:%s&quot;,&quot;成功\\n&quot;);\n        return true;\n    }\n\n    for(int l = 0; l &lt; strlen(s); l++){\n\n        printf(&quot;%s\\n&quot;,&quot;进入循环&quot;);\n        printf(&quot;第%d次循环\\n&quot;,l+1);\n        if(s[l] == &#39;(&#39;) {\n            printf(&quot;l为:%d\\n&quot;, l);\n            printf(&quot;i为:%d\\n&quot;, i);\n            str[i] = s[l];\n            printf(&quot;s[l]为:%c\\ts为:%s\\n&quot;, s[l],s);\n            printf(&quot;str字符串为:%s\\n&quot;, str);\n            i++;\n//            continue;\n        } else if (s[l] == &#39;[&#39;){\n            printf(&quot;l为:%d\\n&quot;, l);\n            printf(&quot;i为:%d\\n&quot;, i);\n            str[i] = s[l];\n            printf(&quot;str字符串为:%s\\n&quot;, str);\n            i++;\n        } else if (s[l] == &#39;{&#39;){\n            str[i] = s[l];\n            i++;\n        } else if (s[l] == &#39;)&#39;){\n            if(strlen(str) == 0){\n                printf(&quot;%s&quot;,&quot;失败\\n&quot;);\n                return false;\n            } else{\n                for (int j = i-1; j &gt;= 0; --j) {\n                    printf(&quot;i为:%d\\n&quot;, i);\n                    printf(&quot;j为:%d\\n&quot;, j);\n                    printf(&quot;str字符串为:%s\\n&quot;, str);\n                    if (str[j] == &#39;(&#39;){\n\n                        str[j] = &#39;\\0&#39;;\n                        printf(&quot;修改后的字符串为:%s\\n&quot;, str);\n                        i--;\n                        break;\n                    }else if (str[j] != &#39;(&#39;){\n                        printf(&quot;%s&quot;,&quot;失败&quot;);\n                        return false;\n\n                    }\n                    else{\n                        printf(&quot;%s&quot;,&quot;失败&quot;);\n                        return false;\n                    }\n                }\n            }\n        } else if (s[l] == &#39;]&#39;){\n            if(strlen(str) == 0){\n                printf(&quot;%s&quot;,&quot;失败&quot;);\n                return false;\n            } else{\n                for (int j = i-1; j &gt;= 0; --j) {\n                    printf(&quot;i为:%d\\n&quot;, i);\n                    printf(&quot;j为:%d\\n&quot;, j);\n                    printf(&quot;str字符串为:%s\\n&quot;, str);\n                    if (str[j] == &#39;[&#39;  ){\n                        str[j] = &#39;\\0&#39;;\n                        printf(&quot;修改后的字符串为:%s\\n&quot;, str);\n                        i--;\n                        break;\n                    } else if (str[j] != &#39;[&#39;){\n                        printf(&quot;%s&quot;,&quot;失败&quot;);\n                        return false;\n\n                    }\n\n                    else{\n                        printf(&quot;%s&quot;,&quot;失败&quot;);\n                        return false;\n                    }\n\n                }\n\n\n            }\n\n        } else if (s[l] == &#39;}&#39;){\n            printf(&quot;%s\\n&quot;,&quot;进入&quot;);\n            if(strlen(str) == 0){\n                printf(&quot;%s&quot;,&quot;失败\\n&quot;);\n                return false;\n            } else{\n                for (int j = i-1; j &gt;= 0; --j) {\n                    printf(&quot;i为:%d\\n&quot;, i);\n                    printf(&quot;j为:%d\\n&quot;, j);\n                    printf(&quot;str字符串为:%s\\n&quot;, str);\n                    if (str[j] == &#39;{&#39;){\n                        str[j] = &#39;\\0&#39;;\n                        i--;\n                        break;\n\n\n                    }else if (str[j] == &#39;{&#39;){\n                        printf(&quot;%s&quot;,&quot;失败&quot;);\n                        return false;\n\n                    }\n                    else{\n                        printf(&quot;%s&quot;,&quot;失败&quot;);\n                        return false;\n                    }\n                }\n\n            }\n        }\n    }\n    if(strlen(str) == 0){\n        printf(&quot;%s&quot;,&quot;成功\\n&quot;);\n        return true;\n    }else{\n        printf(&quot;zheli%s&quot;,&quot;失败\\n&quot;);\n        return false;\n    }\n\n}\n\nint main() {\n//    isValid(&quot;{[]}&quot;);\n    isValid1(&quot;{[]}&quot;);\n    return 0;\n}\n</code></pre>\n"},{"title":"计网第三章 物理层","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"第三章 物理层","abbrlink":"506b","date":"2020-07-27T08:53:23.000Z","password":null,"_content":"## 第三章 物理层\n\n1. 有线传输介质：双绞线、同轴电缆和光纤\n2. 光纤传播模式\n   - 多模传输：多束光线在芯材中通过不同路径传播\n     \n     - 多模阶跃：芯材的密度从中心到边缘是一致的。在边界上，填充材料密度降低（密度突变）\n     \n     - 多模渐变：芯材的中心密度最大，并向外逐步变小，到边界是最小（密度渐变）\n     \n   - 单模传输\n   \n3. 物理连接\n\n   - DTE数据终端设备：是具有数据处理能力及发送和接收数据信息能力的设备\n\n   - DCE数据电路终接设备：是能够通过网络发送和接收模拟或数字信号形式数据的设备（起到帮助的作用）\n\n   - DTE一般不直接连接网络，它通过一台DCE通信。把DTE和DCE的连接成为DTE-DCE接口\n\n4. **媒介是消息传输的物理通路**\n5. DTE是二进制数字数据源或宿\n6. **HDLC中标志域控制了帧的开始和结束**\n\n7. IEEE802标准讲数据链路层划分为一个上子层和一个下子层，分别为LLC和MAC\n\n","source":"_posts/物理层.md","raw":"---\ntitle: 计网第三章 物理层\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nsummary: 第三章 物理层\nabbrlink: 506b\ndate: 2020-07-27 16:53:23\npassword:\n---\n## 第三章 物理层\n\n1. 有线传输介质：双绞线、同轴电缆和光纤\n2. 光纤传播模式\n   - 多模传输：多束光线在芯材中通过不同路径传播\n     \n     - 多模阶跃：芯材的密度从中心到边缘是一致的。在边界上，填充材料密度降低（密度突变）\n     \n     - 多模渐变：芯材的中心密度最大，并向外逐步变小，到边界是最小（密度渐变）\n     \n   - 单模传输\n   \n3. 物理连接\n\n   - DTE数据终端设备：是具有数据处理能力及发送和接收数据信息能力的设备\n\n   - DCE数据电路终接设备：是能够通过网络发送和接收模拟或数字信号形式数据的设备（起到帮助的作用）\n\n   - DTE一般不直接连接网络，它通过一台DCE通信。把DTE和DCE的连接成为DTE-DCE接口\n\n4. **媒介是消息传输的物理通路**\n5. DTE是二进制数字数据源或宿\n6. **HDLC中标志域控制了帧的开始和结束**\n\n7. IEEE802标准讲数据链路层划分为一个上子层和一个下子层，分别为LLC和MAC\n\n","slug":"物理层","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q630045a09k9r971nk7","content":"<h2 id=\"第三章-物理层\"><a href=\"#第三章-物理层\" class=\"headerlink\" title=\"第三章 物理层\"></a>第三章 物理层</h2><ol>\n<li>有线传输介质：双绞线、同轴电缆和光纤</li>\n<li><p>光纤传播模式</p>\n<ul>\n<li><p>多模传输：多束光线在芯材中通过不同路径传播</p>\n<ul>\n<li><p>多模阶跃：芯材的密度从中心到边缘是一致的。在边界上，填充材料密度降低（密度突变）</p>\n</li>\n<li><p>多模渐变：芯材的中心密度最大，并向外逐步变小，到边界是最小（密度渐变）</p>\n</li>\n</ul>\n</li>\n<li><p>单模传输</p>\n</li>\n</ul>\n</li>\n<li><p>物理连接</p>\n<ul>\n<li><p>DTE数据终端设备：是具有数据处理能力及发送和接收数据信息能力的设备</p>\n</li>\n<li><p>DCE数据电路终接设备：是能够通过网络发送和接收模拟或数字信号形式数据的设备（起到帮助的作用）</p>\n</li>\n<li><p>DTE一般不直接连接网络，它通过一台DCE通信。把DTE和DCE的连接成为DTE-DCE接口</p>\n</li>\n</ul>\n</li>\n<li><p><strong>媒介是消息传输的物理通路</strong></p>\n</li>\n<li>DTE是二进制数字数据源或宿</li>\n<li><p><strong>HDLC中标志域控制了帧的开始和结束</strong></p>\n</li>\n<li><p>IEEE802标准讲数据链路层划分为一个上子层和一个下子层，分别为LLC和MAC</p>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第三章-物理层\"><a href=\"#第三章-物理层\" class=\"headerlink\" title=\"第三章 物理层\"></a>第三章 物理层</h2><ol>\n<li>有线传输介质：双绞线、同轴电缆和光纤</li>\n<li><p>光纤传播模式</p>\n<ul>\n<li><p>多模传输：多束光线在芯材中通过不同路径传播</p>\n<ul>\n<li><p>多模阶跃：芯材的密度从中心到边缘是一致的。在边界上，填充材料密度降低（密度突变）</p>\n</li>\n<li><p>多模渐变：芯材的中心密度最大，并向外逐步变小，到边界是最小（密度渐变）</p>\n</li>\n</ul>\n</li>\n<li><p>单模传输</p>\n</li>\n</ul>\n</li>\n<li><p>物理连接</p>\n<ul>\n<li><p>DTE数据终端设备：是具有数据处理能力及发送和接收数据信息能力的设备</p>\n</li>\n<li><p>DCE数据电路终接设备：是能够通过网络发送和接收模拟或数字信号形式数据的设备（起到帮助的作用）</p>\n</li>\n<li><p>DTE一般不直接连接网络，它通过一台DCE通信。把DTE和DCE的连接成为DTE-DCE接口</p>\n</li>\n</ul>\n</li>\n<li><p><strong>媒介是消息传输的物理通路</strong></p>\n</li>\n<li>DTE是二进制数字数据源或宿</li>\n<li><p><strong>HDLC中标志域控制了帧的开始和结束</strong></p>\n</li>\n<li><p>IEEE802标准讲数据链路层划分为一个上子层和一个下子层，分别为LLC和MAC</p>\n</li>\n</ol>\n"},{"title":"每日一题(四) 8.3","top":false,"cover":false,"toc":false,"mathjax":false,"abbrlink":"dde7","date":"2020-08-03T10:15:07.000Z","password":null,"summary":"中序遍历","_content":"## 每日一题（四） 8.3\n##### 二叉树的中序遍历\n##### 给定一个二叉树，返回他的中序遍历\n\n##### 示例：\n\n```c\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n```\n\n##### 代码：\n\n```c\n一.递归实现 \n    void InOrder(BiTree bt){\n    if(bt==NULL) return; \n    InOrder(bt->lchild); \n    visit(bt->data); \n    InOrder(bt->rchild); \n} \n二.中序遍历非递归实现(利用栈来辅助储存，先出栈，在访问) \nvoid NRInOrder(BiTree bt){ \n\tBiTree Stack[maxsize];//初始化辅助栈 \n    int top = -1;//栈的下标 \n    BiTree p = bt;//用p遍历二叉树 \n    while(p!=NULL||p!=-1){ //p不为空或栈不为空 \n       if(p!=NULL){//左孩子不为空 \n           Stack[++top] = p;//入栈 \n           p = p -> lchild;//往左走 \n        }else{ \n            p = tack[top--];//出栈 \n            visit(p);//访问节点 \n            P->rchild;//往右走 \n        } \n    } \n}\n```\n\n","source":"_posts/每日一题8-3.md","raw":"---\ntitle: 每日一题(四) 8.3\ntop: false\ncover: false\ntoc: false\nmathjax: false\ntags:\n  - 代码\n  - 每日一题\n  - 考研\ncategories:\n  - 每日一题\nabbrlink: dde7\ndate: 2020-08-03 18:15:07\npassword:\nsummary: 中序遍历\n---\n## 每日一题（四） 8.3\n##### 二叉树的中序遍历\n##### 给定一个二叉树，返回他的中序遍历\n\n##### 示例：\n\n```c\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n```\n\n##### 代码：\n\n```c\n一.递归实现 \n    void InOrder(BiTree bt){\n    if(bt==NULL) return; \n    InOrder(bt->lchild); \n    visit(bt->data); \n    InOrder(bt->rchild); \n} \n二.中序遍历非递归实现(利用栈来辅助储存，先出栈，在访问) \nvoid NRInOrder(BiTree bt){ \n\tBiTree Stack[maxsize];//初始化辅助栈 \n    int top = -1;//栈的下标 \n    BiTree p = bt;//用p遍历二叉树 \n    while(p!=NULL||p!=-1){ //p不为空或栈不为空 \n       if(p!=NULL){//左孩子不为空 \n           Stack[++top] = p;//入栈 \n           p = p -> lchild;//往左走 \n        }else{ \n            p = tack[top--];//出栈 \n            visit(p);//访问节点 \n            P->rchild;//往右走 \n        } \n    } \n}\n```\n\n","slug":"每日一题8-3","published":1,"updated":"2020-08-10T10:21:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q630048a09k0wcs9s1n","content":"<h2 id=\"每日一题（四）-8-3\"><a href=\"#每日一题（四）-8-3\" class=\"headerlink\" title=\"每日一题（四） 8.3\"></a>每日一题（四） 8.3</h2><h5 id=\"二叉树的中序遍历\"><a href=\"#二叉树的中序遍历\" class=\"headerlink\" title=\"二叉树的中序遍历\"></a>二叉树的中序遍历</h5><h5 id=\"给定一个二叉树，返回他的中序遍历\"><a href=\"#给定一个二叉树，返回他的中序遍历\" class=\"headerlink\" title=\"给定一个二叉树，返回他的中序遍历\"></a>给定一个二叉树，返回他的中序遍历</h5><h5 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h5><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h5><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">一.递归实现 \n    void InOrder(BiTree bt){\n    if(bt==NULL) return; \n    InOrder(bt->lchild); \n    visit(bt->data); \n    InOrder(bt->rchild); \n} \n二.中序遍历非递归实现(利用栈来辅助储存，先出栈，在访问) \nvoid NRInOrder(BiTree bt){ \n    BiTree Stack[maxsize];//初始化辅助栈 \n    int top = -1;//栈的下标 \n    BiTree p = bt;//用p遍历二叉树 \n    while(p!=NULL||p!=-1){ //p不为空或栈不为空 \n       if(p!=NULL){//左孩子不为空 \n           Stack[++top] = p;//入栈 \n           p = p -> lchild;//往左走 \n        }else{ \n            p = tack[top--];//出栈 \n            visit(p);//访问节点 \n            P->rchild;//往右走 \n        } \n    } \n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"每日一题（四）-8-3\"><a href=\"#每日一题（四）-8-3\" class=\"headerlink\" title=\"每日一题（四） 8.3\"></a>每日一题（四） 8.3</h2><h5 id=\"二叉树的中序遍历\"><a href=\"#二叉树的中序遍历\" class=\"headerlink\" title=\"二叉树的中序遍历\"></a>二叉树的中序遍历</h5><h5 id=\"给定一个二叉树，返回他的中序遍历\"><a href=\"#给定一个二叉树，返回他的中序遍历\" class=\"headerlink\" title=\"给定一个二叉树，返回他的中序遍历\"></a>给定一个二叉树，返回他的中序遍历</h5><h5 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h5><pre><code class=\"lang-c\">输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n</code></pre>\n<h5 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h5><pre><code class=\"lang-c\">一.递归实现 \n    void InOrder(BiTree bt){\n    if(bt==NULL) return; \n    InOrder(bt-&gt;lchild); \n    visit(bt-&gt;data); \n    InOrder(bt-&gt;rchild); \n} \n二.中序遍历非递归实现(利用栈来辅助储存，先出栈，在访问) \nvoid NRInOrder(BiTree bt){ \n    BiTree Stack[maxsize];//初始化辅助栈 \n    int top = -1;//栈的下标 \n    BiTree p = bt;//用p遍历二叉树 \n    while(p!=NULL||p!=-1){ //p不为空或栈不为空 \n       if(p!=NULL){//左孩子不为空 \n           Stack[++top] = p;//入栈 \n           p = p -&gt; lchild;//往左走 \n        }else{ \n            p = tack[top--];//出栈 \n            visit(p);//访问节点 \n            P-&gt;rchild;//往右走 \n        } \n    } \n}\n</code></pre>\n"},{"title":"第一次测试","author":"冷冠男","summary":"摘要测试","top":false,"cover":false,"abbrlink":"e047","date":"2020-05-07T01:25:00.000Z","img":null,"password":null,"_content":"\n## -搭建hexo博客-\n## 初记录 :smile:\n### 捯饬了两天，终于把网站搭建好了，\n使用matery主题<br>制作\n本项目由[冷的小站](https://www.lgn2018.com)支持,更多详细使用方法请在博客上查看<br>\n**本项目开源免费归档前长期维护，请勿用于任何商业用途，否则后果自负！<br>**\n## -技术支持 Support-\n在使用过程中有任何问题可以**提交Issue**（邮件不再回复） ，但是**在此之前** ，请仔细阅读下方**使用步骤** ！<br>\n## -使用步骤-\n* 登录前需要想好自己要选择哪一个座位\n* 具体使用步骤请登录 https://www.lgn2018.com 查看 :smile:  </br>\n\n中心主题\n\t分支主题 1\n\t分支主题 2\n\t分支主题 3\n\n\n","source":"_posts/第一次测试.md","raw":"---\ntitle: 第一次测试\nauthor: 冷冠男\nsummary: 摘要测试\ntop: false\ncover: false\ncategories:\n  - first\ntags:\n  - Typora\n  - Markdown\nabbrlink: e047\ndate: 2020-05-07 09:25:00\nimg:\npassword:\n---\n\n## -搭建hexo博客-\n## 初记录 :smile:\n### 捯饬了两天，终于把网站搭建好了，\n使用matery主题<br>制作\n本项目由[冷的小站](https://www.lgn2018.com)支持,更多详细使用方法请在博客上查看<br>\n**本项目开源免费归档前长期维护，请勿用于任何商业用途，否则后果自负！<br>**\n## -技术支持 Support-\n在使用过程中有任何问题可以**提交Issue**（邮件不再回复） ，但是**在此之前** ，请仔细阅读下方**使用步骤** ！<br>\n## -使用步骤-\n* 登录前需要想好自己要选择哪一个座位\n* 具体使用步骤请登录 https://www.lgn2018.com 查看 :smile:  </br>\n\n中心主题\n\t分支主题 1\n\t分支主题 2\n\t分支主题 3\n\n\n","slug":"第一次测试","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q64004ba09kb4eghhdh","content":"<h2 id=\"搭建hexo博客\"><a href=\"#搭建hexo博客\" class=\"headerlink\" title=\"-搭建hexo博客-\"></a>-搭建hexo博客-</h2><h2 id=\"初记录-smile\"><a href=\"#初记录-smile\" class=\"headerlink\" title=\"初记录 :smile:\"></a>初记录 <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8\">😄</span></h2><h3 id=\"捯饬了两天，终于把网站搭建好了，\"><a href=\"#捯饬了两天，终于把网站搭建好了，\" class=\"headerlink\" title=\"捯饬了两天，终于把网站搭建好了，\"></a>捯饬了两天，终于把网站搭建好了，</h3><p>使用matery主题<br>制作<br>本项目由<a href=\"https://www.lgn2018.com\" target=\"_blank\" rel=\"noopener\">冷的小站</a>支持,更多详细使用方法请在博客上查看<br><br><strong>本项目开源免费归档前长期维护，请勿用于任何商业用途，否则后果自负！<br></strong></p>\n<h2 id=\"技术支持-Support\"><a href=\"#技术支持-Support\" class=\"headerlink\" title=\"-技术支持 Support-\"></a>-技术支持 Support-</h2><p>在使用过程中有任何问题可以<strong>提交Issue</strong>（邮件不再回复） ，但是<strong>在此之前</strong> ，请仔细阅读下方<strong>使用步骤</strong> ！<br></p>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"-使用步骤-\"></a>-使用步骤-</h2><ul>\n<li>登录前需要想好自己要选择哪一个座位</li>\n<li>具体使用步骤请登录 <a href=\"https://www.lgn2018.com\" target=\"_blank\" rel=\"noopener\">https://www.lgn2018.com</a> 查看 <span class=\"github-emoji\" style=\"color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain\" data-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8\">😄</span>  <br></li>\n</ul>\n<p>中心主题<br>    分支主题 1<br>    分支主题 2<br>    分支主题 3</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"搭建hexo博客\"><a href=\"#搭建hexo博客\" class=\"headerlink\" title=\"-搭建hexo博客-\"></a>-搭建hexo博客-</h2><h2 id=\"初记录-smile\"><a href=\"#初记录-smile\" class=\"headerlink\" title=\"初记录 :smile:\"></a>初记录 :smile:</h2><h3 id=\"捯饬了两天，终于把网站搭建好了，\"><a href=\"#捯饬了两天，终于把网站搭建好了，\" class=\"headerlink\" title=\"捯饬了两天，终于把网站搭建好了，\"></a>捯饬了两天，终于把网站搭建好了，</h3><p>使用matery主题<br>制作<br>本项目由<a href=\"https://www.lgn2018.com\" target=\"_blank\" rel=\"noopener\">冷的小站</a>支持,更多详细使用方法请在博客上查看<br><br><strong>本项目开源免费归档前长期维护，请勿用于任何商业用途，否则后果自负！<br></strong></p>\n<h2 id=\"技术支持-Support\"><a href=\"#技术支持-Support\" class=\"headerlink\" title=\"-技术支持 Support-\"></a>-技术支持 Support-</h2><p>在使用过程中有任何问题可以<strong>提交Issue</strong>（邮件不再回复） ，但是<strong>在此之前</strong> ，请仔细阅读下方<strong>使用步骤</strong> ！<br></p>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"-使用步骤-\"></a>-使用步骤-</h2><ul>\n<li>登录前需要想好自己要选择哪一个座位</li>\n<li>具体使用步骤请登录 <a href=\"https://www.lgn2018.com\" target=\"_blank\" rel=\"noopener\">https://www.lgn2018.com</a> 查看 :smile:  &lt;/br&gt;</li>\n</ul>\n<p>中心主题<br>    分支主题 1<br>    分支主题 2<br>    分支主题 3</p>\n"},{"title":"线性表代码","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"f4b7","date":"2020-08-21T12:12:24.000Z","password":null,"summary":"线性表代码整理","_content":"## 线性表代码\n\n> ####  1.顺序表创建\n\n```c\n#define MaxSize 50\ntypedef struct {          //定义线性表的最大长度\n    int data[MaxSize];    //顺序表的元素\n    int length;           //顺序表的当前长度\n}SqList;                  //顺序表类型定义\nSqList L;                 //自行比较整型浮点型等简单数据类型的定义方式\n```\n\n> #### 2.顺序表排序（冒泡排序）\n\n```c\nvoid BubbleSort(SqList &L){                 //因为顺序表L将要改变，所以使用引用型。\n    for(int i = 0; i< L.length-1;i++){      //i指针指向表头，从0开始，直到顺序表长度减一\n        for(int j = L.length-1; j> 1;j--){  //j指针指向表尾，从长度减一开始，直到i指针\n            if(L.data[j-1]> L.data[j]){     //如果前一位比后一位大\n                int temp = L.data[j-1];     //就把前一位存入临时变量temp中\n                L.data[j-1] = L.data[j];    //把j指针的数据赋值给j-1\n                L.data[j] = temp;           //再把临时变量中的数据存入j指针中\n                                            //最终完成从小到大的排序过程\n            }                               //交换数据的三行代码不要省略\n        }\n    }\n}\n```\n\n> #### 3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\n\n```c\nbool ListInsert(SqList &L, int i, int e){ //因为顺序表L将要改变，所以使用引用型。又定义指针i和元素e\n    if(i < 1|| i > L.length + 1)          //验证插入的合法性，只能插入数列的有效位\n        return false;\n    if(L.length >= MaxSize)               //验证顺序表长度是否超过最大限制\n        return false;\n    for(int j = L.length; j >= i; j--)    //从最后一位，一次往后移一位，直到要插入的位置\n        L.data[j] = L.data[j-1];\n    L.data[i-1] = e;                      //把元素e插入第i个位置\n    L.length++;                           //最终顺序表长度加1\n    return true;\n}\n```\n\n> #### 4.将元素e插入到递增的顺序表中，并让其仍然有序\n\n```c\nbool ListInster(SqList &L, int e){         //顺序表L会改变，所以用引用型。定义整型变量元素e\n    int i = 0;                             //初始化指针i，指向顺序表头部\n    while(L.data[i] < e && i < L.length){  //从头开始判断顺序表元素与元素e的大小关系，如果指针没有超过\n                                           //顺序表长度并且指针所指元素小于元素e\n        i++;                               //那么指针i向后移一位\n    }\n    for(int j = L.length; j > 1; j--){     //定义指针j指向顺序表元素+1的位置，直到i指针的位置停止\n        L.data[j] = L.data[j-1];           //依次向后移动\n    }\n    L.data[i] = e;                         //元素e插入到指针i的位置\n    L.length++;                            //顺序表长度加一\n    return true;\n}\n```\n\n> #### 5.顺序表删除\n\n- 删除顺序表L中第`i(1≤i≤L.length)`个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。（这是删除某一位置的元素）\n\n  ```c\n  bool ListDelete(SqList &L, int i, int &e){  //顺序表L会发生改变，所以使用引用型\n      if(i < 1 || i > L.length){              //判断i位置是否合法\n          return false;\n      }\n      e = L.data[i-1];                        //把要删除的元素赋值给变量e\n      for(int j = i; j < L.length, j++){\n          L.data[j-1] = L.data[j];            //依次补齐空缺，后一位往前移一位\n      }\n      L.length--;                             //顺序表长度减一\n      return true;\n  }\n  ```\n\n- 删除顺序表L中值为X的元素（这是删除某一值的方式）\n\n  ```c\n  bool ListDelete(SqList &L, int X){\n      int count = 0;                       //记录有多少个值为X的元素（有可能有相同的元素）\n      for(int i = 0; i < L.length; i++){   //从头到尾一次匹配看是否存在元素X\n          if(L.data[i] == x){\n              count++;                     //有的话计数器就加一\n          }else{\n              L.data[i-count] = L.data[i]; //没有的话就将后一位依次向前移动，直到再次匹配到或退出\n          }\n      }\n      L.length = L.length - count;         //更新顺序表长度\n  }\n  ```\n\n- 删除顺序表L中所有素数\n\n  ```c\n  bool Prime(int num){                     //求素数\n      for(int i = 2; i < num; i++){\n          if(num % 2 == 0){\n              return false;\n          }\n      }\n      return true;\n  }\n  void ListDelete(SqList &L, int x){\n      int count = 0;                       //计数器\n      for(int i = 0; i < L.length; i++){   //从头到尾依次查找\n          if(Prime(num)){                  //如果是素数，计数器加一\t\t\n              count++;\n          }else{\n              L.data[i-count] = L.data[i]; //如果没有，则补齐空缺位置\n          }\n      }\n      L.length = L.length - count;         //更新顺序表长度\n  }\n  ```\n\n- 删除顺序表L中最大值（最小值，此处注意与删除奇偶数的区别）\n\n  ```c\n  void ListDelete(SqList &L, int x){\n      int pos = 0;                              //记录最大值所在位置\n      int max = L.data[0];                      //从头开始扫描，把最大的值存入max中\n      for(int i = 1; i < L.length; i++){\n          if(max < L.data[i]){                  //如果max中的值小于后面的元素\n              pos = i;                          //存储最大值的位置\n              max = L.data[i];                  //就把比max大的那个值赋予给max\n          }\n      }\n      fot(int j = pos + 1; j < L.length; i++){  //依次把最大值的后一位往前移动，补全空缺\n          L.data[j-1] = L.data[j];                \n          L.length--;                           //长度减一\n      }\n  }\n  ```\n\n- 删除**顺序表**L中重复的值（**表已经有序**）\n\n  ```c\n  void ListDelete(SqList &L){\n      int count = 0;                          //计数器count\n      int num = L.data[0];                    //从第一个数开始比较是否有相同的值\n      for(int i = 1; i < L.length; i++){      //从头到尾依次扫描\n          if(L.data[i] == num){               //如果之后有值与num相等\n              count++;                        //计数器加一\n          }else{\n              num = L.data[i];                //否则，更新num的值\n              L.data[i - count] = L.data[i];  //并更新顺序表\n          }\n      }\n      L.length = L.length - count;\n  }\n  ```\n\n- 逆置：将顺序表L中的所有元素逆置过来\n\n  ```c\n  void Inversion(SqList &L){\n      int low = 0, high = L.length - 1;  //分别两个指针指向首尾\n      while(low < high){\n          int temp = L.data[low];        //把第一个元素赋值给临时变量temp\n          L.data[low] = L.data[high];    //把high的值赋予low\n          L.data[high] = temp;           //在把temp中的值赋予给high\n          low++;                         //完成一次交换，然后依次交换           \n          high--;\n      }\n  }\n  ```\n\n- 平台：找出顺序表中最大的平台值（**什么是平台值？**）\n\n  ---------------------------------\n\n- 顺序表合并：将两个升序顺序表合并为一个升序的顺序表\n\n  > i++   先执行i=0 再进行i=i+1,也就是i会是0,执行完了再变为1\n  > ++i   先执行i=i+1,i会是1\n\n  ```c\n  SqList Merge(Sqlist L1, Sqlist L2){\n      Sqlist L3;\n      int i = 0, j = 0, k = 0;\n      while(i < L1.length && j < L2.length){  //L1和L2长度要大于0\n          if(L1.data[i] < L2.data[j]){        //如果L1的一位比L2的一位小\n              L3.data[k++] = L1.data[i++];    //就把L1的一位放入L3中，并且i和k自增1\n          }else{                              //如果L1的一位比L2的一位大\n              L3.data[k++] = L2.data[j++];    //就把L2的一位放入L3中，并且j和k自增1\n          }\n      }                                       //当其中一个被放完时，再单独对另一个顺序表操作即可\n      while(i < L1.length){\n          L3.data[k++] = L1.data[i++];\n      }\n      while(i < L2.length){\n          L3.data[k++] = L2.data[j++];\n      }\n      L3.length = k;\n      return L3;\n  }\n  ```\n\n- 将两个升序顺序表合并为一个升序的顺序表**（只求∩交集）**\n\n  ```c\n  SqList Merge(Sqlist L1, Sqlist L2){\n      Sqlist L3;\n      int i = 0, j = 0, k = 0;\n      while(i < L1.length && j < L2.length){  //L1和L2长度要大于0\n          if(L1.data[i] < L2.data[j]){        //如果L1的一位比L2的一位小\n              i++;                            //i++\n          }else if(L1.data[i] > L2.data[j]){  //如果L1的一位比L2的一位大\n              j++;                            //j++\n          }else{\n              L3.data[k++] = L1.data[i++];    //如果L1的一位和L2的一位相等，则放入L3中\n              j++;                            //j++\n          }\n      }                                       \n      L3.length = k;\n      return L3;\n  }\n  ```\n\n- 将两个升序顺序表合并为一个升序的顺序表**（∪并集，没有重复元素）**\n\n  ```c\n  SqList Merge(Sqlist L1, Sqlist L2){\n      Sqlist L3;\n      int i = 0, j = 0, k = 0;\n      while(i < L1.length && j < L2.length){    //L1和L2长度要大于0\n          if(L1.data[i] < L2.data[j]){          //如果L1的一位比L2的一位小\n              L3.length[k++] = L2.length[i++];  //把L1放入L3，并且i和k自增\n          }else if(L1.data[i] > L2.data[j]){    //如果L1的一位比L2的一位大\n              L3.length[k++] = L2.length[j++];  //把L2放入L3，并且j和k自增\n          }else{\n              L3.data[k++] = L1.data[i++];      //如果L1的一位和L2的一位相等，则把L1放入L3中\n              j++;                              //j++\n          }\n      }                                         //当其中一个被放完时，再单独对另一个顺序表操作即可\n      while(i < L1.length){\n          L3.data[k++] = L1.data[i++];\n      }\n      while(i < L2.length){\n          L3.data[k++] = L2.data[j++];\n      }\n      L3.length = k;\n      return L3;\n  }\n  ```\n  \n\n","source":"_posts/线性表代码.md","raw":"---\ntitle: 线性表代码\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\n  - 线性表\ncategories:\n  - 代码\nabbrlink: f4b7\ndate: 2020-08-21 20:12:24\npassword:\nsummary: 线性表代码整理\n---\n## 线性表代码\n\n> ####  1.顺序表创建\n\n```c\n#define MaxSize 50\ntypedef struct {          //定义线性表的最大长度\n    int data[MaxSize];    //顺序表的元素\n    int length;           //顺序表的当前长度\n}SqList;                  //顺序表类型定义\nSqList L;                 //自行比较整型浮点型等简单数据类型的定义方式\n```\n\n> #### 2.顺序表排序（冒泡排序）\n\n```c\nvoid BubbleSort(SqList &L){                 //因为顺序表L将要改变，所以使用引用型。\n    for(int i = 0; i< L.length-1;i++){      //i指针指向表头，从0开始，直到顺序表长度减一\n        for(int j = L.length-1; j> 1;j--){  //j指针指向表尾，从长度减一开始，直到i指针\n            if(L.data[j-1]> L.data[j]){     //如果前一位比后一位大\n                int temp = L.data[j-1];     //就把前一位存入临时变量temp中\n                L.data[j-1] = L.data[j];    //把j指针的数据赋值给j-1\n                L.data[j] = temp;           //再把临时变量中的数据存入j指针中\n                                            //最终完成从小到大的排序过程\n            }                               //交换数据的三行代码不要省略\n        }\n    }\n}\n```\n\n> #### 3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\n\n```c\nbool ListInsert(SqList &L, int i, int e){ //因为顺序表L将要改变，所以使用引用型。又定义指针i和元素e\n    if(i < 1|| i > L.length + 1)          //验证插入的合法性，只能插入数列的有效位\n        return false;\n    if(L.length >= MaxSize)               //验证顺序表长度是否超过最大限制\n        return false;\n    for(int j = L.length; j >= i; j--)    //从最后一位，一次往后移一位，直到要插入的位置\n        L.data[j] = L.data[j-1];\n    L.data[i-1] = e;                      //把元素e插入第i个位置\n    L.length++;                           //最终顺序表长度加1\n    return true;\n}\n```\n\n> #### 4.将元素e插入到递增的顺序表中，并让其仍然有序\n\n```c\nbool ListInster(SqList &L, int e){         //顺序表L会改变，所以用引用型。定义整型变量元素e\n    int i = 0;                             //初始化指针i，指向顺序表头部\n    while(L.data[i] < e && i < L.length){  //从头开始判断顺序表元素与元素e的大小关系，如果指针没有超过\n                                           //顺序表长度并且指针所指元素小于元素e\n        i++;                               //那么指针i向后移一位\n    }\n    for(int j = L.length; j > 1; j--){     //定义指针j指向顺序表元素+1的位置，直到i指针的位置停止\n        L.data[j] = L.data[j-1];           //依次向后移动\n    }\n    L.data[i] = e;                         //元素e插入到指针i的位置\n    L.length++;                            //顺序表长度加一\n    return true;\n}\n```\n\n> #### 5.顺序表删除\n\n- 删除顺序表L中第`i(1≤i≤L.length)`个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。（这是删除某一位置的元素）\n\n  ```c\n  bool ListDelete(SqList &L, int i, int &e){  //顺序表L会发生改变，所以使用引用型\n      if(i < 1 || i > L.length){              //判断i位置是否合法\n          return false;\n      }\n      e = L.data[i-1];                        //把要删除的元素赋值给变量e\n      for(int j = i; j < L.length, j++){\n          L.data[j-1] = L.data[j];            //依次补齐空缺，后一位往前移一位\n      }\n      L.length--;                             //顺序表长度减一\n      return true;\n  }\n  ```\n\n- 删除顺序表L中值为X的元素（这是删除某一值的方式）\n\n  ```c\n  bool ListDelete(SqList &L, int X){\n      int count = 0;                       //记录有多少个值为X的元素（有可能有相同的元素）\n      for(int i = 0; i < L.length; i++){   //从头到尾一次匹配看是否存在元素X\n          if(L.data[i] == x){\n              count++;                     //有的话计数器就加一\n          }else{\n              L.data[i-count] = L.data[i]; //没有的话就将后一位依次向前移动，直到再次匹配到或退出\n          }\n      }\n      L.length = L.length - count;         //更新顺序表长度\n  }\n  ```\n\n- 删除顺序表L中所有素数\n\n  ```c\n  bool Prime(int num){                     //求素数\n      for(int i = 2; i < num; i++){\n          if(num % 2 == 0){\n              return false;\n          }\n      }\n      return true;\n  }\n  void ListDelete(SqList &L, int x){\n      int count = 0;                       //计数器\n      for(int i = 0; i < L.length; i++){   //从头到尾依次查找\n          if(Prime(num)){                  //如果是素数，计数器加一\t\t\n              count++;\n          }else{\n              L.data[i-count] = L.data[i]; //如果没有，则补齐空缺位置\n          }\n      }\n      L.length = L.length - count;         //更新顺序表长度\n  }\n  ```\n\n- 删除顺序表L中最大值（最小值，此处注意与删除奇偶数的区别）\n\n  ```c\n  void ListDelete(SqList &L, int x){\n      int pos = 0;                              //记录最大值所在位置\n      int max = L.data[0];                      //从头开始扫描，把最大的值存入max中\n      for(int i = 1; i < L.length; i++){\n          if(max < L.data[i]){                  //如果max中的值小于后面的元素\n              pos = i;                          //存储最大值的位置\n              max = L.data[i];                  //就把比max大的那个值赋予给max\n          }\n      }\n      fot(int j = pos + 1; j < L.length; i++){  //依次把最大值的后一位往前移动，补全空缺\n          L.data[j-1] = L.data[j];                \n          L.length--;                           //长度减一\n      }\n  }\n  ```\n\n- 删除**顺序表**L中重复的值（**表已经有序**）\n\n  ```c\n  void ListDelete(SqList &L){\n      int count = 0;                          //计数器count\n      int num = L.data[0];                    //从第一个数开始比较是否有相同的值\n      for(int i = 1; i < L.length; i++){      //从头到尾依次扫描\n          if(L.data[i] == num){               //如果之后有值与num相等\n              count++;                        //计数器加一\n          }else{\n              num = L.data[i];                //否则，更新num的值\n              L.data[i - count] = L.data[i];  //并更新顺序表\n          }\n      }\n      L.length = L.length - count;\n  }\n  ```\n\n- 逆置：将顺序表L中的所有元素逆置过来\n\n  ```c\n  void Inversion(SqList &L){\n      int low = 0, high = L.length - 1;  //分别两个指针指向首尾\n      while(low < high){\n          int temp = L.data[low];        //把第一个元素赋值给临时变量temp\n          L.data[low] = L.data[high];    //把high的值赋予low\n          L.data[high] = temp;           //在把temp中的值赋予给high\n          low++;                         //完成一次交换，然后依次交换           \n          high--;\n      }\n  }\n  ```\n\n- 平台：找出顺序表中最大的平台值（**什么是平台值？**）\n\n  ---------------------------------\n\n- 顺序表合并：将两个升序顺序表合并为一个升序的顺序表\n\n  > i++   先执行i=0 再进行i=i+1,也就是i会是0,执行完了再变为1\n  > ++i   先执行i=i+1,i会是1\n\n  ```c\n  SqList Merge(Sqlist L1, Sqlist L2){\n      Sqlist L3;\n      int i = 0, j = 0, k = 0;\n      while(i < L1.length && j < L2.length){  //L1和L2长度要大于0\n          if(L1.data[i] < L2.data[j]){        //如果L1的一位比L2的一位小\n              L3.data[k++] = L1.data[i++];    //就把L1的一位放入L3中，并且i和k自增1\n          }else{                              //如果L1的一位比L2的一位大\n              L3.data[k++] = L2.data[j++];    //就把L2的一位放入L3中，并且j和k自增1\n          }\n      }                                       //当其中一个被放完时，再单独对另一个顺序表操作即可\n      while(i < L1.length){\n          L3.data[k++] = L1.data[i++];\n      }\n      while(i < L2.length){\n          L3.data[k++] = L2.data[j++];\n      }\n      L3.length = k;\n      return L3;\n  }\n  ```\n\n- 将两个升序顺序表合并为一个升序的顺序表**（只求∩交集）**\n\n  ```c\n  SqList Merge(Sqlist L1, Sqlist L2){\n      Sqlist L3;\n      int i = 0, j = 0, k = 0;\n      while(i < L1.length && j < L2.length){  //L1和L2长度要大于0\n          if(L1.data[i] < L2.data[j]){        //如果L1的一位比L2的一位小\n              i++;                            //i++\n          }else if(L1.data[i] > L2.data[j]){  //如果L1的一位比L2的一位大\n              j++;                            //j++\n          }else{\n              L3.data[k++] = L1.data[i++];    //如果L1的一位和L2的一位相等，则放入L3中\n              j++;                            //j++\n          }\n      }                                       \n      L3.length = k;\n      return L3;\n  }\n  ```\n\n- 将两个升序顺序表合并为一个升序的顺序表**（∪并集，没有重复元素）**\n\n  ```c\n  SqList Merge(Sqlist L1, Sqlist L2){\n      Sqlist L3;\n      int i = 0, j = 0, k = 0;\n      while(i < L1.length && j < L2.length){    //L1和L2长度要大于0\n          if(L1.data[i] < L2.data[j]){          //如果L1的一位比L2的一位小\n              L3.length[k++] = L2.length[i++];  //把L1放入L3，并且i和k自增\n          }else if(L1.data[i] > L2.data[j]){    //如果L1的一位比L2的一位大\n              L3.length[k++] = L2.length[j++];  //把L2放入L3，并且j和k自增\n          }else{\n              L3.data[k++] = L1.data[i++];      //如果L1的一位和L2的一位相等，则把L1放入L3中\n              j++;                              //j++\n          }\n      }                                         //当其中一个被放完时，再单独对另一个顺序表操作即可\n      while(i < L1.length){\n          L3.data[k++] = L1.data[i++];\n      }\n      while(i < L2.length){\n          L3.data[k++] = L2.data[j++];\n      }\n      L3.length = k;\n      return L3;\n  }\n  ```\n  \n\n","slug":"线性表代码","published":1,"updated":"2020-08-25T09:25:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q64004ea09k6qs4c7d6","content":"<h2 id=\"线性表代码\"><a href=\"#线性表代码\" class=\"headerlink\" title=\"线性表代码\"></a>线性表代码</h2><blockquote>\n<h4 id=\"1-顺序表创建\"><a href=\"#1-顺序表创建\" class=\"headerlink\" title=\"1.顺序表创建\"></a>1.顺序表创建</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#define MaxSize 50\ntypedef struct {          //定义线性表的最大长度\n    int data[MaxSize];    //顺序表的元素\n    int length;           //顺序表的当前长度\n}SqList;                  //顺序表类型定义\nSqList L;                 //自行比较整型浮点型等简单数据类型的定义方式\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"2-顺序表排序（冒泡排序）\"><a href=\"#2-顺序表排序（冒泡排序）\" class=\"headerlink\" title=\"2.顺序表排序（冒泡排序）\"></a>2.顺序表排序（冒泡排序）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void BubbleSort(SqList &L){                 //因为顺序表L将要改变，所以使用引用型。\n    for(int i = 0; i< L.length-1;i++){      //i指针指向表头，从0开始，直到顺序表长度减一\n        for(int j = L.length-1; j> 1;j--){  //j指针指向表尾，从长度减一开始，直到i指针\n            if(L.data[j-1]> L.data[j]){     //如果前一位比后一位大\n                int temp = L.data[j-1];     //就把前一位存入临时变量temp中\n                L.data[j-1] = L.data[j];    //把j指针的数据赋值给j-1\n                L.data[j] = temp;           //再把临时变量中的数据存入j指针中\n                                            //最终完成从小到大的排序过程\n            }                               //交换数据的三行代码不要省略\n        }\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"3-顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\"><a href=\"#3-顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\" class=\"headerlink\" title=\"3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\"></a>3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool ListInsert(SqList &L, int i, int e){ //因为顺序表L将要改变，所以使用引用型。又定义指针i和元素e\n    if(i < 1|| i > L.length + 1)          //验证插入的合法性，只能插入数列的有效位\n        return false;\n    if(L.length >= MaxSize)               //验证顺序表长度是否超过最大限制\n        return false;\n    for(int j = L.length; j >= i; j--)    //从最后一位，一次往后移一位，直到要插入的位置\n        L.data[j] = L.data[j-1];\n    L.data[i-1] = e;                      //把元素e插入第i个位置\n    L.length++;                           //最终顺序表长度加1\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"4-将元素e插入到递增的顺序表中，并让其仍然有序\"><a href=\"#4-将元素e插入到递增的顺序表中，并让其仍然有序\" class=\"headerlink\" title=\"4.将元素e插入到递增的顺序表中，并让其仍然有序\"></a>4.将元素e插入到递增的顺序表中，并让其仍然有序</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool ListInster(SqList &L, int e){         //顺序表L会改变，所以用引用型。定义整型变量元素e\n    int i = 0;                             //初始化指针i，指向顺序表头部\n    while(L.data[i] < e && i < L.length){  //从头开始判断顺序表元素与元素e的大小关系，如果指针没有超过\n                                           //顺序表长度并且指针所指元素小于元素e\n        i++;                               //那么指针i向后移一位\n    }\n    for(int j = L.length; j > 1; j--){     //定义指针j指向顺序表元素+1的位置，直到i指针的位置停止\n        L.data[j] = L.data[j-1];           //依次向后移动\n    }\n    L.data[i] = e;                         //元素e插入到指针i的位置\n    L.length++;                            //顺序表长度加一\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"5-顺序表删除\"><a href=\"#5-顺序表删除\" class=\"headerlink\" title=\"5.顺序表删除\"></a>5.顺序表删除</h4></blockquote>\n<ul>\n<li><p>删除顺序表L中第<code>i(1≤i≤L.length)</code>个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。（这是删除某一位置的元素）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool ListDelete(SqList &L, int i, int &e){  //顺序表L会发生改变，所以使用引用型\n    if(i < 1 || i > L.length){              //判断i位置是否合法\n        return false;\n    }\n    e = L.data[i-1];                        //把要删除的元素赋值给变量e\n    for(int j = i; j < L.length, j++){\n        L.data[j-1] = L.data[j];            //依次补齐空缺，后一位往前移一位\n    }\n    L.length--;                             //顺序表长度减一\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除顺序表L中值为X的元素（这是删除某一值的方式）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool ListDelete(SqList &L, int X){\n    int count = 0;                       //记录有多少个值为X的元素（有可能有相同的元素）\n    for(int i = 0; i < L.length; i++){   //从头到尾一次匹配看是否存在元素X\n        if(L.data[i] == x){\n            count++;                     //有的话计数器就加一\n        }else{\n            L.data[i-count] = L.data[i]; //没有的话就将后一位依次向前移动，直到再次匹配到或退出\n        }\n    }\n    L.length = L.length - count;         //更新顺序表长度\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除顺序表L中所有素数</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool Prime(int num){                     //求素数\n    for(int i = 2; i < num; i++){\n        if(num % 2 == 0){\n            return false;\n        }\n    }\n    return true;\n}\nvoid ListDelete(SqList &L, int x){\n    int count = 0;                       //计数器\n    for(int i = 0; i < L.length; i++){   //从头到尾依次查找\n        if(Prime(num)){                  //如果是素数，计数器加一        \n            count++;\n        }else{\n            L.data[i-count] = L.data[i]; //如果没有，则补齐空缺位置\n        }\n    }\n    L.length = L.length - count;         //更新顺序表长度\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除顺序表L中最大值（最小值，此处注意与删除奇偶数的区别）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void ListDelete(SqList &L, int x){\n    int pos = 0;                              //记录最大值所在位置\n    int max = L.data[0];                      //从头开始扫描，把最大的值存入max中\n    for(int i = 1; i < L.length; i++){\n        if(max < L.data[i]){                  //如果max中的值小于后面的元素\n            pos = i;                          //存储最大值的位置\n            max = L.data[i];                  //就把比max大的那个值赋予给max\n        }\n    }\n    fot(int j = pos + 1; j < L.length; i++){  //依次把最大值的后一位往前移动，补全空缺\n        L.data[j-1] = L.data[j];                \n        L.length--;                           //长度减一\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除<strong>顺序表</strong>L中重复的值（<strong>表已经有序</strong>）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void ListDelete(SqList &L){\n    int count = 0;                          //计数器count\n    int num = L.data[0];                    //从第一个数开始比较是否有相同的值\n    for(int i = 1; i < L.length; i++){      //从头到尾依次扫描\n        if(L.data[i] == num){               //如果之后有值与num相等\n            count++;                        //计数器加一\n        }else{\n            num = L.data[i];                //否则，更新num的值\n            L.data[i - count] = L.data[i];  //并更新顺序表\n        }\n    }\n    L.length = L.length - count;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逆置：将顺序表L中的所有元素逆置过来</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void Inversion(SqList &L){\n    int low = 0, high = L.length - 1;  //分别两个指针指向首尾\n    while(low < high){\n        int temp = L.data[low];        //把第一个元素赋值给临时变量temp\n        L.data[low] = L.data[high];    //把high的值赋予low\n        L.data[high] = temp;           //在把temp中的值赋予给high\n        low++;                         //完成一次交换，然后依次交换           \n        high--;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>平台：找出顺序表中最大的平台值（<strong>什么是平台值？</strong>）</p>\n<hr>\n</li>\n<li><p>顺序表合并：将两个升序顺序表合并为一个升序的顺序表</p>\n<blockquote>\n<p>i++   先执行i=0 再进行i=i+1,也就是i会是0,执行完了再变为1<br>++i   先执行i=i+1,i会是1</p>\n</blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">SqList Merge(Sqlist L1, Sqlist L2){\n    Sqlist L3;\n    int i = 0, j = 0, k = 0;\n    while(i < L1.length && j < L2.length){  //L1和L2长度要大于0\n        if(L1.data[i] < L2.data[j]){        //如果L1的一位比L2的一位小\n            L3.data[k++] = L1.data[i++];    //就把L1的一位放入L3中，并且i和k自增1\n        }else{                              //如果L1的一位比L2的一位大\n            L3.data[k++] = L2.data[j++];    //就把L2的一位放入L3中，并且j和k自增1\n        }\n    }                                       //当其中一个被放完时，再单独对另一个顺序表操作即可\n    while(i < L1.length){\n        L3.data[k++] = L1.data[i++];\n    }\n    while(i < L2.length){\n        L3.data[k++] = L2.data[j++];\n    }\n    L3.length = k;\n    return L3;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将两个升序顺序表合并为一个升序的顺序表<strong>（只求∩交集）</strong></p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">SqList Merge(Sqlist L1, Sqlist L2){\n    Sqlist L3;\n    int i = 0, j = 0, k = 0;\n    while(i < L1.length && j < L2.length){  //L1和L2长度要大于0\n        if(L1.data[i] < L2.data[j]){        //如果L1的一位比L2的一位小\n            i++;                            //i++\n        }else if(L1.data[i] > L2.data[j]){  //如果L1的一位比L2的一位大\n            j++;                            //j++\n        }else{\n            L3.data[k++] = L1.data[i++];    //如果L1的一位和L2的一位相等，则放入L3中\n            j++;                            //j++\n        }\n    }                                       \n    L3.length = k;\n    return L3;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将两个升序顺序表合并为一个升序的顺序表<strong>（∪并集，没有重复元素）</strong></p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">SqList Merge(Sqlist L1, Sqlist L2){\n    Sqlist L3;\n    int i = 0, j = 0, k = 0;\n    while(i < L1.length && j < L2.length){    //L1和L2长度要大于0\n        if(L1.data[i] < L2.data[j]){          //如果L1的一位比L2的一位小\n            L3.length[k++] = L2.length[i++];  //把L1放入L3，并且i和k自增\n        }else if(L1.data[i] > L2.data[j]){    //如果L1的一位比L2的一位大\n            L3.length[k++] = L2.length[j++];  //把L2放入L3，并且j和k自增\n        }else{\n            L3.data[k++] = L1.data[i++];      //如果L1的一位和L2的一位相等，则把L1放入L3中\n            j++;                              //j++\n        }\n    }                                         //当其中一个被放完时，再单独对另一个顺序表操作即可\n    while(i < L1.length){\n        L3.data[k++] = L1.data[i++];\n    }\n    while(i < L2.length){\n        L3.data[k++] = L2.data[j++];\n    }\n    L3.length = k;\n    return L3;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"线性表代码\"><a href=\"#线性表代码\" class=\"headerlink\" title=\"线性表代码\"></a>线性表代码</h2><blockquote>\n<h4 id=\"1-顺序表创建\"><a href=\"#1-顺序表创建\" class=\"headerlink\" title=\"1.顺序表创建\"></a>1.顺序表创建</h4></blockquote>\n<pre><code class=\"lang-c\">#define MaxSize 50\ntypedef struct {          //定义线性表的最大长度\n    int data[MaxSize];    //顺序表的元素\n    int length;           //顺序表的当前长度\n}SqList;                  //顺序表类型定义\nSqList L;                 //自行比较整型浮点型等简单数据类型的定义方式\n</code></pre>\n<blockquote>\n<h4 id=\"2-顺序表排序（冒泡排序）\"><a href=\"#2-顺序表排序（冒泡排序）\" class=\"headerlink\" title=\"2.顺序表排序（冒泡排序）\"></a>2.顺序表排序（冒泡排序）</h4></blockquote>\n<pre><code class=\"lang-c\">void BubbleSort(SqList &amp;L){                 //因为顺序表L将要改变，所以使用引用型。\n    for(int i = 0; i&lt; L.length-1;i++){      //i指针指向表头，从0开始，直到顺序表长度减一\n        for(int j = L.length-1; j&gt; 1;j--){  //j指针指向表尾，从长度减一开始，直到i指针\n            if(L.data[j-1]&gt; L.data[j]){     //如果前一位比后一位大\n                int temp = L.data[j-1];     //就把前一位存入临时变量temp中\n                L.data[j-1] = L.data[j];    //把j指针的数据赋值给j-1\n                L.data[j] = temp;           //再把临时变量中的数据存入j指针中\n                                            //最终完成从小到大的排序过程\n            }                               //交换数据的三行代码不要省略\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"3-顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\"><a href=\"#3-顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\" class=\"headerlink\" title=\"3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置\"></a>3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置</h4></blockquote>\n<pre><code class=\"lang-c\">bool ListInsert(SqList &amp;L, int i, int e){ //因为顺序表L将要改变，所以使用引用型。又定义指针i和元素e\n    if(i &lt; 1|| i &gt; L.length + 1)          //验证插入的合法性，只能插入数列的有效位\n        return false;\n    if(L.length &gt;= MaxSize)               //验证顺序表长度是否超过最大限制\n        return false;\n    for(int j = L.length; j &gt;= i; j--)    //从最后一位，一次往后移一位，直到要插入的位置\n        L.data[j] = L.data[j-1];\n    L.data[i-1] = e;                      //把元素e插入第i个位置\n    L.length++;                           //最终顺序表长度加1\n    return true;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"4-将元素e插入到递增的顺序表中，并让其仍然有序\"><a href=\"#4-将元素e插入到递增的顺序表中，并让其仍然有序\" class=\"headerlink\" title=\"4.将元素e插入到递增的顺序表中，并让其仍然有序\"></a>4.将元素e插入到递增的顺序表中，并让其仍然有序</h4></blockquote>\n<pre><code class=\"lang-c\">bool ListInster(SqList &amp;L, int e){         //顺序表L会改变，所以用引用型。定义整型变量元素e\n    int i = 0;                             //初始化指针i，指向顺序表头部\n    while(L.data[i] &lt; e &amp;&amp; i &lt; L.length){  //从头开始判断顺序表元素与元素e的大小关系，如果指针没有超过\n                                           //顺序表长度并且指针所指元素小于元素e\n        i++;                               //那么指针i向后移一位\n    }\n    for(int j = L.length; j &gt; 1; j--){     //定义指针j指向顺序表元素+1的位置，直到i指针的位置停止\n        L.data[j] = L.data[j-1];           //依次向后移动\n    }\n    L.data[i] = e;                         //元素e插入到指针i的位置\n    L.length++;                            //顺序表长度加一\n    return true;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"5-顺序表删除\"><a href=\"#5-顺序表删除\" class=\"headerlink\" title=\"5.顺序表删除\"></a>5.顺序表删除</h4></blockquote>\n<ul>\n<li><p>删除顺序表L中第<code>i(1≤i≤L.length)</code>个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。（这是删除某一位置的元素）</p>\n<pre><code class=\"lang-c\">bool ListDelete(SqList &amp;L, int i, int &amp;e){  //顺序表L会发生改变，所以使用引用型\n    if(i &lt; 1 || i &gt; L.length){              //判断i位置是否合法\n        return false;\n    }\n    e = L.data[i-1];                        //把要删除的元素赋值给变量e\n    for(int j = i; j &lt; L.length, j++){\n        L.data[j-1] = L.data[j];            //依次补齐空缺，后一位往前移一位\n    }\n    L.length--;                             //顺序表长度减一\n    return true;\n}\n</code></pre>\n</li>\n<li><p>删除顺序表L中值为X的元素（这是删除某一值的方式）</p>\n<pre><code class=\"lang-c\">bool ListDelete(SqList &amp;L, int X){\n    int count = 0;                       //记录有多少个值为X的元素（有可能有相同的元素）\n    for(int i = 0; i &lt; L.length; i++){   //从头到尾一次匹配看是否存在元素X\n        if(L.data[i] == x){\n            count++;                     //有的话计数器就加一\n        }else{\n            L.data[i-count] = L.data[i]; //没有的话就将后一位依次向前移动，直到再次匹配到或退出\n        }\n    }\n    L.length = L.length - count;         //更新顺序表长度\n}\n</code></pre>\n</li>\n<li><p>删除顺序表L中所有素数</p>\n<pre><code class=\"lang-c\">bool Prime(int num){                     //求素数\n    for(int i = 2; i &lt; num; i++){\n        if(num % 2 == 0){\n            return false;\n        }\n    }\n    return true;\n}\nvoid ListDelete(SqList &amp;L, int x){\n    int count = 0;                       //计数器\n    for(int i = 0; i &lt; L.length; i++){   //从头到尾依次查找\n        if(Prime(num)){                  //如果是素数，计数器加一        \n            count++;\n        }else{\n            L.data[i-count] = L.data[i]; //如果没有，则补齐空缺位置\n        }\n    }\n    L.length = L.length - count;         //更新顺序表长度\n}\n</code></pre>\n</li>\n<li><p>删除顺序表L中最大值（最小值，此处注意与删除奇偶数的区别）</p>\n<pre><code class=\"lang-c\">void ListDelete(SqList &amp;L, int x){\n    int pos = 0;                              //记录最大值所在位置\n    int max = L.data[0];                      //从头开始扫描，把最大的值存入max中\n    for(int i = 1; i &lt; L.length; i++){\n        if(max &lt; L.data[i]){                  //如果max中的值小于后面的元素\n            pos = i;                          //存储最大值的位置\n            max = L.data[i];                  //就把比max大的那个值赋予给max\n        }\n    }\n    fot(int j = pos + 1; j &lt; L.length; i++){  //依次把最大值的后一位往前移动，补全空缺\n        L.data[j-1] = L.data[j];                \n        L.length--;                           //长度减一\n    }\n}\n</code></pre>\n</li>\n<li><p>删除<strong>顺序表</strong>L中重复的值（<strong>表已经有序</strong>）</p>\n<pre><code class=\"lang-c\">void ListDelete(SqList &amp;L){\n    int count = 0;                          //计数器count\n    int num = L.data[0];                    //从第一个数开始比较是否有相同的值\n    for(int i = 1; i &lt; L.length; i++){      //从头到尾依次扫描\n        if(L.data[i] == num){               //如果之后有值与num相等\n            count++;                        //计数器加一\n        }else{\n            num = L.data[i];                //否则，更新num的值\n            L.data[i - count] = L.data[i];  //并更新顺序表\n        }\n    }\n    L.length = L.length - count;\n}\n</code></pre>\n</li>\n<li><p>逆置：将顺序表L中的所有元素逆置过来</p>\n<pre><code class=\"lang-c\">void Inversion(SqList &amp;L){\n    int low = 0, high = L.length - 1;  //分别两个指针指向首尾\n    while(low &lt; high){\n        int temp = L.data[low];        //把第一个元素赋值给临时变量temp\n        L.data[low] = L.data[high];    //把high的值赋予low\n        L.data[high] = temp;           //在把temp中的值赋予给high\n        low++;                         //完成一次交换，然后依次交换           \n        high--;\n    }\n}\n</code></pre>\n</li>\n<li><p>平台：找出顺序表中最大的平台值（<strong>什么是平台值？</strong>）</p>\n<hr>\n</li>\n<li><p>顺序表合并：将两个升序顺序表合并为一个升序的顺序表</p>\n<blockquote>\n<p>i++   先执行i=0 再进行i=i+1,也就是i会是0,执行完了再变为1<br>++i   先执行i=i+1,i会是1</p>\n</blockquote>\n<pre><code class=\"lang-c\">SqList Merge(Sqlist L1, Sqlist L2){\n    Sqlist L3;\n    int i = 0, j = 0, k = 0;\n    while(i &lt; L1.length &amp;&amp; j &lt; L2.length){  //L1和L2长度要大于0\n        if(L1.data[i] &lt; L2.data[j]){        //如果L1的一位比L2的一位小\n            L3.data[k++] = L1.data[i++];    //就把L1的一位放入L3中，并且i和k自增1\n        }else{                              //如果L1的一位比L2的一位大\n            L3.data[k++] = L2.data[j++];    //就把L2的一位放入L3中，并且j和k自增1\n        }\n    }                                       //当其中一个被放完时，再单独对另一个顺序表操作即可\n    while(i &lt; L1.length){\n        L3.data[k++] = L1.data[i++];\n    }\n    while(i &lt; L2.length){\n        L3.data[k++] = L2.data[j++];\n    }\n    L3.length = k;\n    return L3;\n}\n</code></pre>\n</li>\n<li><p>将两个升序顺序表合并为一个升序的顺序表<strong>（只求∩交集）</strong></p>\n<pre><code class=\"lang-c\">SqList Merge(Sqlist L1, Sqlist L2){\n    Sqlist L3;\n    int i = 0, j = 0, k = 0;\n    while(i &lt; L1.length &amp;&amp; j &lt; L2.length){  //L1和L2长度要大于0\n        if(L1.data[i] &lt; L2.data[j]){        //如果L1的一位比L2的一位小\n            i++;                            //i++\n        }else if(L1.data[i] &gt; L2.data[j]){  //如果L1的一位比L2的一位大\n            j++;                            //j++\n        }else{\n            L3.data[k++] = L1.data[i++];    //如果L1的一位和L2的一位相等，则放入L3中\n            j++;                            //j++\n        }\n    }                                       \n    L3.length = k;\n    return L3;\n}\n</code></pre>\n</li>\n<li><p>将两个升序顺序表合并为一个升序的顺序表<strong>（∪并集，没有重复元素）</strong></p>\n<pre><code class=\"lang-c\">SqList Merge(Sqlist L1, Sqlist L2){\n    Sqlist L3;\n    int i = 0, j = 0, k = 0;\n    while(i &lt; L1.length &amp;&amp; j &lt; L2.length){    //L1和L2长度要大于0\n        if(L1.data[i] &lt; L2.data[j]){          //如果L1的一位比L2的一位小\n            L3.length[k++] = L2.length[i++];  //把L1放入L3，并且i和k自增\n        }else if(L1.data[i] &gt; L2.data[j]){    //如果L1的一位比L2的一位大\n            L3.length[k++] = L2.length[j++];  //把L2放入L3，并且j和k自增\n        }else{\n            L3.data[k++] = L1.data[i++];      //如果L1的一位和L2的一位相等，则把L1放入L3中\n            j++;                              //j++\n        }\n    }                                         //当其中一个被放完时，再单独对另一个顺序表操作即可\n    while(i &lt; L1.length){\n        L3.data[k++] = L1.data[i++];\n    }\n    while(i &lt; L2.length){\n        L3.data[k++] = L2.data[j++];\n    }\n    L3.length = k;\n    return L3;\n}\n</code></pre>\n</li>\n</ul>\n"},{"title":"笔迹识别（二）","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"笔迹鉴定论文（二）","abbrlink":"1276","date":"2021-08-18T08:47:35.000Z","password":null,"keywords":null,"description":null,"_content":"### 8.18 笔迹鉴定\n\n#### 1.论文9  \n\nState of the art in off-line writer identification of handwritten text and survey of writer identification of Arabic text \n\n**离线书写人识别技术现状及阿拉伯文本书写人识别综述**   \n\n##### 1.1最小距离分类器\n\n- 最小距离分类器通过测量从测试样本到训练模式的距离并选择最近邻所属的K-nearest classes（**KNN**）来对新模式进行分类。\n\n- K最近邻(kNN，k-NearestNeighbor)分类算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。\n\n- **当预测一个新的值 $ x$ 时，根据它距离最近的 $ K$ 个点是什么类别来判断 $ x$ 属于哪个类别**\n- 绿色的点是我们要预测的点，假设 $ K=3$ 。那么KNN算法就会找到距离他最近的三个点，看看哪种类别多一些。图中蓝色三角形为两个，红色圆形为一个。所以新的绿色点就被归类到蓝色三角形了。\n\n![K=3](https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174428395-6404591.png)\n\n\n\n- 但是，**当 $ K=5$ 的时候，判定就变成不一样了**。这次变成红圆多一些，所以新来的绿点被归类成红圆。所以$ K $的取值是很重要的。\n\n![K=5](https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174434360-1539590461.png)\n\n- K值的选取和点距离的计算是KNN中最重要的。\n- 常见的有曼哈顿距离计算，欧式距离计算等等\n- 二维空间两个点的欧式距离计算公式为：\n$$\n\\rho = \\sqrt { \\left ( x _ { 2 } - x _ { 1 } \\right ) ^ { 2 } + \\left ( y _ { 2 } - y _ { 1 } \\right ) ^ { 2 } }\n$$\n\n- 拓展到多维空间的欧式距离为：\n\n$$\nd(x, y):=\\sqrt{\\left(x_{1}-y_{1}\\right)^{2}+\\left(x_{2}-y_{2}\\right)^{2}+\\cdots+\\left(x_{n}-y_{n}\\right)^{2}}=\\sqrt{\\sum_{i=1}^{n}\\left(x_{i}-y_{i}\\right)^{2}}\n$$\n\n- K值的选择：通过交叉验证，选取一个小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K。\n\n#### 2.论文10\n\nOffline Text-Independent Writer Recognition: A Survey\n\n**离线文本书写人识别**\n\n- 当作者数量增加时，基于频域特征的方法的性能严重下降，并且空间分布特征在捕获个体特征方面优于频域特征和形状特征。\n- 频域特征：图像经过傅立叶变换后得到频谱图，就是图像梯度的分布图。设置手写体在频域中的全局特征。\n- 空间分布特征设计手写体的局部空间结构特征。\n\n#### 3.<span id = 'text12'>论文12 Personal identication based on handwriting</span>\n\nPersonal identication based on handwriting\n\n**书写人身份识别**\n\n- 图像归一化:归一化后所有像素值都在[0，1]之间。\n- 特征提取：多通道Gabor滤波（MGF），灰度共生矩阵（GSCM？？？GLCM）\n- 灰度共生矩阵：指的是一种通过研究灰度的空间相关特性来描述纹理的常用方法。由于纹理是由灰度分布在空间位置上反复出现而形成的，因而在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。\n- 用了两种分类器：加权欧式距离（WED）和K-近邻分类器（KNN）\n\n#### 4.<span id = 'text77'>论文77 **A Comparison of Clustering Methods for Writer Identification and Verification**</span>\n\n书写人识别和鉴定的聚类方法比较\n\n- 通过聚类获得给定笔迹样本的字形码本。（k-means（最简单的聚类，以k为距离划分）, Kohonen SOM 1D and 2D.）\n- 分割方法：靠近上轮廓的下轮廓的最小值处分段，然后经过某种处理，储存下来。\n\n![分割方法](https://leng-mypic.oss-cn-beijing.aliyuncs.com/docdownpNCnLk.gif)\n\n#### 5.<span id = 'text96'>论文96Offline Writer Identification Using Convolutional Neural Network Activation Features</span>\n\n离线书写人识别，利用卷积神经网络\n\n##### 5.1输入层\n\n- 一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于卷积神经网络在CV领域应用较广，因此许多研究在介绍其结构时预先假设了三维输入数据，即平面上的二维像素点和[RGB](https://baike.baidu.com/item/RGB/342517)通道。\n- 使用梯度下降算法学习（是迭代法的一种，用于求解最小二乘问题，在求解损失函数的最小值时，可以通过梯度下降法一步一步迭代求解，得到最小化的损失函数和模型参数值）\n- 若输入数据为像素，可以将[0，25]的原始像素归一化为[0，1]区间，输入特征的标准化有利于提升卷积神经网络的学习效率和表现。\n- 卷积神经网络的隐含层包含卷积层、池化层和全连接层3类常见构筑，\n- 卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector），类似于一个前馈神经网络的神经元（neuron）\n\n#### 6.常用的图像预处理手段\n\n- 去噪：使用滤波器去除\n- 二值化：小于阈值设置为0，大于设置为255\n- 边缘检测：本质上是一种滤波算法。数组点乘边缘算子，然后再取绝对值，对x、y轴共进行两次滤波，得到的结果进行平方求和开根号得到当前像素点的图像梯度，就求出了边缘。\n- 倾斜校正\n- 文本提取\n\n#### 7.分类器的选择\n\n- 小类别集且数据量够多时，可以训练数据得到优秀的模型\n- 当类别多，但每个类别少时，基于距离度量的简单分类器性能更稳定\n- \n\n#### 8.特征的分类\n\n##### 8.1纹理特征\n\n###### 8.1.1频域特征\n\n- 在图像处理中，时域可以理解为空间域，处理对象为图像平面本身。频域就是频率域，是描述信号在频率方面特性时用到的一种坐标系。自变量是频率，即横轴是频率，纵轴是该频率信号的幅度，也就是通常说的频谱图。频谱图描述了信号的频率结构及频率与该频率信号幅度的关系；\n\n- 将笔迹的图像转化为频域信号，通过提取频域信号中的若干属性作为笔迹的特征。\n\n###### 8.1.2空间分布特征\n\n- 空间分布特征是直接统计边缘像素、关键点以及文本行中特定的空间结构来表示笔迹的个性化差异。\n\n- [灰度协方差矩阵](#text12)，也是统计纹理特征的一种方法\n- 灰度游程直方图/灰度游程矩阵：一幅图像的灰度游程矩阵反映了图像灰度关于方向，相邻间隔和变化幅度等综合信息。灰度游程矩阵是对分析影像的局部模式和其排列规则基础之一。灰度游程矩阵可以实现对一幅图像中同一方向同一灰度值连续出现个数的统计。在一幅图像上，在某一方向上连续的像素点具有相同的灰度值，灰度游程矩阵就是通过对这些像素点的分布进行统计得到纹理特征。\n- 梯度：相邻两个像素之间的差值。可以利用求出来的梯度，增强图片对比度，清晰轮廓。（**梯度加原有点像素**）\n- 边缘方向特征：一条边缘和中心夹角的概率分布直方图来表示特征\n- 边缘铰链特征：两条与中心相连通的边缘像素的夹角\n- 尺寸不变特征变换（Scale invariant feature Transform,SIFT）：目标是解决低层次特征提取及其图像匹配应用中的许多实际问题。SIFT算法主要包括两个阶段，一个是SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量；第二阶段是SIFT特征向量的匹配。SIFT方法中的低层次特征提取是选取那些显特征，这些特征具有图像尺度(特征大小)和旋转不变性，而且对光照变化也具有一定程度的不变性。此外，SIFT方法还可以减少由遮挡、杂乱和噪声所引起的低提取概率。\n- 加速鲁棒特征Surf（Speeded Up Robust Features）：Sift尺寸不变特征变换算法的优点是特征稳定，对旋转、尺度变换、亮度保持不变性，对视角变换、噪声也有一定程度的稳定性。缺点是实时性不高，并且对于边缘光滑目标的特征点提取能力较弱。\n   Surf改进了特征的提取和描述方式，用一种更为高效的方式完成特征的提取和描述。\n\n##### 8.2形状基元\n\n- 前提假设：书写人被视为一个随机但服从某种规律的基元产生器。而笔迹书写过程可以看作多个基础基元零件被组成一个个文字的过程。当笔迹的字足够多时，每个基元零件出现的概率就可以用来表示书写人的特征。\n- [论文77](#text77)：利用聚类讨论可能对基元码本可能产生的影响\n\n##### 8.3深度学习特征\n\n- [论文96](#text96)\n\n#### 9.公共数据库\n\n##### 9.1中科院CASIA数据集\n\nCASIA-OLHWDB1.0 ：手写单字，171 个英文数字符号，3866 个常用汉字(其中3740个属于GB2312 - -级汉字)，420套，分别为420个人书写。总共1,694,741个有效样本，分别存在420个POT文件中。\n\nCASIA-OLHWDB1.1 ：手写单字，171个英文数字符号，3755个GB2312级汉字，300套，分别为300个人书写。总共1,174,364个有效样本。分别存在300个POT文件中。\n\n[下载地址](http://www.nlpr.ia.ac.cn/databases/handwriting/Download.html)其他的数据集需要申请。\n\n##### 9.2哈工大HIT-OR3C数据集\n\nHIT-OR3C由5个子集组成 （GB1, GB2, Digit, Letter, 和Document），GB1和GB2是汉字标注库GB2312-80内2个子集的简写。GB1, GB2, Digit, 和 Letter子集已采集完成122套，共832,650 个手写汉字。Document子集包括10个从新浪网收集的文档，每个文档采集2套，共收集了20套。文档子集共有77,168个字符， 覆盖2,442个字符，其中2,286个来自GB1，97个来自GB2，49个来自Letter， 10个来自 Digit。\n\n[下载地址](http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C)\n\n##### 9.3华南理工SCUTCOUCH-2009数据集\n\nSCUT-COUCH2009是一款包括12个子集的完整数据，它们分别是：中文词组、国标一级汉字、国标二级汉字、国标一级汉字对应的繁体字、汉语拼音、英文字母、阿拉伯数字、常用符号、Word8888、Word17366、Word44208和联机文本行数据。每套完整的SCUT-COUCH2009包括6,763个GB2312-80单汉字，5401个Big5繁体字，1384个和GB2312-80一级字库相对应的繁体字，8,888个常用的中文词组，17,366个常用中文词组，摘自《现代汉语大辞典》（第四版）的44,208个词组，2,010个汉语拼音，184个其他符号（包括字母、数字和常用符号）和8,809行联机文本行；现在版本的SCUT-COUCH2009使用PDA或手写屏进行采集，已完成了由190多人书写的完整的数据，字符总数超过3.6百万个。\n\n[下载地址](http://www.hcii-lab.net/data/scutcouch/CN/download.html)（需要申请）\n\n#### 10.边缘共生对\n\n**问题**：怎样选择的边缘像素对，（45和135），（135和202.5）就是随便选的吗？为啥没有270度\n\n#### 11.边缘共生特征与 SIFT 描述子直方图结合\n\n- SIFT：SIFT即尺度不变特征变换，是用于图像处理领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种**局部特征描述子**。\n- 然后**利用直方图**统计领域内像素对应的梯度和幅值：梯度方向角为横轴刻度，取45度为一个单位，那么横轴就有8个刻度；纵轴是对应梯度的幅值累加值。\n- SIFT算法特点：\n\n  - 具有较好的稳定性和不变性，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰\n  - 区分性好，能够在海量特征数据库中进行快速准确的区分信息进行匹配\n  - 多量性，就算只有单个物体，也能产生大量特征向量\n  - 高速性，能够快速的进行特征向量匹配\n  - 可扩展性，能够与其它形式的特征向量进行联合\n- 在不同的尺度空间上查找关键点，并计算出关键点的方向\n\n![](https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-18%2016.05.50.png)\n\n- SIFT关键流程：\n- **提取关键点**：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的兴趣点。\n- **定位关键点并确定特征方向**：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。然后基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。\n- **通过各关键点的特征向量**，进行两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。\n- **最后用SIFT提取到的关键点与边缘元共生对融合特征，就完成了特征提取。**\n\n\n","source":"_posts/笔迹识别（二）.md","raw":"---\ntitle: 笔迹识别（二）\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 论文\n  - 研究生\n  - 笔迹鉴定\ncategories:\n  - 论文\nsummary: 笔迹鉴定论文（二）\nabbrlink: '1276'\ndate: 2021-08-18 16:47:35\npassword:\nkeywords:\ndescription:\n---\n### 8.18 笔迹鉴定\n\n#### 1.论文9  \n\nState of the art in off-line writer identification of handwritten text and survey of writer identification of Arabic text \n\n**离线书写人识别技术现状及阿拉伯文本书写人识别综述**   \n\n##### 1.1最小距离分类器\n\n- 最小距离分类器通过测量从测试样本到训练模式的距离并选择最近邻所属的K-nearest classes（**KNN**）来对新模式进行分类。\n\n- K最近邻(kNN，k-NearestNeighbor)分类算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。\n\n- **当预测一个新的值 $ x$ 时，根据它距离最近的 $ K$ 个点是什么类别来判断 $ x$ 属于哪个类别**\n- 绿色的点是我们要预测的点，假设 $ K=3$ 。那么KNN算法就会找到距离他最近的三个点，看看哪种类别多一些。图中蓝色三角形为两个，红色圆形为一个。所以新的绿色点就被归类到蓝色三角形了。\n\n![K=3](https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174428395-6404591.png)\n\n\n\n- 但是，**当 $ K=5$ 的时候，判定就变成不一样了**。这次变成红圆多一些，所以新来的绿点被归类成红圆。所以$ K $的取值是很重要的。\n\n![K=5](https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174434360-1539590461.png)\n\n- K值的选取和点距离的计算是KNN中最重要的。\n- 常见的有曼哈顿距离计算，欧式距离计算等等\n- 二维空间两个点的欧式距离计算公式为：\n$$\n\\rho = \\sqrt { \\left ( x _ { 2 } - x _ { 1 } \\right ) ^ { 2 } + \\left ( y _ { 2 } - y _ { 1 } \\right ) ^ { 2 } }\n$$\n\n- 拓展到多维空间的欧式距离为：\n\n$$\nd(x, y):=\\sqrt{\\left(x_{1}-y_{1}\\right)^{2}+\\left(x_{2}-y_{2}\\right)^{2}+\\cdots+\\left(x_{n}-y_{n}\\right)^{2}}=\\sqrt{\\sum_{i=1}^{n}\\left(x_{i}-y_{i}\\right)^{2}}\n$$\n\n- K值的选择：通过交叉验证，选取一个小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K。\n\n#### 2.论文10\n\nOffline Text-Independent Writer Recognition: A Survey\n\n**离线文本书写人识别**\n\n- 当作者数量增加时，基于频域特征的方法的性能严重下降，并且空间分布特征在捕获个体特征方面优于频域特征和形状特征。\n- 频域特征：图像经过傅立叶变换后得到频谱图，就是图像梯度的分布图。设置手写体在频域中的全局特征。\n- 空间分布特征设计手写体的局部空间结构特征。\n\n#### 3.<span id = 'text12'>论文12 Personal identication based on handwriting</span>\n\nPersonal identication based on handwriting\n\n**书写人身份识别**\n\n- 图像归一化:归一化后所有像素值都在[0，1]之间。\n- 特征提取：多通道Gabor滤波（MGF），灰度共生矩阵（GSCM？？？GLCM）\n- 灰度共生矩阵：指的是一种通过研究灰度的空间相关特性来描述纹理的常用方法。由于纹理是由灰度分布在空间位置上反复出现而形成的，因而在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。\n- 用了两种分类器：加权欧式距离（WED）和K-近邻分类器（KNN）\n\n#### 4.<span id = 'text77'>论文77 **A Comparison of Clustering Methods for Writer Identification and Verification**</span>\n\n书写人识别和鉴定的聚类方法比较\n\n- 通过聚类获得给定笔迹样本的字形码本。（k-means（最简单的聚类，以k为距离划分）, Kohonen SOM 1D and 2D.）\n- 分割方法：靠近上轮廓的下轮廓的最小值处分段，然后经过某种处理，储存下来。\n\n![分割方法](https://leng-mypic.oss-cn-beijing.aliyuncs.com/docdownpNCnLk.gif)\n\n#### 5.<span id = 'text96'>论文96Offline Writer Identification Using Convolutional Neural Network Activation Features</span>\n\n离线书写人识别，利用卷积神经网络\n\n##### 5.1输入层\n\n- 一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于卷积神经网络在CV领域应用较广，因此许多研究在介绍其结构时预先假设了三维输入数据，即平面上的二维像素点和[RGB](https://baike.baidu.com/item/RGB/342517)通道。\n- 使用梯度下降算法学习（是迭代法的一种，用于求解最小二乘问题，在求解损失函数的最小值时，可以通过梯度下降法一步一步迭代求解，得到最小化的损失函数和模型参数值）\n- 若输入数据为像素，可以将[0，25]的原始像素归一化为[0，1]区间，输入特征的标准化有利于提升卷积神经网络的学习效率和表现。\n- 卷积神经网络的隐含层包含卷积层、池化层和全连接层3类常见构筑，\n- 卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector），类似于一个前馈神经网络的神经元（neuron）\n\n#### 6.常用的图像预处理手段\n\n- 去噪：使用滤波器去除\n- 二值化：小于阈值设置为0，大于设置为255\n- 边缘检测：本质上是一种滤波算法。数组点乘边缘算子，然后再取绝对值，对x、y轴共进行两次滤波，得到的结果进行平方求和开根号得到当前像素点的图像梯度，就求出了边缘。\n- 倾斜校正\n- 文本提取\n\n#### 7.分类器的选择\n\n- 小类别集且数据量够多时，可以训练数据得到优秀的模型\n- 当类别多，但每个类别少时，基于距离度量的简单分类器性能更稳定\n- \n\n#### 8.特征的分类\n\n##### 8.1纹理特征\n\n###### 8.1.1频域特征\n\n- 在图像处理中，时域可以理解为空间域，处理对象为图像平面本身。频域就是频率域，是描述信号在频率方面特性时用到的一种坐标系。自变量是频率，即横轴是频率，纵轴是该频率信号的幅度，也就是通常说的频谱图。频谱图描述了信号的频率结构及频率与该频率信号幅度的关系；\n\n- 将笔迹的图像转化为频域信号，通过提取频域信号中的若干属性作为笔迹的特征。\n\n###### 8.1.2空间分布特征\n\n- 空间分布特征是直接统计边缘像素、关键点以及文本行中特定的空间结构来表示笔迹的个性化差异。\n\n- [灰度协方差矩阵](#text12)，也是统计纹理特征的一种方法\n- 灰度游程直方图/灰度游程矩阵：一幅图像的灰度游程矩阵反映了图像灰度关于方向，相邻间隔和变化幅度等综合信息。灰度游程矩阵是对分析影像的局部模式和其排列规则基础之一。灰度游程矩阵可以实现对一幅图像中同一方向同一灰度值连续出现个数的统计。在一幅图像上，在某一方向上连续的像素点具有相同的灰度值，灰度游程矩阵就是通过对这些像素点的分布进行统计得到纹理特征。\n- 梯度：相邻两个像素之间的差值。可以利用求出来的梯度，增强图片对比度，清晰轮廓。（**梯度加原有点像素**）\n- 边缘方向特征：一条边缘和中心夹角的概率分布直方图来表示特征\n- 边缘铰链特征：两条与中心相连通的边缘像素的夹角\n- 尺寸不变特征变换（Scale invariant feature Transform,SIFT）：目标是解决低层次特征提取及其图像匹配应用中的许多实际问题。SIFT算法主要包括两个阶段，一个是SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量；第二阶段是SIFT特征向量的匹配。SIFT方法中的低层次特征提取是选取那些显特征，这些特征具有图像尺度(特征大小)和旋转不变性，而且对光照变化也具有一定程度的不变性。此外，SIFT方法还可以减少由遮挡、杂乱和噪声所引起的低提取概率。\n- 加速鲁棒特征Surf（Speeded Up Robust Features）：Sift尺寸不变特征变换算法的优点是特征稳定，对旋转、尺度变换、亮度保持不变性，对视角变换、噪声也有一定程度的稳定性。缺点是实时性不高，并且对于边缘光滑目标的特征点提取能力较弱。\n   Surf改进了特征的提取和描述方式，用一种更为高效的方式完成特征的提取和描述。\n\n##### 8.2形状基元\n\n- 前提假设：书写人被视为一个随机但服从某种规律的基元产生器。而笔迹书写过程可以看作多个基础基元零件被组成一个个文字的过程。当笔迹的字足够多时，每个基元零件出现的概率就可以用来表示书写人的特征。\n- [论文77](#text77)：利用聚类讨论可能对基元码本可能产生的影响\n\n##### 8.3深度学习特征\n\n- [论文96](#text96)\n\n#### 9.公共数据库\n\n##### 9.1中科院CASIA数据集\n\nCASIA-OLHWDB1.0 ：手写单字，171 个英文数字符号，3866 个常用汉字(其中3740个属于GB2312 - -级汉字)，420套，分别为420个人书写。总共1,694,741个有效样本，分别存在420个POT文件中。\n\nCASIA-OLHWDB1.1 ：手写单字，171个英文数字符号，3755个GB2312级汉字，300套，分别为300个人书写。总共1,174,364个有效样本。分别存在300个POT文件中。\n\n[下载地址](http://www.nlpr.ia.ac.cn/databases/handwriting/Download.html)其他的数据集需要申请。\n\n##### 9.2哈工大HIT-OR3C数据集\n\nHIT-OR3C由5个子集组成 （GB1, GB2, Digit, Letter, 和Document），GB1和GB2是汉字标注库GB2312-80内2个子集的简写。GB1, GB2, Digit, 和 Letter子集已采集完成122套，共832,650 个手写汉字。Document子集包括10个从新浪网收集的文档，每个文档采集2套，共收集了20套。文档子集共有77,168个字符， 覆盖2,442个字符，其中2,286个来自GB1，97个来自GB2，49个来自Letter， 10个来自 Digit。\n\n[下载地址](http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C)\n\n##### 9.3华南理工SCUTCOUCH-2009数据集\n\nSCUT-COUCH2009是一款包括12个子集的完整数据，它们分别是：中文词组、国标一级汉字、国标二级汉字、国标一级汉字对应的繁体字、汉语拼音、英文字母、阿拉伯数字、常用符号、Word8888、Word17366、Word44208和联机文本行数据。每套完整的SCUT-COUCH2009包括6,763个GB2312-80单汉字，5401个Big5繁体字，1384个和GB2312-80一级字库相对应的繁体字，8,888个常用的中文词组，17,366个常用中文词组，摘自《现代汉语大辞典》（第四版）的44,208个词组，2,010个汉语拼音，184个其他符号（包括字母、数字和常用符号）和8,809行联机文本行；现在版本的SCUT-COUCH2009使用PDA或手写屏进行采集，已完成了由190多人书写的完整的数据，字符总数超过3.6百万个。\n\n[下载地址](http://www.hcii-lab.net/data/scutcouch/CN/download.html)（需要申请）\n\n#### 10.边缘共生对\n\n**问题**：怎样选择的边缘像素对，（45和135），（135和202.5）就是随便选的吗？为啥没有270度\n\n#### 11.边缘共生特征与 SIFT 描述子直方图结合\n\n- SIFT：SIFT即尺度不变特征变换，是用于图像处理领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种**局部特征描述子**。\n- 然后**利用直方图**统计领域内像素对应的梯度和幅值：梯度方向角为横轴刻度，取45度为一个单位，那么横轴就有8个刻度；纵轴是对应梯度的幅值累加值。\n- SIFT算法特点：\n\n  - 具有较好的稳定性和不变性，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰\n  - 区分性好，能够在海量特征数据库中进行快速准确的区分信息进行匹配\n  - 多量性，就算只有单个物体，也能产生大量特征向量\n  - 高速性，能够快速的进行特征向量匹配\n  - 可扩展性，能够与其它形式的特征向量进行联合\n- 在不同的尺度空间上查找关键点，并计算出关键点的方向\n\n![](https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-18%2016.05.50.png)\n\n- SIFT关键流程：\n- **提取关键点**：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的兴趣点。\n- **定位关键点并确定特征方向**：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。然后基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。\n- **通过各关键点的特征向量**，进行两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。\n- **最后用SIFT提取到的关键点与边缘元共生对融合特征，就完成了特征提取。**\n\n\n","slug":"笔迹识别（二）","published":1,"updated":"2021-08-19T04:05:25.187Z","_id":"cksie9q65004ha09kczyp9y75","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"818-笔迹鉴定\"><a class=\"markdownIt-Anchor\" href=\"#818-笔迹鉴定\"></a> 8.18 笔迹鉴定</h3>\n<h4 id=\"1论文9\"><a class=\"markdownIt-Anchor\" href=\"#1论文9\"></a> 1.论文9</h4>\n<p>State of the art in off-line writer identification of handwritten text and survey of writer identification of Arabic text</p>\n<p><strong>离线书写人识别技术现状及阿拉伯文本书写人识别综述</strong></p>\n<h5 id=\"11最小距离分类器\"><a class=\"markdownIt-Anchor\" href=\"#11最小距离分类器\"></a> 1.1最小距离分类器</h5>\n<ul>\n<li>\n<p>最小距离分类器通过测量从测试样本到训练模式的距离并选择最近邻所属的K-nearest classes（<strong>KNN</strong>）来对新模式进行分类。</p>\n</li>\n<li>\n<p>K最近邻(kNN，k-NearestNeighbor)分类算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。</p>\n</li>\n<li>\n<p><strong>当预测一个新的值 $ x$ 时，根据它距离最近的 $ K$ 个点是什么类别来判断 $ x$ 属于哪个类别</strong></p>\n</li>\n<li>\n<p>绿色的点是我们要预测的点，假设 $ K=3$ 。那么KNN算法就会找到距离他最近的三个点，看看哪种类别多一些。图中蓝色三角形为两个，红色圆形为一个。所以新的绿色点就被归类到蓝色三角形了。</p>\n</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174428395-6404591.png\" alt=\"K=3\"></p>\n<ul>\n<li>但是，<strong>当 $ K=5$ 的时候，判定就变成不一样了</strong>。这次变成红圆多一些，所以新来的绿点被归类成红圆。所以$ K $的取值是很重要的。</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174434360-1539590461.png\" alt=\"K=5\"></p>\n<ul>\n<li>K值的选取和点距离的计算是KNN中最重要的。</li>\n<li>常见的有曼哈顿距离计算，欧式距离计算等等</li>\n<li>二维空间两个点的欧式距离计算公式为：</li>\n</ul>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ρ</mi><mo>=</mo><msqrt><mrow><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo fence=\"true\">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding=\"application/x-tex\">\\rho = \\sqrt { \\left ( x _ { 2 } - x _ { 1 } \\right ) ^ { 2 } + \\left ( y _ { 2 } - y _ { 1 } \\right ) ^ { 2 } }\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">ρ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.84em;vertical-align:-0.454121em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.385879em;\"><span class=\"svg-align\" style=\"top:-3.8em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.345879em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.8800000000000001em;\"><svg width=\"400em\" height=\"1.8800000000000001em\" viewBox=\"0 0 400000 1944\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,\n572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,\n-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39\nc-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60\ns208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,\n-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z\nM1001 80H400000v40H1013z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.454121em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li>拓展到多维空间的欧式距离为：</li>\n</ul>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><msqrt><mrow><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>y</mi><mi>n</mi></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding=\"application/x-tex\">d(x, y):=\\sqrt{\\left(x_{1}-y_{1}\\right)^{2}+\\left(x_{2}-y_{2}\\right)^{2}+\\cdots+\\left(x_{n}-y_{n}\\right)^{2}}=\\sqrt{\\sum_{i=1}^{n}\\left(x_{i}-y_{i}\\right)^{2}}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.84em;vertical-align:-0.454121em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.385879em;\"><span class=\"svg-align\" style=\"top:-3.8em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.345879em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.8800000000000001em;\"><svg width=\"400em\" height=\"1.8800000000000001em\" viewBox=\"0 0 400000 1944\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,\n572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,\n-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39\nc-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60\ns208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,\n-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z\nM1001 80H400000v40H1013z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.454121em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.1568160000000005em;vertical-align:-1.277669em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8791470000000006em;\"><span class=\"svg-align\" style=\"top:-5.116816em;\"><span class=\"pstrut\" style=\"height:5.116816em;\"></span><span class=\"mord\" style=\"padding-left:1.056em;\"><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.8391470000000005em;\"><span class=\"pstrut\" style=\"height:5.116816em;\"></span><span class=\"hide-tail\" style=\"min-width:0.742em;height:3.196816em;\"><svg width=\"400em\" height=\"3.196816em\" viewBox=\"0 0 400000 3196\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M702 80H400000v40H742v3062l-4 4-4 4c-.667.7\n-2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667\n-294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155\n 77-156c66 199.333 139 419.667 219 661 l218 661zM702 80H400000v40H742z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li>K值的选择：通过交叉验证，选取一个小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K。</li>\n</ul>\n<h4 id=\"2论文10\"><a class=\"markdownIt-Anchor\" href=\"#2论文10\"></a> 2.论文10</h4>\n<p>Offline Text-Independent Writer Recognition: A Survey</p>\n<p><strong>离线文本书写人识别</strong></p>\n<ul>\n<li>当作者数量增加时，基于频域特征的方法的性能严重下降，并且空间分布特征在捕获个体特征方面优于频域特征和形状特征。</li>\n<li>频域特征：图像经过傅立叶变换后得到频谱图，就是图像梯度的分布图。设置手写体在频域中的全局特征。</li>\n<li>空间分布特征设计手写体的局部空间结构特征。</li>\n</ul>\n<h4 id=\"3span-id-text12论文12-personal-identication-based-on-handwritingspan\"><a class=\"markdownIt-Anchor\" href=\"#3span-id-text12论文12-personal-identication-based-on-handwritingspan\"></a> 3.<span id=\"text12\">论文12 Personal identication based on handwriting</span></h4>\n<p>Personal identication based on handwriting</p>\n<p><strong>书写人身份识别</strong></p>\n<ul>\n<li>图像归一化:归一化后所有像素值都在[0，1]之间。</li>\n<li>特征提取：多通道Gabor滤波（MGF），灰度共生矩阵（GSCM？？？GLCM）</li>\n<li>灰度共生矩阵：指的是一种通过研究灰度的空间相关特性来描述纹理的常用方法。由于纹理是由灰度分布在空间位置上反复出现而形成的，因而在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。</li>\n<li>用了两种分类器：加权欧式距离（WED）和K-近邻分类器（KNN）</li>\n</ul>\n<h4 id=\"4span-id-text77论文77-a-comparison-of-clustering-methods-for-writer-identification-and-verificationspan\"><a class=\"markdownIt-Anchor\" href=\"#4span-id-text77论文77-a-comparison-of-clustering-methods-for-writer-identification-and-verificationspan\"></a> 4.<span id=\"text77\">论文77 <strong>A Comparison of Clustering Methods for Writer Identification and Verification</strong></span></h4>\n<p>书写人识别和鉴定的聚类方法比较</p>\n<ul>\n<li>通过聚类获得给定笔迹样本的字形码本。（k-means（最简单的聚类，以k为距离划分）, Kohonen SOM 1D and 2D.）</li>\n<li>分割方法：靠近上轮廓的下轮廓的最小值处分段，然后经过某种处理，储存下来。</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/docdownpNCnLk.gif\" alt=\"分割方法\"></p>\n<h4 id=\"5span-id-text96论文96offline-writer-identification-using-convolutional-neural-network-activation-featuresspan\"><a class=\"markdownIt-Anchor\" href=\"#5span-id-text96论文96offline-writer-identification-using-convolutional-neural-network-activation-featuresspan\"></a> 5.<span id=\"text96\">论文96Offline Writer Identification Using Convolutional Neural Network Activation Features</span></h4>\n<p>离线书写人识别，利用卷积神经网络</p>\n<h5 id=\"51输入层\"><a class=\"markdownIt-Anchor\" href=\"#51输入层\"></a> 5.1输入层</h5>\n<ul>\n<li>一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于卷积神经网络在CV领域应用较广，因此许多研究在介绍其结构时预先假设了三维输入数据，即平面上的二维像素点和<a href=\"https://baike.baidu.com/item/RGB/342517\" target=\"_blank\" rel=\"noopener\">RGB</a>通道。</li>\n<li>使用梯度下降算法学习（是迭代法的一种，用于求解最小二乘问题，在求解损失函数的最小值时，可以通过梯度下降法一步一步迭代求解，得到最小化的损失函数和模型参数值）</li>\n<li>若输入数据为像素，可以将[0，25]的原始像素归一化为[0，1]区间，输入特征的标准化有利于提升卷积神经网络的学习效率和表现。</li>\n<li>卷积神经网络的隐含层包含卷积层、池化层和全连接层3类常见构筑，</li>\n<li>卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector），类似于一个前馈神经网络的神经元（neuron）</li>\n</ul>\n<h4 id=\"6常用的图像预处理手段\"><a class=\"markdownIt-Anchor\" href=\"#6常用的图像预处理手段\"></a> 6.常用的图像预处理手段</h4>\n<ul>\n<li>去噪：使用滤波器去除</li>\n<li>二值化：小于阈值设置为0，大于设置为255</li>\n<li>边缘检测：本质上是一种滤波算法。数组点乘边缘算子，然后再取绝对值，对x、y轴共进行两次滤波，得到的结果进行平方求和开根号得到当前像素点的图像梯度，就求出了边缘。</li>\n<li>倾斜校正</li>\n<li>文本提取</li>\n</ul>\n<h4 id=\"7分类器的选择\"><a class=\"markdownIt-Anchor\" href=\"#7分类器的选择\"></a> 7.分类器的选择</h4>\n<ul>\n<li>小类别集且数据量够多时，可以训练数据得到优秀的模型</li>\n<li>当类别多，但每个类别少时，基于距离度量的简单分类器性能更稳定</li>\n<li></li>\n</ul>\n<h4 id=\"8特征的分类\"><a class=\"markdownIt-Anchor\" href=\"#8特征的分类\"></a> 8.特征的分类</h4>\n<h5 id=\"81纹理特征\"><a class=\"markdownIt-Anchor\" href=\"#81纹理特征\"></a> 8.1纹理特征</h5>\n<h6 id=\"811频域特征\"><a class=\"markdownIt-Anchor\" href=\"#811频域特征\"></a> 8.1.1频域特征</h6>\n<ul>\n<li>\n<p>在图像处理中，时域可以理解为空间域，处理对象为图像平面本身。频域就是频率域，是描述信号在频率方面特性时用到的一种坐标系。自变量是频率，即横轴是频率，纵轴是该频率信号的幅度，也就是通常说的频谱图。频谱图描述了信号的频率结构及频率与该频率信号幅度的关系；</p>\n</li>\n<li>\n<p>将笔迹的图像转化为频域信号，通过提取频域信号中的若干属性作为笔迹的特征。</p>\n</li>\n</ul>\n<h6 id=\"812空间分布特征\"><a class=\"markdownIt-Anchor\" href=\"#812空间分布特征\"></a> 8.1.2空间分布特征</h6>\n<ul>\n<li>\n<p>空间分布特征是直接统计边缘像素、关键点以及文本行中特定的空间结构来表示笔迹的个性化差异。</p>\n</li>\n<li>\n<p><a href=\"#text12\">灰度协方差矩阵</a>，也是统计纹理特征的一种方法</p>\n</li>\n<li>\n<p>灰度游程直方图/灰度游程矩阵：一幅图像的灰度游程矩阵反映了图像灰度关于方向，相邻间隔和变化幅度等综合信息。灰度游程矩阵是对分析影像的局部模式和其排列规则基础之一。灰度游程矩阵可以实现对一幅图像中同一方向同一灰度值连续出现个数的统计。在一幅图像上，在某一方向上连续的像素点具有相同的灰度值，灰度游程矩阵就是通过对这些像素点的分布进行统计得到纹理特征。</p>\n</li>\n<li>\n<p>梯度：相邻两个像素之间的差值。可以利用求出来的梯度，增强图片对比度，清晰轮廓。（<strong>梯度加原有点像素</strong>）</p>\n</li>\n<li>\n<p>边缘方向特征：一条边缘和中心夹角的概率分布直方图来表示特征</p>\n</li>\n<li>\n<p>边缘铰链特征：两条与中心相连通的边缘像素的夹角</p>\n</li>\n<li>\n<p>尺寸不变特征变换（Scale invariant feature Transform,SIFT）：目标是解决低层次特征提取及其图像匹配应用中的许多实际问题。SIFT算法主要包括两个阶段，一个是SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量；第二阶段是SIFT特征向量的匹配。SIFT方法中的低层次特征提取是选取那些显特征，这些特征具有图像尺度(特征大小)和旋转不变性，而且对光照变化也具有一定程度的不变性。此外，SIFT方法还可以减少由遮挡、杂乱和噪声所引起的低提取概率。</p>\n</li>\n<li>\n<p>加速鲁棒特征Surf（Speeded Up Robust Features）：Sift尺寸不变特征变换算法的优点是特征稳定，对旋转、尺度变换、亮度保持不变性，对视角变换、噪声也有一定程度的稳定性。缺点是实时性不高，并且对于边缘光滑目标的特征点提取能力较弱。<br>\nSurf改进了特征的提取和描述方式，用一种更为高效的方式完成特征的提取和描述。</p>\n</li>\n</ul>\n<h5 id=\"82形状基元\"><a class=\"markdownIt-Anchor\" href=\"#82形状基元\"></a> 8.2形状基元</h5>\n<ul>\n<li>前提假设：书写人被视为一个随机但服从某种规律的基元产生器。而笔迹书写过程可以看作多个基础基元零件被组成一个个文字的过程。当笔迹的字足够多时，每个基元零件出现的概率就可以用来表示书写人的特征。</li>\n<li><a href=\"#text77\">论文77</a>：利用聚类讨论可能对基元码本可能产生的影响</li>\n</ul>\n<h5 id=\"83深度学习特征\"><a class=\"markdownIt-Anchor\" href=\"#83深度学习特征\"></a> 8.3深度学习特征</h5>\n<ul>\n<li><a href=\"#text96\">论文96</a></li>\n</ul>\n<h4 id=\"9公共数据库\"><a class=\"markdownIt-Anchor\" href=\"#9公共数据库\"></a> 9.公共数据库</h4>\n<h5 id=\"91中科院casia数据集\"><a class=\"markdownIt-Anchor\" href=\"#91中科院casia数据集\"></a> 9.1中科院CASIA数据集</h5>\n<p>CASIA-OLHWDB1.0 ：手写单字，171 个英文数字符号，3866 个常用汉字(其中3740个属于GB2312 - -级汉字)，420套，分别为420个人书写。总共1,694,741个有效样本，分别存在420个POT文件中。</p>\n<p>CASIA-OLHWDB1.1 ：手写单字，171个英文数字符号，3755个GB2312级汉字，300套，分别为300个人书写。总共1,174,364个有效样本。分别存在300个POT文件中。</p>\n<p><a href=\"http://www.nlpr.ia.ac.cn/databases/handwriting/Download.html\" target=\"_blank\" rel=\"noopener\">下载地址</a>其他的数据集需要申请。</p>\n<h5 id=\"92哈工大hit-or3c数据集\"><a class=\"markdownIt-Anchor\" href=\"#92哈工大hit-or3c数据集\"></a> 9.2哈工大HIT-OR3C数据集</h5>\n<p>HIT-OR3C由5个子集组成 （GB1, GB2, Digit, Letter, 和Document），GB1和GB2是汉字标注库GB2312-80内2个子集的简写。GB1, GB2, Digit, 和 Letter子集已采集完成122套，共832,650 个手写汉字。Document子集包括10个从新浪网收集的文档，每个文档采集2套，共收集了20套。文档子集共有77,168个字符， 覆盖2,442个字符，其中2,286个来自GB1，97个来自GB2，49个来自Letter， 10个来自 Digit。</p>\n<p>[下载地址](<a href=\"http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C)\" target=\"_blank\" rel=\"noopener\">http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C)</a></p>\n<h5 id=\"93华南理工scutcouch-2009数据集\"><a class=\"markdownIt-Anchor\" href=\"#93华南理工scutcouch-2009数据集\"></a> 9.3华南理工SCUTCOUCH-2009数据集</h5>\n<p>SCUT-COUCH2009是一款包括12个子集的完整数据，它们分别是：中文词组、国标一级汉字、国标二级汉字、国标一级汉字对应的繁体字、汉语拼音、英文字母、阿拉伯数字、常用符号、Word8888、Word17366、Word44208和联机文本行数据。每套完整的SCUT-COUCH2009包括6,763个GB2312-80单汉字，5401个Big5繁体字，1384个和GB2312-80一级字库相对应的繁体字，8,888个常用的中文词组，17,366个常用中文词组，摘自《现代汉语大辞典》（第四版）的44,208个词组，2,010个汉语拼音，184个其他符号（包括字母、数字和常用符号）和8,809行联机文本行；现在版本的SCUT-COUCH2009使用PDA或手写屏进行采集，已完成了由190多人书写的完整的数据，字符总数超过3.6百万个。</p>\n<p><a href=\"http://www.hcii-lab.net/data/scutcouch/CN/download.html\" target=\"_blank\" rel=\"noopener\">下载地址</a>（需要申请）</p>\n<h4 id=\"10边缘共生对\"><a class=\"markdownIt-Anchor\" href=\"#10边缘共生对\"></a> 10.边缘共生对</h4>\n<p><strong>问题</strong>：怎样选择的边缘像素对，（45和135），（135和202.5）就是随便选的吗？为啥没有270度</p>\n<h4 id=\"11边缘共生特征与-sift-描述子直方图结合\"><a class=\"markdownIt-Anchor\" href=\"#11边缘共生特征与-sift-描述子直方图结合\"></a> 11.边缘共生特征与 SIFT 描述子直方图结合</h4>\n<ul>\n<li>\n<p>SIFT：SIFT即尺度不变特征变换，是用于图像处理领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种<strong>局部特征描述子</strong>。</p>\n</li>\n<li>\n<p>然后<strong>利用直方图</strong>统计领域内像素对应的梯度和幅值：梯度方向角为横轴刻度，取45度为一个单位，那么横轴就有8个刻度；纵轴是对应梯度的幅值累加值。</p>\n</li>\n<li>\n<p>SIFT算法特点：</p>\n<ul>\n<li>具有较好的稳定性和不变性，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰</li>\n<li>区分性好，能够在海量特征数据库中进行快速准确的区分信息进行匹配</li>\n<li>多量性，就算只有单个物体，也能产生大量特征向量</li>\n<li>高速性，能够快速的进行特征向量匹配</li>\n<li>可扩展性，能够与其它形式的特征向量进行联合</li>\n</ul>\n</li>\n<li>\n<p>在不同的尺度空间上查找关键点，并计算出关键点的方向</p>\n</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-18%2016.05.50.png\" alt=\"\"></p>\n<ul>\n<li>SIFT关键流程：</li>\n<li><strong>提取关键点</strong>：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的兴趣点。</li>\n<li><strong>定位关键点并确定特征方向</strong>：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。然后基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</li>\n<li><strong>通过各关键点的特征向量</strong>，进行两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。</li>\n<li><strong>最后用SIFT提取到的关键点与边缘元共生对融合特征，就完成了特征提取。</strong></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"818-笔迹鉴定\"><a class=\"markdownIt-Anchor\" href=\"#818-笔迹鉴定\"></a> 8.18 笔迹鉴定</h3>\n<h4 id=\"1论文9\"><a class=\"markdownIt-Anchor\" href=\"#1论文9\"></a> 1.论文9</h4>\n<p>State of the art in off-line writer identification of handwritten text and survey of writer identification of Arabic text</p>\n<p><strong>离线书写人识别技术现状及阿拉伯文本书写人识别综述</strong></p>\n<h5 id=\"11最小距离分类器\"><a class=\"markdownIt-Anchor\" href=\"#11最小距离分类器\"></a> 1.1最小距离分类器</h5>\n<ul>\n<li>\n<p>最小距离分类器通过测量从测试样本到训练模式的距离并选择最近邻所属的K-nearest classes（<strong>KNN</strong>）来对新模式进行分类。</p>\n</li>\n<li>\n<p>K最近邻(kNN，k-NearestNeighbor)分类算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。</p>\n</li>\n<li>\n<p><strong>当预测一个新的值 $ x$ 时，根据它距离最近的 $ K$ 个点是什么类别来判断 $ x$ 属于哪个类别</strong></p>\n</li>\n<li>\n<p>绿色的点是我们要预测的点，假设 $ K=3$ 。那么KNN算法就会找到距离他最近的三个点，看看哪种类别多一些。图中蓝色三角形为两个，红色圆形为一个。所以新的绿色点就被归类到蓝色三角形了。</p>\n</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174428395-6404591.png\" alt=\"K=3\" /></p>\n<ul>\n<li>但是，<strong>当 $ K=5$ 的时候，判定就变成不一样了</strong>。这次变成红圆多一些，所以新来的绿点被归类成红圆。所以$ K $的取值是很重要的。</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174434360-1539590461.png\" alt=\"K=5\" /></p>\n<ul>\n<li>K值的选取和点距离的计算是KNN中最重要的。</li>\n<li>常见的有曼哈顿距离计算，欧式距离计算等等</li>\n<li>二维空间两个点的欧式距离计算公式为：</li>\n</ul>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ρ</mi><mo>=</mo><msqrt><mrow><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo fence=\"true\">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding=\"application/x-tex\">\\rho = \\sqrt { \\left ( x _ { 2 } - x _ { 1 } \\right ) ^ { 2 } + \\left ( y _ { 2 } - y _ { 1 } \\right ) ^ { 2 } }\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">ρ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.84em;vertical-align:-0.454121em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.385879em;\"><span class=\"svg-align\" style=\"top:-3.8em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.345879em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.8800000000000001em;\"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,\n572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,\n-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39\nc-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60\ns208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,\n-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z\nM1001 80H400000v40H1013z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.454121em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li>拓展到多维空间的欧式距离为：</li>\n</ul>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><msqrt><mrow><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>y</mi><mi>n</mi></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo fence=\"true\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo fence=\"true\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding=\"application/x-tex\">d(x, y):=\\sqrt{\\left(x_{1}-y_{1}\\right)^{2}+\\left(x_{2}-y_{2}\\right)^{2}+\\cdots+\\left(x_{n}-y_{n}\\right)^{2}}=\\sqrt{\\sum_{i=1}^{n}\\left(x_{i}-y_{i}\\right)^{2}}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.84em;vertical-align:-0.454121em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.385879em;\"><span class=\"svg-align\" style=\"top:-3.8em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.345879em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.8800000000000001em;\"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,\n572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,\n-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39\nc-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60\ns208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,\n-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z\nM1001 80H400000v40H1013z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.454121em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.1568160000000005em;vertical-align:-1.277669em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8791470000000006em;\"><span class=\"svg-align\" style=\"top:-5.116816em;\"><span class=\"pstrut\" style=\"height:5.116816em;\"></span><span class=\"mord\" style=\"padding-left:1.056em;\"><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.8391470000000005em;\"><span class=\"pstrut\" style=\"height:5.116816em;\"></span><span class=\"hide-tail\" style=\"min-width:0.742em;height:3.196816em;\"><svg width='400em' height='3.196816em' viewBox='0 0 400000 3196' preserveAspectRatio='xMinYMin slice'><path d='M702 80H400000v40H742v3062l-4 4-4 4c-.667.7\n-2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667\n-294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155\n 77-156c66 199.333 139 419.667 219 661 l218 661zM702 80H400000v40H742z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li>K值的选择：通过交叉验证，选取一个小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K。</li>\n</ul>\n<h4 id=\"2论文10\"><a class=\"markdownIt-Anchor\" href=\"#2论文10\"></a> 2.论文10</h4>\n<p>Offline Text-Independent Writer Recognition: A Survey</p>\n<p><strong>离线文本书写人识别</strong></p>\n<ul>\n<li>当作者数量增加时，基于频域特征的方法的性能严重下降，并且空间分布特征在捕获个体特征方面优于频域特征和形状特征。</li>\n<li>频域特征：图像经过傅立叶变换后得到频谱图，就是图像梯度的分布图。设置手写体在频域中的全局特征。</li>\n<li>空间分布特征设计手写体的局部空间结构特征。</li>\n</ul>\n<h4 id=\"3span-id-text12论文12-personal-identication-based-on-handwritingspan\"><a class=\"markdownIt-Anchor\" href=\"#3span-id-text12论文12-personal-identication-based-on-handwritingspan\"></a> 3.<span id = 'text12'>论文12 Personal identication based on handwriting</span></h4>\n<p>Personal identication based on handwriting</p>\n<p><strong>书写人身份识别</strong></p>\n<ul>\n<li>图像归一化:归一化后所有像素值都在[0，1]之间。</li>\n<li>特征提取：多通道Gabor滤波（MGF），灰度共生矩阵（GSCM？？？GLCM）</li>\n<li>灰度共生矩阵：指的是一种通过研究灰度的空间相关特性来描述纹理的常用方法。由于纹理是由灰度分布在空间位置上反复出现而形成的，因而在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。</li>\n<li>用了两种分类器：加权欧式距离（WED）和K-近邻分类器（KNN）</li>\n</ul>\n<h4 id=\"4span-id-text77论文77-a-comparison-of-clustering-methods-for-writer-identification-and-verificationspan\"><a class=\"markdownIt-Anchor\" href=\"#4span-id-text77论文77-a-comparison-of-clustering-methods-for-writer-identification-and-verificationspan\"></a> 4.<span id = 'text77'>论文77 <strong>A Comparison of Clustering Methods for Writer Identification and Verification</strong></span></h4>\n<p>书写人识别和鉴定的聚类方法比较</p>\n<ul>\n<li>通过聚类获得给定笔迹样本的字形码本。（k-means（最简单的聚类，以k为距离划分）, Kohonen SOM 1D and 2D.）</li>\n<li>分割方法：靠近上轮廓的下轮廓的最小值处分段，然后经过某种处理，储存下来。</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/docdownpNCnLk.gif\" alt=\"分割方法\" /></p>\n<h4 id=\"5span-id-text96论文96offline-writer-identification-using-convolutional-neural-network-activation-featuresspan\"><a class=\"markdownIt-Anchor\" href=\"#5span-id-text96论文96offline-writer-identification-using-convolutional-neural-network-activation-featuresspan\"></a> 5.<span id = 'text96'>论文96Offline Writer Identification Using Convolutional Neural Network Activation Features</span></h4>\n<p>离线书写人识别，利用卷积神经网络</p>\n<h5 id=\"51输入层\"><a class=\"markdownIt-Anchor\" href=\"#51输入层\"></a> 5.1输入层</h5>\n<ul>\n<li>一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于卷积神经网络在CV领域应用较广，因此许多研究在介绍其结构时预先假设了三维输入数据，即平面上的二维像素点和<a href=\"https://baike.baidu.com/item/RGB/342517\" target=\"_blank\" rel=\"noopener\">RGB</a>通道。</li>\n<li>使用梯度下降算法学习（是迭代法的一种，用于求解最小二乘问题，在求解损失函数的最小值时，可以通过梯度下降法一步一步迭代求解，得到最小化的损失函数和模型参数值）</li>\n<li>若输入数据为像素，可以将[0，25]的原始像素归一化为[0，1]区间，输入特征的标准化有利于提升卷积神经网络的学习效率和表现。</li>\n<li>卷积神经网络的隐含层包含卷积层、池化层和全连接层3类常见构筑，</li>\n<li>卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector），类似于一个前馈神经网络的神经元（neuron）</li>\n</ul>\n<h4 id=\"6常用的图像预处理手段\"><a class=\"markdownIt-Anchor\" href=\"#6常用的图像预处理手段\"></a> 6.常用的图像预处理手段</h4>\n<ul>\n<li>去噪：使用滤波器去除</li>\n<li>二值化：小于阈值设置为0，大于设置为255</li>\n<li>边缘检测：本质上是一种滤波算法。数组点乘边缘算子，然后再取绝对值，对x、y轴共进行两次滤波，得到的结果进行平方求和开根号得到当前像素点的图像梯度，就求出了边缘。</li>\n<li>倾斜校正</li>\n<li>文本提取</li>\n</ul>\n<h4 id=\"7分类器的选择\"><a class=\"markdownIt-Anchor\" href=\"#7分类器的选择\"></a> 7.分类器的选择</h4>\n<ul>\n<li>小类别集且数据量够多时，可以训练数据得到优秀的模型</li>\n<li>当类别多，但每个类别少时，基于距离度量的简单分类器性能更稳定</li>\n<li></li>\n</ul>\n<h4 id=\"8特征的分类\"><a class=\"markdownIt-Anchor\" href=\"#8特征的分类\"></a> 8.特征的分类</h4>\n<h5 id=\"81纹理特征\"><a class=\"markdownIt-Anchor\" href=\"#81纹理特征\"></a> 8.1纹理特征</h5>\n<h6 id=\"811频域特征\"><a class=\"markdownIt-Anchor\" href=\"#811频域特征\"></a> 8.1.1频域特征</h6>\n<ul>\n<li>\n<p>在图像处理中，时域可以理解为空间域，处理对象为图像平面本身。频域就是频率域，是描述信号在频率方面特性时用到的一种坐标系。自变量是频率，即横轴是频率，纵轴是该频率信号的幅度，也就是通常说的频谱图。频谱图描述了信号的频率结构及频率与该频率信号幅度的关系；</p>\n</li>\n<li>\n<p>将笔迹的图像转化为频域信号，通过提取频域信号中的若干属性作为笔迹的特征。</p>\n</li>\n</ul>\n<h6 id=\"812空间分布特征\"><a class=\"markdownIt-Anchor\" href=\"#812空间分布特征\"></a> 8.1.2空间分布特征</h6>\n<ul>\n<li>\n<p>空间分布特征是直接统计边缘像素、关键点以及文本行中特定的空间结构来表示笔迹的个性化差异。</p>\n</li>\n<li>\n<p><a href=\"#text12\">灰度协方差矩阵</a>，也是统计纹理特征的一种方法</p>\n</li>\n<li>\n<p>灰度游程直方图/灰度游程矩阵：一幅图像的灰度游程矩阵反映了图像灰度关于方向，相邻间隔和变化幅度等综合信息。灰度游程矩阵是对分析影像的局部模式和其排列规则基础之一。灰度游程矩阵可以实现对一幅图像中同一方向同一灰度值连续出现个数的统计。在一幅图像上，在某一方向上连续的像素点具有相同的灰度值，灰度游程矩阵就是通过对这些像素点的分布进行统计得到纹理特征。</p>\n</li>\n<li>\n<p>梯度：相邻两个像素之间的差值。可以利用求出来的梯度，增强图片对比度，清晰轮廓。（<strong>梯度加原有点像素</strong>）</p>\n</li>\n<li>\n<p>边缘方向特征：一条边缘和中心夹角的概率分布直方图来表示特征</p>\n</li>\n<li>\n<p>边缘铰链特征：两条与中心相连通的边缘像素的夹角</p>\n</li>\n<li>\n<p>尺寸不变特征变换（Scale invariant feature Transform,SIFT）：目标是解决低层次特征提取及其图像匹配应用中的许多实际问题。SIFT算法主要包括两个阶段，一个是SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量；第二阶段是SIFT特征向量的匹配。SIFT方法中的低层次特征提取是选取那些显特征，这些特征具有图像尺度(特征大小)和旋转不变性，而且对光照变化也具有一定程度的不变性。此外，SIFT方法还可以减少由遮挡、杂乱和噪声所引起的低提取概率。</p>\n</li>\n<li>\n<p>加速鲁棒特征Surf（Speeded Up Robust Features）：Sift尺寸不变特征变换算法的优点是特征稳定，对旋转、尺度变换、亮度保持不变性，对视角变换、噪声也有一定程度的稳定性。缺点是实时性不高，并且对于边缘光滑目标的特征点提取能力较弱。<br />\nSurf改进了特征的提取和描述方式，用一种更为高效的方式完成特征的提取和描述。</p>\n</li>\n</ul>\n<h5 id=\"82形状基元\"><a class=\"markdownIt-Anchor\" href=\"#82形状基元\"></a> 8.2形状基元</h5>\n<ul>\n<li>前提假设：书写人被视为一个随机但服从某种规律的基元产生器。而笔迹书写过程可以看作多个基础基元零件被组成一个个文字的过程。当笔迹的字足够多时，每个基元零件出现的概率就可以用来表示书写人的特征。</li>\n<li><a href=\"#text77\">论文77</a>：利用聚类讨论可能对基元码本可能产生的影响</li>\n</ul>\n<h5 id=\"83深度学习特征\"><a class=\"markdownIt-Anchor\" href=\"#83深度学习特征\"></a> 8.3深度学习特征</h5>\n<ul>\n<li><a href=\"#text96\">论文96</a></li>\n</ul>\n<h4 id=\"9公共数据库\"><a class=\"markdownIt-Anchor\" href=\"#9公共数据库\"></a> 9.公共数据库</h4>\n<h5 id=\"91中科院casia数据集\"><a class=\"markdownIt-Anchor\" href=\"#91中科院casia数据集\"></a> 9.1中科院CASIA数据集</h5>\n<p>CASIA-OLHWDB1.0 ：手写单字，171 个英文数字符号，3866 个常用汉字(其中3740个属于GB2312 - -级汉字)，420套，分别为420个人书写。总共1,694,741个有效样本，分别存在420个POT文件中。</p>\n<p>CASIA-OLHWDB1.1 ：手写单字，171个英文数字符号，3755个GB2312级汉字，300套，分别为300个人书写。总共1,174,364个有效样本。分别存在300个POT文件中。</p>\n<p><a href=\"http://www.nlpr.ia.ac.cn/databases/handwriting/Download.html\" target=\"_blank\" rel=\"noopener\">下载地址</a>其他的数据集需要申请。</p>\n<h5 id=\"92哈工大hit-or3c数据集\"><a class=\"markdownIt-Anchor\" href=\"#92哈工大hit-or3c数据集\"></a> 9.2哈工大HIT-OR3C数据集</h5>\n<p>HIT-OR3C由5个子集组成 （GB1, GB2, Digit, Letter, 和Document），GB1和GB2是汉字标注库GB2312-80内2个子集的简写。GB1, GB2, Digit, 和 Letter子集已采集完成122套，共832,650 个手写汉字。Document子集包括10个从新浪网收集的文档，每个文档采集2套，共收集了20套。文档子集共有77,168个字符， 覆盖2,442个字符，其中2,286个来自GB1，97个来自GB2，49个来自Letter， 10个来自 Digit。</p>\n<p>[下载地址](<a href=\"http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C)\" target=\"_blank\" rel=\"noopener\">http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C)</a></p>\n<h5 id=\"93华南理工scutcouch-2009数据集\"><a class=\"markdownIt-Anchor\" href=\"#93华南理工scutcouch-2009数据集\"></a> 9.3华南理工SCUTCOUCH-2009数据集</h5>\n<p>SCUT-COUCH2009是一款包括12个子集的完整数据，它们分别是：中文词组、国标一级汉字、国标二级汉字、国标一级汉字对应的繁体字、汉语拼音、英文字母、阿拉伯数字、常用符号、Word8888、Word17366、Word44208和联机文本行数据。每套完整的SCUT-COUCH2009包括6,763个GB2312-80单汉字，5401个Big5繁体字，1384个和GB2312-80一级字库相对应的繁体字，8,888个常用的中文词组，17,366个常用中文词组，摘自《现代汉语大辞典》（第四版）的44,208个词组，2,010个汉语拼音，184个其他符号（包括字母、数字和常用符号）和8,809行联机文本行；现在版本的SCUT-COUCH2009使用PDA或手写屏进行采集，已完成了由190多人书写的完整的数据，字符总数超过3.6百万个。</p>\n<p><a href=\"http://www.hcii-lab.net/data/scutcouch/CN/download.html\" target=\"_blank\" rel=\"noopener\">下载地址</a>（需要申请）</p>\n<h4 id=\"10边缘共生对\"><a class=\"markdownIt-Anchor\" href=\"#10边缘共生对\"></a> 10.边缘共生对</h4>\n<p><strong>问题</strong>：怎样选择的边缘像素对，（45和135），（135和202.5）就是随便选的吗？为啥没有270度</p>\n<h4 id=\"11边缘共生特征与-sift-描述子直方图结合\"><a class=\"markdownIt-Anchor\" href=\"#11边缘共生特征与-sift-描述子直方图结合\"></a> 11.边缘共生特征与 SIFT 描述子直方图结合</h4>\n<ul>\n<li>\n<p>SIFT：SIFT即尺度不变特征变换，是用于图像处理领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种<strong>局部特征描述子</strong>。</p>\n</li>\n<li>\n<p>然后<strong>利用直方图</strong>统计领域内像素对应的梯度和幅值：梯度方向角为横轴刻度，取45度为一个单位，那么横轴就有8个刻度；纵轴是对应梯度的幅值累加值。</p>\n</li>\n<li>\n<p>SIFT算法特点：</p>\n<ul>\n<li>具有较好的稳定性和不变性，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰</li>\n<li>区分性好，能够在海量特征数据库中进行快速准确的区分信息进行匹配</li>\n<li>多量性，就算只有单个物体，也能产生大量特征向量</li>\n<li>高速性，能够快速的进行特征向量匹配</li>\n<li>可扩展性，能够与其它形式的特征向量进行联合</li>\n</ul>\n</li>\n<li>\n<p>在不同的尺度空间上查找关键点，并计算出关键点的方向</p>\n</li>\n</ul>\n<p><img src=\"https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-18%2016.05.50.png\" alt=\"\" /></p>\n<ul>\n<li>SIFT关键流程：</li>\n<li><strong>提取关键点</strong>：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的兴趣点。</li>\n<li><strong>定位关键点并确定特征方向</strong>：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。然后基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</li>\n<li><strong>通过各关键点的特征向量</strong>，进行两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。</li>\n<li><strong>最后用SIFT提取到的关键点与边缘元共生对融合特征，就完成了特征提取。</strong></li>\n</ul>\n"},{"title":"艾宾浩斯背单词","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"背单词","abbrlink":"9eeb","date":"2020-06-13T08:12:49.000Z","password":null,"_content":"---\n<center> <h2>英语单词复习计划表<h2></center>\n\n| 序号 | 学习日期 | 学   习     内   容 | 1天  | 2天  | 4天  | 7天  | 15天 | 1月  | 是否完成 |\n| ---- | -------- | ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | -------- |\n| 1    | 6月14日  | 恋恋有词第1章       | -    | -    | -    | -    | -    | -    |          |\n| 2    | 6月15日  | 恋恋有词第2章       | 1    | -    | -    | -    | -    | -    |          |\n| 3    | 6月16日  | 恋恋有词第3章       | 2    | 1    | -    | -    | -    | -    |          |\n| 4    | 6月17日  | 恋恋有词第4章       | 3    | 2    | -    | -    | -    | -    |          |\n| 5    | 6月18日  | 恋恋有词第5章       | 4    | 3    | 1    | -    | -    | -    |          |\n| 6    | 6月19日  | 恋恋有词第6章       | 5    | 4    | 2    | -    | -    | -    |          |\n| 7    | 6月20日  | 恋恋有词第7章       | 6    | 5    | 3    | -    | -    | -    |          |\n| 8    | 6月21日  | 恋恋有词第8章       | 7    | 6    | 4    | 1    | -    | -    |          |\n| 9    | 6月22日  | 恋恋有词第9章       | 8    | 7    | 5    | 2    | -    | -    |          |\n| 10   | 6月23日  | 恋恋有词第10章      | 9    | 8    | 6    | 3    | -    | -    |          |\n| 11   | 6月24日  | 恋恋有词第11章      | 10   | 9    | 7    | 4    | -    | -    |          |\n| 12   | 6月25日  | 恋恋有词第12章      | 11   | 10   | 8    | 5    | -    | -    |          |\n| 13   | 6月26日  | 恋恋有词第13章      | 12   | 11   | 9    | 6    | -    | -    |          |\n| 14   | 6月27日  | 恋恋有词第14章      | 13   | 12   | 10   | 7    | -    | -    |          |\n| 15   | 6月28日  | 恋恋有词第15章      | 14   | 13   | 11   | 8    | -    | -    |          |\n| 16   | 6月29日  | 恋恋有词第16章      | 15   | 14   | 12   | 9    | 1    | -    |          |\n| 17   | 6月30日  | 恋恋有词第17章      | 16   | 15   | 13   | 10   | 2    | -    |          |\n| 18   | 7月1日   | 恋恋有词第18章      | 17   | 16   | 14   | 11   | 3    | -    |          |\n| 19   | 7月2日   | 恋恋有词第19章      | 18   | 17   | 15   | 12   | 4    | -    |          |\n| 20   | 7月3日   | 恋恋有词第20章      | 19   | 18   | 16   | 13   | 5    | -    |          |\n| 21   | 7月4日   | 恋恋有词第21章      | 20   | 19   | 17   | 14   | 6    | -    |          |\n| 22   | 7月5日   | 恋恋有词第22章      | 21   | 20   | 18   | 15   | 7    | -    |          |\n| 23   | 7月6日   | 恋恋有词第23章      | 22   | 21   | 19   | 16   | 8    | -    |          |\n| 24   | 7月7日   | 恋恋有词第24章      | 23   | 22   | 20   | 17   | 9    | -    |          |\n| 25   | 7月8日   | 恋恋有词第25章      | 24   | 23   | 21   | 18   | 10   | -    |          |\n| 26   | 7月9日   | 恋恋有词第26章      | 25   | 24   | 22   | 19   | 11   | -    |          |\n| 27   | 7月10日  | 恋恋有词第27章      | 26   | 25   | 23   | 20   | 12   | -    |          |\n| 28   | 7月11日  | 恋恋有词第28章      | 27   | 26   | 24   | 21   | 13   | -    |          |\n| 29   | 7月12日  | 恋恋有词第29章      | 28   | 27   | 25   | 22   | 14   | -    |          |\n| 30   | 7月13日  | 恋恋有词第30章      | 29   | 28   | 26   | 23   | 15   | -    |          |\n| 31   | 7月14日  |                     | 30   | 29   | 27   | 24   | 16   | 1    |          |\n| 32   | 7月15日  |                     | 31   | 30   | 28   | 25   | 17   | 2    |          |\n| 33   | 7月16日  |                     | 32   | 31   | 29   | 26   | 18   | 3    |          |\n| 34   | 7月17日  |                     | 33   | 32   | 30   | 27   | 19   | 4    |          |\n| 35   | 7月18日  |                     | 34   | 33   | 31   | 28   | 20   | 5    |          |\n| 36   | 7月19日  |                     | 35   | 34   | 32   | 29   | 21   | 6    |          |\n| 37   | 7月20日  |                     | 36   | 35   | 33   | 30   | 22   | 7    |          |\n| 38   | 7月21日  |                     | 37   | 36   | 34   | 31   | 23   | 8    |          |\n| 39   | 7月22日  |                     | 38   | 37   | 35   | 32   | 24   | 9    |          |\n| 40   | 7月23日  |                     | 39   | 38   | 36   | 33   | 25   | 10   |          |\n| 41   | 7月24日  |                     | 40   | 39   | 37   | 34   | 26   | 11   |          |\n| 42   | 7月25日  |                     | 41   | 40   | 38   | 35   | 27   | 12   |          |\n| 43   | 7月26日  |                     | 42   | 41   | 39   | 36   | 28   | 13   |          |\n| 44   | 7月27日  |                     | 43   | 42   | 40   | 37   | 29   | 14   |          |\n| 45   | 7月28日  |                     | 44   | 43   | 41   | 38   | 30   | 15   |          |\n| 46   | 7月29日  |                     | 45   | 44   | 42   | 39   | 31   | 16   |          |\n| 47   | 7月30日  |                     | 46   | 45   | 43   | 40   | 32   | 17   |          |\n| 48   | 7月31日  |                     | 47   | 46   | 44   | 41   | 33   | 18   |          |\n| 49   | 8月1日   |                     | 48   | 47   | 45   | 42   | 34   | 19   |          |\n| 50   | 8月2日   |                     | 49   | 48   | 46   | 43   | 35   | 20   |          |\n| 51   | 8月3日   |                     | 50   | 49   | 47   | 44   | 36   | 21   |          |\n| 52   | 8月4日   |                     | 51   | 50   | 48   | 45   | 37   | 22   |          |\n| 53   | 8月5日   |                     | 52   | 51   | 49   | 46   | 38   | 23   |          |\n| 54   | 8月6日   |                     | 53   | 52   | 50   | 47   | 39   | 24   |          |\n| 55   | 8月7日   |                     | 54   | 53   | 51   | 48   | 40   | 25   |          |\n| 56   | 8月8日   |                     | 55   | 54   | 52   | 49   | 41   | 26   |          |\n| 57   | 8月9日   |                     | 56   | 55   | 53   | 50   | 42   | 27   |          |\n| 58   | 8月10日  |                     | 57   | 56   | 54   | 51   | 43   | 28   |          |\n| 59   | 8月11日  |                     | 58   | 57   | 55   | 52   | 44   | 29   |          |\n| 60   | 8月12日  |                     | 59   | 58   | 56   | 53   | 45   | 30   |          |\n","source":"_posts/艾宾浩斯背单词.md","raw":"---\ntitle: 艾宾浩斯背单词\ntop: false\ncover: false\ntoc: false\nmathjax: true\nsummary: 背单词\ntags:\n  - 考研\n  - 计划\n  - 男男\n  - 菁菁\ncategories:\n  - 考研\nabbrlink: 9eeb\ndate: 2020-06-13 16:12:49\npassword:\n---\n---\n<center> <h2>英语单词复习计划表<h2></center>\n\n| 序号 | 学习日期 | 学   习     内   容 | 1天  | 2天  | 4天  | 7天  | 15天 | 1月  | 是否完成 |\n| ---- | -------- | ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | -------- |\n| 1    | 6月14日  | 恋恋有词第1章       | -    | -    | -    | -    | -    | -    |          |\n| 2    | 6月15日  | 恋恋有词第2章       | 1    | -    | -    | -    | -    | -    |          |\n| 3    | 6月16日  | 恋恋有词第3章       | 2    | 1    | -    | -    | -    | -    |          |\n| 4    | 6月17日  | 恋恋有词第4章       | 3    | 2    | -    | -    | -    | -    |          |\n| 5    | 6月18日  | 恋恋有词第5章       | 4    | 3    | 1    | -    | -    | -    |          |\n| 6    | 6月19日  | 恋恋有词第6章       | 5    | 4    | 2    | -    | -    | -    |          |\n| 7    | 6月20日  | 恋恋有词第7章       | 6    | 5    | 3    | -    | -    | -    |          |\n| 8    | 6月21日  | 恋恋有词第8章       | 7    | 6    | 4    | 1    | -    | -    |          |\n| 9    | 6月22日  | 恋恋有词第9章       | 8    | 7    | 5    | 2    | -    | -    |          |\n| 10   | 6月23日  | 恋恋有词第10章      | 9    | 8    | 6    | 3    | -    | -    |          |\n| 11   | 6月24日  | 恋恋有词第11章      | 10   | 9    | 7    | 4    | -    | -    |          |\n| 12   | 6月25日  | 恋恋有词第12章      | 11   | 10   | 8    | 5    | -    | -    |          |\n| 13   | 6月26日  | 恋恋有词第13章      | 12   | 11   | 9    | 6    | -    | -    |          |\n| 14   | 6月27日  | 恋恋有词第14章      | 13   | 12   | 10   | 7    | -    | -    |          |\n| 15   | 6月28日  | 恋恋有词第15章      | 14   | 13   | 11   | 8    | -    | -    |          |\n| 16   | 6月29日  | 恋恋有词第16章      | 15   | 14   | 12   | 9    | 1    | -    |          |\n| 17   | 6月30日  | 恋恋有词第17章      | 16   | 15   | 13   | 10   | 2    | -    |          |\n| 18   | 7月1日   | 恋恋有词第18章      | 17   | 16   | 14   | 11   | 3    | -    |          |\n| 19   | 7月2日   | 恋恋有词第19章      | 18   | 17   | 15   | 12   | 4    | -    |          |\n| 20   | 7月3日   | 恋恋有词第20章      | 19   | 18   | 16   | 13   | 5    | -    |          |\n| 21   | 7月4日   | 恋恋有词第21章      | 20   | 19   | 17   | 14   | 6    | -    |          |\n| 22   | 7月5日   | 恋恋有词第22章      | 21   | 20   | 18   | 15   | 7    | -    |          |\n| 23   | 7月6日   | 恋恋有词第23章      | 22   | 21   | 19   | 16   | 8    | -    |          |\n| 24   | 7月7日   | 恋恋有词第24章      | 23   | 22   | 20   | 17   | 9    | -    |          |\n| 25   | 7月8日   | 恋恋有词第25章      | 24   | 23   | 21   | 18   | 10   | -    |          |\n| 26   | 7月9日   | 恋恋有词第26章      | 25   | 24   | 22   | 19   | 11   | -    |          |\n| 27   | 7月10日  | 恋恋有词第27章      | 26   | 25   | 23   | 20   | 12   | -    |          |\n| 28   | 7月11日  | 恋恋有词第28章      | 27   | 26   | 24   | 21   | 13   | -    |          |\n| 29   | 7月12日  | 恋恋有词第29章      | 28   | 27   | 25   | 22   | 14   | -    |          |\n| 30   | 7月13日  | 恋恋有词第30章      | 29   | 28   | 26   | 23   | 15   | -    |          |\n| 31   | 7月14日  |                     | 30   | 29   | 27   | 24   | 16   | 1    |          |\n| 32   | 7月15日  |                     | 31   | 30   | 28   | 25   | 17   | 2    |          |\n| 33   | 7月16日  |                     | 32   | 31   | 29   | 26   | 18   | 3    |          |\n| 34   | 7月17日  |                     | 33   | 32   | 30   | 27   | 19   | 4    |          |\n| 35   | 7月18日  |                     | 34   | 33   | 31   | 28   | 20   | 5    |          |\n| 36   | 7月19日  |                     | 35   | 34   | 32   | 29   | 21   | 6    |          |\n| 37   | 7月20日  |                     | 36   | 35   | 33   | 30   | 22   | 7    |          |\n| 38   | 7月21日  |                     | 37   | 36   | 34   | 31   | 23   | 8    |          |\n| 39   | 7月22日  |                     | 38   | 37   | 35   | 32   | 24   | 9    |          |\n| 40   | 7月23日  |                     | 39   | 38   | 36   | 33   | 25   | 10   |          |\n| 41   | 7月24日  |                     | 40   | 39   | 37   | 34   | 26   | 11   |          |\n| 42   | 7月25日  |                     | 41   | 40   | 38   | 35   | 27   | 12   |          |\n| 43   | 7月26日  |                     | 42   | 41   | 39   | 36   | 28   | 13   |          |\n| 44   | 7月27日  |                     | 43   | 42   | 40   | 37   | 29   | 14   |          |\n| 45   | 7月28日  |                     | 44   | 43   | 41   | 38   | 30   | 15   |          |\n| 46   | 7月29日  |                     | 45   | 44   | 42   | 39   | 31   | 16   |          |\n| 47   | 7月30日  |                     | 46   | 45   | 43   | 40   | 32   | 17   |          |\n| 48   | 7月31日  |                     | 47   | 46   | 44   | 41   | 33   | 18   |          |\n| 49   | 8月1日   |                     | 48   | 47   | 45   | 42   | 34   | 19   |          |\n| 50   | 8月2日   |                     | 49   | 48   | 46   | 43   | 35   | 20   |          |\n| 51   | 8月3日   |                     | 50   | 49   | 47   | 44   | 36   | 21   |          |\n| 52   | 8月4日   |                     | 51   | 50   | 48   | 45   | 37   | 22   |          |\n| 53   | 8月5日   |                     | 52   | 51   | 49   | 46   | 38   | 23   |          |\n| 54   | 8月6日   |                     | 53   | 52   | 50   | 47   | 39   | 24   |          |\n| 55   | 8月7日   |                     | 54   | 53   | 51   | 48   | 40   | 25   |          |\n| 56   | 8月8日   |                     | 55   | 54   | 52   | 49   | 41   | 26   |          |\n| 57   | 8月9日   |                     | 56   | 55   | 53   | 50   | 42   | 27   |          |\n| 58   | 8月10日  |                     | 57   | 56   | 54   | 51   | 43   | 28   |          |\n| 59   | 8月11日  |                     | 58   | 57   | 55   | 52   | 44   | 29   |          |\n| 60   | 8月12日  |                     | 59   | 58   | 56   | 53   | 45   | 30   |          |\n","slug":"艾宾浩斯背单词","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q65004ja09k58e26of5","content":"<hr>\n<center> <h2>英语单词复习计划表</h2><h2></h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>学习日期</th>\n<th>学   习     内   容</th>\n<th>1天</th>\n<th>2天</th>\n<th>4天</th>\n<th>7天</th>\n<th>15天</th>\n<th>1月</th>\n<th>是否完成</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>6月14日</td>\n<td>恋恋有词第1章</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>6月15日</td>\n<td>恋恋有词第2章</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>6月16日</td>\n<td>恋恋有词第3章</td>\n<td>2</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>6月17日</td>\n<td>恋恋有词第4章</td>\n<td>3</td>\n<td>2</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>6月18日</td>\n<td>恋恋有词第5章</td>\n<td>4</td>\n<td>3</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>6月19日</td>\n<td>恋恋有词第6章</td>\n<td>5</td>\n<td>4</td>\n<td>2</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>6月20日</td>\n<td>恋恋有词第7章</td>\n<td>6</td>\n<td>5</td>\n<td>3</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>6月21日</td>\n<td>恋恋有词第8章</td>\n<td>7</td>\n<td>6</td>\n<td>4</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>6月22日</td>\n<td>恋恋有词第9章</td>\n<td>8</td>\n<td>7</td>\n<td>5</td>\n<td>2</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>6月23日</td>\n<td>恋恋有词第10章</td>\n<td>9</td>\n<td>8</td>\n<td>6</td>\n<td>3</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>6月24日</td>\n<td>恋恋有词第11章</td>\n<td>10</td>\n<td>9</td>\n<td>7</td>\n<td>4</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>6月25日</td>\n<td>恋恋有词第12章</td>\n<td>11</td>\n<td>10</td>\n<td>8</td>\n<td>5</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>6月26日</td>\n<td>恋恋有词第13章</td>\n<td>12</td>\n<td>11</td>\n<td>9</td>\n<td>6</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>6月27日</td>\n<td>恋恋有词第14章</td>\n<td>13</td>\n<td>12</td>\n<td>10</td>\n<td>7</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>6月28日</td>\n<td>恋恋有词第15章</td>\n<td>14</td>\n<td>13</td>\n<td>11</td>\n<td>8</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>6月29日</td>\n<td>恋恋有词第16章</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>9</td>\n<td>1</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>6月30日</td>\n<td>恋恋有词第17章</td>\n<td>16</td>\n<td>15</td>\n<td>13</td>\n<td>10</td>\n<td>2</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>7月1日</td>\n<td>恋恋有词第18章</td>\n<td>17</td>\n<td>16</td>\n<td>14</td>\n<td>11</td>\n<td>3</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>7月2日</td>\n<td>恋恋有词第19章</td>\n<td>18</td>\n<td>17</td>\n<td>15</td>\n<td>12</td>\n<td>4</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>7月3日</td>\n<td>恋恋有词第20章</td>\n<td>19</td>\n<td>18</td>\n<td>16</td>\n<td>13</td>\n<td>5</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>7月4日</td>\n<td>恋恋有词第21章</td>\n<td>20</td>\n<td>19</td>\n<td>17</td>\n<td>14</td>\n<td>6</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>7月5日</td>\n<td>恋恋有词第22章</td>\n<td>21</td>\n<td>20</td>\n<td>18</td>\n<td>15</td>\n<td>7</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>7月6日</td>\n<td>恋恋有词第23章</td>\n<td>22</td>\n<td>21</td>\n<td>19</td>\n<td>16</td>\n<td>8</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>7月7日</td>\n<td>恋恋有词第24章</td>\n<td>23</td>\n<td>22</td>\n<td>20</td>\n<td>17</td>\n<td>9</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>7月8日</td>\n<td>恋恋有词第25章</td>\n<td>24</td>\n<td>23</td>\n<td>21</td>\n<td>18</td>\n<td>10</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>7月9日</td>\n<td>恋恋有词第26章</td>\n<td>25</td>\n<td>24</td>\n<td>22</td>\n<td>19</td>\n<td>11</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>7月10日</td>\n<td>恋恋有词第27章</td>\n<td>26</td>\n<td>25</td>\n<td>23</td>\n<td>20</td>\n<td>12</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>7月11日</td>\n<td>恋恋有词第28章</td>\n<td>27</td>\n<td>26</td>\n<td>24</td>\n<td>21</td>\n<td>13</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>7月12日</td>\n<td>恋恋有词第29章</td>\n<td>28</td>\n<td>27</td>\n<td>25</td>\n<td>22</td>\n<td>14</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>7月13日</td>\n<td>恋恋有词第30章</td>\n<td>29</td>\n<td>28</td>\n<td>26</td>\n<td>23</td>\n<td>15</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>7月14日</td>\n<td></td>\n<td>30</td>\n<td>29</td>\n<td>27</td>\n<td>24</td>\n<td>16</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>7月15日</td>\n<td></td>\n<td>31</td>\n<td>30</td>\n<td>28</td>\n<td>25</td>\n<td>17</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>7月16日</td>\n<td></td>\n<td>32</td>\n<td>31</td>\n<td>29</td>\n<td>26</td>\n<td>18</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>7月17日</td>\n<td></td>\n<td>33</td>\n<td>32</td>\n<td>30</td>\n<td>27</td>\n<td>19</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>7月18日</td>\n<td></td>\n<td>34</td>\n<td>33</td>\n<td>31</td>\n<td>28</td>\n<td>20</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>7月19日</td>\n<td></td>\n<td>35</td>\n<td>34</td>\n<td>32</td>\n<td>29</td>\n<td>21</td>\n<td>6</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>7月20日</td>\n<td></td>\n<td>36</td>\n<td>35</td>\n<td>33</td>\n<td>30</td>\n<td>22</td>\n<td>7</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>7月21日</td>\n<td></td>\n<td>37</td>\n<td>36</td>\n<td>34</td>\n<td>31</td>\n<td>23</td>\n<td>8</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>7月22日</td>\n<td></td>\n<td>38</td>\n<td>37</td>\n<td>35</td>\n<td>32</td>\n<td>24</td>\n<td>9</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>7月23日</td>\n<td></td>\n<td>39</td>\n<td>38</td>\n<td>36</td>\n<td>33</td>\n<td>25</td>\n<td>10</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>7月24日</td>\n<td></td>\n<td>40</td>\n<td>39</td>\n<td>37</td>\n<td>34</td>\n<td>26</td>\n<td>11</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>7月25日</td>\n<td></td>\n<td>41</td>\n<td>40</td>\n<td>38</td>\n<td>35</td>\n<td>27</td>\n<td>12</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>7月26日</td>\n<td></td>\n<td>42</td>\n<td>41</td>\n<td>39</td>\n<td>36</td>\n<td>28</td>\n<td>13</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>7月27日</td>\n<td></td>\n<td>43</td>\n<td>42</td>\n<td>40</td>\n<td>37</td>\n<td>29</td>\n<td>14</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>7月28日</td>\n<td></td>\n<td>44</td>\n<td>43</td>\n<td>41</td>\n<td>38</td>\n<td>30</td>\n<td>15</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>7月29日</td>\n<td></td>\n<td>45</td>\n<td>44</td>\n<td>42</td>\n<td>39</td>\n<td>31</td>\n<td>16</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>7月30日</td>\n<td></td>\n<td>46</td>\n<td>45</td>\n<td>43</td>\n<td>40</td>\n<td>32</td>\n<td>17</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td>7月31日</td>\n<td></td>\n<td>47</td>\n<td>46</td>\n<td>44</td>\n<td>41</td>\n<td>33</td>\n<td>18</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td>8月1日</td>\n<td></td>\n<td>48</td>\n<td>47</td>\n<td>45</td>\n<td>42</td>\n<td>34</td>\n<td>19</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td>8月2日</td>\n<td></td>\n<td>49</td>\n<td>48</td>\n<td>46</td>\n<td>43</td>\n<td>35</td>\n<td>20</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td>8月3日</td>\n<td></td>\n<td>50</td>\n<td>49</td>\n<td>47</td>\n<td>44</td>\n<td>36</td>\n<td>21</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>8月4日</td>\n<td></td>\n<td>51</td>\n<td>50</td>\n<td>48</td>\n<td>45</td>\n<td>37</td>\n<td>22</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>8月5日</td>\n<td></td>\n<td>52</td>\n<td>51</td>\n<td>49</td>\n<td>46</td>\n<td>38</td>\n<td>23</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>8月6日</td>\n<td></td>\n<td>53</td>\n<td>52</td>\n<td>50</td>\n<td>47</td>\n<td>39</td>\n<td>24</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>8月7日</td>\n<td></td>\n<td>54</td>\n<td>53</td>\n<td>51</td>\n<td>48</td>\n<td>40</td>\n<td>25</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td>8月8日</td>\n<td></td>\n<td>55</td>\n<td>54</td>\n<td>52</td>\n<td>49</td>\n<td>41</td>\n<td>26</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>8月9日</td>\n<td></td>\n<td>56</td>\n<td>55</td>\n<td>53</td>\n<td>50</td>\n<td>42</td>\n<td>27</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>8月10日</td>\n<td></td>\n<td>57</td>\n<td>56</td>\n<td>54</td>\n<td>51</td>\n<td>43</td>\n<td>28</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>8月11日</td>\n<td></td>\n<td>58</td>\n<td>57</td>\n<td>55</td>\n<td>52</td>\n<td>44</td>\n<td>29</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>8月12日</td>\n<td></td>\n<td>59</td>\n<td>58</td>\n<td>56</td>\n<td>53</td>\n<td>45</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n</div>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<hr>\n<center> <h2>英语单词复习计划表<h2></center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>学习日期</th>\n<th>学   习     内   容</th>\n<th>1天</th>\n<th>2天</th>\n<th>4天</th>\n<th>7天</th>\n<th>15天</th>\n<th>1月</th>\n<th>是否完成</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>6月14日</td>\n<td>恋恋有词第1章</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>6月15日</td>\n<td>恋恋有词第2章</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>6月16日</td>\n<td>恋恋有词第3章</td>\n<td>2</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>6月17日</td>\n<td>恋恋有词第4章</td>\n<td>3</td>\n<td>2</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>6月18日</td>\n<td>恋恋有词第5章</td>\n<td>4</td>\n<td>3</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>6月19日</td>\n<td>恋恋有词第6章</td>\n<td>5</td>\n<td>4</td>\n<td>2</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>6月20日</td>\n<td>恋恋有词第7章</td>\n<td>6</td>\n<td>5</td>\n<td>3</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>6月21日</td>\n<td>恋恋有词第8章</td>\n<td>7</td>\n<td>6</td>\n<td>4</td>\n<td>1</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>6月22日</td>\n<td>恋恋有词第9章</td>\n<td>8</td>\n<td>7</td>\n<td>5</td>\n<td>2</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>6月23日</td>\n<td>恋恋有词第10章</td>\n<td>9</td>\n<td>8</td>\n<td>6</td>\n<td>3</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>6月24日</td>\n<td>恋恋有词第11章</td>\n<td>10</td>\n<td>9</td>\n<td>7</td>\n<td>4</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>6月25日</td>\n<td>恋恋有词第12章</td>\n<td>11</td>\n<td>10</td>\n<td>8</td>\n<td>5</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>6月26日</td>\n<td>恋恋有词第13章</td>\n<td>12</td>\n<td>11</td>\n<td>9</td>\n<td>6</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>6月27日</td>\n<td>恋恋有词第14章</td>\n<td>13</td>\n<td>12</td>\n<td>10</td>\n<td>7</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>6月28日</td>\n<td>恋恋有词第15章</td>\n<td>14</td>\n<td>13</td>\n<td>11</td>\n<td>8</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>6月29日</td>\n<td>恋恋有词第16章</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>9</td>\n<td>1</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>6月30日</td>\n<td>恋恋有词第17章</td>\n<td>16</td>\n<td>15</td>\n<td>13</td>\n<td>10</td>\n<td>2</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>7月1日</td>\n<td>恋恋有词第18章</td>\n<td>17</td>\n<td>16</td>\n<td>14</td>\n<td>11</td>\n<td>3</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>7月2日</td>\n<td>恋恋有词第19章</td>\n<td>18</td>\n<td>17</td>\n<td>15</td>\n<td>12</td>\n<td>4</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>7月3日</td>\n<td>恋恋有词第20章</td>\n<td>19</td>\n<td>18</td>\n<td>16</td>\n<td>13</td>\n<td>5</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>7月4日</td>\n<td>恋恋有词第21章</td>\n<td>20</td>\n<td>19</td>\n<td>17</td>\n<td>14</td>\n<td>6</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>7月5日</td>\n<td>恋恋有词第22章</td>\n<td>21</td>\n<td>20</td>\n<td>18</td>\n<td>15</td>\n<td>7</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>7月6日</td>\n<td>恋恋有词第23章</td>\n<td>22</td>\n<td>21</td>\n<td>19</td>\n<td>16</td>\n<td>8</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>7月7日</td>\n<td>恋恋有词第24章</td>\n<td>23</td>\n<td>22</td>\n<td>20</td>\n<td>17</td>\n<td>9</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>7月8日</td>\n<td>恋恋有词第25章</td>\n<td>24</td>\n<td>23</td>\n<td>21</td>\n<td>18</td>\n<td>10</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>7月9日</td>\n<td>恋恋有词第26章</td>\n<td>25</td>\n<td>24</td>\n<td>22</td>\n<td>19</td>\n<td>11</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>7月10日</td>\n<td>恋恋有词第27章</td>\n<td>26</td>\n<td>25</td>\n<td>23</td>\n<td>20</td>\n<td>12</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>7月11日</td>\n<td>恋恋有词第28章</td>\n<td>27</td>\n<td>26</td>\n<td>24</td>\n<td>21</td>\n<td>13</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>7月12日</td>\n<td>恋恋有词第29章</td>\n<td>28</td>\n<td>27</td>\n<td>25</td>\n<td>22</td>\n<td>14</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>7月13日</td>\n<td>恋恋有词第30章</td>\n<td>29</td>\n<td>28</td>\n<td>26</td>\n<td>23</td>\n<td>15</td>\n<td>-</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>7月14日</td>\n<td></td>\n<td>30</td>\n<td>29</td>\n<td>27</td>\n<td>24</td>\n<td>16</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>7月15日</td>\n<td></td>\n<td>31</td>\n<td>30</td>\n<td>28</td>\n<td>25</td>\n<td>17</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>7月16日</td>\n<td></td>\n<td>32</td>\n<td>31</td>\n<td>29</td>\n<td>26</td>\n<td>18</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>7月17日</td>\n<td></td>\n<td>33</td>\n<td>32</td>\n<td>30</td>\n<td>27</td>\n<td>19</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>7月18日</td>\n<td></td>\n<td>34</td>\n<td>33</td>\n<td>31</td>\n<td>28</td>\n<td>20</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>7月19日</td>\n<td></td>\n<td>35</td>\n<td>34</td>\n<td>32</td>\n<td>29</td>\n<td>21</td>\n<td>6</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>7月20日</td>\n<td></td>\n<td>36</td>\n<td>35</td>\n<td>33</td>\n<td>30</td>\n<td>22</td>\n<td>7</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>7月21日</td>\n<td></td>\n<td>37</td>\n<td>36</td>\n<td>34</td>\n<td>31</td>\n<td>23</td>\n<td>8</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>7月22日</td>\n<td></td>\n<td>38</td>\n<td>37</td>\n<td>35</td>\n<td>32</td>\n<td>24</td>\n<td>9</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>7月23日</td>\n<td></td>\n<td>39</td>\n<td>38</td>\n<td>36</td>\n<td>33</td>\n<td>25</td>\n<td>10</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>7月24日</td>\n<td></td>\n<td>40</td>\n<td>39</td>\n<td>37</td>\n<td>34</td>\n<td>26</td>\n<td>11</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>7月25日</td>\n<td></td>\n<td>41</td>\n<td>40</td>\n<td>38</td>\n<td>35</td>\n<td>27</td>\n<td>12</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>7月26日</td>\n<td></td>\n<td>42</td>\n<td>41</td>\n<td>39</td>\n<td>36</td>\n<td>28</td>\n<td>13</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>7月27日</td>\n<td></td>\n<td>43</td>\n<td>42</td>\n<td>40</td>\n<td>37</td>\n<td>29</td>\n<td>14</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>7月28日</td>\n<td></td>\n<td>44</td>\n<td>43</td>\n<td>41</td>\n<td>38</td>\n<td>30</td>\n<td>15</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>7月29日</td>\n<td></td>\n<td>45</td>\n<td>44</td>\n<td>42</td>\n<td>39</td>\n<td>31</td>\n<td>16</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>7月30日</td>\n<td></td>\n<td>46</td>\n<td>45</td>\n<td>43</td>\n<td>40</td>\n<td>32</td>\n<td>17</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td>7月31日</td>\n<td></td>\n<td>47</td>\n<td>46</td>\n<td>44</td>\n<td>41</td>\n<td>33</td>\n<td>18</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td>8月1日</td>\n<td></td>\n<td>48</td>\n<td>47</td>\n<td>45</td>\n<td>42</td>\n<td>34</td>\n<td>19</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td>8月2日</td>\n<td></td>\n<td>49</td>\n<td>48</td>\n<td>46</td>\n<td>43</td>\n<td>35</td>\n<td>20</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td>8月3日</td>\n<td></td>\n<td>50</td>\n<td>49</td>\n<td>47</td>\n<td>44</td>\n<td>36</td>\n<td>21</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>8月4日</td>\n<td></td>\n<td>51</td>\n<td>50</td>\n<td>48</td>\n<td>45</td>\n<td>37</td>\n<td>22</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>8月5日</td>\n<td></td>\n<td>52</td>\n<td>51</td>\n<td>49</td>\n<td>46</td>\n<td>38</td>\n<td>23</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>8月6日</td>\n<td></td>\n<td>53</td>\n<td>52</td>\n<td>50</td>\n<td>47</td>\n<td>39</td>\n<td>24</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>8月7日</td>\n<td></td>\n<td>54</td>\n<td>53</td>\n<td>51</td>\n<td>48</td>\n<td>40</td>\n<td>25</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td>8月8日</td>\n<td></td>\n<td>55</td>\n<td>54</td>\n<td>52</td>\n<td>49</td>\n<td>41</td>\n<td>26</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>8月9日</td>\n<td></td>\n<td>56</td>\n<td>55</td>\n<td>53</td>\n<td>50</td>\n<td>42</td>\n<td>27</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>8月10日</td>\n<td></td>\n<td>57</td>\n<td>56</td>\n<td>54</td>\n<td>51</td>\n<td>43</td>\n<td>28</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>8月11日</td>\n<td></td>\n<td>58</td>\n<td>57</td>\n<td>55</td>\n<td>52</td>\n<td>44</td>\n<td>29</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>8月12日</td>\n<td></td>\n<td>59</td>\n<td>58</td>\n<td>56</td>\n<td>53</td>\n<td>45</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"菁菁学习计划","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"学习计划","abbrlink":"7930","date":"2020-06-08T06:16:39.000Z","password":null,"_content":"## 总计划 \n![](1.png)\n## 每日计划\n![](2.png)","source":"_posts/菁菁学习计划.md","raw":"---\ntitle: 菁菁学习计划\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 学习计划\ntags:\n  - 考研\n  - 计划\ncategories:\n  - 菁菁\nabbrlink: '7930'\ndate: 2020-06-08 14:16:39\npassword:\n---\n## 总计划 \n![](1.png)\n## 每日计划\n![](2.png)","slug":"菁菁学习计划","published":1,"updated":"2020-08-10T12:34:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q66004oa09kgqry1kaz","content":"<h2 id=\"总计划\"><a href=\"#总计划\" class=\"headerlink\" title=\"总计划\"></a>总计划</h2><p><img src=\"1.png\" alt=\"\"></p>\n<h2 id=\"每日计划\"><a href=\"#每日计划\" class=\"headerlink\" title=\"每日计划\"></a>每日计划</h2><p><img src=\"2.png\" alt=\"\"></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"总计划\"><a href=\"#总计划\" class=\"headerlink\" title=\"总计划\"></a>总计划</h2><p><img src=\"1.png\" alt=\"\"></p>\n<h2 id=\"每日计划\"><a href=\"#每日计划\" class=\"headerlink\" title=\"每日计划\"></a>每日计划</h2><p><img src=\"2.png\" alt=\"\"></p>\n"},{"title":"爬虫数据库bug","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"爬虫数据存入数据库bug修改","abbrlink":"5fd7","date":"2021-05-17T05:32:24.000Z","password":null,"keywords":null,"description":null,"_content":"# 爬虫数据存入数据库bug修改\n\n- 问题：微博所有数据爬取正常，但存入数据库的数据很少，有时还会重复获取同一时间段的文章，导致微博ID一样，无法存入数据库\n- 解决：修改search.py的parse_by_hour为：\n\n```python\n    def parse_by_hour(self, response):\n        \"\"\"以小时为单位筛选\"\"\"\n        keyword = response.meta.get('keyword')\n        is_empty = response.xpath(\n            '//div[@class=\"card card-no-result s-pt20b40\"]')\n        if is_empty:\n            print('当前页面搜索结果为空')\n        else:\n            # 解析当前页面\n            for weibo in self.parse_weibo(response):\n                self.check_environment()\n                yield weibo\n            next_url = response.xpath(\n                '//a[@class=\"next\"]/@href').extract_first()\n            if next_url:\n                next_url = self.base_url + next_url\n                yield scrapy.Request(url=next_url,\n                                     callback=self.parse_page,\n                                     meta={'keyword': keyword})\n```\n\n","source":"_posts/爬虫数据库bug.md","raw":"---\ntitle: 爬虫数据库bug\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - bug\n  - 爬虫\n  - 项目\ncategories:\n  - bug\nsummary: 爬虫数据存入数据库bug修改\nabbrlink: 5fd7\ndate: 2021-05-17 13:32:24\npassword:\nkeywords:\ndescription:\n---\n# 爬虫数据存入数据库bug修改\n\n- 问题：微博所有数据爬取正常，但存入数据库的数据很少，有时还会重复获取同一时间段的文章，导致微博ID一样，无法存入数据库\n- 解决：修改search.py的parse_by_hour为：\n\n```python\n    def parse_by_hour(self, response):\n        \"\"\"以小时为单位筛选\"\"\"\n        keyword = response.meta.get('keyword')\n        is_empty = response.xpath(\n            '//div[@class=\"card card-no-result s-pt20b40\"]')\n        if is_empty:\n            print('当前页面搜索结果为空')\n        else:\n            # 解析当前页面\n            for weibo in self.parse_weibo(response):\n                self.check_environment()\n                yield weibo\n            next_url = response.xpath(\n                '//a[@class=\"next\"]/@href').extract_first()\n            if next_url:\n                next_url = self.base_url + next_url\n                yield scrapy.Request(url=next_url,\n                                     callback=self.parse_page,\n                                     meta={'keyword': keyword})\n```\n\n","slug":"爬虫数据库bug","published":1,"updated":"2021-05-17T05:39:53.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q66004ra09k8lq08vos","content":"<h1 id=\"爬虫数据存入数据库bug修改\"><a href=\"#爬虫数据存入数据库bug修改\" class=\"headerlink\" title=\"爬虫数据存入数据库bug修改\"></a>爬虫数据存入数据库bug修改</h1><ul>\n<li>问题：微博所有数据爬取正常，但存入数据库的数据很少，有时还会重复获取同一时间段的文章，导致微博ID一样，无法存入数据库</li>\n<li>解决：修改search.py的parse_by_hour为：</li>\n</ul>\n<pre class=\"line-numbers language-lang-python\"><code class=\"language-lang-python\">    def parse_by_hour(self, response):\n        \"\"\"以小时为单位筛选\"\"\"\n        keyword = response.meta.get('keyword')\n        is_empty = response.xpath(\n            '//div[@class=\"card card-no-result s-pt20b40\"]')\n        if is_empty:\n            print('当前页面搜索结果为空')\n        else:\n            # 解析当前页面\n            for weibo in self.parse_weibo(response):\n                self.check_environment()\n                yield weibo\n            next_url = response.xpath(\n                '//a[@class=\"next\"]/@href').extract_first()\n            if next_url:\n                next_url = self.base_url + next_url\n                yield scrapy.Request(url=next_url,\n                                     callback=self.parse_page,\n                                     meta={'keyword': keyword})\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"爬虫数据存入数据库bug修改\"><a href=\"#爬虫数据存入数据库bug修改\" class=\"headerlink\" title=\"爬虫数据存入数据库bug修改\"></a>爬虫数据存入数据库bug修改</h1><ul>\n<li>问题：微博所有数据爬取正常，但存入数据库的数据很少，有时还会重复获取同一时间段的文章，导致微博ID一样，无法存入数据库</li>\n<li>解决：修改search.py的parse_by_hour为：</li>\n</ul>\n<pre><code class=\"lang-python\">    def parse_by_hour(self, response):\n        &quot;&quot;&quot;以小时为单位筛选&quot;&quot;&quot;\n        keyword = response.meta.get(&#39;keyword&#39;)\n        is_empty = response.xpath(\n            &#39;//div[@class=&quot;card card-no-result s-pt20b40&quot;]&#39;)\n        if is_empty:\n            print(&#39;当前页面搜索结果为空&#39;)\n        else:\n            # 解析当前页面\n            for weibo in self.parse_weibo(response):\n                self.check_environment()\n                yield weibo\n            next_url = response.xpath(\n                &#39;//a[@class=&quot;next&quot;]/@href&#39;).extract_first()\n            if next_url:\n                next_url = self.base_url + next_url\n                yield scrapy.Request(url=next_url,\n                                     callback=self.parse_page,\n                                     meta={&#39;keyword&#39;: keyword})\n</code></pre>\n"},{"title":"爬虫部署","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"爬虫部署API服务","abbrlink":"b77d","date":"2021-05-17T05:15:19.000Z","password":null,"keywords":null,"description":null,"_content":"# 爬虫部署API服务\n\n### 1. 部署流程\n\n```bash\n# 安装scrapyd框架，用于部署scrapy框架的服务，可将其转化为API接口的形式去运行以及配置参数\n$ pip install scrapyd\n# 在项目根目录下先运行scrapyd，单独运行在一个终端中，这里将显示访问接口的信息\n$ scrapyd\n# 更改scrapy.cfg中[deploy]，更改为[deploy:first_deploy]，启动服务后可以看见部署服务的名称，first_deploy         http://localhost:6800\n$ scrapyd-deploy -l\n# 再执行list语句，显示出scrapy的spider名称MyMooc，即为打包成功\n$ scrapy list\n# 开始项目部署，这个命令会将项目打包成egg文件，会在根目录下创建一个setup.py，会返回一个addversion.json，出现即为部署成功\n$ scrapyd-deploy (部署名称)first_deploy -p (项目名称)MyMooc\n# 运行一次代码，\n$ curl http://localhost:6800/schedule.json -d project=first_deploy -d spider=MyMooc\n\n# 定义变量\n# 加入可选参数，这样在运行scrapy crawl MyMooc在后面就可以添加-a设置参数，\n# scrapy crawl MyMooc -a p=xxx -a test=xxx\n# 这样就解决的scrapyd中可以设置参数的问题，非常nice，perfect！！！\n# 在后面的程序中就可以使用self.p，self.test引入参数\ndef __init__(self, p=None, test=None, *args, **kwargs):\n  super(MySpider, self).__init__(*args, **kwargs)\n  self.p = p\n  self.test = test\n```\n\n### 2. 利用postman加入参数测试接口\n\n- **运行scrapyd，在127.0.0.1:6800访问**\n\n- **查看scrapyd服务器运行状态，get方法，（scrapyd_status）**\n\n- ```bash\n  curl http://127.0.0.1:6800/daemonstatus.json\n  #返回\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"pending\": 0,\n      \"running\": 0,\n      \"finished\": 0\n  }\n  ```\n\n- **获取scrapyd服务器上已经发布的工程列表，get方法，（scrapyd_project）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listprojects.json\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"projects\": [\n          \"MyMooc\",\n          \"default\"\n      ]\n  }\n  ```\n\n- **获取scrapyd服务器上名为MyMooc的工程下的爬虫清单，get方法，（project_spider）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listspiders.json?project=mooc\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"spiders\": [\n          \"MyMooc\"\n      ]\n  }\n  spider是爬虫文件中spiders文件夹中那个爬虫py文件的name\n  \n  ```\n\n- **获取scrapyd服务器上名为MyMooc的工程下的各爬虫的版本，get方法，（project_all_version）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listversions.json?project=MyMooc\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"versions\": [\n          \"1620801044\",\n          \"1620819352\"\n      ]\n  }\n  ```\n\n- **获取scrapyd服务器上的所有任务清单，包括已结束，正在运行的，准备启动的。get方法，（scrapyd_all_jobs）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listjobs.json?project=mooc\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"pending\": [],\n      \"running\": [],\n      \"finished\": []\n  }\n  ```\n\n- **启动 scrapyd服务器上myproject工程下的myspider爬虫，使myspider立刻开始运行 ，注意必须以post方式，（run_project_spider）**\n\n- ```bash\n  http://127.0.0.1:6800/schedule.json -d project=myproject -d spider=myspider\n  http://127.0.0.1:6800/schedule.json -d project=5.13.01 -d spider=MyMooc\n  {\"node_name\": \"MM-202104301802\", \"status\": \"ok\", \"project\": \"MyMooc\", \"version\": \"1620885389\", \"spiders\": 1}\n  \n  ```\n\n- 删除scrapyd服务器上myproject的工程下的版本名为version的爬虫 ，注意必须以post方式\n\n- ```bash\n  http://127.0.0.1:6800/delversion.json -d project=myproject -d version=r99'\n  \n  ```\n\n- **删除scrapyd服务器上myproject工程，注意该命令会自动删除该工程下所有的spider，注意必须以post方式**\n\n- ```bash\n  http://127.0.0.1:6800/delproject.json -d project=myproject\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\"\n  }\n  ```\n\n- ```bash\n  curl http://127.0.0.1:6800/schedule.json -d project=MyMooc -d spider=MyMooc -d p='[\"123\"]'\n  ```\n\n  \n\n","source":"_posts/爬虫部署.md","raw":"---\ntitle: 爬虫部署\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - scrapyd\n  - 部署\n  - 爬虫\n  - 项目\ncategories:\n  - 项目\nsummary: 爬虫部署API服务\nabbrlink: b77d\ndate: 2021-05-17 13:15:19\npassword:\nkeywords:\ndescription:\n---\n# 爬虫部署API服务\n\n### 1. 部署流程\n\n```bash\n# 安装scrapyd框架，用于部署scrapy框架的服务，可将其转化为API接口的形式去运行以及配置参数\n$ pip install scrapyd\n# 在项目根目录下先运行scrapyd，单独运行在一个终端中，这里将显示访问接口的信息\n$ scrapyd\n# 更改scrapy.cfg中[deploy]，更改为[deploy:first_deploy]，启动服务后可以看见部署服务的名称，first_deploy         http://localhost:6800\n$ scrapyd-deploy -l\n# 再执行list语句，显示出scrapy的spider名称MyMooc，即为打包成功\n$ scrapy list\n# 开始项目部署，这个命令会将项目打包成egg文件，会在根目录下创建一个setup.py，会返回一个addversion.json，出现即为部署成功\n$ scrapyd-deploy (部署名称)first_deploy -p (项目名称)MyMooc\n# 运行一次代码，\n$ curl http://localhost:6800/schedule.json -d project=first_deploy -d spider=MyMooc\n\n# 定义变量\n# 加入可选参数，这样在运行scrapy crawl MyMooc在后面就可以添加-a设置参数，\n# scrapy crawl MyMooc -a p=xxx -a test=xxx\n# 这样就解决的scrapyd中可以设置参数的问题，非常nice，perfect！！！\n# 在后面的程序中就可以使用self.p，self.test引入参数\ndef __init__(self, p=None, test=None, *args, **kwargs):\n  super(MySpider, self).__init__(*args, **kwargs)\n  self.p = p\n  self.test = test\n```\n\n### 2. 利用postman加入参数测试接口\n\n- **运行scrapyd，在127.0.0.1:6800访问**\n\n- **查看scrapyd服务器运行状态，get方法，（scrapyd_status）**\n\n- ```bash\n  curl http://127.0.0.1:6800/daemonstatus.json\n  #返回\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"pending\": 0,\n      \"running\": 0,\n      \"finished\": 0\n  }\n  ```\n\n- **获取scrapyd服务器上已经发布的工程列表，get方法，（scrapyd_project）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listprojects.json\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"projects\": [\n          \"MyMooc\",\n          \"default\"\n      ]\n  }\n  ```\n\n- **获取scrapyd服务器上名为MyMooc的工程下的爬虫清单，get方法，（project_spider）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listspiders.json?project=mooc\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"spiders\": [\n          \"MyMooc\"\n      ]\n  }\n  spider是爬虫文件中spiders文件夹中那个爬虫py文件的name\n  \n  ```\n\n- **获取scrapyd服务器上名为MyMooc的工程下的各爬虫的版本，get方法，（project_all_version）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listversions.json?project=MyMooc\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"versions\": [\n          \"1620801044\",\n          \"1620819352\"\n      ]\n  }\n  ```\n\n- **获取scrapyd服务器上的所有任务清单，包括已结束，正在运行的，准备启动的。get方法，（scrapyd_all_jobs）**\n\n- ```bash\n  curl http://127.0.0.1:6800/listjobs.json?project=mooc\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\",\n      \"pending\": [],\n      \"running\": [],\n      \"finished\": []\n  }\n  ```\n\n- **启动 scrapyd服务器上myproject工程下的myspider爬虫，使myspider立刻开始运行 ，注意必须以post方式，（run_project_spider）**\n\n- ```bash\n  http://127.0.0.1:6800/schedule.json -d project=myproject -d spider=myspider\n  http://127.0.0.1:6800/schedule.json -d project=5.13.01 -d spider=MyMooc\n  {\"node_name\": \"MM-202104301802\", \"status\": \"ok\", \"project\": \"MyMooc\", \"version\": \"1620885389\", \"spiders\": 1}\n  \n  ```\n\n- 删除scrapyd服务器上myproject的工程下的版本名为version的爬虫 ，注意必须以post方式\n\n- ```bash\n  http://127.0.0.1:6800/delversion.json -d project=myproject -d version=r99'\n  \n  ```\n\n- **删除scrapyd服务器上myproject工程，注意该命令会自动删除该工程下所有的spider，注意必须以post方式**\n\n- ```bash\n  http://127.0.0.1:6800/delproject.json -d project=myproject\n  {\n      \"node_name\": \"MM-202104301802\",\n      \"status\": \"ok\"\n  }\n  ```\n\n- ```bash\n  curl http://127.0.0.1:6800/schedule.json -d project=MyMooc -d spider=MyMooc -d p='[\"123\"]'\n  ```\n\n  \n\n","slug":"爬虫部署","published":1,"updated":"2021-05-17T05:19:06.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q67004wa09khq8t64dz","content":"<h1 id=\"爬虫部署API服务\"><a href=\"#爬虫部署API服务\" class=\"headerlink\" title=\"爬虫部署API服务\"></a>爬虫部署API服务</h1><h3 id=\"1-部署流程\"><a href=\"#1-部署流程\" class=\"headerlink\" title=\"1. 部署流程\"></a>1. 部署流程</h3><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\"># 安装scrapyd框架，用于部署scrapy框架的服务，可将其转化为API接口的形式去运行以及配置参数\n$ pip install scrapyd\n# 在项目根目录下先运行scrapyd，单独运行在一个终端中，这里将显示访问接口的信息\n$ scrapyd\n# 更改scrapy.cfg中[deploy]，更改为[deploy:first_deploy]，启动服务后可以看见部署服务的名称，first_deploy         http://localhost:6800\n$ scrapyd-deploy -l\n# 再执行list语句，显示出scrapy的spider名称MyMooc，即为打包成功\n$ scrapy list\n# 开始项目部署，这个命令会将项目打包成egg文件，会在根目录下创建一个setup.py，会返回一个addversion.json，出现即为部署成功\n$ scrapyd-deploy (部署名称)first_deploy -p (项目名称)MyMooc\n# 运行一次代码，\n$ curl http://localhost:6800/schedule.json -d project=first_deploy -d spider=MyMooc\n\n# 定义变量\n# 加入可选参数，这样在运行scrapy crawl MyMooc在后面就可以添加-a设置参数，\n# scrapy crawl MyMooc -a p=xxx -a test=xxx\n# 这样就解决的scrapyd中可以设置参数的问题，非常nice，perfect！！！\n# 在后面的程序中就可以使用self.p，self.test引入参数\ndef __init__(self, p=None, test=None, *args, **kwargs):\n  super(MySpider, self).__init__(*args, **kwargs)\n  self.p = p\n  self.test = test\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-利用postman加入参数测试接口\"><a href=\"#2-利用postman加入参数测试接口\" class=\"headerlink\" title=\"2. 利用postman加入参数测试接口\"></a>2. 利用postman加入参数测试接口</h3><ul>\n<li><p><strong>运行scrapyd，在127.0.0.1:6800访问</strong></p>\n</li>\n<li><p><strong>查看scrapyd服务器运行状态，get方法，（scrapyd_status）</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">curl http://127.0.0.1:6800/daemonstatus.json\n#返回\n{\n    \"node_name\": \"MM-202104301802\",\n    \"status\": \"ok\",\n    \"pending\": 0,\n    \"running\": 0,\n    \"finished\": 0\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上已经发布的工程列表，get方法，（scrapyd_project）</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">curl http://127.0.0.1:6800/listprojects.json\n{\n    \"node_name\": \"MM-202104301802\",\n    \"status\": \"ok\",\n    \"projects\": [\n        \"MyMooc\",\n        \"default\"\n    ]\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上名为MyMooc的工程下的爬虫清单，get方法，（project_spider）</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">curl http://127.0.0.1:6800/listspiders.json?project=mooc\n{\n    \"node_name\": \"MM-202104301802\",\n    \"status\": \"ok\",\n    \"spiders\": [\n        \"MyMooc\"\n    ]\n}\nspider是爬虫文件中spiders文件夹中那个爬虫py文件的name\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上名为MyMooc的工程下的各爬虫的版本，get方法，（project_all_version）</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">curl http://127.0.0.1:6800/listversions.json?project=MyMooc\n{\n    \"node_name\": \"MM-202104301802\",\n    \"status\": \"ok\",\n    \"versions\": [\n        \"1620801044\",\n        \"1620819352\"\n    ]\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上的所有任务清单，包括已结束，正在运行的，准备启动的。get方法，（scrapyd_all_jobs）</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">curl http://127.0.0.1:6800/listjobs.json?project=mooc\n{\n    \"node_name\": \"MM-202104301802\",\n    \"status\": \"ok\",\n    \"pending\": [],\n    \"running\": [],\n    \"finished\": []\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>启动 scrapyd服务器上myproject工程下的myspider爬虫，使myspider立刻开始运行 ，注意必须以post方式，（run_project_spider）</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">http://127.0.0.1:6800/schedule.json -d project=myproject -d spider=myspider\nhttp://127.0.0.1:6800/schedule.json -d project=5.13.01 -d spider=MyMooc\n{\"node_name\": \"MM-202104301802\", \"status\": \"ok\", \"project\": \"MyMooc\", \"version\": \"1620885389\", \"spiders\": 1}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除scrapyd服务器上myproject的工程下的版本名为version的爬虫 ，注意必须以post方式</p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">http://127.0.0.1:6800/delversion.json -d project=myproject -d version=r99'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>删除scrapyd服务器上myproject工程，注意该命令会自动删除该工程下所有的spider，注意必须以post方式</strong></p>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">http://127.0.0.1:6800/delproject.json -d project=myproject\n{\n    \"node_name\": \"MM-202104301802\",\n    \"status\": \"ok\"\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><pre class=\"line-numbers language-lang-bash\"><code class=\"language-lang-bash\">curl http://127.0.0.1:6800/schedule.json -d project=MyMooc -d spider=MyMooc -d p='[\"123\"]'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"爬虫部署API服务\"><a href=\"#爬虫部署API服务\" class=\"headerlink\" title=\"爬虫部署API服务\"></a>爬虫部署API服务</h1><h3 id=\"1-部署流程\"><a href=\"#1-部署流程\" class=\"headerlink\" title=\"1. 部署流程\"></a>1. 部署流程</h3><pre><code class=\"lang-bash\"># 安装scrapyd框架，用于部署scrapy框架的服务，可将其转化为API接口的形式去运行以及配置参数\n$ pip install scrapyd\n# 在项目根目录下先运行scrapyd，单独运行在一个终端中，这里将显示访问接口的信息\n$ scrapyd\n# 更改scrapy.cfg中[deploy]，更改为[deploy:first_deploy]，启动服务后可以看见部署服务的名称，first_deploy         http://localhost:6800\n$ scrapyd-deploy -l\n# 再执行list语句，显示出scrapy的spider名称MyMooc，即为打包成功\n$ scrapy list\n# 开始项目部署，这个命令会将项目打包成egg文件，会在根目录下创建一个setup.py，会返回一个addversion.json，出现即为部署成功\n$ scrapyd-deploy (部署名称)first_deploy -p (项目名称)MyMooc\n# 运行一次代码，\n$ curl http://localhost:6800/schedule.json -d project=first_deploy -d spider=MyMooc\n\n# 定义变量\n# 加入可选参数，这样在运行scrapy crawl MyMooc在后面就可以添加-a设置参数，\n# scrapy crawl MyMooc -a p=xxx -a test=xxx\n# 这样就解决的scrapyd中可以设置参数的问题，非常nice，perfect！！！\n# 在后面的程序中就可以使用self.p，self.test引入参数\ndef __init__(self, p=None, test=None, *args, **kwargs):\n  super(MySpider, self).__init__(*args, **kwargs)\n  self.p = p\n  self.test = test\n</code></pre>\n<h3 id=\"2-利用postman加入参数测试接口\"><a href=\"#2-利用postman加入参数测试接口\" class=\"headerlink\" title=\"2. 利用postman加入参数测试接口\"></a>2. 利用postman加入参数测试接口</h3><ul>\n<li><p><strong>运行scrapyd，在127.0.0.1:6800访问</strong></p>\n</li>\n<li><p><strong>查看scrapyd服务器运行状态，get方法，（scrapyd_status）</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">curl http://127.0.0.1:6800/daemonstatus.json\n#返回\n{\n    &quot;node_name&quot;: &quot;MM-202104301802&quot;,\n    &quot;status&quot;: &quot;ok&quot;,\n    &quot;pending&quot;: 0,\n    &quot;running&quot;: 0,\n    &quot;finished&quot;: 0\n}\n</code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上已经发布的工程列表，get方法，（scrapyd_project）</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">curl http://127.0.0.1:6800/listprojects.json\n{\n    &quot;node_name&quot;: &quot;MM-202104301802&quot;,\n    &quot;status&quot;: &quot;ok&quot;,\n    &quot;projects&quot;: [\n        &quot;MyMooc&quot;,\n        &quot;default&quot;\n    ]\n}\n</code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上名为MyMooc的工程下的爬虫清单，get方法，（project_spider）</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">curl http://127.0.0.1:6800/listspiders.json?project=mooc\n{\n    &quot;node_name&quot;: &quot;MM-202104301802&quot;,\n    &quot;status&quot;: &quot;ok&quot;,\n    &quot;spiders&quot;: [\n        &quot;MyMooc&quot;\n    ]\n}\nspider是爬虫文件中spiders文件夹中那个爬虫py文件的name\n</code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上名为MyMooc的工程下的各爬虫的版本，get方法，（project_all_version）</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">curl http://127.0.0.1:6800/listversions.json?project=MyMooc\n{\n    &quot;node_name&quot;: &quot;MM-202104301802&quot;,\n    &quot;status&quot;: &quot;ok&quot;,\n    &quot;versions&quot;: [\n        &quot;1620801044&quot;,\n        &quot;1620819352&quot;\n    ]\n}\n</code></pre>\n</li>\n<li><p><strong>获取scrapyd服务器上的所有任务清单，包括已结束，正在运行的，准备启动的。get方法，（scrapyd_all_jobs）</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">curl http://127.0.0.1:6800/listjobs.json?project=mooc\n{\n    &quot;node_name&quot;: &quot;MM-202104301802&quot;,\n    &quot;status&quot;: &quot;ok&quot;,\n    &quot;pending&quot;: [],\n    &quot;running&quot;: [],\n    &quot;finished&quot;: []\n}\n</code></pre>\n</li>\n<li><p><strong>启动 scrapyd服务器上myproject工程下的myspider爬虫，使myspider立刻开始运行 ，注意必须以post方式，（run_project_spider）</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">http://127.0.0.1:6800/schedule.json -d project=myproject -d spider=myspider\nhttp://127.0.0.1:6800/schedule.json -d project=5.13.01 -d spider=MyMooc\n{&quot;node_name&quot;: &quot;MM-202104301802&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;project&quot;: &quot;MyMooc&quot;, &quot;version&quot;: &quot;1620885389&quot;, &quot;spiders&quot;: 1}\n</code></pre>\n</li>\n<li><p>删除scrapyd服务器上myproject的工程下的版本名为version的爬虫 ，注意必须以post方式</p>\n</li>\n<li><pre><code class=\"lang-bash\">http://127.0.0.1:6800/delversion.json -d project=myproject -d version=r99&#39;\n</code></pre>\n</li>\n<li><p><strong>删除scrapyd服务器上myproject工程，注意该命令会自动删除该工程下所有的spider，注意必须以post方式</strong></p>\n</li>\n<li><pre><code class=\"lang-bash\">http://127.0.0.1:6800/delproject.json -d project=myproject\n{\n    &quot;node_name&quot;: &quot;MM-202104301802&quot;,\n    &quot;status&quot;: &quot;ok&quot;\n}\n</code></pre>\n</li>\n<li><pre><code class=\"lang-bash\">curl http://127.0.0.1:6800/schedule.json -d project=MyMooc -d spider=MyMooc -d p=&#39;[&quot;123&quot;]&#39;\n</code></pre>\n</li>\n</ul>\n"},{"title":"计网第一章　概述","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"第一章　计算机网络概述","abbrlink":"6c68","date":"2020-07-21T12:09:24.000Z","password":null,"_content":"\n## 第一章　计算机网络概述\n\n1. 不同程序同时在一台计算机内使用网络，可使用**服务点地址**来区别。\n\n3. 网络拓扑结构\n\n   - 网状\n   - 星状：中央控制器是整个网络性能的瓶颈\n   - 树状\n   - 总线型\n   - 环形\n\n4. 计算机网络的分类\n   - 按作用范围分类：局域网（一般为私有的）、城域网和广域网\n   - 按通讯介质分类：有线网（同轴电缆、双绞线和光纤）和无线网\n   - 按通信传播方式分类：点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）\n   - 按通信速率分类：低速网、中速网和高速网\n   - 按使用范围分类：公用网和专用网\n   - 按网络控制方式分类：集中式网络和分布式网络（无处理中心，每个结点地位平等）\n   - 按网络环境分类：部门网、企业网和校园网\n   \n4. **网络体系结构**：计算机网络的各个层次及其协议的集合成为体系结构\n\n5. ISO OSI参考模型\n\n   - 计算机网络从逻辑功能上可分为两个子网：**资源子网和通信子网**\n   - **由下到上、由低到高为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层**\n   - 物理层（中继器）：规定了机械、电气、功能和规程4个特性，单位是比特（bit）\n   - 数据链路层（网桥）：相邻结点的数据传输、帧同步、差错控制、流量控制、链路管理，单位是帧（frame）。提供**可靠通信**\n   - 网络层（路由器）：任意节点的数据传输、路由选择、阻塞控制国际互联，单位是分组或包\n   - **物理层、数据链路层和网络层**三层组成**通信子网**\n   - 传输层：**端到端**通信，流量控制、差错控制，单位是报文（message）\n   - 会话层：两个计算机上的进程间建立连接。提供同步点机制\n   - 表示层：解决用户信息的语法问题\n   - 应用层：处理用户的数据和信息\n6. Internet体系结构采用TCP/IP参考模型\n\n7. TCP/IP体系结构：物理层、数据链路层、网络层、传输层和应用层\n   - 物理层和数据链路层：这两层有时又称为网络接口层。数据链路层在TCP/IP协议中被认为是不可靠的。**保证可靠地通讯是传输层的任务**\n   \n   - 网络层：寻址、数据打包和路由选择，IP协议是一个**无连接、不可靠**的协议。包括地址解析协议ARP、反向地址解析协议RARP、Internet协议IP、Internet控制消息协议ICMP和Internet组管理协议IGMP\n   \n   - 传输层\n     - TCP传输控制协议：可靠有链接\n     - UDP用户数据报协议：不可靠无连接\n     \n   - 应用层：FTP交互式文件传输、SMTP邮件服务器间邮件传输、POP从邮件服务器上取回邮件、HTTP传输组成Web页面的文件、DNS解析域名成IP地址、SNMP简单网络管理协议\n   \n8. 物理层为第1层，应用层为第7层。**下层为上面各层提供服务**，相邻层传递的信息为服务数据单元SDU，对等层之间交换信息为协议数据单元PDU。**N层的PDU由N层的SDU加上该层的PCI（协议控制信息）构成**","source":"_posts/计网第一章-概述.md","raw":"---\ntitle: 计网第一章　概述\ntop: false\ncover: false\ntoc: false\nmathjax: true\nsummary: 第一章　计算机网络概述\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nabbrlink: 6c68\ndate: 2020-07-21 20:09:24\npassword:\n---\n\n## 第一章　计算机网络概述\n\n1. 不同程序同时在一台计算机内使用网络，可使用**服务点地址**来区别。\n\n3. 网络拓扑结构\n\n   - 网状\n   - 星状：中央控制器是整个网络性能的瓶颈\n   - 树状\n   - 总线型\n   - 环形\n\n4. 计算机网络的分类\n   - 按作用范围分类：局域网（一般为私有的）、城域网和广域网\n   - 按通讯介质分类：有线网（同轴电缆、双绞线和光纤）和无线网\n   - 按通信传播方式分类：点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）\n   - 按通信速率分类：低速网、中速网和高速网\n   - 按使用范围分类：公用网和专用网\n   - 按网络控制方式分类：集中式网络和分布式网络（无处理中心，每个结点地位平等）\n   - 按网络环境分类：部门网、企业网和校园网\n   \n4. **网络体系结构**：计算机网络的各个层次及其协议的集合成为体系结构\n\n5. ISO OSI参考模型\n\n   - 计算机网络从逻辑功能上可分为两个子网：**资源子网和通信子网**\n   - **由下到上、由低到高为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层**\n   - 物理层（中继器）：规定了机械、电气、功能和规程4个特性，单位是比特（bit）\n   - 数据链路层（网桥）：相邻结点的数据传输、帧同步、差错控制、流量控制、链路管理，单位是帧（frame）。提供**可靠通信**\n   - 网络层（路由器）：任意节点的数据传输、路由选择、阻塞控制国际互联，单位是分组或包\n   - **物理层、数据链路层和网络层**三层组成**通信子网**\n   - 传输层：**端到端**通信，流量控制、差错控制，单位是报文（message）\n   - 会话层：两个计算机上的进程间建立连接。提供同步点机制\n   - 表示层：解决用户信息的语法问题\n   - 应用层：处理用户的数据和信息\n6. Internet体系结构采用TCP/IP参考模型\n\n7. TCP/IP体系结构：物理层、数据链路层、网络层、传输层和应用层\n   - 物理层和数据链路层：这两层有时又称为网络接口层。数据链路层在TCP/IP协议中被认为是不可靠的。**保证可靠地通讯是传输层的任务**\n   \n   - 网络层：寻址、数据打包和路由选择，IP协议是一个**无连接、不可靠**的协议。包括地址解析协议ARP、反向地址解析协议RARP、Internet协议IP、Internet控制消息协议ICMP和Internet组管理协议IGMP\n   \n   - 传输层\n     - TCP传输控制协议：可靠有链接\n     - UDP用户数据报协议：不可靠无连接\n     \n   - 应用层：FTP交互式文件传输、SMTP邮件服务器间邮件传输、POP从邮件服务器上取回邮件、HTTP传输组成Web页面的文件、DNS解析域名成IP地址、SNMP简单网络管理协议\n   \n8. 物理层为第1层，应用层为第7层。**下层为上面各层提供服务**，相邻层传递的信息为服务数据单元SDU，对等层之间交换信息为协议数据单元PDU。**N层的PDU由N层的SDU加上该层的PCI（协议控制信息）构成**","slug":"计网第一章-概述","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q67004za09k3m7t47pl","content":"<h2 id=\"第一章-计算机网络概述\"><a href=\"#第一章-计算机网络概述\" class=\"headerlink\" title=\"第一章　计算机网络概述\"></a>第一章　计算机网络概述</h2><ol>\n<li><p>不同程序同时在一台计算机内使用网络，可使用<strong>服务点地址</strong>来区别。</p>\n</li>\n<li><p>网络拓扑结构</p>\n<ul>\n<li>网状</li>\n<li>星状：中央控制器是整个网络性能的瓶颈</li>\n<li>树状</li>\n<li>总线型</li>\n<li>环形</li>\n</ul>\n</li>\n<li><p>计算机网络的分类</p>\n<ul>\n<li>按作用范围分类：局域网（一般为私有的）、城域网和广域网</li>\n<li>按通讯介质分类：有线网（同轴电缆、双绞线和光纤）和无线网</li>\n<li>按通信传播方式分类：点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）</li>\n<li>按通信速率分类：低速网、中速网和高速网</li>\n<li>按使用范围分类：公用网和专用网</li>\n<li>按网络控制方式分类：集中式网络和分布式网络（无处理中心，每个结点地位平等）</li>\n<li>按网络环境分类：部门网、企业网和校园网</li>\n</ul>\n</li>\n<li><p><strong>网络体系结构</strong>：计算机网络的各个层次及其协议的集合成为体系结构</p>\n</li>\n<li><p>ISO OSI参考模型</p>\n<ul>\n<li>计算机网络从逻辑功能上可分为两个子网：<strong>资源子网和通信子网</strong></li>\n<li><strong>由下到上、由低到高为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong></li>\n<li>物理层（中继器）：规定了机械、电气、功能和规程4个特性，单位是比特（bit）</li>\n<li>数据链路层（网桥）：相邻结点的数据传输、帧同步、差错控制、流量控制、链路管理，单位是帧（frame）。提供<strong>可靠通信</strong></li>\n<li>网络层（路由器）：任意节点的数据传输、路由选择、阻塞控制国际互联，单位是分组或包</li>\n<li><strong>物理层、数据链路层和网络层</strong>三层组成<strong>通信子网</strong></li>\n<li>传输层：<strong>端到端</strong>通信，流量控制、差错控制，单位是报文（message）</li>\n<li>会话层：两个计算机上的进程间建立连接。提供同步点机制</li>\n<li>表示层：解决用户信息的语法问题</li>\n<li>应用层：处理用户的数据和信息</li>\n</ul>\n</li>\n<li><p>Internet体系结构采用TCP/IP参考模型</p>\n</li>\n<li><p>TCP/IP体系结构：物理层、数据链路层、网络层、传输层和应用层</p>\n<ul>\n<li><p>物理层和数据链路层：这两层有时又称为网络接口层。数据链路层在TCP/IP协议中被认为是不可靠的。<strong>保证可靠地通讯是传输层的任务</strong></p>\n</li>\n<li><p>网络层：寻址、数据打包和路由选择，IP协议是一个<strong>无连接、不可靠</strong>的协议。包括地址解析协议ARP、反向地址解析协议RARP、Internet协议IP、Internet控制消息协议ICMP和Internet组管理协议IGMP</p>\n</li>\n<li><p>传输层</p>\n<ul>\n<li>TCP传输控制协议：可靠有链接</li>\n<li>UDP用户数据报协议：不可靠无连接</li>\n</ul>\n</li>\n<li><p>应用层：FTP交互式文件传输、SMTP邮件服务器间邮件传输、POP从邮件服务器上取回邮件、HTTP传输组成Web页面的文件、DNS解析域名成IP地址、SNMP简单网络管理协议</p>\n</li>\n</ul>\n</li>\n<li><p>物理层为第1层，应用层为第7层。<strong>下层为上面各层提供服务</strong>，相邻层传递的信息为服务数据单元SDU，对等层之间交换信息为协议数据单元PDU。<strong>N层的PDU由N层的SDU加上该层的PCI（协议控制信息）构成</strong></p>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第一章-计算机网络概述\"><a href=\"#第一章-计算机网络概述\" class=\"headerlink\" title=\"第一章　计算机网络概述\"></a>第一章　计算机网络概述</h2><ol>\n<li><p>不同程序同时在一台计算机内使用网络，可使用<strong>服务点地址</strong>来区别。</p>\n</li>\n<li><p>网络拓扑结构</p>\n<ul>\n<li>网状</li>\n<li>星状：中央控制器是整个网络性能的瓶颈</li>\n<li>树状</li>\n<li>总线型</li>\n<li>环形</li>\n</ul>\n</li>\n<li><p>计算机网络的分类</p>\n<ul>\n<li>按作用范围分类：局域网（一般为私有的）、城域网和广域网</li>\n<li>按通讯介质分类：有线网（同轴电缆、双绞线和光纤）和无线网</li>\n<li>按通信传播方式分类：点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）</li>\n<li>按通信速率分类：低速网、中速网和高速网</li>\n<li>按使用范围分类：公用网和专用网</li>\n<li>按网络控制方式分类：集中式网络和分布式网络（无处理中心，每个结点地位平等）</li>\n<li>按网络环境分类：部门网、企业网和校园网</li>\n</ul>\n</li>\n<li><p><strong>网络体系结构</strong>：计算机网络的各个层次及其协议的集合成为体系结构</p>\n</li>\n<li><p>ISO OSI参考模型</p>\n<ul>\n<li>计算机网络从逻辑功能上可分为两个子网：<strong>资源子网和通信子网</strong></li>\n<li><strong>由下到上、由低到高为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong></li>\n<li>物理层（中继器）：规定了机械、电气、功能和规程4个特性，单位是比特（bit）</li>\n<li>数据链路层（网桥）：相邻结点的数据传输、帧同步、差错控制、流量控制、链路管理，单位是帧（frame）。提供<strong>可靠通信</strong></li>\n<li>网络层（路由器）：任意节点的数据传输、路由选择、阻塞控制国际互联，单位是分组或包</li>\n<li><strong>物理层、数据链路层和网络层</strong>三层组成<strong>通信子网</strong></li>\n<li>传输层：<strong>端到端</strong>通信，流量控制、差错控制，单位是报文（message）</li>\n<li>会话层：两个计算机上的进程间建立连接。提供同步点机制</li>\n<li>表示层：解决用户信息的语法问题</li>\n<li>应用层：处理用户的数据和信息</li>\n</ul>\n</li>\n<li><p>Internet体系结构采用TCP/IP参考模型</p>\n</li>\n<li><p>TCP/IP体系结构：物理层、数据链路层、网络层、传输层和应用层</p>\n<ul>\n<li><p>物理层和数据链路层：这两层有时又称为网络接口层。数据链路层在TCP/IP协议中被认为是不可靠的。<strong>保证可靠地通讯是传输层的任务</strong></p>\n</li>\n<li><p>网络层：寻址、数据打包和路由选择，IP协议是一个<strong>无连接、不可靠</strong>的协议。包括地址解析协议ARP、反向地址解析协议RARP、Internet协议IP、Internet控制消息协议ICMP和Internet组管理协议IGMP</p>\n</li>\n<li><p>传输层</p>\n<ul>\n<li>TCP传输控制协议：可靠有链接</li>\n<li>UDP用户数据报协议：不可靠无连接</li>\n</ul>\n</li>\n<li><p>应用层：FTP交互式文件传输、SMTP邮件服务器间邮件传输、POP从邮件服务器上取回邮件、HTTP传输组成Web页面的文件、DNS解析域名成IP地址、SNMP简单网络管理协议</p>\n</li>\n</ul>\n</li>\n<li><p>物理层为第1层，应用层为第7层。<strong>下层为上面各层提供服务</strong>，相邻层传递的信息为服务数据单元SDU，对等层之间交换信息为协议数据单元PDU。<strong>N层的PDU由N层的SDU加上该层的PCI（协议控制信息）构成</strong></p>\n</li>\n</ol>\n"},{"title":"计网第七章-局域网和广域网技术","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"93d0","date":"2020-08-12T13:18:52.000Z","password":null,"summary":"第七章 局域网和广域网技术","_content":"## 第七章 局域网和广域网技术\n\n1. IEEE802.2：它是LLC协议标准，分为两个功能子集，**数据链路控制（LLC）子层**和**媒体访问控制（MAC）子层**\n\n2. 逻辑链路控制（LLC）子层是IEEE802数据链路层的上子层，它对于所有的LAN协议来说都是相同的\n\n3. MAC子层解决共享介质的竞争使用问题。它包含了将数据从一个地方传送到另一个地方所必须的同步、标记、流量和差错控制的规范，同时也包括下一个站点的物理地址。不同的局域网具有不同的MAC协议\n\n4. IEEE802各个标准和OSI模型的层次对应关系\n\n![对应关系](img.png)\n\n5. 逻辑链路控制（LLC）子层\n\n![对应关系](img2.png)\n   - LLC-PDU与HDLC类似，包含四个域：目的服务访问点（DSAP）、源服务访问点（SSAP）、控制域和信息域\n   - DASP和SSAP是LLC所使用的地址，SAP叫服务访问点。用来标明接收和发送数据的计算机上的协议栈\n\n6. LLC地址与MAC地址\n   - 在MAC帧的帧首中，有目的站地址和源站地址，它们是6字节长。MAC帧中的地址是站点的物理地址\n   - 在LLC帧的帧首中，用DSAP和SSAP，该地址是逻辑地址，是数据链路层的不同服务访问点\n\n7. 以太网\n   - IEEE 讲基带划分为5个不同的标准：10Base5、10base-T和100base-T等\n   - 开头数字指明了数据传输速率：最后的数字或字母（5,2，T（双绞线））指明了最大电缆长度或电缆类别；base指明的是基带传输\n   - IEEE只定义了一个宽带类标准：10Broad36，用于小区网络连接\n   - IEEE 802.3定义了两类标准：基带和宽带\n   - 基带类使用数字信号传输数据，用以太网使用曼彻斯特编码\n   - 宽带类使用模拟信号传输数据\n\n8. 以太网访问模式\n\n   - 在LAN中，多个用户在没有任何控制的情况下同时访问一条线路时，会存在由于不同信号叠加而相互破坏的情况。这就是**冲突**。为了使冲突发生的可能性最小，需要有一种机制来协调通信\n\n   - 以太网的媒体访问控制机制称为**带有冲突检测**的载波帧听多路访问（**CSMA/CD**）\n   - **多路访问（MA）**：不提供通信管制（**不听就说**）\n   - **载波监听多路访问（CSMA）**：首先监听链路上是否已经存在通信。由于存在传输延迟，还是会出现冲突**（先听后说）**\n   - **带有冲突检测的载波监听多路访问（CSMA/CD）**：发送是同CSMA一样，在传输的时候继续监听链路是否发生冲突（**边听边说**）\n     - 如果链路是空闲的，则可以发送并同时检测冲突\n     - 如果链路的忙的，则继续监听，直到检测到链路空闲\n     - 如果在发送过程中检测到冲突，则停止当前帧的发送，发阻塞信号，等待一段选定的时间（退避间隔）\n     - **先听后发，也听也发，冲突停发，随机重发**\n\n9. CSMA可分为三种\n   - 非坚持CSMA：如果链路是空闲的，则可以发送。如果链路是忙的，则等待一段时间。等待时间的长短在一个时间范围内随机选择\n   - 坚持CSMA（1-坚持）：如果链路是空闲的，则可以发送。如果链路是忙的，则继续帧听，直到检测到链路空闲，立即发送\n   - P-坚持CSMA：如果链路是空闲的，则以P的概率发送，而以（1-P）的概率延迟一个单位时间。如果链路是忙的，继续监听直至链路空闲。（例如，当有N个站点时，试图传输的站点的期望值为NP，为避免冲突应使**NP<1**）\n\n10. 退避算法（二进制指数退避）\n    - 对每一个帧，当第一次发生冲突时，设置参数`L=2`；\n    - 退避间隔取1到L个时间片中的一个随机数。一个时间片等于链路上最大传输延迟的两倍\n    - 当帧重复发生一次冲突时，则将参数L加倍。L的最大值为1024.即当L增加到1024时，L不再增加\n    - 帧的最大重传次数为16，超过这个次数，则该帧不再重传，并报告出错\n\n11. 最短帧长公式：$L_{min} =2×S÷V×R$ \n    - $L_{min}$：最短数据帧长（$bit$）\n    - $S$：任意两站点间的最大距离（$m$）\n    - $R$：数据传输速率（$Mbps$）\n    - $V$：电子传播速度（$200m/us$）\n\n12. 以太网$MAC$帧格式\n\n    | 前导码 |  SFD  | 目标地址 | 源地址 | LLC-PDU长度/类型 |   LLC-PDU   |  CRC  |\n    | :----: | :---: | :------: | :----: | :--------------: | :---------: | :---: |\n    | 7字节  | 1字节 |  6字节   | 6字节  |      2字节       | 46-1500字节 | 4字节 |\n\n    - 前导码：包含7个字节，在这个域中，1和0交替出现，警告系统接收即将到来的数据帧，同时使系统能够调整同步输入时钟\n    - 帧起始分界符（SFD）：帧起始分界符标记了**帧的开始**。它只有一个字节，模式是`10101011`，SFD通知接收方后面所有内容都是数据\n    - 目的地址（DA）：DA域为6个字节，标记了数据帧下一个结点的物理地址\n    - 源地址（SA）：SA域也分配了6个字节。它包含了最后一个转发此帧的设备的物理地址。也是上个结点的物理地址\n    - LLC-PDU的长度/类型：该字节指出了LLC-PDU的字节数，即LLC-PDU域中的有效字节数\n    - LLC-PDU：以太网MAC帧讲802.2的整个帧作为透明数据包含了进来。该域的长度可以从46到1500字节不等\n    - CRC：MAC帧的最后一个域是差错检测，占32位，用CRC\n\n13. 以太网种类\n    - 10base5粗缆以太网（总线）\n    - 10base2细缆以太网（总线）\n    - 10base-T双绞线以太网（星型）\n    - 100base-T快速以太网（星型）","source":"_posts/计网第七章-局域网和广域网技术.md","raw":"---\ntitle: 计网第七章-局域网和广域网技术\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nabbrlink: 93d0\ndate: 2020-08-12 21:18:52\npassword:\nsummary: 第七章 局域网和广域网技术\n---\n## 第七章 局域网和广域网技术\n\n1. IEEE802.2：它是LLC协议标准，分为两个功能子集，**数据链路控制（LLC）子层**和**媒体访问控制（MAC）子层**\n\n2. 逻辑链路控制（LLC）子层是IEEE802数据链路层的上子层，它对于所有的LAN协议来说都是相同的\n\n3. MAC子层解决共享介质的竞争使用问题。它包含了将数据从一个地方传送到另一个地方所必须的同步、标记、流量和差错控制的规范，同时也包括下一个站点的物理地址。不同的局域网具有不同的MAC协议\n\n4. IEEE802各个标准和OSI模型的层次对应关系\n\n![对应关系](img.png)\n\n5. 逻辑链路控制（LLC）子层\n\n![对应关系](img2.png)\n   - LLC-PDU与HDLC类似，包含四个域：目的服务访问点（DSAP）、源服务访问点（SSAP）、控制域和信息域\n   - DASP和SSAP是LLC所使用的地址，SAP叫服务访问点。用来标明接收和发送数据的计算机上的协议栈\n\n6. LLC地址与MAC地址\n   - 在MAC帧的帧首中，有目的站地址和源站地址，它们是6字节长。MAC帧中的地址是站点的物理地址\n   - 在LLC帧的帧首中，用DSAP和SSAP，该地址是逻辑地址，是数据链路层的不同服务访问点\n\n7. 以太网\n   - IEEE 讲基带划分为5个不同的标准：10Base5、10base-T和100base-T等\n   - 开头数字指明了数据传输速率：最后的数字或字母（5,2，T（双绞线））指明了最大电缆长度或电缆类别；base指明的是基带传输\n   - IEEE只定义了一个宽带类标准：10Broad36，用于小区网络连接\n   - IEEE 802.3定义了两类标准：基带和宽带\n   - 基带类使用数字信号传输数据，用以太网使用曼彻斯特编码\n   - 宽带类使用模拟信号传输数据\n\n8. 以太网访问模式\n\n   - 在LAN中，多个用户在没有任何控制的情况下同时访问一条线路时，会存在由于不同信号叠加而相互破坏的情况。这就是**冲突**。为了使冲突发生的可能性最小，需要有一种机制来协调通信\n\n   - 以太网的媒体访问控制机制称为**带有冲突检测**的载波帧听多路访问（**CSMA/CD**）\n   - **多路访问（MA）**：不提供通信管制（**不听就说**）\n   - **载波监听多路访问（CSMA）**：首先监听链路上是否已经存在通信。由于存在传输延迟，还是会出现冲突**（先听后说）**\n   - **带有冲突检测的载波监听多路访问（CSMA/CD）**：发送是同CSMA一样，在传输的时候继续监听链路是否发生冲突（**边听边说**）\n     - 如果链路是空闲的，则可以发送并同时检测冲突\n     - 如果链路的忙的，则继续监听，直到检测到链路空闲\n     - 如果在发送过程中检测到冲突，则停止当前帧的发送，发阻塞信号，等待一段选定的时间（退避间隔）\n     - **先听后发，也听也发，冲突停发，随机重发**\n\n9. CSMA可分为三种\n   - 非坚持CSMA：如果链路是空闲的，则可以发送。如果链路是忙的，则等待一段时间。等待时间的长短在一个时间范围内随机选择\n   - 坚持CSMA（1-坚持）：如果链路是空闲的，则可以发送。如果链路是忙的，则继续帧听，直到检测到链路空闲，立即发送\n   - P-坚持CSMA：如果链路是空闲的，则以P的概率发送，而以（1-P）的概率延迟一个单位时间。如果链路是忙的，继续监听直至链路空闲。（例如，当有N个站点时，试图传输的站点的期望值为NP，为避免冲突应使**NP<1**）\n\n10. 退避算法（二进制指数退避）\n    - 对每一个帧，当第一次发生冲突时，设置参数`L=2`；\n    - 退避间隔取1到L个时间片中的一个随机数。一个时间片等于链路上最大传输延迟的两倍\n    - 当帧重复发生一次冲突时，则将参数L加倍。L的最大值为1024.即当L增加到1024时，L不再增加\n    - 帧的最大重传次数为16，超过这个次数，则该帧不再重传，并报告出错\n\n11. 最短帧长公式：$L_{min} =2×S÷V×R$ \n    - $L_{min}$：最短数据帧长（$bit$）\n    - $S$：任意两站点间的最大距离（$m$）\n    - $R$：数据传输速率（$Mbps$）\n    - $V$：电子传播速度（$200m/us$）\n\n12. 以太网$MAC$帧格式\n\n    | 前导码 |  SFD  | 目标地址 | 源地址 | LLC-PDU长度/类型 |   LLC-PDU   |  CRC  |\n    | :----: | :---: | :------: | :----: | :--------------: | :---------: | :---: |\n    | 7字节  | 1字节 |  6字节   | 6字节  |      2字节       | 46-1500字节 | 4字节 |\n\n    - 前导码：包含7个字节，在这个域中，1和0交替出现，警告系统接收即将到来的数据帧，同时使系统能够调整同步输入时钟\n    - 帧起始分界符（SFD）：帧起始分界符标记了**帧的开始**。它只有一个字节，模式是`10101011`，SFD通知接收方后面所有内容都是数据\n    - 目的地址（DA）：DA域为6个字节，标记了数据帧下一个结点的物理地址\n    - 源地址（SA）：SA域也分配了6个字节。它包含了最后一个转发此帧的设备的物理地址。也是上个结点的物理地址\n    - LLC-PDU的长度/类型：该字节指出了LLC-PDU的字节数，即LLC-PDU域中的有效字节数\n    - LLC-PDU：以太网MAC帧讲802.2的整个帧作为透明数据包含了进来。该域的长度可以从46到1500字节不等\n    - CRC：MAC帧的最后一个域是差错检测，占32位，用CRC\n\n13. 以太网种类\n    - 10base5粗缆以太网（总线）\n    - 10base2细缆以太网（总线）\n    - 10base-T双绞线以太网（星型）\n    - 100base-T快速以太网（星型）","slug":"计网第七章-局域网和广域网技术","published":1,"updated":"2020-08-21T06:24:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q680054a09k5j2v7g0m","content":"<h2 id=\"第七章-局域网和广域网技术\"><a href=\"#第七章-局域网和广域网技术\" class=\"headerlink\" title=\"第七章 局域网和广域网技术\"></a>第七章 局域网和广域网技术</h2><ol>\n<li><p>IEEE802.2：它是LLC协议标准，分为两个功能子集，<strong>数据链路控制（LLC）子层</strong>和<strong>媒体访问控制（MAC）子层</strong></p>\n</li>\n<li><p>逻辑链路控制（LLC）子层是IEEE802数据链路层的上子层，它对于所有的LAN协议来说都是相同的</p>\n</li>\n<li><p>MAC子层解决共享介质的竞争使用问题。它包含了将数据从一个地方传送到另一个地方所必须的同步、标记、流量和差错控制的规范，同时也包括下一个站点的物理地址。不同的局域网具有不同的MAC协议</p>\n</li>\n<li><p>IEEE802各个标准和OSI模型的层次对应关系</p>\n</li>\n</ol>\n<p><img src=\"img.png\" alt=\"对应关系\"></p>\n<ol>\n<li>逻辑链路控制（LLC）子层</li>\n</ol>\n<p><img src=\"img2.png\" alt=\"对应关系\"></p>\n<ul>\n<li>LLC-PDU与HDLC类似，包含四个域：目的服务访问点（DSAP）、源服务访问点（SSAP）、控制域和信息域</li>\n<li>DASP和SSAP是LLC所使用的地址，SAP叫服务访问点。用来标明接收和发送数据的计算机上的协议栈</li>\n</ul>\n<ol>\n<li><p>LLC地址与MAC地址</p>\n<ul>\n<li>在MAC帧的帧首中，有目的站地址和源站地址，它们是6字节长。MAC帧中的地址是站点的物理地址</li>\n<li>在LLC帧的帧首中，用DSAP和SSAP，该地址是逻辑地址，是数据链路层的不同服务访问点</li>\n</ul>\n</li>\n<li><p>以太网</p>\n<ul>\n<li>IEEE 讲基带划分为5个不同的标准：10Base5、10base-T和100base-T等</li>\n<li>开头数字指明了数据传输速率：最后的数字或字母（5,2，T（双绞线））指明了最大电缆长度或电缆类别；base指明的是基带传输</li>\n<li>IEEE只定义了一个宽带类标准：10Broad36，用于小区网络连接</li>\n<li>IEEE 802.3定义了两类标准：基带和宽带</li>\n<li>基带类使用数字信号传输数据，用以太网使用曼彻斯特编码</li>\n<li>宽带类使用模拟信号传输数据</li>\n</ul>\n</li>\n<li><p>以太网访问模式</p>\n<ul>\n<li><p>在LAN中，多个用户在没有任何控制的情况下同时访问一条线路时，会存在由于不同信号叠加而相互破坏的情况。这就是<strong>冲突</strong>。为了使冲突发生的可能性最小，需要有一种机制来协调通信</p>\n</li>\n<li><p>以太网的媒体访问控制机制称为<strong>带有冲突检测</strong>的载波帧听多路访问（<strong>CSMA/CD</strong>）</p>\n</li>\n<li><strong>多路访问（MA）</strong>：不提供通信管制（<strong>不听就说</strong>）</li>\n<li><strong>载波监听多路访问（CSMA）</strong>：首先监听链路上是否已经存在通信。由于存在传输延迟，还是会出现冲突<strong>（先听后说）</strong></li>\n<li><strong>带有冲突检测的载波监听多路访问（CSMA/CD）</strong>：发送是同CSMA一样，在传输的时候继续监听链路是否发生冲突（<strong>边听边说</strong>）<ul>\n<li>如果链路是空闲的，则可以发送并同时检测冲突</li>\n<li>如果链路的忙的，则继续监听，直到检测到链路空闲</li>\n<li>如果在发送过程中检测到冲突，则停止当前帧的发送，发阻塞信号，等待一段选定的时间（退避间隔）</li>\n<li><strong>先听后发，也听也发，冲突停发，随机重发</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CSMA可分为三种</p>\n<ul>\n<li>非坚持CSMA：如果链路是空闲的，则可以发送。如果链路是忙的，则等待一段时间。等待时间的长短在一个时间范围内随机选择</li>\n<li>坚持CSMA（1-坚持）：如果链路是空闲的，则可以发送。如果链路是忙的，则继续帧听，直到检测到链路空闲，立即发送</li>\n<li>P-坚持CSMA：如果链路是空闲的，则以P的概率发送，而以（1-P）的概率延迟一个单位时间。如果链路是忙的，继续监听直至链路空闲。（例如，当有N个站点时，试图传输的站点的期望值为NP，为避免冲突应使<strong>NP&lt;1</strong>）</li>\n</ul>\n</li>\n<li><p>退避算法（二进制指数退避）</p>\n<ul>\n<li>对每一个帧，当第一次发生冲突时，设置参数<code>L=2</code>；</li>\n<li>退避间隔取1到L个时间片中的一个随机数。一个时间片等于链路上最大传输延迟的两倍</li>\n<li>当帧重复发生一次冲突时，则将参数L加倍。L的最大值为1024.即当L增加到1024时，L不再增加</li>\n<li>帧的最大重传次数为16，超过这个次数，则该帧不再重传，并报告出错</li>\n</ul>\n</li>\n<li><p>最短帧长公式：$L_{min} =2×S÷V×R$ </p>\n<ul>\n<li>$L_{min}$：最短数据帧长（$bit$）</li>\n<li>$S$：任意两站点间的最大距离（$m$）</li>\n<li>$R$：数据传输速率（$Mbps$）</li>\n<li>$V$：电子传播速度（$200m/us$）</li>\n</ul>\n</li>\n<li><p>以太网$MAC$帧格式</p>\n<p>| 前导码 |  SFD  | 目标地址 | 源地址 | LLC-PDU长度/类型 |   LLC-PDU   |  CRC  |<br>| :——: | :—-: | :———: | :——: | :———————: | :————-: | :—-: |<br>| 7字节  | 1字节 |  6字节   | 6字节  |      2字节       | 46-1500字节 | 4字节 |</p>\n<ul>\n<li>前导码：包含7个字节，在这个域中，1和0交替出现，警告系统接收即将到来的数据帧，同时使系统能够调整同步输入时钟</li>\n<li>帧起始分界符（SFD）：帧起始分界符标记了<strong>帧的开始</strong>。它只有一个字节，模式是<code>10101011</code>，SFD通知接收方后面所有内容都是数据</li>\n<li>目的地址（DA）：DA域为6个字节，标记了数据帧下一个结点的物理地址</li>\n<li>源地址（SA）：SA域也分配了6个字节。它包含了最后一个转发此帧的设备的物理地址。也是上个结点的物理地址</li>\n<li>LLC-PDU的长度/类型：该字节指出了LLC-PDU的字节数，即LLC-PDU域中的有效字节数</li>\n<li>LLC-PDU：以太网MAC帧讲802.2的整个帧作为透明数据包含了进来。该域的长度可以从46到1500字节不等</li>\n<li>CRC：MAC帧的最后一个域是差错检测，占32位，用CRC</li>\n</ul>\n</li>\n<li><p>以太网种类</p>\n<ul>\n<li>10base5粗缆以太网（总线）</li>\n<li>10base2细缆以太网（总线）</li>\n<li>10base-T双绞线以太网（星型）</li>\n<li>100base-T快速以太网（星型）</li>\n</ul>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第七章-局域网和广域网技术\"><a href=\"#第七章-局域网和广域网技术\" class=\"headerlink\" title=\"第七章 局域网和广域网技术\"></a>第七章 局域网和广域网技术</h2><ol>\n<li><p>IEEE802.2：它是LLC协议标准，分为两个功能子集，<strong>数据链路控制（LLC）子层</strong>和<strong>媒体访问控制（MAC）子层</strong></p>\n</li>\n<li><p>逻辑链路控制（LLC）子层是IEEE802数据链路层的上子层，它对于所有的LAN协议来说都是相同的</p>\n</li>\n<li><p>MAC子层解决共享介质的竞争使用问题。它包含了将数据从一个地方传送到另一个地方所必须的同步、标记、流量和差错控制的规范，同时也包括下一个站点的物理地址。不同的局域网具有不同的MAC协议</p>\n</li>\n<li><p>IEEE802各个标准和OSI模型的层次对应关系</p>\n</li>\n</ol>\n<p><img src=\"img.png\" alt=\"对应关系\"></p>\n<ol>\n<li>逻辑链路控制（LLC）子层</li>\n</ol>\n<p><img src=\"img2.png\" alt=\"对应关系\"></p>\n<ul>\n<li>LLC-PDU与HDLC类似，包含四个域：目的服务访问点（DSAP）、源服务访问点（SSAP）、控制域和信息域</li>\n<li>DASP和SSAP是LLC所使用的地址，SAP叫服务访问点。用来标明接收和发送数据的计算机上的协议栈</li>\n</ul>\n<ol>\n<li><p>LLC地址与MAC地址</p>\n<ul>\n<li>在MAC帧的帧首中，有目的站地址和源站地址，它们是6字节长。MAC帧中的地址是站点的物理地址</li>\n<li>在LLC帧的帧首中，用DSAP和SSAP，该地址是逻辑地址，是数据链路层的不同服务访问点</li>\n</ul>\n</li>\n<li><p>以太网</p>\n<ul>\n<li>IEEE 讲基带划分为5个不同的标准：10Base5、10base-T和100base-T等</li>\n<li>开头数字指明了数据传输速率：最后的数字或字母（5,2，T（双绞线））指明了最大电缆长度或电缆类别；base指明的是基带传输</li>\n<li>IEEE只定义了一个宽带类标准：10Broad36，用于小区网络连接</li>\n<li>IEEE 802.3定义了两类标准：基带和宽带</li>\n<li>基带类使用数字信号传输数据，用以太网使用曼彻斯特编码</li>\n<li>宽带类使用模拟信号传输数据</li>\n</ul>\n</li>\n<li><p>以太网访问模式</p>\n<ul>\n<li><p>在LAN中，多个用户在没有任何控制的情况下同时访问一条线路时，会存在由于不同信号叠加而相互破坏的情况。这就是<strong>冲突</strong>。为了使冲突发生的可能性最小，需要有一种机制来协调通信</p>\n</li>\n<li><p>以太网的媒体访问控制机制称为<strong>带有冲突检测</strong>的载波帧听多路访问（<strong>CSMA/CD</strong>）</p>\n</li>\n<li><strong>多路访问（MA）</strong>：不提供通信管制（<strong>不听就说</strong>）</li>\n<li><strong>载波监听多路访问（CSMA）</strong>：首先监听链路上是否已经存在通信。由于存在传输延迟，还是会出现冲突<strong>（先听后说）</strong></li>\n<li><strong>带有冲突检测的载波监听多路访问（CSMA/CD）</strong>：发送是同CSMA一样，在传输的时候继续监听链路是否发生冲突（<strong>边听边说</strong>）<ul>\n<li>如果链路是空闲的，则可以发送并同时检测冲突</li>\n<li>如果链路的忙的，则继续监听，直到检测到链路空闲</li>\n<li>如果在发送过程中检测到冲突，则停止当前帧的发送，发阻塞信号，等待一段选定的时间（退避间隔）</li>\n<li><strong>先听后发，也听也发，冲突停发，随机重发</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CSMA可分为三种</p>\n<ul>\n<li>非坚持CSMA：如果链路是空闲的，则可以发送。如果链路是忙的，则等待一段时间。等待时间的长短在一个时间范围内随机选择</li>\n<li>坚持CSMA（1-坚持）：如果链路是空闲的，则可以发送。如果链路是忙的，则继续帧听，直到检测到链路空闲，立即发送</li>\n<li>P-坚持CSMA：如果链路是空闲的，则以P的概率发送，而以（1-P）的概率延迟一个单位时间。如果链路是忙的，继续监听直至链路空闲。（例如，当有N个站点时，试图传输的站点的期望值为NP，为避免冲突应使<strong>NP&lt;1</strong>）</li>\n</ul>\n</li>\n<li><p>退避算法（二进制指数退避）</p>\n<ul>\n<li>对每一个帧，当第一次发生冲突时，设置参数<code>L=2</code>；</li>\n<li>退避间隔取1到L个时间片中的一个随机数。一个时间片等于链路上最大传输延迟的两倍</li>\n<li>当帧重复发生一次冲突时，则将参数L加倍。L的最大值为1024.即当L增加到1024时，L不再增加</li>\n<li>帧的最大重传次数为16，超过这个次数，则该帧不再重传，并报告出错</li>\n</ul>\n</li>\n<li><p>最短帧长公式：$L_{min} =2×S÷V×R$ </p>\n<ul>\n<li>$L_{min}$：最短数据帧长（$bit$）</li>\n<li>$S$：任意两站点间的最大距离（$m$）</li>\n<li>$R$：数据传输速率（$Mbps$）</li>\n<li>$V$：电子传播速度（$200m/us$）</li>\n</ul>\n</li>\n<li><p>以太网$MAC$帧格式</p>\n<p>| 前导码 |  SFD  | 目标地址 | 源地址 | LLC-PDU长度/类型 |   LLC-PDU   |  CRC  |<br>| :——: | :—-: | :———: | :——: | :———————: | :————-: | :—-: |<br>| 7字节  | 1字节 |  6字节   | 6字节  |      2字节       | 46-1500字节 | 4字节 |</p>\n<ul>\n<li>前导码：包含7个字节，在这个域中，1和0交替出现，警告系统接收即将到来的数据帧，同时使系统能够调整同步输入时钟</li>\n<li>帧起始分界符（SFD）：帧起始分界符标记了<strong>帧的开始</strong>。它只有一个字节，模式是<code>10101011</code>，SFD通知接收方后面所有内容都是数据</li>\n<li>目的地址（DA）：DA域为6个字节，标记了数据帧下一个结点的物理地址</li>\n<li>源地址（SA）：SA域也分配了6个字节。它包含了最后一个转发此帧的设备的物理地址。也是上个结点的物理地址</li>\n<li>LLC-PDU的长度/类型：该字节指出了LLC-PDU的字节数，即LLC-PDU域中的有效字节数</li>\n<li>LLC-PDU：以太网MAC帧讲802.2的整个帧作为透明数据包含了进来。该域的长度可以从46到1500字节不等</li>\n<li>CRC：MAC帧的最后一个域是差错检测，占32位，用CRC</li>\n</ul>\n</li>\n<li><p>以太网种类</p>\n<ul>\n<li>10base5粗缆以太网（总线）</li>\n<li>10base2细缆以太网（总线）</li>\n<li>10base-T双绞线以太网（星型）</li>\n<li>100base-T快速以太网（星型）</li>\n</ul>\n</li>\n</ol>\n"},{"title":"计网第五章-网络层","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"8cfd","date":"2020-08-10T10:22:12.000Z","password":null,"summary":"第五章 网络层","_content":"## 第五章 网络层\n\n1. 网络层的主要功能：交换和路由\n2. 距离向量路由算法：在距离向量路由中，每个路由器周期性的将自己关于整个网络的信息发送给他的邻居\n   - 每个路由都保存关于整个网络的信息\n   - 仅仅和邻居交换网络信息\n   - 信息的交换是通过有规律的时间间隔来进行的\n\n3. 链路状态路由算法：链路状态路由中，每个路由器和互联网络中的所有其他路由器共享关于其邻居的信息\n   - 共享关于邻居的信息\n   - 共享的信息发送给所有的路由器\n   - 信息的共享在有规律的时间间隔内进行\n\n4. 链路状态数据库\n\n   - $Dijkstra$**算法**：从路由器到网络的链路的费用才有效，而从网络到路由器的链路的费用总是0\n\n     - 每个路由器在使用$Dijkstra$算法时，根据下面四个步骤来形成自己的最短路径树（最小支撑树）\n\n       ①选择自己作为根的结点，并将根标记为永久性结点。算法接着从根出发连接其所有邻居结点。这种结点是临时性的\n\n       ②算法比较所有的临时连接，找出费用最小的路径，该路径上的所有弧和结点被标记为最短路径树上的永久部分\n\n       ③算法考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有非永久性结点，将这些结点临时性地加到最短路径树上\n\n       ④如果所有的结点已经成为最短路径树上的永久部分，则算法结束，去掉非永久性的弧。否则，转步骤②继续执行。\n\n   - $Dijkstra$算法总结\n   \n     ①初始化：设$N$表示网络结点集合，先令$N={1}$，对所有不在$N$中的结点写出：\n     \n     $$\n     S(V)= \\begin{cases} L(1,V) & \\text {;若结点V与结点1相邻}  \\\\ \\infty & \\text {;若结点V与结点1不相邻} \\end{cases}\n     $$\n     \n     ②找出一个不在$N$中的结点W，使$S(W)$值为最小，把$W$加入$N$中，然后对所有不在$N$中的结点按下式更新：\n     $$\n     S(V) \\leftarrow min[S(V),S(W)+L(W,V)]\n     $$\n     \n     ③重复步骤②，直到所有的网络结点都在$N$中为止","source":"_posts/计网第五章-网络层.md","raw":"---\ntitle: 计网第五章-网络层\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nabbrlink: 8cfd\ndate: 2020-08-10 18:22:12\npassword:\nsummary: 第五章 网络层\n---\n## 第五章 网络层\n\n1. 网络层的主要功能：交换和路由\n2. 距离向量路由算法：在距离向量路由中，每个路由器周期性的将自己关于整个网络的信息发送给他的邻居\n   - 每个路由都保存关于整个网络的信息\n   - 仅仅和邻居交换网络信息\n   - 信息的交换是通过有规律的时间间隔来进行的\n\n3. 链路状态路由算法：链路状态路由中，每个路由器和互联网络中的所有其他路由器共享关于其邻居的信息\n   - 共享关于邻居的信息\n   - 共享的信息发送给所有的路由器\n   - 信息的共享在有规律的时间间隔内进行\n\n4. 链路状态数据库\n\n   - $Dijkstra$**算法**：从路由器到网络的链路的费用才有效，而从网络到路由器的链路的费用总是0\n\n     - 每个路由器在使用$Dijkstra$算法时，根据下面四个步骤来形成自己的最短路径树（最小支撑树）\n\n       ①选择自己作为根的结点，并将根标记为永久性结点。算法接着从根出发连接其所有邻居结点。这种结点是临时性的\n\n       ②算法比较所有的临时连接，找出费用最小的路径，该路径上的所有弧和结点被标记为最短路径树上的永久部分\n\n       ③算法考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有非永久性结点，将这些结点临时性地加到最短路径树上\n\n       ④如果所有的结点已经成为最短路径树上的永久部分，则算法结束，去掉非永久性的弧。否则，转步骤②继续执行。\n\n   - $Dijkstra$算法总结\n   \n     ①初始化：设$N$表示网络结点集合，先令$N={1}$，对所有不在$N$中的结点写出：\n     \n     $$\n     S(V)= \\begin{cases} L(1,V) & \\text {;若结点V与结点1相邻}  \\\\ \\infty & \\text {;若结点V与结点1不相邻} \\end{cases}\n     $$\n     \n     ②找出一个不在$N$中的结点W，使$S(W)$值为最小，把$W$加入$N$中，然后对所有不在$N$中的结点按下式更新：\n     $$\n     S(V) \\leftarrow min[S(V),S(W)+L(W,V)]\n     $$\n     \n     ③重复步骤②，直到所有的网络结点都在$N$中为止","slug":"计网第五章-网络层","published":1,"updated":"2020-08-10T12:19:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q690057a09k7d4b5m24","content":"<h2 id=\"第五章-网络层\"><a href=\"#第五章-网络层\" class=\"headerlink\" title=\"第五章 网络层\"></a>第五章 网络层</h2><ol>\n<li>网络层的主要功能：交换和路由</li>\n<li><p>距离向量路由算法：在距离向量路由中，每个路由器周期性的将自己关于整个网络的信息发送给他的邻居</p>\n<ul>\n<li>每个路由都保存关于整个网络的信息</li>\n<li>仅仅和邻居交换网络信息</li>\n<li>信息的交换是通过有规律的时间间隔来进行的</li>\n</ul>\n</li>\n<li><p>链路状态路由算法：链路状态路由中，每个路由器和互联网络中的所有其他路由器共享关于其邻居的信息</p>\n<ul>\n<li>共享关于邻居的信息</li>\n<li>共享的信息发送给所有的路由器</li>\n<li>信息的共享在有规律的时间间隔内进行</li>\n</ul>\n</li>\n<li><p>链路状态数据库</p>\n<ul>\n<li><p>$Dijkstra$<strong>算法</strong>：从路由器到网络的链路的费用才有效，而从网络到路由器的链路的费用总是0</p>\n<ul>\n<li><p>每个路由器在使用$Dijkstra$算法时，根据下面四个步骤来形成自己的最短路径树（最小支撑树）</p>\n<p>①选择自己作为根的结点，并将根标记为永久性结点。算法接着从根出发连接其所有邻居结点。这种结点是临时性的</p>\n<p>②算法比较所有的临时连接，找出费用最小的路径，该路径上的所有弧和结点被标记为最短路径树上的永久部分</p>\n<p>③算法考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有非永久性结点，将这些结点临时性地加到最短路径树上</p>\n<p>④如果所有的结点已经成为最短路径树上的永久部分，则算法结束，去掉非永久性的弧。否则，转步骤②继续执行。</p>\n</li>\n</ul>\n</li>\n<li><p>$Dijkstra$算法总结</p>\n<p>①初始化：设$N$表示网络结点集合，先令$N={1}$，对所有不在$N$中的结点写出：</p>\n<script type=\"math/tex; mode=display\">\nS(V)= \\begin{cases} L(1,V) & \\text {;若结点V与结点1相邻}  \\\\ \\infty & \\text {;若结点V与结点1不相邻} \\end{cases}</script><p>②找出一个不在$N$中的结点W，使$S(W)$值为最小，把$W$加入$N$中，然后对所有不在$N$中的结点按下式更新：</p>\n<script type=\"math/tex; mode=display\">\nS(V) \\leftarrow min[S(V),S(W)+L(W,V)]</script><p>③重复步骤②，直到所有的网络结点都在$N$中为止</p>\n</li>\n</ul>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第五章-网络层\"><a href=\"#第五章-网络层\" class=\"headerlink\" title=\"第五章 网络层\"></a>第五章 网络层</h2><ol>\n<li>网络层的主要功能：交换和路由</li>\n<li><p>距离向量路由算法：在距离向量路由中，每个路由器周期性的将自己关于整个网络的信息发送给他的邻居</p>\n<ul>\n<li>每个路由都保存关于整个网络的信息</li>\n<li>仅仅和邻居交换网络信息</li>\n<li>信息的交换是通过有规律的时间间隔来进行的</li>\n</ul>\n</li>\n<li><p>链路状态路由算法：链路状态路由中，每个路由器和互联网络中的所有其他路由器共享关于其邻居的信息</p>\n<ul>\n<li>共享关于邻居的信息</li>\n<li>共享的信息发送给所有的路由器</li>\n<li>信息的共享在有规律的时间间隔内进行</li>\n</ul>\n</li>\n<li><p>链路状态数据库</p>\n<ul>\n<li><p>$Dijkstra$<strong>算法</strong>：从路由器到网络的链路的费用才有效，而从网络到路由器的链路的费用总是0</p>\n<ul>\n<li><p>每个路由器在使用$Dijkstra$算法时，根据下面四个步骤来形成自己的最短路径树（最小支撑树）</p>\n<p>①选择自己作为根的结点，并将根标记为永久性结点。算法接着从根出发连接其所有邻居结点。这种结点是临时性的</p>\n<p>②算法比较所有的临时连接，找出费用最小的路径，该路径上的所有弧和结点被标记为最短路径树上的永久部分</p>\n<p>③算法考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有非永久性结点，将这些结点临时性地加到最短路径树上</p>\n<p>④如果所有的结点已经成为最短路径树上的永久部分，则算法结束，去掉非永久性的弧。否则，转步骤②继续执行。</p>\n</li>\n</ul>\n</li>\n<li><p>$Dijkstra$算法总结</p>\n<p>①初始化：设$N$表示网络结点集合，先令$N={1}$，对所有不在$N$中的结点写出：</p>\n<script type=\"math/tex; mode=display\">\nS(V)= \\begin{cases} L(1,V) & \\text {;若结点V与结点1相邻}  \\\\ \\infty & \\text {;若结点V与结点1不相邻} \\end{cases}</script><p>②找出一个不在$N$中的结点W，使$S(W)$值为最小，把$W$加入$N$中，然后对所有不在$N$中的结点按下式更新：</p>\n<script type=\"math/tex; mode=display\">\nS(V) \\leftarrow min[S(V),S(W)+L(W,V)]</script><p>③重复步骤②，直到所有的网络结点都在$N$中为止</p>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"计网第八章-TCP/IP协议","top":false,"cover":false,"toc":false,"mathjax":true,"abbrlink":"156a","date":"2020-08-23T02:49:07.000Z","password":null,"summary":"第八章 TCP/IP协议","_content":"## 第八章 TCP/IP协议\n\n1. TCP/IP体系结构\n   - TCP/IP协议的网络层的主要功能是寻址、数据打包和路由选择\n   - 主要协议有：地址解析协议（ARP）、反向地址解析协议（RARP）、网际协议（IP）、Internet控制消息协议（ICMP）和Internet组管理协议（IGMP）\n   - ARP负责将IP地址解析为结点的物理地址，以便于物理设备（如网卡）按该地址接收数据\n   - RARP负责将物理地址解析成IP地址，这个协议主要是针对无盘工作站获得IP地址而设计的\n   - ICMP用于传送差错报文及其他控制信息\n2. 网际协议IP\n   - IP协议是TCP/IP协议族中的核心协议。所有的TCP、UDP、ICMP、IGMP数据都是以IP数据报格式传输的\n   - IP协议为高层提供不可靠、无连接的数据报通信。尽最大努力交付\n\n3. IP地址：网络中的每个独立主机的每个接口必须有一个唯一的Internet地址，也称为**IP地址**。IP地址长度为**32位**。表示地址空间是$2^{32}$\n4. IP地址的表示方法\n   - 二进制表示方法\n   - 点分十进制表示方法：为了使32位地址更加简介和更容易阅读，因特网的地址通常写成用小数点把各字节分隔开的形式。每个字节用一个十进制数表示，这个数小于256\n   - 十六进制表示方法\n   - 二进制表示方法：在二进制表示方法中，用一个32位的比特序列表示IP地址，为了使这个地址有更好的可读性，通常在每个字节之间加上一个或多个空格做分割。例如：`10000001 00001110 00000110 00011111`，但不便于记忆\n\n5. 分类IP地址：IP地址按照层次结构划分成五类：A、B、C、D、E类。每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志一个主机地址。\n\n   ![ip地址分类](ip地址分类.png)\n\n6. 各类IP地址的范围\n\n   ![IP地址范围](IP地址范围.png)\n\n   **助记：**`0～A(128)～B(28+64)～C(128+64+32)～D(128+64+32+16)~E(128+64+32+16+8)`\n\n7. IPv4报文格式\n\n   ![IP报文格式](IP报文格式.png)\n\n   - 总长度：占16位，指首部和数据之和的长度，单位为字节。因此数据报的最大长度为65535字节。总长度必须不超过最大传送单元MTU\n   - 标识（identification）：占16位，它是一个计数器，用来产生数据报的标识\n   - 标志（flag）：占3位，目前只有前两位有意义。\n     - 标识字段的**MF（More Fragment）**。**MF=1表示后面\"还有分片\"**，MF=0表示最后一个分片\n     - 标识字段的**DF（Don't Fragment）**。**DF=0时表示允许分片**\n\n   - 片偏移13位（偏移量）：较长的分组在分片后某片在原分组中的相对位置。**片偏移以8个字节为偏移单位**\n     - 例：以太网的MTU（最大传输单位）为1400字节，路由器将把到达的一个4000字节数据的报文为3段，第一段有1400字节数据，分段偏移为0；第二段有1400字节数据，分段偏移位1400÷8=175；第三段有1200字节数据，分段偏移位350\n\n8. **子网掩码（待补充）**：IP地址 + 子网掩码 = 网络地址\n\n9. 特殊的IP地址\n\n   - 网络地址（NET-ID）：主机标识部分为全\"0\"的IP地址不分配给任何主机，而是作为网络本身的标识\n     - 例：主机 202.198.151.136所在网段的网络地址为：202.198.151.0（主机位变为0）；主机130.100.100.136（B类地址）所在网段的网络地址为：130.100.0.0\n\n   - 直接广播地址：主机标识全为\"1\"的IP地址不分配给任何主机，用做广播地址\n     - 例：主机 202.198.151.136所在网段的直接广播地址为：202.198.151.255（主机位变为1）；主机130.100.100.136（B类地址）所在网段的直接广播地址为：130.100.255.25\n   - 有限广播地址：32位为全为1的IP地址称为有限广播地址\n     - 例：有限广播地址为：255.255.255.255\n   - 主机本身地址：32位为全0的IP地址称为主机本身地址\n     - 例：主机本身地址：0.0.0.0\n\n10. 划分子网：从1985年起在IP地址中又增加了一个\"子网号字段\"，使两级的IP地址变成为三级的IP地址。这种做法叫做划分子网（SubNetting）。划分子网已成为因特网的正式标准协议\n\n    - 目前所有的主机都要求支持子网编址。子网编址不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号进一步划分为一个子网号和一个主机号\n\n      ![B类子网编码](B类子网编码.png)\n\n    - 当没有划分子网时，IP地址是两级结构。划分子网后，IP地址就变成了三级结构\n\n    - 划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id\n\n11. **子网掩码（有待补充）**：从一个IP地址中无法解析源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码（Subnet Mask）可以找出IP地址中的子网部分\n\n12. ARP地址解析协议：就是将主机IP地址映射为硬件地址。在局域网中，网络中实际传输的单元是\"数据帧\"，数据帧的首部有目的主机的MAC地址。在以太网中，一个主机要和另一个主机进行直接通信，必须通过地址解析协议获得目的主机的MAC地址。**ARP协议的基本功能就是通过目的设备的IP地址，查询目标设备的MAC地址（物理地址）**\n\n13. Internet控制报文协议ICMP[网络层]：IP协议是一种不可可靠无连接的包传输。当数据包经过多个网络传输过程中，可能出现错误、目的主机不响应、包拥塞和包丢失等。为了处理这些问题，在IP层引入了一个子协议：ICMP（Internet Control Message Protocol）\n\n14. Internet组管理协议IGMP：IP地址有三种类型，分别是单播地址、广播地址和多播地址。广播和多播地址仅应用于UDP协议，它们主要应用在报文同时传送到多个接收者的情况\n\n    - 多播使用多播地址（D类IP地址）\n    - 当把多播通信扩展到单个网络段以外需要通过路由器转发多播数据时，复杂性就增加了。需要一个协议让多播路由器了解确定网络中属于多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP）\n\n15. 用户数据报协议（UDP）：UDP采用非连接的方式提供应用层的事务处理，UDP不提供可靠性，也就是说，UDP协议不提供端到端的确认和重传功能，他不保证数据包一定能达到目的地，因此称为不可靠协议。UDP必须在IP上运行。他的下层协议是以IP作为前提的\n\n16. 传输控制协议TCP：TCP提供了一种可靠的面向连接的字节流传输层服务，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检查和。尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。\n\n    - TCP连接的建立和释放：建立一个TCP连接需要三次握手，而释放一个TCP连接需要经过4次握手\n    - TCP连接的建立采用客户/服务器方式\n    - 主动发起连接建立的应用进程叫做客户（client）\n    - 被动等待连接的应用进程叫做服务器（server）\n\n    > #### 三次握手:\n    >\n    > TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。\n\n    <img src=\"三次挥手.gif\" alt=\"三次挥手\" style=\"zoom: 67%;\" />\n\n    > ​\t张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。\n    >\n    > ​\t但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。\n    >\n    > ​\t于是两人加快步伐，走到了一起，相互拥抱。\n\n    <img src=\"三次握手建立过程.gif\" alt=\"三次握手建立过程\" style=\"zoom: 50%;\" />\n\n    > ​\t我们看到这个过程中一共是四个动作，张三招手--李四点头微笑--李四招手--张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手--李四点头微笑并招手--张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。\n    >\n    > ​\t我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。\n\n    > #### 四次挥手:\n    > \n    > ​\tTCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。\n\n    <img src=\"四次挥手.gif\" alt=\"四次挥手\" style=\"zoom:67%;\" />\n\n    > ​\t之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。\n\n    <img src=\"四次挥手过程.gif\" alt=\"四次挥手过程\"  />\n    \n    > 上面有一个非常特殊的状态`time_wait`，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。\n    >\n    > 它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的`time_wait`状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。\n    >\n    > 它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。\n    >\n    > 同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。\n    >\n    > 4分钟就是2个MSL，每个MSL是2分钟。MSL就是`maximium segment lifetime`——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。\n    >\n    > 四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从`fin_wait_1`状态直接进入到`time_wait`状态，跳过了`fin_wait_2`状态。","source":"_posts/计网第八章-TCP-IP协议.md","raw":"---\ntitle: 计网第八章-TCP/IP协议\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nabbrlink: 156a\ndate: 2020-08-23 10:49:07\npassword:\nsummary: 第八章 TCP/IP协议\n---\n## 第八章 TCP/IP协议\n\n1. TCP/IP体系结构\n   - TCP/IP协议的网络层的主要功能是寻址、数据打包和路由选择\n   - 主要协议有：地址解析协议（ARP）、反向地址解析协议（RARP）、网际协议（IP）、Internet控制消息协议（ICMP）和Internet组管理协议（IGMP）\n   - ARP负责将IP地址解析为结点的物理地址，以便于物理设备（如网卡）按该地址接收数据\n   - RARP负责将物理地址解析成IP地址，这个协议主要是针对无盘工作站获得IP地址而设计的\n   - ICMP用于传送差错报文及其他控制信息\n2. 网际协议IP\n   - IP协议是TCP/IP协议族中的核心协议。所有的TCP、UDP、ICMP、IGMP数据都是以IP数据报格式传输的\n   - IP协议为高层提供不可靠、无连接的数据报通信。尽最大努力交付\n\n3. IP地址：网络中的每个独立主机的每个接口必须有一个唯一的Internet地址，也称为**IP地址**。IP地址长度为**32位**。表示地址空间是$2^{32}$\n4. IP地址的表示方法\n   - 二进制表示方法\n   - 点分十进制表示方法：为了使32位地址更加简介和更容易阅读，因特网的地址通常写成用小数点把各字节分隔开的形式。每个字节用一个十进制数表示，这个数小于256\n   - 十六进制表示方法\n   - 二进制表示方法：在二进制表示方法中，用一个32位的比特序列表示IP地址，为了使这个地址有更好的可读性，通常在每个字节之间加上一个或多个空格做分割。例如：`10000001 00001110 00000110 00011111`，但不便于记忆\n\n5. 分类IP地址：IP地址按照层次结构划分成五类：A、B、C、D、E类。每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志一个主机地址。\n\n   ![ip地址分类](ip地址分类.png)\n\n6. 各类IP地址的范围\n\n   ![IP地址范围](IP地址范围.png)\n\n   **助记：**`0～A(128)～B(28+64)～C(128+64+32)～D(128+64+32+16)~E(128+64+32+16+8)`\n\n7. IPv4报文格式\n\n   ![IP报文格式](IP报文格式.png)\n\n   - 总长度：占16位，指首部和数据之和的长度，单位为字节。因此数据报的最大长度为65535字节。总长度必须不超过最大传送单元MTU\n   - 标识（identification）：占16位，它是一个计数器，用来产生数据报的标识\n   - 标志（flag）：占3位，目前只有前两位有意义。\n     - 标识字段的**MF（More Fragment）**。**MF=1表示后面\"还有分片\"**，MF=0表示最后一个分片\n     - 标识字段的**DF（Don't Fragment）**。**DF=0时表示允许分片**\n\n   - 片偏移13位（偏移量）：较长的分组在分片后某片在原分组中的相对位置。**片偏移以8个字节为偏移单位**\n     - 例：以太网的MTU（最大传输单位）为1400字节，路由器将把到达的一个4000字节数据的报文为3段，第一段有1400字节数据，分段偏移为0；第二段有1400字节数据，分段偏移位1400÷8=175；第三段有1200字节数据，分段偏移位350\n\n8. **子网掩码（待补充）**：IP地址 + 子网掩码 = 网络地址\n\n9. 特殊的IP地址\n\n   - 网络地址（NET-ID）：主机标识部分为全\"0\"的IP地址不分配给任何主机，而是作为网络本身的标识\n     - 例：主机 202.198.151.136所在网段的网络地址为：202.198.151.0（主机位变为0）；主机130.100.100.136（B类地址）所在网段的网络地址为：130.100.0.0\n\n   - 直接广播地址：主机标识全为\"1\"的IP地址不分配给任何主机，用做广播地址\n     - 例：主机 202.198.151.136所在网段的直接广播地址为：202.198.151.255（主机位变为1）；主机130.100.100.136（B类地址）所在网段的直接广播地址为：130.100.255.25\n   - 有限广播地址：32位为全为1的IP地址称为有限广播地址\n     - 例：有限广播地址为：255.255.255.255\n   - 主机本身地址：32位为全0的IP地址称为主机本身地址\n     - 例：主机本身地址：0.0.0.0\n\n10. 划分子网：从1985年起在IP地址中又增加了一个\"子网号字段\"，使两级的IP地址变成为三级的IP地址。这种做法叫做划分子网（SubNetting）。划分子网已成为因特网的正式标准协议\n\n    - 目前所有的主机都要求支持子网编址。子网编址不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号进一步划分为一个子网号和一个主机号\n\n      ![B类子网编码](B类子网编码.png)\n\n    - 当没有划分子网时，IP地址是两级结构。划分子网后，IP地址就变成了三级结构\n\n    - 划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id\n\n11. **子网掩码（有待补充）**：从一个IP地址中无法解析源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码（Subnet Mask）可以找出IP地址中的子网部分\n\n12. ARP地址解析协议：就是将主机IP地址映射为硬件地址。在局域网中，网络中实际传输的单元是\"数据帧\"，数据帧的首部有目的主机的MAC地址。在以太网中，一个主机要和另一个主机进行直接通信，必须通过地址解析协议获得目的主机的MAC地址。**ARP协议的基本功能就是通过目的设备的IP地址，查询目标设备的MAC地址（物理地址）**\n\n13. Internet控制报文协议ICMP[网络层]：IP协议是一种不可可靠无连接的包传输。当数据包经过多个网络传输过程中，可能出现错误、目的主机不响应、包拥塞和包丢失等。为了处理这些问题，在IP层引入了一个子协议：ICMP（Internet Control Message Protocol）\n\n14. Internet组管理协议IGMP：IP地址有三种类型，分别是单播地址、广播地址和多播地址。广播和多播地址仅应用于UDP协议，它们主要应用在报文同时传送到多个接收者的情况\n\n    - 多播使用多播地址（D类IP地址）\n    - 当把多播通信扩展到单个网络段以外需要通过路由器转发多播数据时，复杂性就增加了。需要一个协议让多播路由器了解确定网络中属于多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP）\n\n15. 用户数据报协议（UDP）：UDP采用非连接的方式提供应用层的事务处理，UDP不提供可靠性，也就是说，UDP协议不提供端到端的确认和重传功能，他不保证数据包一定能达到目的地，因此称为不可靠协议。UDP必须在IP上运行。他的下层协议是以IP作为前提的\n\n16. 传输控制协议TCP：TCP提供了一种可靠的面向连接的字节流传输层服务，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检查和。尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。\n\n    - TCP连接的建立和释放：建立一个TCP连接需要三次握手，而释放一个TCP连接需要经过4次握手\n    - TCP连接的建立采用客户/服务器方式\n    - 主动发起连接建立的应用进程叫做客户（client）\n    - 被动等待连接的应用进程叫做服务器（server）\n\n    > #### 三次握手:\n    >\n    > TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。\n\n    <img src=\"三次挥手.gif\" alt=\"三次挥手\" style=\"zoom: 67%;\" />\n\n    > ​\t张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。\n    >\n    > ​\t但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。\n    >\n    > ​\t于是两人加快步伐，走到了一起，相互拥抱。\n\n    <img src=\"三次握手建立过程.gif\" alt=\"三次握手建立过程\" style=\"zoom: 50%;\" />\n\n    > ​\t我们看到这个过程中一共是四个动作，张三招手--李四点头微笑--李四招手--张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手--李四点头微笑并招手--张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。\n    >\n    > ​\t我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。\n\n    > #### 四次挥手:\n    > \n    > ​\tTCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。\n\n    <img src=\"四次挥手.gif\" alt=\"四次挥手\" style=\"zoom:67%;\" />\n\n    > ​\t之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。\n\n    <img src=\"四次挥手过程.gif\" alt=\"四次挥手过程\"  />\n    \n    > 上面有一个非常特殊的状态`time_wait`，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。\n    >\n    > 它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的`time_wait`状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。\n    >\n    > 它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。\n    >\n    > 同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。\n    >\n    > 4分钟就是2个MSL，每个MSL是2分钟。MSL就是`maximium segment lifetime`——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。\n    >\n    > 四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从`fin_wait_1`状态直接进入到`time_wait`状态，跳过了`fin_wait_2`状态。","slug":"计网第八章-TCP-IP协议","published":1,"updated":"2020-08-25T13:10:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q6a005ca09kbjhsaisp","content":"<h2 id=\"第八章-TCP-IP协议\"><a href=\"#第八章-TCP-IP协议\" class=\"headerlink\" title=\"第八章 TCP/IP协议\"></a>第八章 TCP/IP协议</h2><ol>\n<li>TCP/IP体系结构<ul>\n<li>TCP/IP协议的网络层的主要功能是寻址、数据打包和路由选择</li>\n<li>主要协议有：地址解析协议（ARP）、反向地址解析协议（RARP）、网际协议（IP）、Internet控制消息协议（ICMP）和Internet组管理协议（IGMP）</li>\n<li>ARP负责将IP地址解析为结点的物理地址，以便于物理设备（如网卡）按该地址接收数据</li>\n<li>RARP负责将物理地址解析成IP地址，这个协议主要是针对无盘工作站获得IP地址而设计的</li>\n<li>ICMP用于传送差错报文及其他控制信息</li>\n</ul>\n</li>\n<li><p>网际协议IP</p>\n<ul>\n<li>IP协议是TCP/IP协议族中的核心协议。所有的TCP、UDP、ICMP、IGMP数据都是以IP数据报格式传输的</li>\n<li>IP协议为高层提供不可靠、无连接的数据报通信。尽最大努力交付</li>\n</ul>\n</li>\n<li><p>IP地址：网络中的每个独立主机的每个接口必须有一个唯一的Internet地址，也称为<strong>IP地址</strong>。IP地址长度为<strong>32位</strong>。表示地址空间是$2^{32}$</p>\n</li>\n<li><p>IP地址的表示方法</p>\n<ul>\n<li>二进制表示方法</li>\n<li>点分十进制表示方法：为了使32位地址更加简介和更容易阅读，因特网的地址通常写成用小数点把各字节分隔开的形式。每个字节用一个十进制数表示，这个数小于256</li>\n<li>十六进制表示方法</li>\n<li>二进制表示方法：在二进制表示方法中，用一个32位的比特序列表示IP地址，为了使这个地址有更好的可读性，通常在每个字节之间加上一个或多个空格做分割。例如：<code>10000001 00001110 00000110 00011111</code>，但不便于记忆</li>\n</ul>\n</li>\n<li><p>分类IP地址：IP地址按照层次结构划分成五类：A、B、C、D、E类。每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志一个主机地址。</p>\n<p><img src=\"ip地址分类.png\" alt=\"ip地址分类\"></p>\n</li>\n<li><p>各类IP地址的范围</p>\n<p><img src=\"IP地址范围.png\" alt=\"IP地址范围\"></p>\n<p><strong>助记：</strong><code>0～A(128)～B(28+64)～C(128+64+32)～D(128+64+32+16)~E(128+64+32+16+8)</code></p>\n</li>\n<li><p>IPv4报文格式</p>\n<p><img src=\"IP报文格式.png\" alt=\"IP报文格式\"></p>\n<ul>\n<li>总长度：占16位，指首部和数据之和的长度，单位为字节。因此数据报的最大长度为65535字节。总长度必须不超过最大传送单元MTU</li>\n<li>标识（identification）：占16位，它是一个计数器，用来产生数据报的标识</li>\n<li><p>标志（flag）：占3位，目前只有前两位有意义。</p>\n<ul>\n<li>标识字段的<strong>MF（More Fragment）</strong>。<strong>MF=1表示后面”还有分片”</strong>，MF=0表示最后一个分片</li>\n<li>标识字段的<strong>DF（Don’t Fragment）</strong>。<strong>DF=0时表示允许分片</strong></li>\n</ul>\n</li>\n<li><p>片偏移13位（偏移量）：较长的分组在分片后某片在原分组中的相对位置。<strong>片偏移以8个字节为偏移单位</strong></p>\n<ul>\n<li>例：以太网的MTU（最大传输单位）为1400字节，路由器将把到达的一个4000字节数据的报文为3段，第一段有1400字节数据，分段偏移为0；第二段有1400字节数据，分段偏移位1400÷8=175；第三段有1200字节数据，分段偏移位350</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>子网掩码（待补充）</strong>：IP地址 + 子网掩码 = 网络地址</p>\n</li>\n<li><p>特殊的IP地址</p>\n<ul>\n<li><p>网络地址（NET-ID）：主机标识部分为全”0”的IP地址不分配给任何主机，而是作为网络本身的标识</p>\n<ul>\n<li>例：主机 202.198.151.136所在网段的网络地址为：202.198.151.0（主机位变为0）；主机130.100.100.136（B类地址）所在网段的网络地址为：130.100.0.0</li>\n</ul>\n</li>\n<li><p>直接广播地址：主机标识全为”1”的IP地址不分配给任何主机，用做广播地址</p>\n<ul>\n<li>例：主机 202.198.151.136所在网段的直接广播地址为：202.198.151.255（主机位变为1）；主机130.100.100.136（B类地址）所在网段的直接广播地址为：130.100.255.25</li>\n</ul>\n</li>\n<li>有限广播地址：32位为全为1的IP地址称为有限广播地址<ul>\n<li>例：有限广播地址为：255.255.255.255</li>\n</ul>\n</li>\n<li>主机本身地址：32位为全0的IP地址称为主机本身地址<ul>\n<li>例：主机本身地址：0.0.0.0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>划分子网：从1985年起在IP地址中又增加了一个”子网号字段”，使两级的IP地址变成为三级的IP地址。这种做法叫做划分子网（SubNetting）。划分子网已成为因特网的正式标准协议</p>\n<ul>\n<li><p>目前所有的主机都要求支持子网编址。子网编址不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号进一步划分为一个子网号和一个主机号</p>\n<p><img src=\"B类子网编码.png\" alt=\"B类子网编码\"></p>\n</li>\n<li><p>当没有划分子网时，IP地址是两级结构。划分子网后，IP地址就变成了三级结构</p>\n</li>\n<li><p>划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id</p>\n</li>\n</ul>\n</li>\n<li><p><strong>子网掩码（有待补充）</strong>：从一个IP地址中无法解析源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码（Subnet Mask）可以找出IP地址中的子网部分</p>\n</li>\n<li><p>ARP地址解析协议：就是将主机IP地址映射为硬件地址。在局域网中，网络中实际传输的单元是”数据帧”，数据帧的首部有目的主机的MAC地址。在以太网中，一个主机要和另一个主机进行直接通信，必须通过地址解析协议获得目的主机的MAC地址。<strong>ARP协议的基本功能就是通过目的设备的IP地址，查询目标设备的MAC地址（物理地址）</strong></p>\n</li>\n<li><p>Internet控制报文协议ICMP[网络层]：IP协议是一种不可可靠无连接的包传输。当数据包经过多个网络传输过程中，可能出现错误、目的主机不响应、包拥塞和包丢失等。为了处理这些问题，在IP层引入了一个子协议：ICMP（Internet Control Message Protocol）</p>\n</li>\n<li><p>Internet组管理协议IGMP：IP地址有三种类型，分别是单播地址、广播地址和多播地址。广播和多播地址仅应用于UDP协议，它们主要应用在报文同时传送到多个接收者的情况</p>\n<ul>\n<li>多播使用多播地址（D类IP地址）</li>\n<li>当把多播通信扩展到单个网络段以外需要通过路由器转发多播数据时，复杂性就增加了。需要一个协议让多播路由器了解确定网络中属于多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP）</li>\n</ul>\n</li>\n<li><p>用户数据报协议（UDP）：UDP采用非连接的方式提供应用层的事务处理，UDP不提供可靠性，也就是说，UDP协议不提供端到端的确认和重传功能，他不保证数据包一定能达到目的地，因此称为不可靠协议。UDP必须在IP上运行。他的下层协议是以IP作为前提的</p>\n</li>\n<li><p>传输控制协议TCP：TCP提供了一种可靠的面向连接的字节流传输层服务，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检查和。尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。</p>\n<ul>\n<li>TCP连接的建立和释放：建立一个TCP连接需要三次握手，而释放一个TCP连接需要经过4次握手</li>\n<li>TCP连接的建立采用客户/服务器方式</li>\n<li>主动发起连接建立的应用进程叫做客户（client）</li>\n<li>被动等待连接的应用进程叫做服务器（server）</li>\n</ul>\n<blockquote>\n<h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手:\"></a>三次握手:</h4><p>TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。</p>\n</blockquote>\n<p><img src=\"三次挥手.gif\" alt=\"三次挥手\" style=\"zoom: 67%;\"></p>\n<blockquote>\n<p>​    张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。</p>\n<p>​    但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。</p>\n<p>​    于是两人加快步伐，走到了一起，相互拥抱。</p>\n</blockquote>\n<p><img src=\"三次握手建立过程.gif\" alt=\"三次握手建立过程\" style=\"zoom: 50%;\"></p>\n<blockquote>\n<p>​    我们看到这个过程中一共是四个动作，张三招手—李四点头微笑—李四招手—张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手—李四点头微笑并招手—张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。</p>\n<p>​    我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。</p>\n<h4 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手:\"></a>四次挥手:</h4><p>​    TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。</p>\n</blockquote>\n<p><img src=\"四次挥手.gif\" alt=\"四次挥手\" style=\"zoom:67%;\"></p>\n<blockquote>\n<p>​    之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。</p>\n</blockquote>\n<p><img src=\"四次挥手过程.gif\" alt=\"四次挥手过程\"></p>\n<blockquote>\n<p>上面有一个非常特殊的状态<code>time_wait</code>，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。</p>\n<p>它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的<code>time_wait</code>状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。</p>\n<p>它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。</p>\n<p>同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。</p>\n<p>4分钟就是2个MSL，每个MSL是2分钟。MSL就是<code>maximium segment lifetime</code>——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。</p>\n<p>四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从<code>fin_wait_1</code>状态直接进入到<code>time_wait</code>状态，跳过了<code>fin_wait_2</code>状态。</p>\n</blockquote>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第八章-TCP-IP协议\"><a href=\"#第八章-TCP-IP协议\" class=\"headerlink\" title=\"第八章 TCP/IP协议\"></a>第八章 TCP/IP协议</h2><ol>\n<li>TCP/IP体系结构<ul>\n<li>TCP/IP协议的网络层的主要功能是寻址、数据打包和路由选择</li>\n<li>主要协议有：地址解析协议（ARP）、反向地址解析协议（RARP）、网际协议（IP）、Internet控制消息协议（ICMP）和Internet组管理协议（IGMP）</li>\n<li>ARP负责将IP地址解析为结点的物理地址，以便于物理设备（如网卡）按该地址接收数据</li>\n<li>RARP负责将物理地址解析成IP地址，这个协议主要是针对无盘工作站获得IP地址而设计的</li>\n<li>ICMP用于传送差错报文及其他控制信息</li>\n</ul>\n</li>\n<li><p>网际协议IP</p>\n<ul>\n<li>IP协议是TCP/IP协议族中的核心协议。所有的TCP、UDP、ICMP、IGMP数据都是以IP数据报格式传输的</li>\n<li>IP协议为高层提供不可靠、无连接的数据报通信。尽最大努力交付</li>\n</ul>\n</li>\n<li><p>IP地址：网络中的每个独立主机的每个接口必须有一个唯一的Internet地址，也称为<strong>IP地址</strong>。IP地址长度为<strong>32位</strong>。表示地址空间是$2^{32}$</p>\n</li>\n<li><p>IP地址的表示方法</p>\n<ul>\n<li>二进制表示方法</li>\n<li>点分十进制表示方法：为了使32位地址更加简介和更容易阅读，因特网的地址通常写成用小数点把各字节分隔开的形式。每个字节用一个十进制数表示，这个数小于256</li>\n<li>十六进制表示方法</li>\n<li>二进制表示方法：在二进制表示方法中，用一个32位的比特序列表示IP地址，为了使这个地址有更好的可读性，通常在每个字节之间加上一个或多个空格做分割。例如：<code>10000001 00001110 00000110 00011111</code>，但不便于记忆</li>\n</ul>\n</li>\n<li><p>分类IP地址：IP地址按照层次结构划分成五类：A、B、C、D、E类。每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志一个主机地址。</p>\n<p><img src=\"ip地址分类.png\" alt=\"ip地址分类\"></p>\n</li>\n<li><p>各类IP地址的范围</p>\n<p><img src=\"IP地址范围.png\" alt=\"IP地址范围\"></p>\n<p><strong>助记：</strong><code>0～A(128)～B(28+64)～C(128+64+32)～D(128+64+32+16)~E(128+64+32+16+8)</code></p>\n</li>\n<li><p>IPv4报文格式</p>\n<p><img src=\"IP报文格式.png\" alt=\"IP报文格式\"></p>\n<ul>\n<li>总长度：占16位，指首部和数据之和的长度，单位为字节。因此数据报的最大长度为65535字节。总长度必须不超过最大传送单元MTU</li>\n<li>标识（identification）：占16位，它是一个计数器，用来产生数据报的标识</li>\n<li><p>标志（flag）：占3位，目前只有前两位有意义。</p>\n<ul>\n<li>标识字段的<strong>MF（More Fragment）</strong>。<strong>MF=1表示后面”还有分片”</strong>，MF=0表示最后一个分片</li>\n<li>标识字段的<strong>DF（Don’t Fragment）</strong>。<strong>DF=0时表示允许分片</strong></li>\n</ul>\n</li>\n<li><p>片偏移13位（偏移量）：较长的分组在分片后某片在原分组中的相对位置。<strong>片偏移以8个字节为偏移单位</strong></p>\n<ul>\n<li>例：以太网的MTU（最大传输单位）为1400字节，路由器将把到达的一个4000字节数据的报文为3段，第一段有1400字节数据，分段偏移为0；第二段有1400字节数据，分段偏移位1400÷8=175；第三段有1200字节数据，分段偏移位350</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>子网掩码（待补充）</strong>：IP地址 + 子网掩码 = 网络地址</p>\n</li>\n<li><p>特殊的IP地址</p>\n<ul>\n<li><p>网络地址（NET-ID）：主机标识部分为全”0”的IP地址不分配给任何主机，而是作为网络本身的标识</p>\n<ul>\n<li>例：主机 202.198.151.136所在网段的网络地址为：202.198.151.0（主机位变为0）；主机130.100.100.136（B类地址）所在网段的网络地址为：130.100.0.0</li>\n</ul>\n</li>\n<li><p>直接广播地址：主机标识全为”1”的IP地址不分配给任何主机，用做广播地址</p>\n<ul>\n<li>例：主机 202.198.151.136所在网段的直接广播地址为：202.198.151.255（主机位变为1）；主机130.100.100.136（B类地址）所在网段的直接广播地址为：130.100.255.25</li>\n</ul>\n</li>\n<li>有限广播地址：32位为全为1的IP地址称为有限广播地址<ul>\n<li>例：有限广播地址为：255.255.255.255</li>\n</ul>\n</li>\n<li>主机本身地址：32位为全0的IP地址称为主机本身地址<ul>\n<li>例：主机本身地址：0.0.0.0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>划分子网：从1985年起在IP地址中又增加了一个”子网号字段”，使两级的IP地址变成为三级的IP地址。这种做法叫做划分子网（SubNetting）。划分子网已成为因特网的正式标准协议</p>\n<ul>\n<li><p>目前所有的主机都要求支持子网编址。子网编址不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号进一步划分为一个子网号和一个主机号</p>\n<p><img src=\"B类子网编码.png\" alt=\"B类子网编码\"></p>\n</li>\n<li><p>当没有划分子网时，IP地址是两级结构。划分子网后，IP地址就变成了三级结构</p>\n</li>\n<li><p>划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id</p>\n</li>\n</ul>\n</li>\n<li><p><strong>子网掩码（有待补充）</strong>：从一个IP地址中无法解析源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码（Subnet Mask）可以找出IP地址中的子网部分</p>\n</li>\n<li><p>ARP地址解析协议：就是将主机IP地址映射为硬件地址。在局域网中，网络中实际传输的单元是”数据帧”，数据帧的首部有目的主机的MAC地址。在以太网中，一个主机要和另一个主机进行直接通信，必须通过地址解析协议获得目的主机的MAC地址。<strong>ARP协议的基本功能就是通过目的设备的IP地址，查询目标设备的MAC地址（物理地址）</strong></p>\n</li>\n<li><p>Internet控制报文协议ICMP[网络层]：IP协议是一种不可可靠无连接的包传输。当数据包经过多个网络传输过程中，可能出现错误、目的主机不响应、包拥塞和包丢失等。为了处理这些问题，在IP层引入了一个子协议：ICMP（Internet Control Message Protocol）</p>\n</li>\n<li><p>Internet组管理协议IGMP：IP地址有三种类型，分别是单播地址、广播地址和多播地址。广播和多播地址仅应用于UDP协议，它们主要应用在报文同时传送到多个接收者的情况</p>\n<ul>\n<li>多播使用多播地址（D类IP地址）</li>\n<li>当把多播通信扩展到单个网络段以外需要通过路由器转发多播数据时，复杂性就增加了。需要一个协议让多播路由器了解确定网络中属于多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP）</li>\n</ul>\n</li>\n<li><p>用户数据报协议（UDP）：UDP采用非连接的方式提供应用层的事务处理，UDP不提供可靠性，也就是说，UDP协议不提供端到端的确认和重传功能，他不保证数据包一定能达到目的地，因此称为不可靠协议。UDP必须在IP上运行。他的下层协议是以IP作为前提的</p>\n</li>\n<li><p>传输控制协议TCP：TCP提供了一种可靠的面向连接的字节流传输层服务，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检查和。尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。</p>\n<ul>\n<li>TCP连接的建立和释放：建立一个TCP连接需要三次握手，而释放一个TCP连接需要经过4次握手</li>\n<li>TCP连接的建立采用客户/服务器方式</li>\n<li>主动发起连接建立的应用进程叫做客户（client）</li>\n<li>被动等待连接的应用进程叫做服务器（server）</li>\n</ul>\n<blockquote>\n<h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手:\"></a>三次握手:</h4><p>TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。</p>\n</blockquote>\n<p><img src=\"三次挥手.gif\" alt=\"三次挥手\" style=\"zoom: 67%;\" /></p>\n<blockquote>\n<p>​    张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。</p>\n<p>​    但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。</p>\n<p>​    于是两人加快步伐，走到了一起，相互拥抱。</p>\n</blockquote>\n<p><img src=\"三次握手建立过程.gif\" alt=\"三次握手建立过程\" style=\"zoom: 50%;\" /></p>\n<blockquote>\n<p>​    我们看到这个过程中一共是四个动作，张三招手—李四点头微笑—李四招手—张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手—李四点头微笑并招手—张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。</p>\n<p>​    我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。</p>\n<h4 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手:\"></a>四次挥手:</h4><p>​    TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。</p>\n</blockquote>\n<p><img src=\"四次挥手.gif\" alt=\"四次挥手\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>​    之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。</p>\n</blockquote>\n<p><img src=\"四次挥手过程.gif\" alt=\"四次挥手过程\"  /></p>\n<blockquote>\n<p>上面有一个非常特殊的状态<code>time_wait</code>，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。</p>\n<p>它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的<code>time_wait</code>状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。</p>\n<p>它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。</p>\n<p>同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。</p>\n<p>4分钟就是2个MSL，每个MSL是2分钟。MSL就是<code>maximium segment lifetime</code>——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。</p>\n<p>四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从<code>fin_wait_1</code>状态直接进入到<code>time_wait</code>状态，跳过了<code>fin_wait_2</code>状态。</p>\n</blockquote>\n</li>\n</ol>\n"},{"title":"计网第六章-传输层","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"第六章 传输层","abbrlink":"2140","date":"2020-08-12T06:41:19.000Z","password":null,"_content":"## 第六章 传输层\n\n1. 在OSI参考模型中，传输层位于通信子网和资源子网之间，是整个协议层次中最核心的一层\n2. 传输层的作用：在优化网络服务的基础上，为源主机上的进程和目的主机上的进程之间**提供可靠地透明数据传送**，使高层用户在相互通信时不必关心通信子网实现的细节\n3. 拥塞控制\n   - Cwnd --- 拥塞窗口（发送端窗口的大小，不和Rwnd一致）\n   - Rwnd --- 接收端窗口\n   - SMSS --- 发送端最大数据段尺寸（单个数据段的大小上限，不包括TCP/IP报文的头）\n   - Ssthresh --- 慢启动阀值（调整拥塞窗口增长）\n4. 慢启动\n\n","source":"_posts/计网第六章-传输层.md","raw":"---\ntitle: 计网第六章-传输层\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nsummary: 第六章 传输层\nabbrlink: '2140'\ndate: 2020-08-12 14:41:19\npassword:\n---\n## 第六章 传输层\n\n1. 在OSI参考模型中，传输层位于通信子网和资源子网之间，是整个协议层次中最核心的一层\n2. 传输层的作用：在优化网络服务的基础上，为源主机上的进程和目的主机上的进程之间**提供可靠地透明数据传送**，使高层用户在相互通信时不必关心通信子网实现的细节\n3. 拥塞控制\n   - Cwnd --- 拥塞窗口（发送端窗口的大小，不和Rwnd一致）\n   - Rwnd --- 接收端窗口\n   - SMSS --- 发送端最大数据段尺寸（单个数据段的大小上限，不包括TCP/IP报文的头）\n   - Ssthresh --- 慢启动阀值（调整拥塞窗口增长）\n4. 慢启动\n\n","slug":"计网第六章-传输层","published":1,"updated":"2020-09-08T08:11:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q6b005fa09kgeyah8c3","content":"<h2 id=\"第六章-传输层\"><a href=\"#第六章-传输层\" class=\"headerlink\" title=\"第六章 传输层\"></a>第六章 传输层</h2><ol>\n<li>在OSI参考模型中，传输层位于通信子网和资源子网之间，是整个协议层次中最核心的一层</li>\n<li>传输层的作用：在优化网络服务的基础上，为源主机上的进程和目的主机上的进程之间<strong>提供可靠地透明数据传送</strong>，使高层用户在相互通信时不必关心通信子网实现的细节</li>\n<li>拥塞控制<ul>\n<li>Cwnd —- 拥塞窗口（发送端窗口的大小，不和Rwnd一致）</li>\n<li>Rwnd —- 接收端窗口</li>\n<li>SMSS —- 发送端最大数据段尺寸（单个数据段的大小上限，不包括TCP/IP报文的头）</li>\n<li>Ssthresh —- 慢启动阀值（调整拥塞窗口增长）</li>\n</ul>\n</li>\n<li>慢启动</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第六章-传输层\"><a href=\"#第六章-传输层\" class=\"headerlink\" title=\"第六章 传输层\"></a>第六章 传输层</h2><ol>\n<li>在OSI参考模型中，传输层位于通信子网和资源子网之间，是整个协议层次中最核心的一层</li>\n<li>传输层的作用：在优化网络服务的基础上，为源主机上的进程和目的主机上的进程之间<strong>提供可靠地透明数据传送</strong>，使高层用户在相互通信时不必关心通信子网实现的细节</li>\n<li>拥塞控制<ul>\n<li>Cwnd —- 拥塞窗口（发送端窗口的大小，不和Rwnd一致）</li>\n<li>Rwnd —- 接收端窗口</li>\n<li>SMSS —- 发送端最大数据段尺寸（单个数据段的大小上限，不包括TCP/IP报文的头）</li>\n<li>Ssthresh —- 慢启动阀值（调整拥塞窗口增长）</li>\n</ul>\n</li>\n<li>慢启动</li>\n</ol>\n"},{"title":"计网第四章-数据链路层","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"第四章 数据链路层","abbrlink":"2693","date":"2020-07-28T11:51:43.000Z","password":null,"_content":"## 第四章 数据链路层\n\n1. 线路规程：\n\n   - 询问/确认模式\n\n     - 使用场合：一条链路的两端的设备级别相同，任意一个设备都可以启动一个会话过程\n\n     - 工作方式：启动方首先发送一个询问帧（ENQ）询问接收方是否可以接收数据。接收方如果已经准备好接收，必须回答一个确认帧（ACK）。一旦讲所有数据发送完毕，发送系统以一个传输结束帧（EOT）结束传输\n- 轮询/选择模式\n     - 使用场合：在有一个设备作为主设备，其他设备为从设备的多点连接系统\n     - 工作方式\n     - 选择：当主设备有数据发送时就采用选择模式。在发送数据前，主设备产生并发送一个选择帧（SEL），并在帧的地址域中填入接收数据的从设备的地址。如果从设备是激活的并且正在运行，其地址和选择帧中的地址域中的地址相同，它向主设备返回一个确认帧（ACK）。\n     - 轮询：轮询功能是主设备请求从设备进行传输。在没有接到请求前，从设备是不允许发送数据的。当主设备收到否认帧，主设备就轮询下一个从设备，直到他发现一个要发送的从设备为止。当回应是数据帧时，从设备读入该帧并向从设备返回一个确认帧来确认已经接收。\n2. 流量控制与差错控制\n   - 自动重复请求（ARQ）：数据帧在传输中出现错误，接收方就返回一个否定应答帧（NAK），出错的帧就会被发送方重新传送。这个过程叫做自动重复请求。\n   - 数据被重传的情况有三种：**帧破坏、帧丢失和应答帧丢失**\n   - 流量控制和差错控制是结合在一起实现的。\n\n3. **停止等待协议**\n\n   - 发送方每发送一帧后就等待应答。只有收到一个应答帧（ACK）后，才发送下一个帧。直到发送方发送一个传输结束帧（也就是线路上只有一帧）\n\n   - 完成一帧发送所需最短的时间\n\n     - 一个窗口时间$WT$。$WT=t_1+2t_p+2t_{Proc}+t_S$。\n     \n       _其中，$t_I$是发送一个数据帧的时间，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒。_\n     \n       _$t_s$是确认帧的发送时间，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒。_\n     \n       _$t_p$是电信号在物理链路上的传播延迟。_\n     \n       $t_{Proc}$是收到一帧的处理时间和一个帧的形成时间。\n     \n     \n\n4. **滑动窗口协议**\n   - 流量控制：发送方在收到应答消息前可以发送多个帧。接收方使用一个确认（ACK）帧来对多个帧的接收进行确认。具体可以接受多少帧视窗口大小而定。\n     - 回退n自动重复请求\n     - 选择拒绝自动重复请求：窗口尺寸小于等于$n/2$。","source":"_posts/计网第四章-数据链路层.md","raw":"---\ntitle: 计网第四章-数据链路层\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 计网\n  - 总结\n  - 考研\ncategories:\n  - 计网\nsummary: 第四章 数据链路层\nabbrlink: '2693'\ndate: 2020-07-28 19:51:43\npassword:\n---\n## 第四章 数据链路层\n\n1. 线路规程：\n\n   - 询问/确认模式\n\n     - 使用场合：一条链路的两端的设备级别相同，任意一个设备都可以启动一个会话过程\n\n     - 工作方式：启动方首先发送一个询问帧（ENQ）询问接收方是否可以接收数据。接收方如果已经准备好接收，必须回答一个确认帧（ACK）。一旦讲所有数据发送完毕，发送系统以一个传输结束帧（EOT）结束传输\n- 轮询/选择模式\n     - 使用场合：在有一个设备作为主设备，其他设备为从设备的多点连接系统\n     - 工作方式\n     - 选择：当主设备有数据发送时就采用选择模式。在发送数据前，主设备产生并发送一个选择帧（SEL），并在帧的地址域中填入接收数据的从设备的地址。如果从设备是激活的并且正在运行，其地址和选择帧中的地址域中的地址相同，它向主设备返回一个确认帧（ACK）。\n     - 轮询：轮询功能是主设备请求从设备进行传输。在没有接到请求前，从设备是不允许发送数据的。当主设备收到否认帧，主设备就轮询下一个从设备，直到他发现一个要发送的从设备为止。当回应是数据帧时，从设备读入该帧并向从设备返回一个确认帧来确认已经接收。\n2. 流量控制与差错控制\n   - 自动重复请求（ARQ）：数据帧在传输中出现错误，接收方就返回一个否定应答帧（NAK），出错的帧就会被发送方重新传送。这个过程叫做自动重复请求。\n   - 数据被重传的情况有三种：**帧破坏、帧丢失和应答帧丢失**\n   - 流量控制和差错控制是结合在一起实现的。\n\n3. **停止等待协议**\n\n   - 发送方每发送一帧后就等待应答。只有收到一个应答帧（ACK）后，才发送下一个帧。直到发送方发送一个传输结束帧（也就是线路上只有一帧）\n\n   - 完成一帧发送所需最短的时间\n\n     - 一个窗口时间$WT$。$WT=t_1+2t_p+2t_{Proc}+t_S$。\n     \n       _其中，$t_I$是发送一个数据帧的时间，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒。_\n     \n       _$t_s$是确认帧的发送时间，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒。_\n     \n       _$t_p$是电信号在物理链路上的传播延迟。_\n     \n       $t_{Proc}$是收到一帧的处理时间和一个帧的形成时间。\n     \n     \n\n4. **滑动窗口协议**\n   - 流量控制：发送方在收到应答消息前可以发送多个帧。接收方使用一个确认（ACK）帧来对多个帧的接收进行确认。具体可以接受多少帧视窗口大小而定。\n     - 回退n自动重复请求\n     - 选择拒绝自动重复请求：窗口尺寸小于等于$n/2$。","slug":"计网第四章-数据链路层","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q6c005ka09kc5p7127v","content":"<h2 id=\"第四章-数据链路层\"><a href=\"#第四章-数据链路层\" class=\"headerlink\" title=\"第四章 数据链路层\"></a>第四章 数据链路层</h2><ol>\n<li><p>线路规程：</p>\n<ul>\n<li><p>询问/确认模式</p>\n<ul>\n<li><p>使用场合：一条链路的两端的设备级别相同，任意一个设备都可以启动一个会话过程</p>\n</li>\n<li><p>工作方式：启动方首先发送一个询问帧（ENQ）询问接收方是否可以接收数据。接收方如果已经准备好接收，必须回答一个确认帧（ACK）。一旦讲所有数据发送完毕，发送系统以一个传输结束帧（EOT）结束传输</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>轮询/选择模式<ul>\n<li>使用场合：在有一个设备作为主设备，其他设备为从设备的多点连接系统</li>\n<li>工作方式</li>\n<li>选择：当主设备有数据发送时就采用选择模式。在发送数据前，主设备产生并发送一个选择帧（SEL），并在帧的地址域中填入接收数据的从设备的地址。如果从设备是激活的并且正在运行，其地址和选择帧中的地址域中的地址相同，它向主设备返回一个确认帧（ACK）。</li>\n<li>轮询：轮询功能是主设备请求从设备进行传输。在没有接到请求前，从设备是不允许发送数据的。当主设备收到否认帧，主设备就轮询下一个从设备，直到他发现一个要发送的从设备为止。当回应是数据帧时，从设备读入该帧并向从设备返回一个确认帧来确认已经接收。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>流量控制与差错控制</p>\n<ul>\n<li>自动重复请求（ARQ）：数据帧在传输中出现错误，接收方就返回一个否定应答帧（NAK），出错的帧就会被发送方重新传送。这个过程叫做自动重复请求。</li>\n<li>数据被重传的情况有三种：<strong>帧破坏、帧丢失和应答帧丢失</strong></li>\n<li>流量控制和差错控制是结合在一起实现的。</li>\n</ul>\n</li>\n<li><p><strong>停止等待协议</strong></p>\n<ul>\n<li><p>发送方每发送一帧后就等待应答。只有收到一个应答帧（ACK）后，才发送下一个帧。直到发送方发送一个传输结束帧（也就是线路上只有一帧）</p>\n</li>\n<li><p>完成一帧发送所需最短的时间</p>\n<ul>\n<li><p>一个窗口时间$WT$。$WT=t_1+2t_p+2t_{Proc}+t_S$。</p>\n<p>_其中，$t_I$是发送一个数据帧的时间，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒。_</p>\n<p>_$t_s$是确认帧的发送时间，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒。_</p>\n<p>_$t_p$是电信号在物理链路上的传播延迟。_</p>\n<p>$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><strong>滑动窗口协议</strong><ul>\n<li>流量控制：发送方在收到应答消息前可以发送多个帧。接收方使用一个确认（ACK）帧来对多个帧的接收进行确认。具体可以接受多少帧视窗口大小而定。<ul>\n<li>回退n自动重复请求</li>\n<li>选择拒绝自动重复请求：窗口尺寸小于等于$n/2$。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第四章-数据链路层\"><a href=\"#第四章-数据链路层\" class=\"headerlink\" title=\"第四章 数据链路层\"></a>第四章 数据链路层</h2><ol>\n<li><p>线路规程：</p>\n<ul>\n<li><p>询问/确认模式</p>\n<ul>\n<li><p>使用场合：一条链路的两端的设备级别相同，任意一个设备都可以启动一个会话过程</p>\n</li>\n<li><p>工作方式：启动方首先发送一个询问帧（ENQ）询问接收方是否可以接收数据。接收方如果已经准备好接收，必须回答一个确认帧（ACK）。一旦讲所有数据发送完毕，发送系统以一个传输结束帧（EOT）结束传输</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>轮询/选择模式<ul>\n<li>使用场合：在有一个设备作为主设备，其他设备为从设备的多点连接系统</li>\n<li>工作方式</li>\n<li>选择：当主设备有数据发送时就采用选择模式。在发送数据前，主设备产生并发送一个选择帧（SEL），并在帧的地址域中填入接收数据的从设备的地址。如果从设备是激活的并且正在运行，其地址和选择帧中的地址域中的地址相同，它向主设备返回一个确认帧（ACK）。</li>\n<li>轮询：轮询功能是主设备请求从设备进行传输。在没有接到请求前，从设备是不允许发送数据的。当主设备收到否认帧，主设备就轮询下一个从设备，直到他发现一个要发送的从设备为止。当回应是数据帧时，从设备读入该帧并向从设备返回一个确认帧来确认已经接收。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>流量控制与差错控制</p>\n<ul>\n<li>自动重复请求（ARQ）：数据帧在传输中出现错误，接收方就返回一个否定应答帧（NAK），出错的帧就会被发送方重新传送。这个过程叫做自动重复请求。</li>\n<li>数据被重传的情况有三种：<strong>帧破坏、帧丢失和应答帧丢失</strong></li>\n<li>流量控制和差错控制是结合在一起实现的。</li>\n</ul>\n</li>\n<li><p><strong>停止等待协议</strong></p>\n<ul>\n<li><p>发送方每发送一帧后就等待应答。只有收到一个应答帧（ACK）后，才发送下一个帧。直到发送方发送一个传输结束帧（也就是线路上只有一帧）</p>\n</li>\n<li><p>完成一帧发送所需最短的时间</p>\n<ul>\n<li><p>一个窗口时间$WT$。$WT=t_1+2t_p+2t_{Proc}+t_S$。</p>\n<p>_其中，$t_I$是发送一个数据帧的时间，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒。_</p>\n<p>_$t_s$是确认帧的发送时间，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒。_</p>\n<p>_$t_p$是电信号在物理链路上的传播延迟。_</p>\n<p>$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><strong>滑动窗口协议</strong><ul>\n<li>流量控制：发送方在收到应答消息前可以发送多个帧。接收方使用一个确认（ACK）帧来对多个帧的接收进行确认。具体可以接受多少帧视窗口大小而定。<ul>\n<li>回退n自动重复请求</li>\n<li>选择拒绝自动重复请求：窗口尺寸小于等于$n/2$。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"链表代码","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"链表代码整理","abbrlink":"d09f","date":"2020-08-26T13:14:06.000Z","password":null,"_content":"\n## 链表相关代码\n\n> #### 1.单链表结点类型描述\n```c\ntypedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *next;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\n```\n\n\n> #### 2.链表创建（头插法）\n>\n> 每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$\n\n> - `sizeof`函数计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示\n> - `malloc`函数用于在内存开辟了一段地址，而这段地址的首地址存在返回的那个指针变量里，由于不知道到底这段地址有多长，可以存什么变量，所以它的类型是空的，你可以强制类型转换，使其变成确定长度，固定存放一种数据类型的地址，而不管它是哪种类型，其首地址还是原来那个，还是存在一个指针变量中，指针变量就是放指针的嘛，指针是一个地址，指针变量是一个我们定义的，用来放那个地址的变量。\n>\n> **那么代码的意思就是说：**\n>\n> - 分配一个内存，大小是LNode的大小，并将这个内存地址转化为Linklist型，然后将赋给L，所以L为地址。是给L赋值，也就是L被改为指向malloc()新分配的地址\n>\n```c\nLinkList CreatList(LinkList &L){\n    LNode *s;\n    int x;                                  //待插入的数据x\n    L = (LinkList)malloc(sizeof(LNode));    //创建LNode型头结点，并强制转换成LinkList类型，头结点\n                                            //L是一个指针的地址，所以要转化成指针类型\n    L -> next = NULL;                       //初始为空链表\n    scanf(\"%d\",x);                          //输入结点的值\n    while(x!=9999){                         //输入9999表示结束\n        //申请一个LNode大小的空间,得到的指针强制转换为指向Lnode类型的指针,然后赋值给s\n        s = (LNode*)malloc(sizeof(LNode));  //创建新节点，这句话的作用是由系统生成一个LNode型链表\n                                            //的结点，同时将该结点的起始位置赋给指针变量s\n                                            //，s为LNode型的指针\n        s -> data = x;                      //赋值\n        s ->next = L -> next;\n        L -> next = s;                      //将新结点插入表中，L为头指针，注意头插法的代码顺序\n        scanf(\"%d\",&x)                      //继续输入值\n    }\n    return L;\n}\n```\n\n> #### 3.链表创建（尾插法）\n>\n> 每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$\n\n```c\nLinkList CreatList(LinkList &L){\n    int x;                                  //待插入数据\n    L = (LinkList)maclloc(sizeof(LNode));   //创建头结点\n    LNode *s, *r = L;                       //r为表尾指针\n    scanf(\"%d\",x);                          //输入结点的值\n    while(x!=9999){\n        s = (LNode*)malloc(sizeof(LNode));  //创建新结点\n        s -> data = x;                      //赋值\n        r -> next = s;                      //尾插法，插入的结点在尾指针的后边\n        r = s;                              //尾指针r再指向新插入尾部的结点s\n        scanf(\"%d\",&x);                     //继续输入值\n    }\n    r -> next = NULL;                       //尾结点指针置空\n    return L;\n}\n```\n\n> #### 4.链表的排序（**重点**）不理解，要复习\n\n```c\nvoid sort(LinkList &L){\n    LNode *p = L -> next, *pre;\n    LNode *r = p -> next;\n    p -> next = NULL;\n    p = r;\n    while(p!=NULL){\n        r = p -> next;\n        pre = L;\n        while(pre->next != NULL && pre->next->data < p->data){\n            pre = pre -> next;\n        }\n        p -> next = pre -> next;\n        pre -> next = p;\n        p = r;\n    }\n}\n```\n\n> #### 5.链表的插入\n\n- 将元素x插入到第n个位置上，需要先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点（链表带头结点）\n\n  ```c\n  bool Insert(LinkList &L,int n,int e){             //链表L引用型\n      LNode *pre = L,*p = L->next;                  //LNode型pre指针指向头结点L，p指针指向next\n      int i = 1;                                    //开始计数\n      while(i<n && p){\n          pre = p;                                  //直到到达n，找到前驱pre\n          p = p -> next;\n          i++\n      }\n      if(i == n){\n          LNode *s = (LNode*)malloc(sizeof(LNode)); //新建指针s指向结点\n          s -> data = e;                            //赋值为e\n          s -> next = pre -> next;                  //新插入的s的后继指向pre的后继\n          pre -> next = s;                          //pre的后继指向s\n          return true;                              //完成插入\n      }else{\n          return false;\n      }\n  }\n  ```\n\n- 将元素x插入到有序链表中，使其仍然有序（链表带头结点）\n\n  ```c\n  void Insert(LinkList &L, int e){\n      LNode *pre = L,*p = L->next;\n      while(p){                                     //判断p指针的数据和元素e的大小\n          if(p->data < e){\n              pre = p;                              //直到找到\n              p = p -> next;\n          }else{\n              break;                                //当找到后，跳出循环\n          }\n      }\n      LNode *s = (LNode*)malloc(sizeof(LNode));     //分配s指针的结点\n      s -> data = e;                                //插入数据\n      s -> next = pre -> next;\n      pre ->next = s;\n  }\n  ```\n\n> #### 5.链表的删除\n\n- 删除链表中值为x的结点\n\n  ```c\n  void Del(LinkList &L,int x){\n      LNode *pre = L;                   //pre指针指向头结点\n      LNode *p = L -> next;             //p指针指向头结点的next\n      while(p){                         //p不为空时\n          if(p->data != x){             //如果没有查询到\n              pre = p;                  //两个指针依次往后移\n              p = p -> next;\n          }else{                        //直到p指针的值与x的相同\n              pre -> next = p -> next;  //删除节点\n              free(p);                  //free多余的结点\n              p = pre -> next;\n          }\n      }\n      return L;\n  }\n  ```\n\n- 删除链表中最大值的结点（多加入两个确定最大值的指针即可）\n\n  ```c\n  LinkList Del(LinkList &L, int x){\n      LNode *pre = L, *p = L -> next, *mpre = pre, *mp = p; //建立结点\n      while(p){\n          if(p->data > mp->data){                           //比较数据的大小\n              mpre = pre;                                   //如果大于，最大值指向p\n              mp = p;\n          }\n          pre = p;                                          //一次往后查找\n          p = p -> next;\n      }\n      mpre -> next = mp -> next;                            //删除节点\n      free(mp);\n      return L;\n  }\n  ```\n\n- 删除**有序**链表中重复值节点\n\n  ```c\n  LinkList Del(LinkList &L, int x){\n      LNode *pre = L, *p = L -> next;\n      while(p){\n          if(pre->next && pre->next->data == p->data){\n              pre -> next = p -> next;\n              free(p);\n              p = pre -> next;\n          }else{\n              pre = p;\n              p = p -> next;\n          }\n      }\n      return L;\n  }\n  ```\n\n> #### 6. 链表的逆置\n\n- 将链表L的所有结点逆置（采用头插法）\n\n  ```c\n  LinkList Inversion(LinkList &L){\n      LNode *p = L -> next, *r;\n      L -> next = NULL;\n      while(p){\n          r = p -> next;\n          p -> next = L -> next;\n          L -> next = p;\n          p = r;\n      }\n      return L;\n  }\n  ```\n\n> #### 7. 链表的合并\n\n- 将两个有序链表合并为一个有序链表\n\n  ```c\n  LinkList Merge(LinkList &L1, LinkList &L2){\n      LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n      L1 -> next = NULL;\n      while(p && q){\n          if(p->data < q->data){\n              r -> next = p;\n              r = p;\n              p = p -> next;\n          }else{\n              r -> next = q;\n              r = q;\n              q = q -> next;\n          }\n      }\n      return L1;\n  }\n  ```\n\n- 将两个有序链表合并为一个有序链表（取交集）\n\n  ```c\n  LinkList Merge(LinkList &L1, LinkList &L2){\n      LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n      L1 -> next = NULL;\n      while(p && q){\n          if(p->data < q->data){\n              p = p -> next;\n          }else if(p->data > q->data){\n              q = q -> next;\n          }else{\n              r -> next = p;\n              r = p;\n              p = p -> next;\n              q = q -> next;\n          }\n      }\n      return L1;\n  }\n  ```\n\n- 将两个有序链表合并为一个有序链表（并集）\n\n  ```c\n  LinkList Merge(LinkList &L1, LinkList &L2){\n      LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n      L1 -> next = NULL;\n      while(p && q){\n          if(p->data < q->data){\n              r -> next = p;\n              r = p;\n              p = p -> next;\n          }else if(p->data > q->data){\n              r -> next = p;\n              r = q;\n              q = q -> next;\n          }else{\n              r -> next = p;\n              r = p;\n              p = p -> next;\n              q = q -> next;\n          }\n      }\n      while(p){\n          r -> next = p;\n      }\n      while(q){\n          r -> next = q;\n      }\n      return L1;\n  }\n  ```\n\n> #### 8. 链表拆分问题\n\n- 设`C = {a1,b1,a2,b2,...,an,bn}`为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得`A={a1,a2,...,an},B={bn,...,b2,b1}`\n\n  ```c\n  LinkList Merge(LinkList &L){\n      LNode *p = L -> next, *r;\n      int i = 1;\n      LinkList A = L, *s = A;                      //尾插需要个尾指针，指向头指针\n      LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n      B -> next = NULL;                            //B表的初始化\n      while(p){\n          r = p -> next;\n          if(i%2 == 1){                            //基数位时\n              s -> next = p;                       //尾插法，正序\n              s = p;\n              p = r;\n              i++;\n          }else{                                   //偶数时\n              p -> next = B -> next;               //头插法，因为要倒序\n              B -> next = p;                      \n              p = r;\n              i++;\n          }\n      }\n      s -> next =NULL;\n      return A,B;\n}\n  ```\n  \n\n- 设`C = {a1,b1,a2,b2,...,an,bn}`为线性表，采用带头结点的hc单链表存放，计一个就地算法，讲其拆分为两个线性表，使得`A={a1,a2,...,an},B={b1,...,bn-1,bn}`\n\n  - 与上一题相比，只有链表B变为尾插（保证正序即可）\n\n  ```c\n  LinkList Merge(LinkList &L){\n      LNode *p = L -> next, *r;\n      int i = 1;\n      LinkList A = L; *s = A;\n      LinkList B = (LNode*)malloc(sizeof(LNode)), *s1 = b;  //创建B表表头,并指向头指针\n      while(p){\n          r = p -> next;\n          if(i%2 == 1){                            //基数位时\n              s -> next = p;                       //尾插法，正序\n              s = p;\n              p = r;\n              i++;\n          }else{                                   //偶数时\n              s1 -> next = p;                       //尾插法，正序\n              s = p;\n              p = r;\n              i++;\n          }\n      }\n      s -> next =NULL;\n      s1 -> next =NULL;\n      return A,B;\n  }\n  ```\n\n- 设`C = {a1,b1,a2,b2,...,an,bn}`为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得`A={an,an-1,...,a1},B={bn,...,b2,b1}`\n\n  ```c\n  LinkList Merge(LinkList &L){\n      LNode *p = L -> next, *r;\n      int i = 1;\n      LinkList A = L; \n      LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n      A -> next = NULL;\n      A -> next = NULL;\n      while(p){\n          r = p -> next;\n          if(i%2 == 1){                            //基数位时\n              p -> next = A -> next;               //头插法，因为要倒序\n              A -> next = p;                      \n              p = r;\n              i++;\n          }else{                                   //偶数时\n              p -> next = B -> next;               //头插法，因为要倒序\n              B -> next = p;                      \n              p = r;\n              i++;\n          }\n      }\n      return A,B;\n  }\n  ```\n\n> #### 9. 判断两个链表是否有相同结点（找出相同结点）\n\n```c\nint Length(LinkList &L){  //计算链表长度\n    int num = 0;\n    while(L != NULL){\n        num++;\n        L = L -> next;\n    }\n    return num;\n}\nbool Judeg(LinkList &L1, LinkList &L2){\n    int len1 = Length(L1);\n    int len2 = Length(L2);\n    if(len1 > len2){                   //让两个链表拥有相同的尾部长度\n        int num = len1 - len2;\n        for(int i = 0; i < num; i++){\n            L1 = L1 -> next;\n        }\n    }else{\n        int num = len2 - len1;\n        for(int i = 0; i < num; i++){\n            L2 = L2 -> next;\n    }\n    while(L1){\n        if(L1 == L2){\n            return 1;\n        }\n        L1 = L1 -> next;\n        L2 = L2 -> next;\n    }\n    return 0;\n}\n```\n\n> #### 10. 栈的基本操作\n\n- 栈的顺序存储类型描述\n\n  ```c\n  #define Maxsize 50       //定义栈中元素的最大个数\n  typedef struct{\n      int data[Maxsize];   //存放栈中元素\n      int top;             //栈顶指针\n  }SqStack;\n  ```\n\n- 初始化\n\n  ```c\n  void InitStack(Sqstack &S){\n      S.top = -1;               //初始化栈顶指针\n  }\n  ```\n\n- 判断栈空\n\n  ```c\n  bool StackEmpty(S){\n      if(S.top == -1){\n          return true;\n      }else{\n          return false;\n      }\n  }\n  ```\n\n- 进栈\n\n  ```c\n  bool Push(SqStack &S, int x){\n      if(S.top == MaxSize - 1){\n          return false;\n      }\n      S.data[++S.top] = x;       //指针先加1，再入栈\n      return true;\n  }\n  ```\n\n- 出栈\n\n  ```c\n  bool Pop（SqStack &S, int &x){\n      if(S.top == -1){\n          return false;\n      }\n      x = S.data[S.top--];\n      return true;\n  }\n  ```\n\n- 读栈顶元素\n\n  ```c\n  bool GetTop(SqStack S, int &x){\n      if(S.top == MaxSize - 1){\n          return false;\n      }\n      x = S.data[S.top];\n      return true;\n  }\n  ```\n","source":"_posts/链表代码.md","raw":"---\ntitle: 链表代码\ntop: false\ncover: false\ntoc: false\nmathjax: true\ntags:\n  - 代码\n  - 考研\n  - 链表\ncategories:\n  - 代码\nsummary: 链表代码整理\nabbrlink: d09f\ndate: 2020-08-26 21:14:06\npassword:\n---\n\n## 链表相关代码\n\n> #### 1.单链表结点类型描述\n```c\ntypedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *next;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\n```\n\n\n> #### 2.链表创建（头插法）\n>\n> 每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$\n\n> - `sizeof`函数计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示\n> - `malloc`函数用于在内存开辟了一段地址，而这段地址的首地址存在返回的那个指针变量里，由于不知道到底这段地址有多长，可以存什么变量，所以它的类型是空的，你可以强制类型转换，使其变成确定长度，固定存放一种数据类型的地址，而不管它是哪种类型，其首地址还是原来那个，还是存在一个指针变量中，指针变量就是放指针的嘛，指针是一个地址，指针变量是一个我们定义的，用来放那个地址的变量。\n>\n> **那么代码的意思就是说：**\n>\n> - 分配一个内存，大小是LNode的大小，并将这个内存地址转化为Linklist型，然后将赋给L，所以L为地址。是给L赋值，也就是L被改为指向malloc()新分配的地址\n>\n```c\nLinkList CreatList(LinkList &L){\n    LNode *s;\n    int x;                                  //待插入的数据x\n    L = (LinkList)malloc(sizeof(LNode));    //创建LNode型头结点，并强制转换成LinkList类型，头结点\n                                            //L是一个指针的地址，所以要转化成指针类型\n    L -> next = NULL;                       //初始为空链表\n    scanf(\"%d\",x);                          //输入结点的值\n    while(x!=9999){                         //输入9999表示结束\n        //申请一个LNode大小的空间,得到的指针强制转换为指向Lnode类型的指针,然后赋值给s\n        s = (LNode*)malloc(sizeof(LNode));  //创建新节点，这句话的作用是由系统生成一个LNode型链表\n                                            //的结点，同时将该结点的起始位置赋给指针变量s\n                                            //，s为LNode型的指针\n        s -> data = x;                      //赋值\n        s ->next = L -> next;\n        L -> next = s;                      //将新结点插入表中，L为头指针，注意头插法的代码顺序\n        scanf(\"%d\",&x)                      //继续输入值\n    }\n    return L;\n}\n```\n\n> #### 3.链表创建（尾插法）\n>\n> 每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$\n\n```c\nLinkList CreatList(LinkList &L){\n    int x;                                  //待插入数据\n    L = (LinkList)maclloc(sizeof(LNode));   //创建头结点\n    LNode *s, *r = L;                       //r为表尾指针\n    scanf(\"%d\",x);                          //输入结点的值\n    while(x!=9999){\n        s = (LNode*)malloc(sizeof(LNode));  //创建新结点\n        s -> data = x;                      //赋值\n        r -> next = s;                      //尾插法，插入的结点在尾指针的后边\n        r = s;                              //尾指针r再指向新插入尾部的结点s\n        scanf(\"%d\",&x);                     //继续输入值\n    }\n    r -> next = NULL;                       //尾结点指针置空\n    return L;\n}\n```\n\n> #### 4.链表的排序（**重点**）不理解，要复习\n\n```c\nvoid sort(LinkList &L){\n    LNode *p = L -> next, *pre;\n    LNode *r = p -> next;\n    p -> next = NULL;\n    p = r;\n    while(p!=NULL){\n        r = p -> next;\n        pre = L;\n        while(pre->next != NULL && pre->next->data < p->data){\n            pre = pre -> next;\n        }\n        p -> next = pre -> next;\n        pre -> next = p;\n        p = r;\n    }\n}\n```\n\n> #### 5.链表的插入\n\n- 将元素x插入到第n个位置上，需要先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点（链表带头结点）\n\n  ```c\n  bool Insert(LinkList &L,int n,int e){             //链表L引用型\n      LNode *pre = L,*p = L->next;                  //LNode型pre指针指向头结点L，p指针指向next\n      int i = 1;                                    //开始计数\n      while(i<n && p){\n          pre = p;                                  //直到到达n，找到前驱pre\n          p = p -> next;\n          i++\n      }\n      if(i == n){\n          LNode *s = (LNode*)malloc(sizeof(LNode)); //新建指针s指向结点\n          s -> data = e;                            //赋值为e\n          s -> next = pre -> next;                  //新插入的s的后继指向pre的后继\n          pre -> next = s;                          //pre的后继指向s\n          return true;                              //完成插入\n      }else{\n          return false;\n      }\n  }\n  ```\n\n- 将元素x插入到有序链表中，使其仍然有序（链表带头结点）\n\n  ```c\n  void Insert(LinkList &L, int e){\n      LNode *pre = L,*p = L->next;\n      while(p){                                     //判断p指针的数据和元素e的大小\n          if(p->data < e){\n              pre = p;                              //直到找到\n              p = p -> next;\n          }else{\n              break;                                //当找到后，跳出循环\n          }\n      }\n      LNode *s = (LNode*)malloc(sizeof(LNode));     //分配s指针的结点\n      s -> data = e;                                //插入数据\n      s -> next = pre -> next;\n      pre ->next = s;\n  }\n  ```\n\n> #### 5.链表的删除\n\n- 删除链表中值为x的结点\n\n  ```c\n  void Del(LinkList &L,int x){\n      LNode *pre = L;                   //pre指针指向头结点\n      LNode *p = L -> next;             //p指针指向头结点的next\n      while(p){                         //p不为空时\n          if(p->data != x){             //如果没有查询到\n              pre = p;                  //两个指针依次往后移\n              p = p -> next;\n          }else{                        //直到p指针的值与x的相同\n              pre -> next = p -> next;  //删除节点\n              free(p);                  //free多余的结点\n              p = pre -> next;\n          }\n      }\n      return L;\n  }\n  ```\n\n- 删除链表中最大值的结点（多加入两个确定最大值的指针即可）\n\n  ```c\n  LinkList Del(LinkList &L, int x){\n      LNode *pre = L, *p = L -> next, *mpre = pre, *mp = p; //建立结点\n      while(p){\n          if(p->data > mp->data){                           //比较数据的大小\n              mpre = pre;                                   //如果大于，最大值指向p\n              mp = p;\n          }\n          pre = p;                                          //一次往后查找\n          p = p -> next;\n      }\n      mpre -> next = mp -> next;                            //删除节点\n      free(mp);\n      return L;\n  }\n  ```\n\n- 删除**有序**链表中重复值节点\n\n  ```c\n  LinkList Del(LinkList &L, int x){\n      LNode *pre = L, *p = L -> next;\n      while(p){\n          if(pre->next && pre->next->data == p->data){\n              pre -> next = p -> next;\n              free(p);\n              p = pre -> next;\n          }else{\n              pre = p;\n              p = p -> next;\n          }\n      }\n      return L;\n  }\n  ```\n\n> #### 6. 链表的逆置\n\n- 将链表L的所有结点逆置（采用头插法）\n\n  ```c\n  LinkList Inversion(LinkList &L){\n      LNode *p = L -> next, *r;\n      L -> next = NULL;\n      while(p){\n          r = p -> next;\n          p -> next = L -> next;\n          L -> next = p;\n          p = r;\n      }\n      return L;\n  }\n  ```\n\n> #### 7. 链表的合并\n\n- 将两个有序链表合并为一个有序链表\n\n  ```c\n  LinkList Merge(LinkList &L1, LinkList &L2){\n      LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n      L1 -> next = NULL;\n      while(p && q){\n          if(p->data < q->data){\n              r -> next = p;\n              r = p;\n              p = p -> next;\n          }else{\n              r -> next = q;\n              r = q;\n              q = q -> next;\n          }\n      }\n      return L1;\n  }\n  ```\n\n- 将两个有序链表合并为一个有序链表（取交集）\n\n  ```c\n  LinkList Merge(LinkList &L1, LinkList &L2){\n      LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n      L1 -> next = NULL;\n      while(p && q){\n          if(p->data < q->data){\n              p = p -> next;\n          }else if(p->data > q->data){\n              q = q -> next;\n          }else{\n              r -> next = p;\n              r = p;\n              p = p -> next;\n              q = q -> next;\n          }\n      }\n      return L1;\n  }\n  ```\n\n- 将两个有序链表合并为一个有序链表（并集）\n\n  ```c\n  LinkList Merge(LinkList &L1, LinkList &L2){\n      LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n      L1 -> next = NULL;\n      while(p && q){\n          if(p->data < q->data){\n              r -> next = p;\n              r = p;\n              p = p -> next;\n          }else if(p->data > q->data){\n              r -> next = p;\n              r = q;\n              q = q -> next;\n          }else{\n              r -> next = p;\n              r = p;\n              p = p -> next;\n              q = q -> next;\n          }\n      }\n      while(p){\n          r -> next = p;\n      }\n      while(q){\n          r -> next = q;\n      }\n      return L1;\n  }\n  ```\n\n> #### 8. 链表拆分问题\n\n- 设`C = {a1,b1,a2,b2,...,an,bn}`为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得`A={a1,a2,...,an},B={bn,...,b2,b1}`\n\n  ```c\n  LinkList Merge(LinkList &L){\n      LNode *p = L -> next, *r;\n      int i = 1;\n      LinkList A = L, *s = A;                      //尾插需要个尾指针，指向头指针\n      LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n      B -> next = NULL;                            //B表的初始化\n      while(p){\n          r = p -> next;\n          if(i%2 == 1){                            //基数位时\n              s -> next = p;                       //尾插法，正序\n              s = p;\n              p = r;\n              i++;\n          }else{                                   //偶数时\n              p -> next = B -> next;               //头插法，因为要倒序\n              B -> next = p;                      \n              p = r;\n              i++;\n          }\n      }\n      s -> next =NULL;\n      return A,B;\n}\n  ```\n  \n\n- 设`C = {a1,b1,a2,b2,...,an,bn}`为线性表，采用带头结点的hc单链表存放，计一个就地算法，讲其拆分为两个线性表，使得`A={a1,a2,...,an},B={b1,...,bn-1,bn}`\n\n  - 与上一题相比，只有链表B变为尾插（保证正序即可）\n\n  ```c\n  LinkList Merge(LinkList &L){\n      LNode *p = L -> next, *r;\n      int i = 1;\n      LinkList A = L; *s = A;\n      LinkList B = (LNode*)malloc(sizeof(LNode)), *s1 = b;  //创建B表表头,并指向头指针\n      while(p){\n          r = p -> next;\n          if(i%2 == 1){                            //基数位时\n              s -> next = p;                       //尾插法，正序\n              s = p;\n              p = r;\n              i++;\n          }else{                                   //偶数时\n              s1 -> next = p;                       //尾插法，正序\n              s = p;\n              p = r;\n              i++;\n          }\n      }\n      s -> next =NULL;\n      s1 -> next =NULL;\n      return A,B;\n  }\n  ```\n\n- 设`C = {a1,b1,a2,b2,...,an,bn}`为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得`A={an,an-1,...,a1},B={bn,...,b2,b1}`\n\n  ```c\n  LinkList Merge(LinkList &L){\n      LNode *p = L -> next, *r;\n      int i = 1;\n      LinkList A = L; \n      LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n      A -> next = NULL;\n      A -> next = NULL;\n      while(p){\n          r = p -> next;\n          if(i%2 == 1){                            //基数位时\n              p -> next = A -> next;               //头插法，因为要倒序\n              A -> next = p;                      \n              p = r;\n              i++;\n          }else{                                   //偶数时\n              p -> next = B -> next;               //头插法，因为要倒序\n              B -> next = p;                      \n              p = r;\n              i++;\n          }\n      }\n      return A,B;\n  }\n  ```\n\n> #### 9. 判断两个链表是否有相同结点（找出相同结点）\n\n```c\nint Length(LinkList &L){  //计算链表长度\n    int num = 0;\n    while(L != NULL){\n        num++;\n        L = L -> next;\n    }\n    return num;\n}\nbool Judeg(LinkList &L1, LinkList &L2){\n    int len1 = Length(L1);\n    int len2 = Length(L2);\n    if(len1 > len2){                   //让两个链表拥有相同的尾部长度\n        int num = len1 - len2;\n        for(int i = 0; i < num; i++){\n            L1 = L1 -> next;\n        }\n    }else{\n        int num = len2 - len1;\n        for(int i = 0; i < num; i++){\n            L2 = L2 -> next;\n    }\n    while(L1){\n        if(L1 == L2){\n            return 1;\n        }\n        L1 = L1 -> next;\n        L2 = L2 -> next;\n    }\n    return 0;\n}\n```\n\n> #### 10. 栈的基本操作\n\n- 栈的顺序存储类型描述\n\n  ```c\n  #define Maxsize 50       //定义栈中元素的最大个数\n  typedef struct{\n      int data[Maxsize];   //存放栈中元素\n      int top;             //栈顶指针\n  }SqStack;\n  ```\n\n- 初始化\n\n  ```c\n  void InitStack(Sqstack &S){\n      S.top = -1;               //初始化栈顶指针\n  }\n  ```\n\n- 判断栈空\n\n  ```c\n  bool StackEmpty(S){\n      if(S.top == -1){\n          return true;\n      }else{\n          return false;\n      }\n  }\n  ```\n\n- 进栈\n\n  ```c\n  bool Push(SqStack &S, int x){\n      if(S.top == MaxSize - 1){\n          return false;\n      }\n      S.data[++S.top] = x;       //指针先加1，再入栈\n      return true;\n  }\n  ```\n\n- 出栈\n\n  ```c\n  bool Pop（SqStack &S, int &x){\n      if(S.top == -1){\n          return false;\n      }\n      x = S.data[S.top--];\n      return true;\n  }\n  ```\n\n- 读栈顶元素\n\n  ```c\n  bool GetTop(SqStack S, int &x){\n      if(S.top == MaxSize - 1){\n          return false;\n      }\n      x = S.data[S.top];\n      return true;\n  }\n  ```\n","slug":"链表代码","published":1,"updated":"2020-08-30T13:46:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q6c005na09k40side1d","content":"<h2 id=\"链表相关代码\"><a href=\"#链表相关代码\" class=\"headerlink\" title=\"链表相关代码\"></a>链表相关代码</h2><blockquote>\n<h4 id=\"1-单链表结点类型描述\"><a href=\"#1-单链表结点类型描述\" class=\"headerlink\" title=\"1.单链表结点类型描述\"></a>1.单链表结点类型描述</h4><pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">typedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *next;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-链表创建（头插法）\"><a href=\"#2-链表创建（头插法）\" class=\"headerlink\" title=\"2.链表创建（头插法）\"></a>2.链表创建（头插法）</h4><p>每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$</p>\n<ul>\n<li><code>sizeof</code>函数计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示</li>\n<li><code>malloc</code>函数用于在内存开辟了一段地址，而这段地址的首地址存在返回的那个指针变量里，由于不知道到底这段地址有多长，可以存什么变量，所以它的类型是空的，你可以强制类型转换，使其变成确定长度，固定存放一种数据类型的地址，而不管它是哪种类型，其首地址还是原来那个，还是存在一个指针变量中，指针变量就是放指针的嘛，指针是一个地址，指针变量是一个我们定义的，用来放那个地址的变量。</li>\n</ul>\n<p><strong>那么代码的意思就是说：</strong></p>\n<ul>\n<li>分配一个内存，大小是LNode的大小，并将这个内存地址转化为Linklist型，然后将赋给L，所以L为地址。是给L赋值，也就是L被改为指向malloc()新分配的地址</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList CreatList(LinkList &L){\n    LNode *s;\n    int x;                                  //待插入的数据x\n    L = (LinkList)malloc(sizeof(LNode));    //创建LNode型头结点，并强制转换成LinkList类型，头结点\n                                            //L是一个指针的地址，所以要转化成指针类型\n    L -> next = NULL;                       //初始为空链表\n    scanf(\"%d\",x);                          //输入结点的值\n    while(x!=9999){                         //输入9999表示结束\n        //申请一个LNode大小的空间,得到的指针强制转换为指向Lnode类型的指针,然后赋值给s\n        s = (LNode*)malloc(sizeof(LNode));  //创建新节点，这句话的作用是由系统生成一个LNode型链表\n                                            //的结点，同时将该结点的起始位置赋给指针变量s\n                                            //，s为LNode型的指针\n        s -> data = x;                      //赋值\n        s ->next = L -> next;\n        L -> next = s;                      //将新结点插入表中，L为头指针，注意头插法的代码顺序\n        scanf(\"%d\",&x)                      //继续输入值\n    }\n    return L;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3-链表创建（尾插法）\"><a href=\"#3-链表创建（尾插法）\" class=\"headerlink\" title=\"3.链表创建（尾插法）\"></a>3.链表创建（尾插法）</h4><p>每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$</p>\n</blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList CreatList(LinkList &L){\n    int x;                                  //待插入数据\n    L = (LinkList)maclloc(sizeof(LNode));   //创建头结点\n    LNode *s, *r = L;                       //r为表尾指针\n    scanf(\"%d\",x);                          //输入结点的值\n    while(x!=9999){\n        s = (LNode*)malloc(sizeof(LNode));  //创建新结点\n        s -> data = x;                      //赋值\n        r -> next = s;                      //尾插法，插入的结点在尾指针的后边\n        r = s;                              //尾指针r再指向新插入尾部的结点s\n        scanf(\"%d\",&x);                     //继续输入值\n    }\n    r -> next = NULL;                       //尾结点指针置空\n    return L;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"4-链表的排序（重点）不理解，要复习\"><a href=\"#4-链表的排序（重点）不理解，要复习\" class=\"headerlink\" title=\"4.链表的排序（重点）不理解，要复习\"></a>4.链表的排序（<strong>重点</strong>）不理解，要复习</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void sort(LinkList &L){\n    LNode *p = L -> next, *pre;\n    LNode *r = p -> next;\n    p -> next = NULL;\n    p = r;\n    while(p!=NULL){\n        r = p -> next;\n        pre = L;\n        while(pre->next != NULL && pre->next->data < p->data){\n            pre = pre -> next;\n        }\n        p -> next = pre -> next;\n        pre -> next = p;\n        p = r;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"5-链表的插入\"><a href=\"#5-链表的插入\" class=\"headerlink\" title=\"5.链表的插入\"></a>5.链表的插入</h4></blockquote>\n<ul>\n<li><p>将元素x插入到第n个位置上，需要先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点（链表带头结点）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool Insert(LinkList &L,int n,int e){             //链表L引用型\n    LNode *pre = L,*p = L->next;                  //LNode型pre指针指向头结点L，p指针指向next\n    int i = 1;                                    //开始计数\n    while(i<n && p){\n        pre = p;                                  //直到到达n，找到前驱pre\n        p = p -> next;\n        i++\n    }\n    if(i == n){\n        LNode *s = (LNode*)malloc(sizeof(LNode)); //新建指针s指向结点\n        s -> data = e;                            //赋值为e\n        s -> next = pre -> next;                  //新插入的s的后继指向pre的后继\n        pre -> next = s;                          //pre的后继指向s\n        return true;                              //完成插入\n    }else{\n        return false;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将元素x插入到有序链表中，使其仍然有序（链表带头结点）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void Insert(LinkList &L, int e){\n    LNode *pre = L,*p = L->next;\n    while(p){                                     //判断p指针的数据和元素e的大小\n        if(p->data < e){\n            pre = p;                              //直到找到\n            p = p -> next;\n        }else{\n            break;                                //当找到后，跳出循环\n        }\n    }\n    LNode *s = (LNode*)malloc(sizeof(LNode));     //分配s指针的结点\n    s -> data = e;                                //插入数据\n    s -> next = pre -> next;\n    pre ->next = s;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"5-链表的删除\"><a href=\"#5-链表的删除\" class=\"headerlink\" title=\"5.链表的删除\"></a>5.链表的删除</h4></blockquote>\n<ul>\n<li><p>删除链表中值为x的结点</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void Del(LinkList &L,int x){\n    LNode *pre = L;                   //pre指针指向头结点\n    LNode *p = L -> next;             //p指针指向头结点的next\n    while(p){                         //p不为空时\n        if(p->data != x){             //如果没有查询到\n            pre = p;                  //两个指针依次往后移\n            p = p -> next;\n        }else{                        //直到p指针的值与x的相同\n            pre -> next = p -> next;  //删除节点\n            free(p);                  //free多余的结点\n            p = pre -> next;\n        }\n    }\n    return L;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除链表中最大值的结点（多加入两个确定最大值的指针即可）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Del(LinkList &L, int x){\n    LNode *pre = L, *p = L -> next, *mpre = pre, *mp = p; //建立结点\n    while(p){\n        if(p->data > mp->data){                           //比较数据的大小\n            mpre = pre;                                   //如果大于，最大值指向p\n            mp = p;\n        }\n        pre = p;                                          //一次往后查找\n        p = p -> next;\n    }\n    mpre -> next = mp -> next;                            //删除节点\n    free(mp);\n    return L;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除<strong>有序</strong>链表中重复值节点</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Del(LinkList &L, int x){\n    LNode *pre = L, *p = L -> next;\n    while(p){\n        if(pre->next && pre->next->data == p->data){\n            pre -> next = p -> next;\n            free(p);\n            p = pre -> next;\n        }else{\n            pre = p;\n            p = p -> next;\n        }\n    }\n    return L;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"6-链表的逆置\"><a href=\"#6-链表的逆置\" class=\"headerlink\" title=\"6. 链表的逆置\"></a>6. 链表的逆置</h4></blockquote>\n<ul>\n<li><p>将链表L的所有结点逆置（采用头插法）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Inversion(LinkList &L){\n    LNode *p = L -> next, *r;\n    L -> next = NULL;\n    while(p){\n        r = p -> next;\n        p -> next = L -> next;\n        L -> next = p;\n        p = r;\n    }\n    return L;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"7-链表的合并\"><a href=\"#7-链表的合并\" class=\"headerlink\" title=\"7. 链表的合并\"></a>7. 链表的合并</h4></blockquote>\n<ul>\n<li><p>将两个有序链表合并为一个有序链表</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Merge(LinkList &L1, LinkList &L2){\n    LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n    L1 -> next = NULL;\n    while(p && q){\n        if(p->data < q->data){\n            r -> next = p;\n            r = p;\n            p = p -> next;\n        }else{\n            r -> next = q;\n            r = q;\n            q = q -> next;\n        }\n    }\n    return L1;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将两个有序链表合并为一个有序链表（取交集）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Merge(LinkList &L1, LinkList &L2){\n    LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n    L1 -> next = NULL;\n    while(p && q){\n        if(p->data < q->data){\n            p = p -> next;\n        }else if(p->data > q->data){\n            q = q -> next;\n        }else{\n            r -> next = p;\n            r = p;\n            p = p -> next;\n            q = q -> next;\n        }\n    }\n    return L1;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将两个有序链表合并为一个有序链表（并集）</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Merge(LinkList &L1, LinkList &L2){\n    LNode *p = L1 -> next, *q = L2 -> next, *r = L1;\n    L1 -> next = NULL;\n    while(p && q){\n        if(p->data < q->data){\n            r -> next = p;\n            r = p;\n            p = p -> next;\n        }else if(p->data > q->data){\n            r -> next = p;\n            r = q;\n            q = q -> next;\n        }else{\n            r -> next = p;\n            r = p;\n            p = p -> next;\n            q = q -> next;\n        }\n    }\n    while(p){\n        r -> next = p;\n    }\n    while(q){\n        r -> next = q;\n    }\n    return L1;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"8-链表拆分问题\"><a href=\"#8-链表拆分问题\" class=\"headerlink\" title=\"8. 链表拆分问题\"></a>8. 链表拆分问题</h4></blockquote>\n<ul>\n<li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得<code>A={a1,a2,...,an},B={bn,...,b2,b1}</code></p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Merge(LinkList &L){\n    LNode *p = L -> next, *r;\n    int i = 1;\n    LinkList A = L, *s = A;                      //尾插需要个尾指针，指向头指针\n    LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n    B -> next = NULL;                            //B表的初始化\n    while(p){\n        r = p -> next;\n        if(i%2 == 1){                            //基数位时\n            s -> next = p;                       //尾插法，正序\n            s = p;\n            p = r;\n            i++;\n        }else{                                   //偶数时\n            p -> next = B -> next;               //头插法，因为要倒序\n            B -> next = p;                      \n            p = r;\n            i++;\n        }\n    }\n    s -> next =NULL;\n    return A,B;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，计一个就地算法，讲其拆分为两个线性表，使得<code>A={a1,a2,...,an},B={b1,...,bn-1,bn}</code></p>\n<ul>\n<li>与上一题相比，只有链表B变为尾插（保证正序即可）</li>\n</ul>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Merge(LinkList &L){\n    LNode *p = L -> next, *r;\n    int i = 1;\n    LinkList A = L; *s = A;\n    LinkList B = (LNode*)malloc(sizeof(LNode)), *s1 = b;  //创建B表表头,并指向头指针\n    while(p){\n        r = p -> next;\n        if(i%2 == 1){                            //基数位时\n            s -> next = p;                       //尾插法，正序\n            s = p;\n            p = r;\n            i++;\n        }else{                                   //偶数时\n            s1 -> next = p;                       //尾插法，正序\n            s = p;\n            p = r;\n            i++;\n        }\n    }\n    s -> next =NULL;\n    s1 -> next =NULL;\n    return A,B;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得<code>A={an,an-1,...,a1},B={bn,...,b2,b1}</code></p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">LinkList Merge(LinkList &L){\n    LNode *p = L -> next, *r;\n    int i = 1;\n    LinkList A = L; \n    LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n    A -> next = NULL;\n    A -> next = NULL;\n    while(p){\n        r = p -> next;\n        if(i%2 == 1){                            //基数位时\n            p -> next = A -> next;               //头插法，因为要倒序\n            A -> next = p;                      \n            p = r;\n            i++;\n        }else{                                   //偶数时\n            p -> next = B -> next;               //头插法，因为要倒序\n            B -> next = p;                      \n            p = r;\n            i++;\n        }\n    }\n    return A,B;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"9-判断两个链表是否有相同结点（找出相同结点）\"><a href=\"#9-判断两个链表是否有相同结点（找出相同结点）\" class=\"headerlink\" title=\"9. 判断两个链表是否有相同结点（找出相同结点）\"></a>9. 判断两个链表是否有相同结点（找出相同结点）</h4></blockquote>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">int Length(LinkList &L){  //计算链表长度\n    int num = 0;\n    while(L != NULL){\n        num++;\n        L = L -> next;\n    }\n    return num;\n}\nbool Judeg(LinkList &L1, LinkList &L2){\n    int len1 = Length(L1);\n    int len2 = Length(L2);\n    if(len1 > len2){                   //让两个链表拥有相同的尾部长度\n        int num = len1 - len2;\n        for(int i = 0; i < num; i++){\n            L1 = L1 -> next;\n        }\n    }else{\n        int num = len2 - len1;\n        for(int i = 0; i < num; i++){\n            L2 = L2 -> next;\n    }\n    while(L1){\n        if(L1 == L2){\n            return 1;\n        }\n        L1 = L1 -> next;\n        L2 = L2 -> next;\n    }\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<h4 id=\"10-栈的基本操作\"><a href=\"#10-栈的基本操作\" class=\"headerlink\" title=\"10. 栈的基本操作\"></a>10. 栈的基本操作</h4></blockquote>\n<ul>\n<li><p>栈的顺序存储类型描述</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">#define Maxsize 50       //定义栈中元素的最大个数\ntypedef struct{\n    int data[Maxsize];   //存放栈中元素\n    int top;             //栈顶指针\n}SqStack;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>初始化</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">void InitStack(Sqstack &S){\n    S.top = -1;               //初始化栈顶指针\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>判断栈空</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool StackEmpty(S){\n    if(S.top == -1){\n        return true;\n    }else{\n        return false;\n    }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>进栈</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool Push(SqStack &S, int x){\n    if(S.top == MaxSize - 1){\n        return false;\n    }\n    S.data[++S.top] = x;       //指针先加1，再入栈\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>出栈</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool Pop（SqStack &S, int &x){\n    if(S.top == -1){\n        return false;\n    }\n    x = S.data[S.top--];\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>读栈顶元素</p>\n<pre class=\"line-numbers language-lang-c\"><code class=\"language-lang-c\">bool GetTop(SqStack S, int &x){\n    if(S.top == MaxSize - 1){\n        return false;\n    }\n    x = S.data[S.top];\n    return true;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"链表相关代码\"><a href=\"#链表相关代码\" class=\"headerlink\" title=\"链表相关代码\"></a>链表相关代码</h2><blockquote>\n<h4 id=\"1-单链表结点类型描述\"><a href=\"#1-单链表结点类型描述\" class=\"headerlink\" title=\"1.单链表结点类型描述\"></a>1.单链表结点类型描述</h4><pre><code class=\"lang-c\">typedef struct LNode{     //定义单链表结点类型\n    int data;             //数据域\n    struct LNode *next;   //指针域，指向下一个结点的指针\n}LNode,*LinkList;         //LNode是结构体的别名，用LNode即可代替typedef struct LNode\n                          //LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next\n</code></pre>\n<h4 id=\"2-链表创建（头插法）\"><a href=\"#2-链表创建（头插法）\" class=\"headerlink\" title=\"2.链表创建（头插法）\"></a>2.链表创建（头插法）</h4><p>每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$</p>\n<ul>\n<li><code>sizeof</code>函数计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示</li>\n<li><code>malloc</code>函数用于在内存开辟了一段地址，而这段地址的首地址存在返回的那个指针变量里，由于不知道到底这段地址有多长，可以存什么变量，所以它的类型是空的，你可以强制类型转换，使其变成确定长度，固定存放一种数据类型的地址，而不管它是哪种类型，其首地址还是原来那个，还是存在一个指针变量中，指针变量就是放指针的嘛，指针是一个地址，指针变量是一个我们定义的，用来放那个地址的变量。</li>\n</ul>\n<p><strong>那么代码的意思就是说：</strong></p>\n<ul>\n<li>分配一个内存，大小是LNode的大小，并将这个内存地址转化为Linklist型，然后将赋给L，所以L为地址。是给L赋值，也就是L被改为指向malloc()新分配的地址</li>\n</ul>\n<pre><code class=\"lang-c\">LinkList CreatList(LinkList &amp;L){\n    LNode *s;\n    int x;                                  //待插入的数据x\n    L = (LinkList)malloc(sizeof(LNode));    //创建LNode型头结点，并强制转换成LinkList类型，头结点\n                                            //L是一个指针的地址，所以要转化成指针类型\n    L -&gt; next = NULL;                       //初始为空链表\n    scanf(&quot;%d&quot;,x);                          //输入结点的值\n    while(x!=9999){                         //输入9999表示结束\n        //申请一个LNode大小的空间,得到的指针强制转换为指向Lnode类型的指针,然后赋值给s\n        s = (LNode*)malloc(sizeof(LNode));  //创建新节点，这句话的作用是由系统生成一个LNode型链表\n                                            //的结点，同时将该结点的起始位置赋给指针变量s\n                                            //，s为LNode型的指针\n        s -&gt; data = x;                      //赋值\n        s -&gt;next = L -&gt; next;\n        L -&gt; next = s;                      //将新结点插入表中，L为头指针，注意头插法的代码顺序\n        scanf(&quot;%d&quot;,&amp;x)                      //继续输入值\n    }\n    return L;\n}\n</code></pre>\n<h4 id=\"3-链表创建（尾插法）\"><a href=\"#3-链表创建（尾插法）\" class=\"headerlink\" title=\"3.链表创建（尾插法）\"></a>3.链表创建（尾插法）</h4><p>每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$</p>\n</blockquote>\n<pre><code class=\"lang-c\">LinkList CreatList(LinkList &amp;L){\n    int x;                                  //待插入数据\n    L = (LinkList)maclloc(sizeof(LNode));   //创建头结点\n    LNode *s, *r = L;                       //r为表尾指针\n    scanf(&quot;%d&quot;,x);                          //输入结点的值\n    while(x!=9999){\n        s = (LNode*)malloc(sizeof(LNode));  //创建新结点\n        s -&gt; data = x;                      //赋值\n        r -&gt; next = s;                      //尾插法，插入的结点在尾指针的后边\n        r = s;                              //尾指针r再指向新插入尾部的结点s\n        scanf(&quot;%d&quot;,&amp;x);                     //继续输入值\n    }\n    r -&gt; next = NULL;                       //尾结点指针置空\n    return L;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"4-链表的排序（重点）不理解，要复习\"><a href=\"#4-链表的排序（重点）不理解，要复习\" class=\"headerlink\" title=\"4.链表的排序（重点）不理解，要复习\"></a>4.链表的排序（<strong>重点</strong>）不理解，要复习</h4></blockquote>\n<pre><code class=\"lang-c\">void sort(LinkList &amp;L){\n    LNode *p = L -&gt; next, *pre;\n    LNode *r = p -&gt; next;\n    p -&gt; next = NULL;\n    p = r;\n    while(p!=NULL){\n        r = p -&gt; next;\n        pre = L;\n        while(pre-&gt;next != NULL &amp;&amp; pre-&gt;next-&gt;data &lt; p-&gt;data){\n            pre = pre -&gt; next;\n        }\n        p -&gt; next = pre -&gt; next;\n        pre -&gt; next = p;\n        p = r;\n    }\n}\n</code></pre>\n<blockquote>\n<h4 id=\"5-链表的插入\"><a href=\"#5-链表的插入\" class=\"headerlink\" title=\"5.链表的插入\"></a>5.链表的插入</h4></blockquote>\n<ul>\n<li><p>将元素x插入到第n个位置上，需要先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点（链表带头结点）</p>\n<pre><code class=\"lang-c\">bool Insert(LinkList &amp;L,int n,int e){             //链表L引用型\n    LNode *pre = L,*p = L-&gt;next;                  //LNode型pre指针指向头结点L，p指针指向next\n    int i = 1;                                    //开始计数\n    while(i&lt;n &amp;&amp; p){\n        pre = p;                                  //直到到达n，找到前驱pre\n        p = p -&gt; next;\n        i++\n    }\n    if(i == n){\n        LNode *s = (LNode*)malloc(sizeof(LNode)); //新建指针s指向结点\n        s -&gt; data = e;                            //赋值为e\n        s -&gt; next = pre -&gt; next;                  //新插入的s的后继指向pre的后继\n        pre -&gt; next = s;                          //pre的后继指向s\n        return true;                              //完成插入\n    }else{\n        return false;\n    }\n}\n</code></pre>\n</li>\n<li><p>将元素x插入到有序链表中，使其仍然有序（链表带头结点）</p>\n<pre><code class=\"lang-c\">void Insert(LinkList &amp;L, int e){\n    LNode *pre = L,*p = L-&gt;next;\n    while(p){                                     //判断p指针的数据和元素e的大小\n        if(p-&gt;data &lt; e){\n            pre = p;                              //直到找到\n            p = p -&gt; next;\n        }else{\n            break;                                //当找到后，跳出循环\n        }\n    }\n    LNode *s = (LNode*)malloc(sizeof(LNode));     //分配s指针的结点\n    s -&gt; data = e;                                //插入数据\n    s -&gt; next = pre -&gt; next;\n    pre -&gt;next = s;\n}\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"5-链表的删除\"><a href=\"#5-链表的删除\" class=\"headerlink\" title=\"5.链表的删除\"></a>5.链表的删除</h4></blockquote>\n<ul>\n<li><p>删除链表中值为x的结点</p>\n<pre><code class=\"lang-c\">void Del(LinkList &amp;L,int x){\n    LNode *pre = L;                   //pre指针指向头结点\n    LNode *p = L -&gt; next;             //p指针指向头结点的next\n    while(p){                         //p不为空时\n        if(p-&gt;data != x){             //如果没有查询到\n            pre = p;                  //两个指针依次往后移\n            p = p -&gt; next;\n        }else{                        //直到p指针的值与x的相同\n            pre -&gt; next = p -&gt; next;  //删除节点\n            free(p);                  //free多余的结点\n            p = pre -&gt; next;\n        }\n    }\n    return L;\n}\n</code></pre>\n</li>\n<li><p>删除链表中最大值的结点（多加入两个确定最大值的指针即可）</p>\n<pre><code class=\"lang-c\">LinkList Del(LinkList &amp;L, int x){\n    LNode *pre = L, *p = L -&gt; next, *mpre = pre, *mp = p; //建立结点\n    while(p){\n        if(p-&gt;data &gt; mp-&gt;data){                           //比较数据的大小\n            mpre = pre;                                   //如果大于，最大值指向p\n            mp = p;\n        }\n        pre = p;                                          //一次往后查找\n        p = p -&gt; next;\n    }\n    mpre -&gt; next = mp -&gt; next;                            //删除节点\n    free(mp);\n    return L;\n}\n</code></pre>\n</li>\n<li><p>删除<strong>有序</strong>链表中重复值节点</p>\n<pre><code class=\"lang-c\">LinkList Del(LinkList &amp;L, int x){\n    LNode *pre = L, *p = L -&gt; next;\n    while(p){\n        if(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;data == p-&gt;data){\n            pre -&gt; next = p -&gt; next;\n            free(p);\n            p = pre -&gt; next;\n        }else{\n            pre = p;\n            p = p -&gt; next;\n        }\n    }\n    return L;\n}\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"6-链表的逆置\"><a href=\"#6-链表的逆置\" class=\"headerlink\" title=\"6. 链表的逆置\"></a>6. 链表的逆置</h4></blockquote>\n<ul>\n<li><p>将链表L的所有结点逆置（采用头插法）</p>\n<pre><code class=\"lang-c\">LinkList Inversion(LinkList &amp;L){\n    LNode *p = L -&gt; next, *r;\n    L -&gt; next = NULL;\n    while(p){\n        r = p -&gt; next;\n        p -&gt; next = L -&gt; next;\n        L -&gt; next = p;\n        p = r;\n    }\n    return L;\n}\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"7-链表的合并\"><a href=\"#7-链表的合并\" class=\"headerlink\" title=\"7. 链表的合并\"></a>7. 链表的合并</h4></blockquote>\n<ul>\n<li><p>将两个有序链表合并为一个有序链表</p>\n<pre><code class=\"lang-c\">LinkList Merge(LinkList &amp;L1, LinkList &amp;L2){\n    LNode *p = L1 -&gt; next, *q = L2 -&gt; next, *r = L1;\n    L1 -&gt; next = NULL;\n    while(p &amp;&amp; q){\n        if(p-&gt;data &lt; q-&gt;data){\n            r -&gt; next = p;\n            r = p;\n            p = p -&gt; next;\n        }else{\n            r -&gt; next = q;\n            r = q;\n            q = q -&gt; next;\n        }\n    }\n    return L1;\n}\n</code></pre>\n</li>\n<li><p>将两个有序链表合并为一个有序链表（取交集）</p>\n<pre><code class=\"lang-c\">LinkList Merge(LinkList &amp;L1, LinkList &amp;L2){\n    LNode *p = L1 -&gt; next, *q = L2 -&gt; next, *r = L1;\n    L1 -&gt; next = NULL;\n    while(p &amp;&amp; q){\n        if(p-&gt;data &lt; q-&gt;data){\n            p = p -&gt; next;\n        }else if(p-&gt;data &gt; q-&gt;data){\n            q = q -&gt; next;\n        }else{\n            r -&gt; next = p;\n            r = p;\n            p = p -&gt; next;\n            q = q -&gt; next;\n        }\n    }\n    return L1;\n}\n</code></pre>\n</li>\n<li><p>将两个有序链表合并为一个有序链表（并集）</p>\n<pre><code class=\"lang-c\">LinkList Merge(LinkList &amp;L1, LinkList &amp;L2){\n    LNode *p = L1 -&gt; next, *q = L2 -&gt; next, *r = L1;\n    L1 -&gt; next = NULL;\n    while(p &amp;&amp; q){\n        if(p-&gt;data &lt; q-&gt;data){\n            r -&gt; next = p;\n            r = p;\n            p = p -&gt; next;\n        }else if(p-&gt;data &gt; q-&gt;data){\n            r -&gt; next = p;\n            r = q;\n            q = q -&gt; next;\n        }else{\n            r -&gt; next = p;\n            r = p;\n            p = p -&gt; next;\n            q = q -&gt; next;\n        }\n    }\n    while(p){\n        r -&gt; next = p;\n    }\n    while(q){\n        r -&gt; next = q;\n    }\n    return L1;\n}\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"8-链表拆分问题\"><a href=\"#8-链表拆分问题\" class=\"headerlink\" title=\"8. 链表拆分问题\"></a>8. 链表拆分问题</h4></blockquote>\n<ul>\n<li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得<code>A={a1,a2,...,an},B={bn,...,b2,b1}</code></p>\n<pre><code class=\"lang-c\">LinkList Merge(LinkList &amp;L){\n    LNode *p = L -&gt; next, *r;\n    int i = 1;\n    LinkList A = L, *s = A;                      //尾插需要个尾指针，指向头指针\n    LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n    B -&gt; next = NULL;                            //B表的初始化\n    while(p){\n        r = p -&gt; next;\n        if(i%2 == 1){                            //基数位时\n            s -&gt; next = p;                       //尾插法，正序\n            s = p;\n            p = r;\n            i++;\n        }else{                                   //偶数时\n            p -&gt; next = B -&gt; next;               //头插法，因为要倒序\n            B -&gt; next = p;                      \n            p = r;\n            i++;\n        }\n    }\n    s -&gt; next =NULL;\n    return A,B;\n}\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，计一个就地算法，讲其拆分为两个线性表，使得<code>A={a1,a2,...,an},B={b1,...,bn-1,bn}</code></p>\n<ul>\n<li>与上一题相比，只有链表B变为尾插（保证正序即可）</li>\n</ul>\n<pre><code class=\"lang-c\">LinkList Merge(LinkList &amp;L){\n    LNode *p = L -&gt; next, *r;\n    int i = 1;\n    LinkList A = L; *s = A;\n    LinkList B = (LNode*)malloc(sizeof(LNode)), *s1 = b;  //创建B表表头,并指向头指针\n    while(p){\n        r = p -&gt; next;\n        if(i%2 == 1){                            //基数位时\n            s -&gt; next = p;                       //尾插法，正序\n            s = p;\n            p = r;\n            i++;\n        }else{                                   //偶数时\n            s1 -&gt; next = p;                       //尾插法，正序\n            s = p;\n            p = r;\n            i++;\n        }\n    }\n    s -&gt; next =NULL;\n    s1 -&gt; next =NULL;\n    return A,B;\n}\n</code></pre>\n</li>\n<li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得<code>A={an,an-1,...,a1},B={bn,...,b2,b1}</code></p>\n<pre><code class=\"lang-c\">LinkList Merge(LinkList &amp;L){\n    LNode *p = L -&gt; next, *r;\n    int i = 1;\n    LinkList A = L; \n    LinkList B = (LNode*)malloc(sizeof(LNode));  //创建B表表头\n    A -&gt; next = NULL;\n    A -&gt; next = NULL;\n    while(p){\n        r = p -&gt; next;\n        if(i%2 == 1){                            //基数位时\n            p -&gt; next = A -&gt; next;               //头插法，因为要倒序\n            A -&gt; next = p;                      \n            p = r;\n            i++;\n        }else{                                   //偶数时\n            p -&gt; next = B -&gt; next;               //头插法，因为要倒序\n            B -&gt; next = p;                      \n            p = r;\n            i++;\n        }\n    }\n    return A,B;\n}\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<h4 id=\"9-判断两个链表是否有相同结点（找出相同结点）\"><a href=\"#9-判断两个链表是否有相同结点（找出相同结点）\" class=\"headerlink\" title=\"9. 判断两个链表是否有相同结点（找出相同结点）\"></a>9. 判断两个链表是否有相同结点（找出相同结点）</h4></blockquote>\n<pre><code class=\"lang-c\">int Length(LinkList &amp;L){  //计算链表长度\n    int num = 0;\n    while(L != NULL){\n        num++;\n        L = L -&gt; next;\n    }\n    return num;\n}\nbool Judeg(LinkList &amp;L1, LinkList &amp;L2){\n    int len1 = Length(L1);\n    int len2 = Length(L2);\n    if(len1 &gt; len2){                   //让两个链表拥有相同的尾部长度\n        int num = len1 - len2;\n        for(int i = 0; i &lt; num; i++){\n            L1 = L1 -&gt; next;\n        }\n    }else{\n        int num = len2 - len1;\n        for(int i = 0; i &lt; num; i++){\n            L2 = L2 -&gt; next;\n    }\n    while(L1){\n        if(L1 == L2){\n            return 1;\n        }\n        L1 = L1 -&gt; next;\n        L2 = L2 -&gt; next;\n    }\n    return 0;\n}\n</code></pre>\n<blockquote>\n<h4 id=\"10-栈的基本操作\"><a href=\"#10-栈的基本操作\" class=\"headerlink\" title=\"10. 栈的基本操作\"></a>10. 栈的基本操作</h4></blockquote>\n<ul>\n<li><p>栈的顺序存储类型描述</p>\n<pre><code class=\"lang-c\">#define Maxsize 50       //定义栈中元素的最大个数\ntypedef struct{\n    int data[Maxsize];   //存放栈中元素\n    int top;             //栈顶指针\n}SqStack;\n</code></pre>\n</li>\n<li><p>初始化</p>\n<pre><code class=\"lang-c\">void InitStack(Sqstack &amp;S){\n    S.top = -1;               //初始化栈顶指针\n}\n</code></pre>\n</li>\n<li><p>判断栈空</p>\n<pre><code class=\"lang-c\">bool StackEmpty(S){\n    if(S.top == -1){\n        return true;\n    }else{\n        return false;\n    }\n}\n</code></pre>\n</li>\n<li><p>进栈</p>\n<pre><code class=\"lang-c\">bool Push(SqStack &amp;S, int x){\n    if(S.top == MaxSize - 1){\n        return false;\n    }\n    S.data[++S.top] = x;       //指针先加1，再入栈\n    return true;\n}\n</code></pre>\n</li>\n<li><p>出栈</p>\n<pre><code class=\"lang-c\">bool Pop（SqStack &amp;S, int &amp;x){\n    if(S.top == -1){\n        return false;\n    }\n    x = S.data[S.top--];\n    return true;\n}\n</code></pre>\n</li>\n<li><p>读栈顶元素</p>\n<pre><code class=\"lang-c\">bool GetTop(SqStack S, int &amp;x){\n    if(S.top == MaxSize - 1){\n        return false;\n    }\n    x = S.data[S.top];\n    return true;\n}\n</code></pre>\n</li>\n</ul>\n"},{"title":"高数第一讲总结","top":false,"cover":false,"toc":false,"mathjax":true,"summary":"第一章　函数极限与连续","abbrlink":"6214","date":"2020-07-21T06:38:44.000Z","password":null,"_content":"\n## 第一章　函数极限与连续\n\n- ### 极限\n\n  - 等式脱帽法\n\n$$\n  f(x)=A+ x ,其中\\displaystyle \\lim_{x \\to }{x}=0\n$$\n  - 局部保号性：若Ａ大于０，则函数ｆ(x)也大于０\n\n- ### 极限的计算\n\n  - 先化简\n\n  - 再变形\n    \n    - 换元、通分、因式分解\n    \n  - **中值定理**\n\n    - 拉格朗日中值定理：见到ｆ - ｆ、ｆ - ｆ的导数 \n\n    - 积分中值定理（见到函数和积分时使用）\n    $$\n    \\int_a^b{f(x)}dx=f(\\xi)(b-a)\n    $$\n    - 牛顿－莱布尼兹公式\n  \n    - 泰勒公式（三阶及其以上使用）\n\n  \n\n","source":"_posts/高数第一讲总结.md","raw":"---\ntitle: 高数第一讲总结\ntop: false\ncover: false\ntoc: false\nmathjax: true\nsummary: 第一章　函数极限与连续\ntags:\n  - 高数\n  - 总结\n  - 考研\ncategories:\n  - 数学\nabbrlink: '6214'\ndate: 2020-07-21 14:38:44\npassword:\n---\n\n## 第一章　函数极限与连续\n\n- ### 极限\n\n  - 等式脱帽法\n\n$$\n  f(x)=A+ x ,其中\\displaystyle \\lim_{x \\to }{x}=0\n$$\n  - 局部保号性：若Ａ大于０，则函数ｆ(x)也大于０\n\n- ### 极限的计算\n\n  - 先化简\n\n  - 再变形\n    \n    - 换元、通分、因式分解\n    \n  - **中值定理**\n\n    - 拉格朗日中值定理：见到ｆ - ｆ、ｆ - ｆ的导数 \n\n    - 积分中值定理（见到函数和积分时使用）\n    $$\n    \\int_a^b{f(x)}dx=f(\\xi)(b-a)\n    $$\n    - 牛顿－莱布尼兹公式\n  \n    - 泰勒公式（三阶及其以上使用）\n\n  \n\n","slug":"高数第一讲总结","published":1,"updated":"2020-08-10T07:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksie9q6d005sa09k6rqp2vox","content":"<h2 id=\"第一章-函数极限与连续\"><a href=\"#第一章-函数极限与连续\" class=\"headerlink\" title=\"第一章　函数极限与连续\"></a>第一章　函数极限与连续</h2><ul>\n<li><h3 id=\"极限\"><a href=\"#极限\" class=\"headerlink\" title=\"极限\"></a>极限</h3><ul>\n<li>等式脱帽法</li>\n</ul>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n  f(x)=A+ x ,其中\\displaystyle \\lim_{x \\to }{x}=0</script><ul>\n<li>局部保号性：若Ａ大于０，则函数ｆ(x)也大于０</li>\n</ul>\n<ul>\n<li><h3 id=\"极限的计算\"><a href=\"#极限的计算\" class=\"headerlink\" title=\"极限的计算\"></a>极限的计算</h3><ul>\n<li><p>先化简</p>\n</li>\n<li><p>再变形</p>\n<ul>\n<li>换元、通分、因式分解</li>\n</ul>\n</li>\n<li><p><strong>中值定理</strong></p>\n<ul>\n<li><p>拉格朗日中值定理：见到ｆ - ｆ、ｆ - ｆ的导数 </p>\n</li>\n<li><p>积分中值定理（见到函数和积分时使用）</p>\n<script type=\"math/tex; mode=display\">\n\\int_a^b{f(x)}dx=f(\\xi)(b-a)</script></li>\n<li><p>牛顿－莱布尼兹公式</p>\n</li>\n<li><p>泰勒公式（三阶及其以上使用）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"galleries":[{"name":"2020","cover":"2020/images/cover/p0.jpg","description":"我的图床","photos":["0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","0.jpg","1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg"]},{"name":"test","cover":"test/images/cover/13.jpg","description":"2018年记录","photos":["12.jpg"]},{"name":"serect","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]},{"name":"个人生活","cover":"serect/images/lock.jpg","description":"密码","photos":["15.jpg"]}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"第一章-函数极限与连续\"><a href=\"#第一章-函数极限与连续\" class=\"headerlink\" title=\"第一章　函数极限与连续\"></a>第一章　函数极限与连续</h2><ul>\n<li><h3 id=\"极限\"><a href=\"#极限\" class=\"headerlink\" title=\"极限\"></a>极限</h3><ul>\n<li>等式脱帽法</li>\n</ul>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n  f(x)=A+ x ,其中\\displaystyle \\lim_{x \\to }{x}=0</script><ul>\n<li>局部保号性：若Ａ大于０，则函数ｆ(x)也大于０</li>\n</ul>\n<ul>\n<li><h3 id=\"极限的计算\"><a href=\"#极限的计算\" class=\"headerlink\" title=\"极限的计算\"></a>极限的计算</h3><ul>\n<li><p>先化简</p>\n</li>\n<li><p>再变形</p>\n<ul>\n<li>换元、通分、因式分解</li>\n</ul>\n</li>\n<li><p><strong>中值定理</strong></p>\n<ul>\n<li><p>拉格朗日中值定理：见到ｆ - ｆ、ｆ - ｆ的导数 </p>\n</li>\n<li><p>积分中值定理（见到函数和积分时使用）</p>\n<script type=\"math/tex; mode=display\">\n\\int_a^b{f(x)}dx=f(\\xi)(b-a)</script></li>\n<li><p>牛顿－莱布尼兹公式</p>\n</li>\n<li><p>泰勒公式（三阶及其以上使用）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/SimCSE（四）/Supervised SimCSE.png","slug":"Supervised SimCSE.png","post":"cksie9q5t0029a09kfsp05wa9","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（九）/训练结果.png","slug":"训练结果.png","post":"cksie9q5q001pa09k69qb6xc2","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（三）/ICML2020.pdf","slug":"ICML2020.pdf","post":"cksie9q5p001ka09kdpcj16mv","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（三）/对比表示学习.webp","slug":"对比表示学习.webp","post":"cksie9q5p001ka09kdpcj16mv","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（十）/dropout.jpeg","slug":"dropout.jpeg","post":"cksie9q5r001ya09k0eb01ep7","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（十）/拟合对比.png","slug":"拟合对比.png","post":"cksie9q5r001ya09k0eb01ep7","modified":0,"renderable":0},{"_id":"source/_posts/菁菁学习计划/1.png","slug":"1.png","post":"cksie9q66004oa09kgqry1kaz","modified":0,"renderable":0},{"_id":"source/_posts/菁菁学习计划/2.png","slug":"2.png","post":"cksie9q66004oa09kgqry1kaz","modified":0,"renderable":0},{"_id":"source/_posts/计网第七章-局域网和广域网技术/img.png","slug":"img.png","post":"cksie9q680054a09k5j2v7g0m","modified":0,"renderable":0},{"_id":"source/_posts/计网第七章-局域网和广域网技术/img2.png","slug":"img2.png","post":"cksie9q680054a09k5j2v7g0m","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（一）/dropout.jpeg","slug":"dropout.jpeg","post":"cksie9q5n0019a09kgo4sdsqx","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（一）/拟合图片.jpeg","slug":"拟合图片.jpeg","post":"cksie9q5n0019a09kgo4sdsqx","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（一）/拟合对比.png","slug":"拟合对比.png","post":"cksie9q5n0019a09kgo4sdsqx","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（四）/001-surprise.png","slug":"001-surprise.png","post":"cksie9q5t0029a09kfsp05wa9","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（四）/Unsupervised SimCSE.png","slug":"Unsupervised SimCSE.png","post":"cksie9q5t0029a09kfsp05wa9","modified":0,"renderable":0},{"_id":"source/_posts/tensorflow（一）/下载1.png","slug":"下载1.png","post":"cksie9q5u002ha09k2ws22eph","modified":0,"renderable":0},{"_id":"source/_posts/tensorflow（一）/下载2.png","slug":"下载2.png","post":"cksie9q5u002ha09k2ws22eph","modified":0,"renderable":0},{"_id":"source/_posts/tensorflow（一）/模型情况.png","slug":"模型情况.png","post":"cksie9q5u002ha09k2ws22eph","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（六）/Figure 2.png","slug":"Figure 2.png","post":"cksie9q5s0025a09kcfzb49sw","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（六）/Table 2.png","slug":"Table 2.png","post":"cksie9q5s0025a09kcfzb49sw","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（六）/Table 3.png","slug":"Table 3.png","post":"cksie9q5s0025a09kcfzb49sw","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（六）/Table 4.png","slug":"Table 4.png","post":"cksie9q5s0025a09kcfzb49sw","modified":0,"renderable":0},{"_id":"source/_posts/SimCSE（六）/Table 5.png","slug":"Table 5.png","post":"cksie9q5s0025a09kcfzb49sw","modified":0,"renderable":0},{"_id":"source/_posts/吉林大学招生简章/专硕.png","slug":"专硕.png","post":"cksie9q5v002oa09kdh43d9e1","modified":0,"renderable":0},{"_id":"source/_posts/吉林大学招生简章/学硕.png","slug":"学硕.png","post":"cksie9q5v002oa09kdh43d9e1","modified":0,"renderable":0},{"_id":"source/_posts/吉林大学招生简章/计算机专硕.png","slug":"计算机专硕.png","post":"cksie9q5v002oa09kdh43d9e1","modified":0,"renderable":0},{"_id":"source/_posts/吉林大学招生简章/计算机学硕1.png","slug":"计算机学硕1.png","post":"cksie9q5v002oa09kdh43d9e1","modified":0,"renderable":0},{"_id":"source/_posts/吉林大学招生简章/计算机学硕2.png","slug":"计算机学硕2.png","post":"cksie9q5v002oa09kdh43d9e1","modified":0,"renderable":0},{"_id":"source/_posts/前端设计原稿/数据表格1.png","slug":"数据表格1.png","post":"cksie9q5v002la09k3phaghpr","modified":0,"renderable":0},{"_id":"source/_posts/前端设计原稿/数据表格2.png","slug":"数据表格2.png","post":"cksie9q5v002la09k3phaghpr","modified":0,"renderable":0},{"_id":"source/_posts/前端设计原稿/数据表格展示.pdf","slug":"数据表格展示.pdf","post":"cksie9q5v002la09k3phaghpr","modified":0,"renderable":0},{"_id":"source/_posts/前端设计原稿/爬取设置.pdf","slug":"爬取设置.pdf","post":"cksie9q5v002la09k3phaghpr","modified":0,"renderable":0},{"_id":"source/_posts/前端设计原稿/爬取设置.png","slug":"爬取设置.png","post":"cksie9q5v002la09k3phaghpr","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/ASK.png","slug":"ASK.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/FSK.png","slug":"FSK.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/PSK.png","slug":"PSK.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/QAM.png","slug":"QAM.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/单极性编码.png","slug":"单极性编码.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/曼彻斯特.png","slug":"曼彻斯特.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/强化-计网第二章-物理层/非归零编码.png","slug":"非归零编码.png","post":"cksie9q5y003aa09k8f673dsj","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/B类子网编码.png","slug":"B类子网编码.png","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/IP地址范围.png","slug":"IP地址范围.png","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/IP报文格式.png","slug":"IP报文格式.png","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/ip地址分类.png","slug":"ip地址分类.png","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/三次挥手.gif","slug":"三次挥手.gif","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/三次握手建立过程.gif","slug":"三次握手建立过程.gif","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/四次挥手.gif","slug":"四次挥手.gif","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0},{"_id":"source/_posts/计网第八章-TCP-IP协议/四次挥手过程.gif","slug":"四次挥手过程.gif","post":"cksie9q6a005ca09kbjhsaisp","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cksie9q5a0009a09kah7x9pia","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5f000ha09kd5p0exd3"},{"post_id":"cksie9q550001a09k3u3zcriz","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5h000ma09k5wuf6vyi"},{"post_id":"cksie9q5b000ba09k9fafcny7","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5j000pa09kg1vtbzpo"},{"post_id":"cksie9q5d000fa09kdu32frth","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5k000ua09kc1nedqva"},{"post_id":"cksie9q570003a09kbn3fd2er","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5k000xa09k7zo33138"},{"post_id":"cksie9q5f000la09k7zhrhrnm","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5l0012a09k4lvohwwe"},{"post_id":"cksie9q590007a09khcob65lm","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5m0015a09k5rdr32k5"},{"post_id":"cksie9q5j000ta09kbj3ja7wy","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5n001aa09k7v0k67k3"},{"post_id":"cksie9q5e000ga09ke0mdcpvn","category_id":"cksie9q5j000qa09kcdv55r96","_id":"cksie9q5o001da09k4al3gxc3"},{"post_id":"cksie9q5i000oa09kbosg5d5x","category_id":"cksie9q5k000ya09khzywhh3n","_id":"cksie9q5p001ia09k9gjj2eh8"},{"post_id":"cksie9q5k000wa09kc5lpcg5j","category_id":"cksie9q5k000ya09khzywhh3n","_id":"cksie9q5p001ma09k398sb876"},{"post_id":"cksie9q5l0011a09kgd3f9zga","category_id":"cksie9q5o001fa09kero1dbtf","_id":"cksie9q5r001ua09kd9idfkfm"},{"post_id":"cksie9q5q001ra09kb0evesmc","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5s0022a09k2hf59tig"},{"post_id":"cksie9q5l0014a09k4xyidjed","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5t0026a09k4hucahkg"},{"post_id":"cksie9q5r001va09ka0rjaial","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5t002aa09k074rhmt7"},{"post_id":"cksie9q5r001ya09k0eb01ep7","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5u002ea09kdszu4zs7"},{"post_id":"cksie9q5n0019a09kgo4sdsqx","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5u002ia09k04k710ic"},{"post_id":"cksie9q5s0021a09k13hi3lq3","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5v002ma09k61n6hurm"},{"post_id":"cksie9q5s0025a09kcfzb49sw","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5v002pa09k8e0o0sho"},{"post_id":"cksie9q5n001ca09kf56563ma","category_id":"cksie9q5o001fa09kero1dbtf","_id":"cksie9q5w002ua09k8hxphrb3"},{"post_id":"cksie9q5t0029a09kfsp05wa9","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5w002xa09kfdhefh0v"},{"post_id":"cksie9q5u002da09k8v1z5g0y","category_id":"cksie9q5k000ya09khzywhh3n","_id":"cksie9q5x0032a09k53mo0i9a"},{"post_id":"cksie9q5o001ha09kfl1lf6sy","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5x0034a09k4ykr66zq"},{"post_id":"cksie9q5p001ka09kdpcj16mv","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5y0038a09k0kod3eo0"},{"post_id":"cksie9q5q001pa09k69qb6xc2","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q5y003ba09k903pa0g4"},{"post_id":"cksie9q5w002wa09k9uq6gx7h","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q5z003ga09khw4c8qux"},{"post_id":"cksie9q5u002ha09k2ws22eph","category_id":"cksie9q5w002ya09khu903ai1","_id":"cksie9q5z003ja09k2yhj1xbp"},{"post_id":"cksie9q5x0033a09k18zq1hf1","category_id":"cksie9q5k000ya09khzywhh3n","_id":"cksie9q60003oa09k3npe7htv"},{"post_id":"cksie9q5v002la09k3phaghpr","category_id":"cksie9q5x0035a09k0lbc1wda","_id":"cksie9q61003ra09kgimh4si8"},{"post_id":"cksie9q5v002oa09kdh43d9e1","category_id":"cksie9q5y003ea09k5pon3ksr","_id":"cksie9q61003va09k48re82wk"},{"post_id":"cksie9q60003na09k2sq70ybp","category_id":"cksie9q5x0035a09k0lbc1wda","_id":"cksie9q62003ya09k7ijveoop"},{"post_id":"cksie9q5w002ta09k5t774pzk","category_id":"cksie9q5x0035a09k0lbc1wda","_id":"cksie9q620042a09k4ftl21l4"},{"post_id":"cksie9q60003qa09k7szff6hf","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q630046a09k24nuaabl"},{"post_id":"cksie9q61003ua09kewyob7nv","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q630049a09k5l911ieq"},{"post_id":"cksie9q5x0031a09kd75uh4yt","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q64004ca09k1qw3bu8j"},{"post_id":"cksie9q630045a09k9r971nk7","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q64004fa09k2ca66lix"},{"post_id":"cksie9q5y0037a09k6g2a6jeb","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q65004ia09kalu1aovd"},{"post_id":"cksie9q5y003aa09k8f673dsj","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q65004ka09k08mh3d6l"},{"post_id":"cksie9q64004ea09k6qs4c7d6","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q66004pa09kbttcdsj8"},{"post_id":"cksie9q65004ha09kczyp9y75","category_id":"cksie9q5p001oa09kbhax8mal","_id":"cksie9q66004sa09key7d9p6d"},{"post_id":"cksie9q5z003fa09kexb5bpi1","category_id":"cksie9q64004ga09kb2aj6s0i","_id":"cksie9q67004xa09kcrdn0sgc"},{"post_id":"cksie9q66004oa09kgqry1kaz","category_id":"cksie9q5j000qa09kcdv55r96","_id":"cksie9q680050a09kbdckfqil"},{"post_id":"cksie9q5z003ia09k7zv99on1","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q680055a09k32rn4y3m"},{"post_id":"cksie9q67004wa09khq8t64dz","category_id":"cksie9q5x0035a09k0lbc1wda","_id":"cksie9q6a0058a09k83kzfqci"},{"post_id":"cksie9q62003xa09kc6ycgb4j","category_id":"cksie9q64004ga09kb2aj6s0i","_id":"cksie9q6b005da09kbzbt7k6j"},{"post_id":"cksie9q67004za09k3m7t47pl","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q6b005ga09k1p07b4kt"},{"post_id":"cksie9q680054a09k5j2v7g0m","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q6c005la09kh5cp8uer"},{"post_id":"cksie9q620041a09kct4zga6r","category_id":"cksie9q64004ga09kb2aj6s0i","_id":"cksie9q6d005oa09k2hjv32un"},{"post_id":"cksie9q690057a09k7d4b5m24","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q6d005ta09k81cibjep"},{"post_id":"cksie9q6a005ca09kbjhsaisp","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q6e005va09kgrk8f0ir"},{"post_id":"cksie9q630048a09k0wcs9s1n","category_id":"cksie9q64004ga09kb2aj6s0i","_id":"cksie9q6e005za09k7p4sdfng"},{"post_id":"cksie9q6b005fa09kgeyah8c3","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q6e0060a09k2je77n5m"},{"post_id":"cksie9q6c005ka09kc5p7127v","category_id":"cksie9q61003ta09k0g3k2qeq","_id":"cksie9q6e0063a09k2hvges6i"},{"post_id":"cksie9q64004ba09kb4eghhdh","category_id":"cksie9q6b005ia09kdyfe423q","_id":"cksie9q6e0064a09kadu5c8cy"},{"post_id":"cksie9q6c005na09k40side1d","category_id":"cksie9q580005a09k930h2acr","_id":"cksie9q6e0067a09khlgi44jk"},{"post_id":"cksie9q65004ja09k58e26of5","category_id":"cksie9q6d005qa09k2tfxf3a1","_id":"cksie9q6f0069a09kda2n9dnl"},{"post_id":"cksie9q66004ra09k8lq08vos","category_id":"cksie9q6e005ya09kgefidxv5","_id":"cksie9q6f006ca09k6gc9421i"},{"post_id":"cksie9q6d005sa09k6rqp2vox","category_id":"cksie9q6e0062a09k6n9cd8q5","_id":"cksie9q6f006ea09k27tdcy04"}],"PostTag":[{"post_id":"cksie9q5d000fa09kdu32frth","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5f000ka09kdjoh8zlq"},{"post_id":"cksie9q5d000fa09kdu32frth","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5i000na09ka7a9gfgf"},{"post_id":"cksie9q550001a09k3u3zcriz","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5j000sa09kc6v7b7ob"},{"post_id":"cksie9q550001a09k3u3zcriz","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5k000va09kf7a90q8e"},{"post_id":"cksie9q5f000la09k7zhrhrnm","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5l0010a09k0gis97vw"},{"post_id":"cksie9q5f000la09k7zhrhrnm","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5l0013a09k9qh4dfso"},{"post_id":"cksie9q5j000ta09kbj3ja7wy","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5n0018a09k01ez8x01"},{"post_id":"cksie9q5j000ta09kbj3ja7wy","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5n001ba09kfmol9wk7"},{"post_id":"cksie9q570003a09kbn3fd2er","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5o001ga09kbufpcx3q"},{"post_id":"cksie9q570003a09kbn3fd2er","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5p001ja09k2e8r1k27"},{"post_id":"cksie9q590007a09khcob65lm","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5p001na09kh8uu3ncn"},{"post_id":"cksie9q590007a09khcob65lm","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5q001qa09kgak85seg"},{"post_id":"cksie9q5a0009a09kah7x9pia","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5r001ta09k4nl6fsl9"},{"post_id":"cksie9q5a0009a09kah7x9pia","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5r001xa09k2cyr56um"},{"post_id":"cksie9q5b000ba09k9fafcny7","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q5s0020a09k92da7oq3"},{"post_id":"cksie9q5b000ba09k9fafcny7","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5s0024a09k8zej8bfv"},{"post_id":"cksie9q5e000ga09ke0mdcpvn","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5t0027a09k6nao3ndd"},{"post_id":"cksie9q5e000ga09ke0mdcpvn","tag_id":"cksie9q5r001sa09k3i634f38","_id":"cksie9q5t002ca09k1bis8dm5"},{"post_id":"cksie9q5i000oa09kbosg5d5x","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5u002fa09kb55844bi"},{"post_id":"cksie9q5i000oa09kbosg5d5x","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q5v002ka09kdt3r7meo"},{"post_id":"cksie9q5k000wa09kc5lpcg5j","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5v002na09k4r5wecrp"},{"post_id":"cksie9q5k000wa09kc5lpcg5j","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q5w002sa09k6649f49m"},{"post_id":"cksie9q5u002da09k8v1z5g0y","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5w002va09kakp14uls"},{"post_id":"cksie9q5u002da09k8v1z5g0y","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q5x0030a09kes1c2t18"},{"post_id":"cksie9q5l0011a09kgd3f9zga","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q5y0039a09k8hvjgt13"},{"post_id":"cksie9q5l0011a09kgd3f9zga","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q5y003ca09k4g6w3nz4"},{"post_id":"cksie9q5l0011a09kgd3f9zga","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q5z003ha09k5sdy31e2"},{"post_id":"cksie9q5x0033a09k18zq1hf1","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q5z003ka09k9ru61int"},{"post_id":"cksie9q5x0033a09k18zq1hf1","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q60003pa09k86nc9dyi"},{"post_id":"cksie9q5l0014a09k4xyidjed","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q62003wa09k6eav6148"},{"post_id":"cksie9q5l0014a09k4xyidjed","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q62003za09kgjgzf40y"},{"post_id":"cksie9q5l0014a09k4xyidjed","tag_id":"cksie9q5z003la09kegj92irq","_id":"cksie9q630044a09k49emg64k"},{"post_id":"cksie9q65004ha09kczyp9y75","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q66004na09k1xbqeymf"},{"post_id":"cksie9q65004ha09kczyp9y75","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q66004qa09kdehph81u"},{"post_id":"cksie9q65004ha09kczyp9y75","tag_id":"cksie9q5z003la09kegj92irq","_id":"cksie9q67004va09k3kc9eu7f"},{"post_id":"cksie9q5n0019a09kgo4sdsqx","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q67004ya09kai08cqz9"},{"post_id":"cksie9q5n0019a09kgo4sdsqx","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q680053a09k4i503py1"},{"post_id":"cksie9q5n0019a09kgo4sdsqx","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q690056a09k3tvq61tq"},{"post_id":"cksie9q5n0019a09kgo4sdsqx","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6a005ba09kgr4qd34e"},{"post_id":"cksie9q66004oa09kgqry1kaz","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6b005ea09k23xodre2"},{"post_id":"cksie9q66004oa09kgqry1kaz","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q6c005ja09kei1jhc2g"},{"post_id":"cksie9q5n001ca09kf56563ma","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6c005ma09keh315phc"},{"post_id":"cksie9q5n001ca09kf56563ma","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6d005ra09kbnn38ufc"},{"post_id":"cksie9q5n001ca09kf56563ma","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6d005ua09k2wnu3vk8"},{"post_id":"cksie9q5n001ca09kf56563ma","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q6e005xa09k2e187lh5"},{"post_id":"cksie9q5o001ha09kfl1lf6sy","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6e0066a09k1g0aebhk"},{"post_id":"cksie9q5o001ha09kfl1lf6sy","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6e0068a09kcg5h76th"},{"post_id":"cksie9q5o001ha09kfl1lf6sy","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6f006ba09khose6f8m"},{"post_id":"cksie9q5o001ha09kfl1lf6sy","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6f006da09kgybz095g"},{"post_id":"cksie9q5p001ka09kdpcj16mv","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6f006ia09k5zuc6xmk"},{"post_id":"cksie9q5p001ka09kdpcj16mv","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6f006ja09khlhkb9pv"},{"post_id":"cksie9q5p001ka09kdpcj16mv","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6f006la09k7qpk86nr"},{"post_id":"cksie9q5p001ka09kdpcj16mv","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6f006ma09kfaj74qc0"},{"post_id":"cksie9q5q001pa09k69qb6xc2","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6g006pa09kggtfak0m"},{"post_id":"cksie9q5q001pa09k69qb6xc2","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6g006qa09khlcvbim8"},{"post_id":"cksie9q5q001pa09k69qb6xc2","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6g006sa09k4r1j6enb"},{"post_id":"cksie9q5q001pa09k69qb6xc2","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6g006ta09k6mjh9x67"},{"post_id":"cksie9q5q001ra09kb0evesmc","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6h006xa09k3ivu8i4q"},{"post_id":"cksie9q5q001ra09kb0evesmc","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6h006ya09kbf3zdojr"},{"post_id":"cksie9q5q001ra09kb0evesmc","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6h0070a09kf16k0svy"},{"post_id":"cksie9q5q001ra09kb0evesmc","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6h0071a09k7tcvgh5w"},{"post_id":"cksie9q5r001va09ka0rjaial","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6h0075a09khabz127q"},{"post_id":"cksie9q5r001va09ka0rjaial","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6h0076a09k8e3y9i45"},{"post_id":"cksie9q5r001va09ka0rjaial","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6i0078a09kgvur4b1j"},{"post_id":"cksie9q5r001va09ka0rjaial","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6i0079a09k7gqm1ujj"},{"post_id":"cksie9q5r001ya09k0eb01ep7","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6i007da09k822k04gg"},{"post_id":"cksie9q5r001ya09k0eb01ep7","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6i007ea09k88mtcjht"},{"post_id":"cksie9q5r001ya09k0eb01ep7","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6i007ga09kaqi3bxy4"},{"post_id":"cksie9q5r001ya09k0eb01ep7","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6i007ha09kad0y0cmz"},{"post_id":"cksie9q5s0021a09k13hi3lq3","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6i007ka09k61tya56i"},{"post_id":"cksie9q5s0021a09k13hi3lq3","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6j007la09kgmbfgw7n"},{"post_id":"cksie9q5s0021a09k13hi3lq3","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6j007na09k2ahub309"},{"post_id":"cksie9q5s0021a09k13hi3lq3","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6j007oa09kc32cbuy3"},{"post_id":"cksie9q5s0025a09kcfzb49sw","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6j007sa09k1fcq15jk"},{"post_id":"cksie9q5s0025a09kcfzb49sw","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6j007ta09k5z5325dm"},{"post_id":"cksie9q5s0025a09kcfzb49sw","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6j007va09k9g0h2f21"},{"post_id":"cksie9q5s0025a09kcfzb49sw","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6j007wa09kcu8vchkz"},{"post_id":"cksie9q5t0029a09kfsp05wa9","tag_id":"cksie9q5u002ga09kd6lq89nc","_id":"cksie9q6k0080a09k15mfgxsz"},{"post_id":"cksie9q5t0029a09kfsp05wa9","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6k0081a09kgfafb9es"},{"post_id":"cksie9q5t0029a09kfsp05wa9","tag_id":"cksie9q630047a09kf5smcqb6","_id":"cksie9q6k0083a09kaljp1jp6"},{"post_id":"cksie9q5t0029a09kfsp05wa9","tag_id":"cksie9q64004da09k5o7c4rl9","_id":"cksie9q6k0084a09kenqt2m79"},{"post_id":"cksie9q5u002ha09k2ws22eph","tag_id":"cksie9q5v002ra09k71707tvy","_id":"cksie9q6k0088a09ka3sob8no"},{"post_id":"cksie9q5u002ha09k2ws22eph","tag_id":"cksie9q6k0082a09k94f17pgt","_id":"cksie9q6k0089a09k262d5eg1"},{"post_id":"cksie9q5u002ha09k2ws22eph","tag_id":"cksie9q6k0085a09k2jlc5q89","_id":"cksie9q6k008ba09kek166wsc"},{"post_id":"cksie9q5u002ha09k2ws22eph","tag_id":"cksie9q6k0086a09k5oh3gv6y","_id":"cksie9q6k008ca09kcveb1bng"},{"post_id":"cksie9q5v002la09k3phaghpr","tag_id":"cksie9q6k0087a09k66zreq5m","_id":"cksie9q6k008fa09ke90sfwky"},{"post_id":"cksie9q5v002la09k3phaghpr","tag_id":"cksie9q6k008aa09kgi6p7fc5","_id":"cksie9q6k008ga09ke7nt5v9b"},{"post_id":"cksie9q5v002la09k3phaghpr","tag_id":"cksie9q6k008da09k1y1v8wgk","_id":"cksie9q6l008ia09k8q1r1dhy"},{"post_id":"cksie9q5v002oa09kdh43d9e1","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6l008ja09kcj56bq5v"},{"post_id":"cksie9q5v002oa09kdh43d9e1","tag_id":"cksie9q5r001sa09k3i634f38","_id":"cksie9q6l008la09k3ecncg3k"},{"post_id":"cksie9q5v002oa09kdh43d9e1","tag_id":"cksie9q6k008ea09kfcfh17ml","_id":"cksie9q6l008ma09khpy91u6a"},{"post_id":"cksie9q5w002ta09k5t774pzk","tag_id":"cksie9q6k008ha09khd5aen6d","_id":"cksie9q6l008qa09k4nhb81no"},{"post_id":"cksie9q5w002ta09k5t774pzk","tag_id":"cksie9q6l008ka09ketpf8juv","_id":"cksie9q6l008ra09kagxv5jq8"},{"post_id":"cksie9q5w002ta09k5t774pzk","tag_id":"cksie9q6l008na09kavxlfv9y","_id":"cksie9q6l008ta09kasu52osi"},{"post_id":"cksie9q5w002ta09k5t774pzk","tag_id":"cksie9q6k008da09k1y1v8wgk","_id":"cksie9q6l008ua09k0qw53va8"},{"post_id":"cksie9q5w002wa09k9uq6gx7h","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6l008wa09k90y32qxs"},{"post_id":"cksie9q5w002wa09k9uq6gx7h","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6l008xa09kglxwhsml"},{"post_id":"cksie9q5w002wa09k9uq6gx7h","tag_id":"cksie9q6l008pa09k3qtqgwd5","_id":"cksie9q6l008za09keq3ja3x8"},{"post_id":"cksie9q5x0031a09kd75uh4yt","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6m0091a09k0o1wdg5g"},{"post_id":"cksie9q5x0031a09kd75uh4yt","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6m0092a09kdpt47at6"},{"post_id":"cksie9q5x0031a09kd75uh4yt","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6m0094a09khdbl68xp"},{"post_id":"cksie9q5x0031a09kd75uh4yt","tag_id":"cksie9q6l008ya09k56j31uxn","_id":"cksie9q6m0095a09kcln57ctc"},{"post_id":"cksie9q5y0037a09k6g2a6jeb","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6m0099a09kho8whpti"},{"post_id":"cksie9q5y0037a09k6g2a6jeb","tag_id":"cksie9q6m0093a09k24qve20m","_id":"cksie9q6m009aa09ka9eo3bnp"},{"post_id":"cksie9q5y0037a09k6g2a6jeb","tag_id":"cksie9q6m0096a09kds9mcw01","_id":"cksie9q6m009ca09kgpyg1tjx"},{"post_id":"cksie9q5y0037a09k6g2a6jeb","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6m009da09k0hpecioq"},{"post_id":"cksie9q5y0037a09k6g2a6jeb","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6m009fa09kcuuk1le9"},{"post_id":"cksie9q5y003aa09k8f673dsj","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6n009ha09k20ujalwz"},{"post_id":"cksie9q5y003aa09k8f673dsj","tag_id":"cksie9q6m0096a09kds9mcw01","_id":"cksie9q6n009ia09kb8729734"},{"post_id":"cksie9q5y003aa09k8f673dsj","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6n009ka09k3zpz72bs"},{"post_id":"cksie9q5y003aa09k8f673dsj","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6n009la09ke02i3vgd"},{"post_id":"cksie9q5z003fa09kexb5bpi1","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6n009na09kf8tnh7nk"},{"post_id":"cksie9q5z003fa09kexb5bpi1","tag_id":"cksie9q6m009ga09kb8122sjy","_id":"cksie9q6n009oa09khvvs0wtq"},{"post_id":"cksie9q5z003fa09kexb5bpi1","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6n009qa09k884d1ogc"},{"post_id":"cksie9q5z003ia09k7zv99on1","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6n009sa09kebv36dy1"},{"post_id":"cksie9q5z003ia09k7zv99on1","tag_id":"cksie9q6m0096a09kds9mcw01","_id":"cksie9q6n009ta09k570h55sd"},{"post_id":"cksie9q5z003ia09k7zv99on1","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6n009va09k4ed6euiw"},{"post_id":"cksie9q5z003ia09k7zv99on1","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6n009wa09kdsmi21uo"},{"post_id":"cksie9q60003na09k2sq70ybp","tag_id":"cksie9q6n009ra09k66frg5ge","_id":"cksie9q6o00a0a09kdrh99meo"},{"post_id":"cksie9q60003na09k2sq70ybp","tag_id":"cksie9q6n009ua09k20px5ue5","_id":"cksie9q6o00a1a09k20degk4i"},{"post_id":"cksie9q60003na09k2sq70ybp","tag_id":"cksie9q6n009xa09k9tgd6twp","_id":"cksie9q6o00a3a09kh0hx5ebd"},{"post_id":"cksie9q60003na09k2sq70ybp","tag_id":"cksie9q6k008da09k1y1v8wgk","_id":"cksie9q6o00a4a09kcvuc9nts"},{"post_id":"cksie9q60003qa09k7szff6hf","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6o00a6a09kg6tl5trs"},{"post_id":"cksie9q60003qa09k7szff6hf","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6o00a7a09k6qg27aaw"},{"post_id":"cksie9q60003qa09k7szff6hf","tag_id":"cksie9q6o009za09kfzrkhf7g","_id":"cksie9q6o00a9a09khfpd370u"},{"post_id":"cksie9q61003ua09kewyob7nv","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6o00aaa09k9dykhqt1"},{"post_id":"cksie9q61003ua09kewyob7nv","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6o00aca09kg29447pg"},{"post_id":"cksie9q61003ua09kewyob7nv","tag_id":"cksie9q6o00a2a09keryk9yvk","_id":"cksie9q6p00ada09kaq9k2u5g"},{"post_id":"cksie9q62003xa09kc6ycgb4j","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6p00afa09k5yjbd01l"},{"post_id":"cksie9q62003xa09kc6ycgb4j","tag_id":"cksie9q6m009ga09kb8122sjy","_id":"cksie9q6p00aga09k6eskgl6f"},{"post_id":"cksie9q62003xa09kc6ycgb4j","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6p00aia09k06yrc9nh"},{"post_id":"cksie9q620041a09kct4zga6r","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6p00aja09kfee2eogz"},{"post_id":"cksie9q620041a09kct4zga6r","tag_id":"cksie9q6m009ga09kb8122sjy","_id":"cksie9q6p00ala09k9kic5pae"},{"post_id":"cksie9q620041a09kct4zga6r","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6p00ama09k2e4cgf8a"},{"post_id":"cksie9q630045a09k9r971nk7","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6p00aoa09k42oqft3k"},{"post_id":"cksie9q630045a09k9r971nk7","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6p00apa09kdrg4avdw"},{"post_id":"cksie9q630045a09k9r971nk7","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6p00aqa09k0eck1kst"},{"post_id":"cksie9q630048a09k0wcs9s1n","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6p00asa09k2uysavyt"},{"post_id":"cksie9q630048a09k0wcs9s1n","tag_id":"cksie9q6m009ga09kb8122sjy","_id":"cksie9q6p00ata09khrejbkdg"},{"post_id":"cksie9q630048a09k0wcs9s1n","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6q00ava09kh68768di"},{"post_id":"cksie9q64004ba09kb4eghhdh","tag_id":"cksie9q6p00aka09k8on7g6n5","_id":"cksie9q6q00awa09kd8ywf59t"},{"post_id":"cksie9q64004ba09kb4eghhdh","tag_id":"cksie9q6p00ana09k46g046sm","_id":"cksie9q6q00aya09ka49xguna"},{"post_id":"cksie9q64004ea09k6qs4c7d6","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6q00aza09k76kn8xvj"},{"post_id":"cksie9q64004ea09k6qs4c7d6","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6q00b1a09k6g8w00dc"},{"post_id":"cksie9q64004ea09k6qs4c7d6","tag_id":"cksie9q6p00ara09khlnq85hl","_id":"cksie9q6q00b2a09ke6yv1uvn"},{"post_id":"cksie9q65004ja09k58e26of5","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6q00b4a09keg9tbzuk"},{"post_id":"cksie9q65004ja09k58e26of5","tag_id":"cksie9q5s001za09k7k391s9w","_id":"cksie9q6q00b5a09kcr6g5dl4"},{"post_id":"cksie9q65004ja09k58e26of5","tag_id":"cksie9q6l008ya09k56j31uxn","_id":"cksie9q6q00b7a09kfk678xhw"},{"post_id":"cksie9q65004ja09k58e26of5","tag_id":"cksie9q6q00axa09k0zwigzca","_id":"cksie9q6q00b8a09k6xud1u03"},{"post_id":"cksie9q66004ra09k8lq08vos","tag_id":"cksie9q6q00b0a09k3twn8o7r","_id":"cksie9q6q00baa09kg6i337sd"},{"post_id":"cksie9q66004ra09k8lq08vos","tag_id":"cksie9q6n009xa09k9tgd6twp","_id":"cksie9q6r00bba09k2xw36qcg"},{"post_id":"cksie9q66004ra09k8lq08vos","tag_id":"cksie9q6k008da09k1y1v8wgk","_id":"cksie9q6r00bda09k82onexq9"},{"post_id":"cksie9q67004wa09khq8t64dz","tag_id":"cksie9q6q00b9a09k49ve47mp","_id":"cksie9q6r00bha09k7jjy57q7"},{"post_id":"cksie9q67004wa09khq8t64dz","tag_id":"cksie9q6l008na09kavxlfv9y","_id":"cksie9q6r00bia09k6wm4ckd2"},{"post_id":"cksie9q67004wa09khq8t64dz","tag_id":"cksie9q6n009xa09k9tgd6twp","_id":"cksie9q6r00bka09k5fcc88o6"},{"post_id":"cksie9q67004wa09khq8t64dz","tag_id":"cksie9q6k008da09k1y1v8wgk","_id":"cksie9q6r00bla09kb3p6gj5j"},{"post_id":"cksie9q67004za09k3m7t47pl","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6r00bna09ka63l5oxl"},{"post_id":"cksie9q67004za09k3m7t47pl","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6r00boa09kepisgopc"},{"post_id":"cksie9q67004za09k3m7t47pl","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6s00bqa09kfx2gdxqi"},{"post_id":"cksie9q680054a09k5j2v7g0m","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6s00bsa09kcyw4dpbu"},{"post_id":"cksie9q680054a09k5j2v7g0m","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6s00bta09k60440m9z"},{"post_id":"cksie9q680054a09k5j2v7g0m","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6s00bva09kb6jn0vgi"},{"post_id":"cksie9q690057a09k7d4b5m24","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6s00bxa09k70hg3lm3"},{"post_id":"cksie9q690057a09k7d4b5m24","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6s00bya09k0h942dd4"},{"post_id":"cksie9q690057a09k7d4b5m24","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6s00c0a09kcajahnil"},{"post_id":"cksie9q6a005ca09kbjhsaisp","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6t00c2a09kbgphgsu0"},{"post_id":"cksie9q6a005ca09kbjhsaisp","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6t00c3a09k1t9jfywu"},{"post_id":"cksie9q6a005ca09kbjhsaisp","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6t00c5a09kbvpwd63f"},{"post_id":"cksie9q6b005fa09kgeyah8c3","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6t00c7a09kh5uf6wv5"},{"post_id":"cksie9q6b005fa09kgeyah8c3","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6t00c8a09k8ta306mt"},{"post_id":"cksie9q6b005fa09kgeyah8c3","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6t00caa09kehtj4nd3"},{"post_id":"cksie9q6c005ka09kc5p7127v","tag_id":"cksie9q6l008sa09ke4agauj0","_id":"cksie9q6u00cca09k0ihzb23j"},{"post_id":"cksie9q6c005ka09kc5p7127v","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6u00cda09k8iix79ge"},{"post_id":"cksie9q6c005ka09kc5p7127v","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6u00cfa09kbv7u1fzc"},{"post_id":"cksie9q6c005na09k40side1d","tag_id":"cksie9q590006a09k5q7pcrnx","_id":"cksie9q6u00cga09keabye6jr"},{"post_id":"cksie9q6c005na09k40side1d","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6u00cia09k8xhz3sgk"},{"post_id":"cksie9q6c005na09k40side1d","tag_id":"cksie9q6u00cba09k1hvybmxi","_id":"cksie9q6u00cja09k6ujtggyi"},{"post_id":"cksie9q6d005sa09k6rqp2vox","tag_id":"cksie9q6u00cea09k1w2m0aum","_id":"cksie9q6u00cka09kh4ba3sks"},{"post_id":"cksie9q6d005sa09k6rqp2vox","tag_id":"cksie9q6l008va09k7q8r36rv","_id":"cksie9q6u00cla09k3e403hyy"},{"post_id":"cksie9q6d005sa09k6rqp2vox","tag_id":"cksie9q5c000da09kbicl7gws","_id":"cksie9q6u00cma09khxtg8k57"}],"Tag":[{"name":"代码","_id":"cksie9q590006a09k5q7pcrnx"},{"name":"考研","_id":"cksie9q5c000da09kbicl7gws"},{"name":"心理学","_id":"cksie9q5r001sa09k3i634f38"},{"name":"计划","_id":"cksie9q5s001za09k7k391s9w"},{"name":"论文","_id":"cksie9q5u002ga09kd6lq89nc"},{"name":"研究生","_id":"cksie9q5v002ra09k71707tvy"},{"name":"笔迹鉴定","_id":"cksie9q5z003la09kegj92irq"},{"name":"知识图谱","_id":"cksie9q630047a09kf5smcqb6"},{"name":"SimCSE","_id":"cksie9q64004da09k5o7c4rl9"},{"name":"tensorflow","_id":"cksie9q6k0082a09k94f17pgt"},{"name":"NLP","_id":"cksie9q6k0085a09k2jlc5q89"},{"name":"神经网络","_id":"cksie9q6k0086a09k5oh3gv6y"},{"name":"前端","_id":"cksie9q6k0087a09k66zreq5m"},{"name":"Vue","_id":"cksie9q6k008aa09kgi6p7fc5"},{"name":"项目","_id":"cksie9q6k008da09k1y1v8wgk"},{"name":"计算机","_id":"cksie9q6k008ea09kfcfh17ml"},{"name":"NodeJS","_id":"cksie9q6k008ha09khd5aen6d"},{"name":"API","_id":"cksie9q6l008ka09ketpf8juv"},{"name":"部署","_id":"cksie9q6l008na09kavxlfv9y"},{"name":"图","_id":"cksie9q6l008pa09k3qtqgwd5"},{"name":"计网","_id":"cksie9q6l008sa09ke4agauj0"},{"name":"总结","_id":"cksie9q6l008va09k7q8r36rv"},{"name":"男男","_id":"cksie9q6l008ya09k56j31uxn"},{"name":"数据链路层","_id":"cksie9q6m0093a09k24qve20m"},{"name":"强化","_id":"cksie9q6m0096a09kds9mcw01"},{"name":"每日一题","_id":"cksie9q6m009ga09kb8122sjy"},{"name":"scrapy","_id":"cksie9q6n009ra09k66frg5ge"},{"name":"微博","_id":"cksie9q6n009ua09k20px5ue5"},{"name":"爬虫","_id":"cksie9q6n009xa09k9tgd6twp"},{"name":"排序","_id":"cksie9q6o009za09kfzrkhf7g"},{"name":"树","_id":"cksie9q6o00a2a09keryk9yvk"},{"name":"Typora","_id":"cksie9q6p00aka09k8on7g6n5"},{"name":"Markdown","_id":"cksie9q6p00ana09k46g046sm"},{"name":"线性表","_id":"cksie9q6p00ara09khlnq85hl"},{"name":"菁菁","_id":"cksie9q6q00axa09k0zwigzca"},{"name":"bug","_id":"cksie9q6q00b0a09k3twn8o7r"},{"name":"scrapyd","_id":"cksie9q6q00b9a09k49ve47mp"},{"name":"链表","_id":"cksie9q6u00cba09k1hvybmxi"},{"name":"高数","_id":"cksie9q6u00cea09k1w2m0aum"}]}}