<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pytorch知识点</title>
      <link href="/posts/3b1e.html/"/>
      <url>/posts/3b1e.html/</url>
      
        <content type="html"><![CDATA[<ul><li>dir():打开，看见<ul><li>能让我们知道工具箱以及工具箱中的分割区有什么东西。</li></ul></li><li>help（）：说明书<ul><li>能让我们知道每个工具是如何使用的，工具的使用方法。</li></ul></li></ul><hr><ul><li><p>jupyter</p><ul><li>shift+回车：快捷运行，以每一块作为运行整体</li></ul></li><li><p>加载数据</p><ul><li>Dataset：提供一种方式去获取。如何获取每个数据及其label，告诉我们总共有多少个数据</li><li>Dataloader：为后面的网络提供不同的数据形式</li></ul></li></ul><hr><ul><li>tensorboard</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriterwriter <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">'logs'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># writer.add_image()</span><span class="token comment" spellcheck="true"># y = x</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'y=x'</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<code>tensorboard --logdir=logs</code>，logs为目录</li><li>使用<code>tensorboard --logdir=logs --port=6007</code>，如果端口占用，可用可选端口</li></ul><hr><ul><li>在项目文件夹中放入图片</li></ul><pre class="line-numbers language-python"><code class="language-python">image_url <span class="token operator">=</span> <span class="token string">'./dataset/练手数据集/val/bees/6a00d8341c630a53ef00e553d0beb18834-800wi.jpg'</span>img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>image_url<span class="token punctuation">)</span>np_img <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>img<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>add_image<span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> np_img<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> dataformats<span class="token operator">=</span><span class="token string">'HWC'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li><p>Transforms的使用</p></li><li><p>是一个工具箱，里面有很多函数</p><ul><li>ToTensor，resize等等</li></ul></li><li><p>python中的用法 -》 tensor数据类型</p></li><li><p>通过transform.ToTensor去解决两个问题</p><ul><li><p>1、transform如何使用，需要先穿件函数 实例，因为里面有__call__方法，功能是把函数可以实例化为类使用。应先实例化，再调用。</p></li><li><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transformsimg_path <span class="token operator">=</span> <span class="token string">'./dataset/练手数据集/train/ants_image/0013035.jpg'</span>img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(img)</span>tensor_trans <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span>tensor_img <span class="token operator">=</span> tensor_trans<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>tensor_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2、为什么需要Tensor数据类型</p></li><li><p>__call__用法：</p></li></ul></li><li><p>常见的Transforms</p><ul><li>输入：PIL，Image.open，tensor，narrays</li><li>输出：</li></ul></li></ul><p><strong>忽略大小写，进行提示匹配</strong></p><ul><li>Compose method: It is need list, [item1, item 2],they must be transforms type</li></ul><p><strong>关注函数的输入和输出类型，多看官方文档。关注方法需要的参数</strong></p><hr><p>**神经网络股价骨架</p><ul><li>先继承nn.model</li><li>卷积层：Conv2d<ul><li>in_channel：同时输入的数据量</li><li>out_channel:卷积计算后的个数，有几个卷积核就有几个输出通道，卷积核一般不同</li></ul></li></ul><hr><ul><li>池化层 pooling layers<ul><li>Max pooling，也被称作下采样，选kennal核最大的那个数字</li><li>dtype选择float才可以计算</li><li>选取特征，减少大小</li></ul></li></ul><hr><ul><li>非线性激活层（举例ReLu）</li></ul><hr><ul><li>线性层以及其他层<ul><li>正则化层，用的不是很多</li><li><code>torch.flatten</code>把输入展开为一行</li></ul></li></ul><hr><ul><li>sequential：</li></ul><hr><ul><li>损失函数与反向传播<ul><li>loss：1、计算输出和目标的差距。2、为我们更新输出提供一定的依据<strong>（反向传播）</strong>,利用梯度<ul><li>MSE:平方平均。L1loss：加和平均</li><li>交叉熵：C类</li><li><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/mac-img/20220817100145.png"></li></ul></li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 1-batch_size,1 channel, 1line3column</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><ul><li><p>优化器</p><ul><li>lr学习速率，learning rate</li><li><code>optimizer.zero_grad()</code>每一次后清零梯度</li><li>求梯度</li></ul></li><li><p>训练简单步骤</p></li><li></li><li><pre class="line-numbers language-python"><code class="language-python">loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>tudui <span class="token operator">=</span> Tudui<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 优化器</span>optim <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>tudui<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    running_loss <span class="token operator">=</span> <span class="token number">0.0</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>        imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data        outputs <span class="token operator">=</span> tudui<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>        result_loss <span class="token operator">=</span> loss<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 梯度为0</span>        optim<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        result_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        optim<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        running_loss <span class="token operator">=</span> running_loss <span class="token operator">+</span> result_loss    <span class="token keyword">print</span><span class="token punctuation">(</span>running_loss<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><ul><li><p>模型使用与修改</p><ul><li><p>增加已有模型，增加一层</p></li><li><pre class="line-numbers language-python"><code class="language-python">vgg16_true<span class="token punctuation">.</span>classifier<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'add_linear'</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改已有的层级</p></li><li><pre class="line-numbers language-python"><code class="language-python">vgg16_false<span class="token punctuation">.</span>classifier<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><hr><ul><li><p>模型的保存和读取</p></li><li><p>减少内存，把tensor提取出数字</p></li><li><pre class="line-numbers language-python"><code class="language-python">loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 保存方式1,模型结构+模型参数</span>torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>vgg16<span class="token punctuation">,</span> <span class="token string">"vgg16_method1.pth"</span><span class="token punctuation">)</span>model <span class="token operator">=</span> torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"vgg16_method1.pth"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存方式2，模型参数（官方推荐）</span>torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>vgg16<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"vgg16_method2.pth"</span><span class="token punctuation">)</span>vgg16<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"vgg16_method2.pth"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><ul><li><p>完整模型训练步骤</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span class="token keyword">from</span> model <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment" spellcheck="true"># 准备数据集</span><span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoadertrain_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                          download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                         download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># length 长度</span>train_data_size <span class="token operator">=</span> len<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>test_data_size <span class="token operator">=</span> len<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 如果train_data_size=10, 训练数据集的长度为：10</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"训练数据集的长度为：{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>train_data_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试数据集的长度为：{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>test_data_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 利用 DataLoader 来加载数据集</span>train_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>test_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建网络模型</span>tudui <span class="token operator">=</span> Tudui<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 损失函数</span>loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 优化器</span><span class="token comment" spellcheck="true"># learning_rate = 0.01</span><span class="token comment" spellcheck="true"># 1e-2=1 x (10)^(-2) = 1 /100 = 0.01</span>learning_rate <span class="token operator">=</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">2</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>tudui<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置训练网络的一些参数</span><span class="token comment" spellcheck="true"># 记录训练的次数</span>total_train_step <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 记录测试的次数</span>total_test_step <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 训练的轮数</span>epoch <span class="token operator">=</span> <span class="token number">10</span><span class="token comment" spellcheck="true"># 添加tensorboard</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"./logs"</span><span class="token punctuation">)</span>start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>epoch<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-------第 {} 轮训练开始-------"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 训练步骤开始</span>    tudui<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> train_dataloader<span class="token punctuation">:</span>        imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data        outputs <span class="token operator">=</span> tudui<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>        loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 优化器优化模型</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        total_train_step <span class="token operator">=</span> total_train_step <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> total_train_step <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>              end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>end_time <span class="token operator">-</span> start_time<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"训练次数：{}, Loss: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>total_train_step<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"train_loss"</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> total_train_step<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 测试步骤开始</span>    tudui<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>    total_test_loss <span class="token operator">=</span> <span class="token number">0</span>    total_accuracy <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> data <span class="token keyword">in</span> test_dataloader<span class="token punctuation">:</span>            imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data            outputs <span class="token operator">=</span> tudui<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>            loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>            total_test_loss <span class="token operator">=</span> total_test_loss <span class="token operator">+</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            accuracy <span class="token operator">=</span> <span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> targets<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span>            total_accuracy <span class="token operator">=</span> total_accuracy <span class="token operator">+</span> accuracy    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"整体测试集上的Loss: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>total_test_loss<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"整体测试集上的正确率: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>total_accuracy<span class="token operator">/</span>test_data_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"test_loss"</span><span class="token punctuation">,</span> total_test_loss<span class="token punctuation">,</span> total_test_step<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"test_accuracy"</span><span class="token punctuation">,</span> total_accuracy<span class="token operator">/</span>test_data_size<span class="token punctuation">,</span> total_test_step<span class="token punctuation">)</span>    total_test_step <span class="token operator">=</span> total_test_step <span class="token operator">+</span> <span class="token number">1</span>    torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>tudui<span class="token punctuation">,</span> <span class="token string">"a_{}.pth"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"模型已保存"</span><span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><ul><li><p>GPU训练</p></li><li></li><li><pre class="line-numbers language-python"><code class="language-python">device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda"</span><span class="token punctuation">)</span>tudui <span class="token operator">=</span> tudui<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><ul><li>测试</li></ul><hr><ul><li>参数设置</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生 </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题（七）</title>
      <link href="/posts/c4b6.html/"/>
      <url>/posts/c4b6.html/</url>
      
        <content type="html"><![CDATA[<h2 id="382-链表随机结点"><a href="#382-链表随机结点" class="headerlink" title="382.链表随机结点"></a>382.链表随机结点</h2><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。</p><p>实现 <code>Solution</code> 类：</p><ul><li><code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li><li><code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li></ul><p><strong>示例：</strong></p><p><img src="https://s2.loli.net/2022/01/16/7QkdaPLfKen1Ex4.png" alt=""></p><pre class="line-numbers language-lang-python"><code class="language-lang-python">输入["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"][[[1, 2, 3]], [], [], [], [], []]输出[null, 1, 3, 2, 2, 3]解释Solution solution = new Solution([1, 2, 3]);solution.getRandom(); // 返回 1solution.getRandom(); // 返回 3solution.getRandom(); // 返回 2solution.getRandom(); // 返回 2solution.getRandom(); // 返回 3// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>链表中的节点数在范围 <code>[1, 104]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li>至多调用 <code>getRandom</code> 方法 <code>104</code> 次</li></ul><h2 id="主要使用蓄水池抽样算法"><a href="#主要使用蓄水池抽样算法" class="headerlink" title="主要使用蓄水池抽样算法"></a>主要使用蓄水池抽样算法</h2><p><a href="http://blog.bangbangbangbang.top/posts/6b1e.html/">蓄水池抽样算法</a></p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import randomclass ListNode(object):    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def __init__(self, head: ListNode):        self.head = head    def getRandom(self) -> int:        count = 0        reserve = 0        cur = self.head        while cur:            count += 1            rand = random.randint(1, count)            if rand == count:                reserve = cur.val            cur = cur.next        return reserveL = ListNode([1,2])s = Solution(L)print(s.getRandom())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 每日一题 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓄水池算法</title>
      <link href="/posts/6b1e.html/"/>
      <url>/posts/6b1e.html/</url>
      
        <content type="html"><![CDATA[<h2 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a>蓄水池抽样算法</h2><p>即：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。</p><h3 id="当-k-1-时，即此题的情况"><a href="#当-k-1-时，即此题的情况" class="headerlink" title="当 k = 1 时，即此题的情况"></a>当 k = 1 时，即此题的情况</h3><p>也就是说，我们每次只能读一个数据。</p><p>假设数据流含有N个数，我们知道如果要保证所有的数被抽到的概率相等，那么每个数抽到的概率应该为 1/N</p><p>那如何保证呢？</p><p>先说方案：</p><p>每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数。</p><p>举例说明： 1 - 10</p><ul><li>遇到1，概率为1，保留第一个数。</li><li>遇到2，概率为1/2，这个时候，1和2各1/2的概率被保留</li><li>遇到3，3被保留的概率为1/3，(之前剩下的数假设1被保留)，2/3的概率 1 被保留，(此时1被保留的总概率为 2/3 * 1/2 = 1/3)</li><li>遇到4，4被保留的概率为1/4，(之前剩下的数假设1被保留)，3/4的概率 1 被保留，(此时1被保留的总概率为 3/4 * 2/3 * 1/2 = 1/4)</li></ul><p>以此类推，每个数被保留的概率都是1/N。</p><h3 id="当-k-m-时"><a href="#当-k-m-时" class="headerlink" title="当 k = m 时"></a>当 k = m 时</h3><p>也就是说，我们每次能读m个数据。</p><p>和上面相同的道理，只不过概率在每次乘以了m而已</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> next<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> head    <span class="token keyword">def</span> <span class="token function">getRandom</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        reserve <span class="token operator">=</span> <span class="token number">0</span>        cur <span class="token operator">=</span> self<span class="token punctuation">.</span>head        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>            rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span>            <span class="token keyword">if</span> rand <span class="token operator">==</span> count<span class="token punctuation">:</span>                reserve <span class="token operator">=</span> cur<span class="token punctuation">.</span>val            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> reserveL <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>s <span class="token operator">=</span> Solution<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>getRandom<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题（六）</title>
      <link href="/posts/f8d3.html/"/>
      <url>/posts/f8d3.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><ul><li>循环生成数组</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># enumerate枚举，生成索引和对应数字</span><span class="token comment" spellcheck="true"># 第一个i是对数组的操作，i,x in...是生成枚举数组</span>a <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">==</span> another<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。示例 1：输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：输入：nums = [3,3], target = 6输出：[0,1]"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            another <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'预计另一个数是'</span><span class="token punctuation">,</span> another<span class="token punctuation">,</span> <span class="token string">'第'</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">'轮'</span><span class="token punctuation">)</span>            a <span class="token operator">=</span> <span class="token punctuation">[</span>j <span class="token keyword">for</span> j<span class="token punctuation">,</span> x <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">==</span> another<span class="token punctuation">]</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    S <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span>    target <span class="token operator">=</span> <span class="token number">9</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>twoSum<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 每日一题 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题（五）</title>
      <link href="/posts/b0ca.html/"/>
      <url>/posts/b0ca.html/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一题1716-计算力扣银行的钱"><a href="#每日一题1716-计算力扣银行的钱" class="headerlink" title="每日一题1716. 计算力扣银行的钱"></a>每日一题1716. 计算力扣银行的钱</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""1716. 计算力扣银行的钱Hercy 想要为购买第一辆车存钱。他每天都往力扣银行里存钱。最开始，他在周一的时候存入1块钱。从周二到周日，他每天都比前一天多存入1块钱。在接下来每一个周一，他都会比前一个周一多存入1块钱。给你n，请你返回在第n天结束的时候他在力扣银行总共存了多少块钱。示例 1：输入：n = 4输出：10解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。示例 2：输入：n = 10输出：37解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。示例 3：输入：n = 20输出：96解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">totalnum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> f<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>        totalnum <span class="token operator">=</span> <span class="token punctuation">(</span>f <span class="token operator">+</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>l <span class="token operator">-</span> f <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        totalnum <span class="token operator">=</span> int<span class="token punctuation">(</span>totalnum<span class="token punctuation">)</span>        <span class="token keyword">return</span> totalnum    <span class="token keyword">def</span> <span class="token function">totalMoney</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type n: int        :rtype: int        """</span>        total <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">:</span>            total <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">/</span> <span class="token number">2</span>            total <span class="token operator">=</span> int<span class="token punctuation">(</span>total<span class="token punctuation">)</span>            <span class="token keyword">return</span> total        <span class="token keyword">else</span><span class="token punctuation">:</span>            week <span class="token operator">=</span> int<span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">7</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            week_array <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>week<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>week<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> week_array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    total <span class="token operator">=</span> total <span class="token operator">+</span> self<span class="token punctuation">.</span>totalnum<span class="token punctuation">(</span>week_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> week_array<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    total <span class="token operator">=</span> total <span class="token operator">+</span> self<span class="token punctuation">.</span>totalnum<span class="token punctuation">(</span>week_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> week_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span>            <span class="token keyword">return</span> total<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    S <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    total <span class="token operator">=</span> S<span class="token punctuation">.</span>totalMoney<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 每日一题 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末代码</title>
      <link href="/posts/c157.html/"/>
      <url>/posts/c157.html/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt<span class="token keyword">def</span> <span class="token function">highPassFiltering</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 传递参数为傅里叶变换后的频谱图和滤波尺寸</span>    h<span class="token punctuation">,</span> w <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取图像属性</span>    h1<span class="token punctuation">,</span> w1 <span class="token operator">=</span> int<span class="token punctuation">(</span>h <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>w <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 找到傅里叶频谱图的中心点</span>    img<span class="token punctuation">[</span>h1 <span class="token operator">-</span> int<span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>h1 <span class="token operator">+</span> int<span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    w1 <span class="token operator">-</span> int<span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>w1 <span class="token operator">+</span> int<span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 中心点加减滤波尺寸的一半，刚好形成一个定义尺寸的滤波大小，然后设置为0</span>    <span class="token keyword">return</span> img<span class="token comment" spellcheck="true"># 初始图像</span>img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'photo.JPG'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 直方图规定化基础图像</span>img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cankao.png'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># img1初始RGB图像转HSV图像</span>img_hsv1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2HSV<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># img_hsv1（HSV图像）再转回初始RGB图像</span>hsv_img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_HSV2BGR<span class="token punctuation">)</span>img_hsv2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2HSV<span class="token punctuation">)</span>color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> col <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># histr = cv2.calcHist([img_hsv1], [i], None, [256], [0, 256])</span>    <span class="token comment" spellcheck="true"># ravel变为一维数组</span>    <span class="token comment" spellcheck="true"># img_hsv1[:, :, i].ravel()待统计数组，256表示表示统计范围的最小值和最大值，</span>    hist1<span class="token punctuation">,</span> bins <span class="token operator">=</span> np<span class="token punctuation">.</span>histogram<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    hist2<span class="token punctuation">,</span> bins <span class="token operator">=</span> np<span class="token punctuation">.</span>histogram<span class="token punctuation">(</span>img_hsv2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    cdf1 <span class="token operator">=</span> hist1<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 灰度值0-255的累计值数组</span>    cdf2 <span class="token operator">=</span> hist2<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span>    cdf1_hist <span class="token operator">=</span> hist1<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> cdf1<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 灰度值的累计值的比率</span>    cdf2_hist <span class="token operator">=</span> hist2<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> cdf2<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span>    diff_cdf <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># diff_cdf 里是每2个灰度值比率间的差值</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            diff_cdf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> abs<span class="token punctuation">(</span>cdf1_hist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> cdf2_hist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>    lut <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 映射表</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min <span class="token operator">=</span> diff_cdf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 直方图规定化的映射原理</span>            <span class="token keyword">if</span> min <span class="token operator">></span> diff_cdf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                min <span class="token operator">=</span> diff_cdf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span>                index <span class="token operator">=</span> k        lut<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>j<span class="token punctuation">,</span> index<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print(lut)</span>    h <span class="token operator">=</span> int<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    w <span class="token operator">=</span> int<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 对原图像进行灰度值的映射</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># print(img_hsv1[j, k, i])</span>            <span class="token comment" spellcheck="true"># print(lut[img_hsv1[j, k, i]][1])</span>            img_hsv1<span class="token punctuation">[</span>j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> lut<span class="token punctuation">[</span>img_hsv1<span class="token punctuation">[</span>j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>hsv_img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_HSV2BGR<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># hsv转bgr</span><span class="token comment" spellcheck="true"># 转换为灰度图</span>image_gray <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Numpy库的傅里叶变换</span><span class="token comment" spellcheck="true"># 傅里叶变换</span>f <span class="token operator">=</span> np<span class="token punctuation">.</span>fft<span class="token punctuation">.</span>fft2<span class="token punctuation">(</span>image_gray<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将左上角低频部分移动到中间</span>fshift <span class="token operator">=</span> np<span class="token punctuation">.</span>fft<span class="token punctuation">.</span>fftshift<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用高通滤波函数</span>img12 <span class="token operator">=</span> highPassFiltering<span class="token punctuation">(</span>fshift<span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 复数化整，方便观察频谱图</span>res <span class="token operator">=</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>img12<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 傅里叶逆变换</span>ishift <span class="token operator">=</span> np<span class="token punctuation">.</span>fft<span class="token punctuation">.</span>ifftshift<span class="token punctuation">(</span>img12<span class="token punctuation">)</span>iimg <span class="token operator">=</span> np<span class="token punctuation">.</span>fft<span class="token punctuation">.</span>ifft2<span class="token punctuation">(</span>ishift<span class="token punctuation">)</span>iimg <span class="token operator">=</span> np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>iimg<span class="token punctuation">)</span>output1 <span class="token operator">=</span> iimg<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># python类型转换</span>image11 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>output1<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_GRAY2BGR<span class="token punctuation">)</span>iimage_color <span class="token operator">=</span> cv2<span class="token punctuation">.</span>applyColorMap<span class="token punctuation">(</span>output1<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLORMAP_JET<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'histogram_base_RGB_image'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'histogram_base_RGB_image'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image_to_HSV'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image_to_HSV'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'origin_HSV_to_rgb'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'origin_HSV_to_rgb'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image_to_HSV_histogram_to_RGB'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image_to_HSV_histogram_to_RGB'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'HSV_histogram_to_gray'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'HSV_histogram_to_gray'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'gray_HSV_histogram_to_highPassFiltering'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'gray_HSV_histogram_to_highPassFiltering'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">'gray_HSV_histogram_to_highPassFiltering_to_RGB'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>resizeWindow<span class="token punctuation">(</span><span class="token string">'gray_HSV_histogram_to_highPassFiltering_to_RGB'</span><span class="token punctuation">,</span> <span class="token number">1270</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image'</span><span class="token punctuation">,</span> img1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'histogram_base_RGB_image'</span><span class="token punctuation">,</span> img2<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image_to_HSV'</span><span class="token punctuation">,</span> img_hsv1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'origin_HSV_to_rgb'</span><span class="token punctuation">,</span> hsv_img2<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'origin_RGB_image_to_HSV_histogram_to_RGB'</span><span class="token punctuation">,</span> hsv_img1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'HSV_histogram_to_gray'</span><span class="token punctuation">,</span> image_gray<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'gray_HSV_histogram_to_highPassFiltering'</span><span class="token punctuation">,</span> iimg<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'gray_HSV_histogram_to_highPassFiltering_to_RGB'</span><span class="token punctuation">,</span> iimage_color<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># cv2.waitKey(0)</span><span class="token comment" spellcheck="true"># cv2.destroyAllWindows()</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 显示中文</span><span class="token comment" spellcheck="true"># 展示结果</span>b1<span class="token punctuation">,</span> g1<span class="token punctuation">,</span> r1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img1<span class="token punctuation">)</span>img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">[</span>r1<span class="token punctuation">,</span> g1<span class="token punctuation">,</span> b1<span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">241</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img1<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>b2<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> r2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img2<span class="token punctuation">)</span>img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">[</span>r2<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> b2<span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">242</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img2<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'直方图规定化原图像'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>b3<span class="token punctuation">,</span> g3<span class="token punctuation">,</span> r3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">)</span>img_hsv1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">[</span>r3<span class="token punctuation">,</span> g3<span class="token punctuation">,</span> b3<span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">243</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_hsv1<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像转HSV'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>b4<span class="token punctuation">,</span> g4<span class="token punctuation">,</span> r4 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>hsv_img2<span class="token punctuation">)</span>hsv_img2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">[</span>r4<span class="token punctuation">,</span> g4<span class="token punctuation">,</span> b4<span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">244</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>hsv_img2<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像转HSV再转RGB'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>b5<span class="token punctuation">,</span> g5<span class="token punctuation">,</span> r5 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>hsv_img1<span class="token punctuation">)</span>hsv_img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">[</span>r5<span class="token punctuation">,</span> g5<span class="token punctuation">,</span> b5<span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">245</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>hsv_img1<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像直方图规定化'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># g6, r6 = cv2.split(image_gray)</span><span class="token comment" spellcheck="true"># image_gray = cv2.merge([r6, g6])</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">246</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>image_gray<span class="token punctuation">,</span> <span class="token string">'gray'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像直方图规定化转灰度图像'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># g7, r7 = cv2.split(iimg)</span><span class="token comment" spellcheck="true"># iimg = cv2.merge([r7, g7])</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">247</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>iimg<span class="token punctuation">,</span> <span class="token string">'gray'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像直方图规定化转灰度图像做高通滤波'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>b8<span class="token punctuation">,</span> g8<span class="token punctuation">,</span> r8 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>image11<span class="token punctuation">)</span>image11 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">[</span>r8<span class="token punctuation">,</span> g8<span class="token punctuation">,</span> b8<span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">248</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>iimage_color<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'原图像直方图规定化转灰度图像高通滤波转RGB'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>axis<span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从离线笔记迁移学习到签名鉴定</title>
      <link href="/posts/3014.html/"/>
      <url>/posts/3014.html/</url>
      
        <content type="html"><![CDATA[<h3 id="Learning-Representations-from-Persian-Handwriting-for-Off-line-Signature-Verification-a-Deep-Transfer-Learning-Approach（利用深度迁移学习，从波斯笔迹中学习用于离线签名验证的表示）"><a href="#Learning-Representations-from-Persian-Handwriting-for-Off-line-Signature-Verification-a-Deep-Transfer-Learning-Approach（利用深度迁移学习，从波斯笔迹中学习用于离线签名验证的表示）" class="headerlink" title="Learning Representations from Persian Handwriting for Off-line Signature Verification,a Deep Transfer Learning Approach（利用深度迁移学习，从波斯笔迹中学习用于离线签名验证的表示）"></a>Learning Representations from Persian Handwriting for Off-line Signature Verification,a Deep Transfer Learning Approach（利用深度迁移学习，从波斯笔迹中学习用于离线签名验证的表示）</h3><h3 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h3><ul><li>离线签名验证（OSV）是一项具有挑战性的模式识别任务，特别是当它有望很好地推广到培训期间无法使用的熟练伪造品上时。它的挑战还包括小的训练样本和大的变化。<strong>考虑到这些局限性，我们提出了一种从波斯语手写域到多语言OSV域的迁移学习方法。</strong>基于词分类和作者识别两个不同的任务，我们分别在源域上训练<strong>两个剩余CNN</strong>。<ul><li><strong>深度残差网络</strong>（Deep residual network, Res-Net）：深度残差网络的设计就是为了克服这种由于网络深度加深而产生的学习效率变低，准确率无法有效提升的问题（也称为网络退化）。甚至在一些场景下，网络层数的增加反而会降低正确率。这种本质问题是由于出现了信息丢失而产生的过拟合问（over-fitting，所建的机器学习模型或者是深度学习模型在训练样本中表现的过于优越，导致在验证数据集及测试数据集中表现不佳，即为了得到一致假设而使假设变得过度复杂）。<strong>解决思路是尝试着使他们引入这些刺激的差异性和解决泛化能力为主。</strong></li></ul></li><li>由于识别一个人的签名类似于识别一个人的笔迹，因此在特征学习阶段使用笔迹似乎非常方便。在更加多样化和丰富的手写数据集上学习的表示可以弥补原始任务（即OSV）中训练数据的不足，而不会牺牲通用性。我们提出的OSV系统包括两个步骤：<strong>表示学习</strong>和<strong>验证输入签名</strong>。第一步，将特征图像输入训练后的残差神经网络。然后使用输出表示训练支持向量机进行验证。我们在三个不同的签名数据集上测试OSV系统，包括MCYT（一个西班牙签名数据集）、UTSig（一个波斯签名数据集）和GPDS合成（一个人工数据集）。在UT上-SIG，我们实现了9.80%的等错误率（EER），与文献中最好的EER（17.45%）相比有了实质性的改善。我们提出的方法比最先进的方法高出6%在GPDS合成上，达到6.81%。在MCYT，EER为3.98%获得的结果与之前报告的最佳结果相当。<ul><li>表示学习，又称学习表示。在深度学习领域内，表示是指通过模型的参数，采用何种形式、何种方式来表示模型的输入观测样本X。表示学习指学习对观测样本X有效的表示。表示学习有很多种形式，比如CNN参数的有监督训练是一种有监督的表示学习形式，对自动编码器和限制玻尔兹曼机参数的无监督预训练是一种无监督的表示学习形式，对DBN参数-先进行无监督预训练，再进行有监督fine-tuning-是一种半监督的共享表示学习形式。</li></ul></li></ul><h3 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h3><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h3><p>A.使用迁移学习生成特征</p><ul><li>源域：波斯语手写笔迹数据集，有115个单词，每个单词有标签，有500多个不同的书写人</li><li>目标域：手写签名。</li><li>特征生成器的训练过程</li></ul><p>B.签名验证</p><ul><li>为每个签名人训练分类器。分类器依据神经网络输入数据中提取的特征进行训练。利用支持向量机作为分类器</li></ul><p>C.论文的方法</p><ul><li>OSV两个步骤：特征生成和最终验证。<ul><li>特征生成：CNN</li><li>验证：用SVM验证与真实样本的距离</li></ul></li></ul><p>总结：</p><ul><li>数据集的预处理</li><li>将数据集划分为训练集和测试集</li><li>特征生成网络的训练：<ul><li>在源任务上训练特征生成器网络</li><li>测试经过训练的网络以分析其性能</li><li>通过微调或不微调将网络权重传输到目标任务</li></ul></li><li>分类器的训练：<ul><li>每个用户类生成一个SVM</li><li>为每个签名类生成一组随机伪造</li><li>根据特定用户的真实签名和其他用户的随机伪造签名训练SVM</li></ul></li></ul><p>利用CNN训练出特征。为每个签名的书写人训练SVM分类器。 最后计算想要的数据是否分类正确</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经处理学报</title>
      <link href="/posts/e3f3.html/"/>
      <url>/posts/e3f3.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Neural-Processing-Letters（神经处理学报）"><a href="#Neural-Processing-Letters（神经处理学报）" class="headerlink" title="Neural Processing Letters（神经处理学报）"></a>Neural Processing Letters（神经处理学报）</h2><ul><li><strong>transfer learning（迁移学习）</strong>：把已学训练好的模型参数迁移到新的模型来帮助新模型训练，要求两个模型要有相似的地方。比如会自行车可以电动车，但汽车不行，跨度不能太大。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/img/v2-86da372638c7aa7e7ad27efa11583bc0_1440w.jpg"></p><ul><li><p>文章要求：<strong>所有被接受的文章都有望解决或部分解决迁移学习中的一个开放问题，或者激发新的想法，以帮助进一步推进迁移学习。</strong></p></li><li><p>迁移深度学习算法和模型</p></li><li><p>大规模迁移学习算法设计</p></li><li><p>处理缺失值和噪声样本的迁移学习方法</p></li><li><p>迁移学习新理论</p></li><li><p><strong>迁移学习新策略迁移学习及其在医学信息学、计算机视觉、自然语言处理等方面的应用</strong></p></li><li><p>与多视图学习、多任务学习、集成学习的关系</p></li><li><p>新的高质量迁移学习数据集</p></li><li><p>大数据和 covid-19 数据建模的迁移学习</p></li></ul><ol start="3"><li>交稿时间</li></ol><ul><li>投稿截止日期：<strong>2021年12月31日</strong></li><li>第一次通知：2022年3月10日</li><li>第二次通知：2022年6月30日</li><li>最终决定：2022年7月30日</li></ul><ol start="4"><li>投稿要求</li></ol><ul><li>至少有30%的新内容</li></ul><ol start="5"><li>迁移学习</li></ol><ul><li>迁移学习(Transfer learning) 顾名思义就是把已学训练好的模型参数迁移到新的模型来帮助新模型训练。考虑到大部分数据或任务是存在相关性的，所以通过迁移学习我们可以将已经学到的模型参数（也可理解为模型学到的知识）通过某种方式来分享给新模型从而加快并优化模型的学习效率不用像大多数网络那样从零学习。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SCI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIFT代码（一）</title>
      <link href="/posts/b1d3.html/"/>
      <url>/posts/b1d3.html/</url>
      
        <content type="html"><![CDATA[<h2 id="SIFT代码（一）"><a href="#SIFT代码（一）" class="headerlink" title="SIFT代码（一）"></a>SIFT代码（一）</h2><h4 id="不调用库，手写rbg转灰度，利用大津法灰度转二值图像"><a href="#不调用库，手写rbg转灰度，利用大津法灰度转二值图像" class="headerlink" title="不调用库，手写rbg转灰度，利用大津法灰度转二值图像"></a>不调用库，手写rbg转灰度，利用大津法灰度转二值图像</h4><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/%E7%AC%94%E8%BF%B9%E5%9B%BE%E5%83%8F.png" alt="原始图像"></p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210831182941.png" alt="灰度图像"></p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210831183030.png" alt="大津法二值图像"></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">class</span> <span class="token class-name">SIFT</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param img:  图像路径        """</span>        self<span class="token punctuation">.</span>img <span class="token operator">=</span> img        self<span class="token punctuation">.</span>rgbToray<span class="token punctuation">(</span>img<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># self.openConvertImg(img)</span>    <span class="token comment" spellcheck="true"># 将彩色图片转化为灰度图片,调用库</span>    <span class="token keyword">def</span> <span class="token function">openConvertImg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        L <span class="token operator">=</span> img<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span>        L<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> L    <span class="token comment" spellcheck="true"># 将RGB转化为灰度图片，手写</span>    <span class="token keyword">def</span> <span class="token function">rgbToray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param img:        :return: gray_img，灰度图像        astype是numpy中类型转换的方式，括号中是要变为的格式        读入图片的格式是uint8，进行计算处理时转化为float32，算完了再转回来        """</span>        img_float <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>        b <span class="token operator">=</span> img_float<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        g <span class="token operator">=</span> img_float<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> img_float<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        gray_img <span class="token operator">=</span> <span class="token number">0.2126</span> <span class="token operator">*</span> r <span class="token operator">+</span> <span class="token number">0.7152</span> <span class="token operator">*</span> g <span class="token operator">+</span> <span class="token number">0.0722</span> <span class="token operator">*</span> b        self<span class="token punctuation">.</span>otus<span class="token punctuation">(</span>gray_img<span class="token punctuation">)</span>        <span class="token keyword">return</span> gray_img    <span class="token comment" spellcheck="true"># 显示图片</span>    <span class="token keyword">def</span> <span class="token function">showImg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 大津法二值化图像</span>    <span class="token keyword">def</span> <span class="token function">otus</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> gray_img<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        h: 图片高度        w：图片宽度        threshold_t： 阈值t        max_g：最大类间方差        n0: 小于阈值t的像素，前景        n1：大于阈值t的像素，背景        n0 + n1 = h * w ：总像素个数        w0：前景像素数量占总像素数量的比例，w0 = n0 / (h * w)        w1：背景像素数量占总像素数量的比例，w1 = n1 / (h * w)        w0 + w1 == 1        u0：前景平均灰度，u0 = n0灰度累加和 / n0        u1：背景平均灰度，u1 = n1灰度累加和 / n1        u：平均灰度， u = (n0灰度累加和 + n1灰度累加和) / (h * w)        u = w0 * u0 + w1 * u1        g：类间方差（那个灰度的g最大，哪个灰度就是需要的阈值t）        g = w0 * (u0 - u)^2 + w1 * (u1 - u)^2        根据上面的关系，可以推出：（这个一步一步推导就可以得到）        g = w0 * w1 * (u0 - u1) ^ 2        """</span>        h <span class="token operator">=</span> gray_img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        w <span class="token operator">=</span> gray_img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        threshold_t <span class="token operator">=</span> <span class="token number">0</span>        max_g <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 遍历每一个灰度层</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            n0 <span class="token operator">=</span> gray_img<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>gray_img <span class="token operator">&lt;</span> t<span class="token punctuation">)</span><span class="token punctuation">]</span>            n1 <span class="token operator">=</span> gray_img<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>gray_img <span class="token operator">>=</span> t<span class="token punctuation">)</span><span class="token punctuation">]</span>            w0 <span class="token operator">=</span> len<span class="token punctuation">(</span>n0<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>h <span class="token operator">*</span> w<span class="token punctuation">)</span>            w1 <span class="token operator">=</span> len<span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>h <span class="token operator">*</span> w<span class="token punctuation">)</span>            u0 <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>n0<span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>n0<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>            u1 <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>            g <span class="token operator">=</span> w0 <span class="token operator">*</span> w1 <span class="token operator">*</span> <span class="token punctuation">(</span>u0 <span class="token operator">-</span> u1<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>            <span class="token keyword">if</span> g <span class="token operator">></span> max_g<span class="token punctuation">:</span>                max_g <span class="token operator">=</span> g                threshold_t <span class="token operator">=</span> t        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类间方差最大阈值：'</span><span class="token punctuation">,</span> threshold_t<span class="token punctuation">)</span>        gray_img<span class="token punctuation">[</span>gray_img <span class="token operator">&lt;</span> threshold_t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        gray_img<span class="token punctuation">[</span>gray_img <span class="token operator">></span> threshold_t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span>        <span class="token comment" spellcheck="true"># 显示图像</span>        self<span class="token punctuation">.</span>showImg<span class="token punctuation">(</span>gray_img<span class="token punctuation">)</span>        <span class="token keyword">return</span> gray_imgimgUrl <span class="token operator">=</span> <span class="token string">'笔迹图像.png'</span>SIFT<span class="token punctuation">(</span>imgUrl<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 大津法 </tag>
            
            <tag> SIFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14年SIFT总结+神经网络</title>
      <link href="/posts/1f51.html/"/>
      <url>/posts/1f51.html/</url>
      
        <content type="html"><![CDATA[<h2 id="14年SIFT论文总结"><a href="#14年SIFT论文总结" class="headerlink" title="14年SIFT论文总结"></a>14年SIFT论文总结</h2><h4 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h4><ul><li>利用SIFT尺度不变特征变换的方法来提取关键信息的一种方法</li></ul><h5 id="1-1分词：将手写图像分割为每个独立的单词"><a href="#1-1分词：将手写图像分割为每个独立的单词" class="headerlink" title="1.1分词：将手写图像分割为每个独立的单词"></a>1.1分词：将手写图像分割为每个独立的单词</h5><ul><li><p>先使用大津法（最大类间方差）将笔迹的灰度图像转化为二值图像（a变为b）。</p><ul><li>假设以阈值T为图像背景与目标的分割界限，目标像素占图像总像素的比例为$w_0$，平均灰度为$u_0$；背景像素占比为$w_1$，平均灰度为$u_1$，图像总平均灰度为u，背景和目标的方差为g。则：</li></ul><p>$$<br>\begin{array}{c}<br>u=w_{0} \times u_{0}+w_{1} \times u_{1} \<br>g=w_{0} \times\left(u_{0}-u\right)^{2}+w_{1} \times\left(u_{1}-u\right)^{2} \<br>g=w_{0} \times w_{1} \times\left(u_{0}-u_{1}\right)^{2} 或\<br>g=\frac{w_{0}}{1-w_{0}} \times\left(u_{0}-u\right)^{2}<br>\end{array}<br>$$</p><ul><li>当方差g最大时，灰度T就是最佳阈值。</li><li>大津法，按照图像的灰度特性，将图像分成背景和目标两个部分。当取到最佳阈值时，两者之间的差别是最大的，背景和目标之间的类间方差如果越大，则说明构成图像的两个部分之间差别越大，出错概率就会越小（<strong>使方差最大的那个阈值就是我们想要的</strong>）。</li></ul></li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829143931.png"></p><ul><li>获取图像b中的所有连接组件的高度，计算他们的平均高度$h_a$。</li><li>使用高斯拉普拉斯滤波器对图像b进行滤波得到图像c。因为同一个词之间内部的距离会小于不同词之间的距离，所以选取适当的方差就可以分离单词。同一个单词之间的连接组件艰巨与单词高度成正比，所以使用图像b中所有连接组件的平均高度$h_a$来确定过滤器的方差$σ = 2.5*h_a$（方差越大，图片越模糊）。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829145122.png"></p><ul><li>再利用大津法对图像c进行二值化得到图像d。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829145512.png"></p><ul><li>将图像b中的单词向图像d的区域上分配，把重叠的区域合并，再拆分重叠边界，得到最终分割好的字词区间WRs，图像f，g。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829150050.png"></p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829150312.png"></p><h5 id="1-2特征提取"><a href="#1-2特征提取" class="headerlink" title="1.2特征提取"></a>1.2特征提取</h5><ul><li><p>SIFT特征提取：主要有四个步骤，尺度空间构造、关键点定位、方向分配和关键点特征提取。</p><ul><li><p>在第一阶段制度空间构造，原始图像被分解成<strong>高斯金字塔</strong>，金字塔的每一层被叫做octave，octave通过使用具有不同方差的<strong>DoG滤波器</strong>（差分高斯函数，利用两个相邻的高斯函数平滑参数，如0.3和0.4。两个图像相减，得到的就是差分高斯函数的图像）在相应的金字塔层卷积初始图像而进一步分解成若干个子层。</p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210830144400.png"></p><ul><li>DoG（Different of Guassian）差分高斯函数：</li><li>左边的四张图（包括原始图）是不同参数下高斯滤波结果的图像。</li><li>对高斯滤波后的图片（相邻状态下）依次进行两两相减可得到右边的三个高斯函数的差分图（简称DOG）。然后根据上面的模型，依次求中间图片每个像素与该像素同尺度的8个相邻点以及上下相邻尺度对应的9*2共26个点的极值。一个点如果在DOG空间本层以及上下两层的26个领域中是最大值和最小值时，就认为该点是图像在该尺度下的一个特征点。</li><li>图像金字塔：以多分辨率来处理图像的一种方法，金字塔底部是待处理图像的高分辨率表示，顶部是低分辨率表示，当金字塔向上层移动时，尺寸和分辨率都会降低。为了图像在任何尺度下都能有对应的特征点</li><li>高斯金字塔就是在提取图像时使用高斯滤波。</li></ul></li><li><p>第二阶段检测出稳定的关键点：本质上去除DoG局部曲率非常不对称的像素，尺度就是平滑参数相差的值</p><ul><li><p>网上的一种</p></li><li><p>通过拟和三维二次函数以精确确定关键点的位置和尺度 (达到亚像素精度），同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应), 以增强匹配稳定性、提高抗噪声能力, 在这里使用近似Harris Corner检测器。</p></li><li><p>他的空间尺度函数泰勒展开，对其求导并令为零</p></li><li><p>$$<br>D(\mathrm{x})=D+\frac{\partial D^{T}}{\partial \mathrm{x}}^{T} \mathrm{x}+\frac{1}{2} \mathrm{x}^{\mathrm{T}} \frac{\partial^{2} D}{\partial \mathrm{x}^{2}} \mathrm{x}<br>$$</p></li><li><p>$$<br>\hat{\mathrm{x}}=-\frac{\partial^{2} D^{-1}}{\partial \mathrm{x}^{2}} \quad \frac{\partial D}{\partial \mathrm{x}} \text {. }<br>$$</p></li><li><p>在已经检测到的特征点中，要去掉对比度低的特征点和不稳定的边缘相应点。去除低对比度的点，将公式3带入公式2，即在DoG的极值点处取值得到，若值大于0.03该特征点就留下来：</p></li><li><p>$$<br>D(\hat{\mathbf{x}})=D+\frac{1}{2} \frac{\partial D^{T}}{\partial \mathbf{x}} \hat{\mathbf{x}}<br>$$</p></li><li><p>边缘不好点的去除：一个定义不好的高斯查分算子的极值在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向有较小的主曲率。主曲率通过一个黑塞矩阵求解（是一个多元函数的二阶偏导书构成的方阵，描述了函数的局部曲率）</p></li></ul><p>$$<br>H=\left[\begin{array}{cc}<br>D_{x x} &amp; D_{x y} \<br>D_{x y} &amp; D_{y y}<br>\end{array}\right]<br>$$</p><ul><li>主曲率和H矩阵的特征值成正比，最终比较曲率是否在矩阵特征半径某个范围内即可</li></ul></li><li><p>第三阶段：计算关键点的方向（利用关键点邻域像素的梯度方向分布特征为每个关键点制定方向参数，使其具备旋转不变性质），下面为（x，y）处梯度的模长和方向公式</p></li></ul><p>$$<br>\begin{array}{l}<br>m(x, y)=\sqrt{(L(x+1, y)-L(x-1, y))^{2}+(L(x, y+1)-L(x, y-1))^{2}} \<br>\theta(x, y)=a \tan 2((L(x, y+1)-L(x, y-1)) /(L(x+1, y)-L(x-1, y)))<br>\end{array}<br>$$</p><ul><li><p>第四阶段：为每个关键点生成一个描述子</p><ul><li>先将坐标轴旋转到关键点的方向，以确保旋转不变，以关键点为中心取8x8的窗口</li><li>然后在每4x4的小块上计算8个方向的梯度直方图，即可形成一个种子点，共生成4个种子点，每个种子点有8个方向向量信息，对于特征匹配时也会有很好的容错性。</li><li>这样就是每个特征点生成的描述子有4x8=32维的描述子</li><li>如果是16x16，就可以生成4x4x8=128维的描述子</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210830152732.png"></p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210830152749.png"></p></li></ul></li><li><p>SDS为特征点描述子</p></li><li><p>SOH为尺度和方向直方图</p></li></ul><h5 id="1-3码本生成"><a href="#1-3码本生成" class="headerlink" title="1.3码本生成"></a>1.3码本生成</h5><ul><li><p>给定一副手写文档图像，先通过分词得到多个单词区域WRs。对于每个WR，使用SIFT检测关键点，并提取关键点的描述子、尺度和方向。为了使特征的数量有限，将训练样本中提取的关键点SDs聚类成N个类，并用其中心表示每个类别。形成一个大小为N的码本。</p></li><li><p>利用SOM聚类算法生成SD码本，依据经验，选择大小为N=300。</p><ul><li><p>SOM（Self Organizing Maps）自组织映射神经网络，对数据无监督学习聚类。</p></li><li><p>只有输入层和隐藏层的神经网络，隐藏层中的一个节点代表一个需要聚成的类。</p></li><li><p>训练时采用竞争学习的方式，每个输入的样例在隐藏层中找到一个和他最匹配的节点，成为他的激活节点。然后使用随机梯度下降法更新激活节点的参数。同时，和激活点邻近的点也会根据他们的距离激活节点远近适当的更新参数</p></li><li><p>SOM网络包含输入层和输出层。输入层对应一个高维的输入向量，输出层由一系列组织在2维网格上的有序节点构成，输入节点与输出节点通过权重向量连接。学习过程中，找到与之距离最短的输出层单元，即获胜单元，对其更新。同时，将邻近区域的权值更新，使输出节点保持输入向量的拓扑特征。</p><ul><li><p>BP神经网络：输入，隐层，输出层。又称反向传播神经网络， 通过样本数据的训练，不断修正网络权值和阈值使误差函数沿负梯度方向下降，逼近期望输出。</p><ul><li>隐层公式：$l=\sqrt{n+m}+a$，n为输入神经元个数，m为输出神经元个数，a为1～10之间常数。</li><li>偏置是为了描述训练数据中没有的特征。</li><li>BP层与层之间的关系是通过激活函数来描述的。激活函数必须满足处处可导。</li><li>BP训练开始前，对网络的权重和偏置值进行初始化，权重取-1～1之间一个随机数，偏置取0～1之间一个随机数。每一次迭代都使用训练集的所有样本。设定误差函数</li><li>利用网络期望输出和实际输出，计算误差函数对输出层各个神经元的偏导数。</li><li>利用输出层各个神经元的偏导数和隐含层神经元的输出来修正权值</li><li>利用输入层各个神经元的偏导数和隐含层神经元的输出来修正权值</li><li>网络初始化：输入层节点个数问$n$，隐含层节点为$l$，输出层节点个数为$m$。输入层到隐含层的权重为$w_{ij}$，偏置为$a_j$，隐含层到输出层权重为$w_{jk}$，偏置为$b_k$。学习速率为$\eta$，激励函数为$g(x),x$为激励函数。i从1～n，j从1～l，k从1～m。</li><li>三层bp神经网络隐含层输出$H_j$为：</li></ul><p>$$<br>H_{j}=\left(\sum_{i=1}^{n} \omega_{i j} x_{i}+a_{j}\right)<br>$$</p><ul><li>输出层的输出$O_k$：</li></ul><p>$$<br>O_{k}=\sum_{j=1}^{l} H_{j} \omega_{j k}+b_{k}<br>$$</p><ul><li>误差的计算：</li></ul><p>$$<br>E=\frac{1}{2} \sum_{k=1}^{m}\left(Y_{k}-O_{k}\right)^{2}<br>$$</p><ul><li>权值的更新：</li></ul><p>$$<br>\left{\begin{array}{c}<br>\omega_{i j}=\omega_{i j}+\eta H_{j}\left(1-H_{j}\right) x_{i} \sum_{k=1}^{m} \omega_{j k} e_{k} \<br>\omega_{j k}=\omega_{j k}+\eta H_{j} e_{k}<br>\end{array}\right.<br>$$</p><ul><li>误差反向传播，目标是使误差函数达到最小值，使用梯度下降算法，公式就能推出来上边这个</li><li>偏置的更新：公式推倒…….</li></ul></li><li><p>梯度下降算法：找到最快下山的路。$j$是关于$\Theta$的函数，当前处于$\Theta^0$点，要从这个点走到$j$的最小值，相当于走到山底。首先需要确定前进的方向，就是梯度反方向，然后确定每一步的步长或学习率$\alpha$。以此迭代，直到找到最小的值。</p></li></ul><p>$$<br>\Theta^{1}=\Theta^{0}-\alpha \nabla J(\Theta)<br>$$</p><ul><li><p>SOM步骤：随机初始化权重，寻找最近的神经元，更新邻近神经元的权重，梯度下降学习。</p><ul><li>判别函数定义为输入向量i和神经元j的权值之间的欧几里得距离</li><li>如果$S_{ij}$是神经元i和j之间的横向距离，则T为拓扑邻域：</li></ul><p>$$<br>T_{j, I(x)}=\exp \left(-\frac{S_{j, I(x)}^{2}}{2 \sigma^{2}}\right)<br>$$</p><ul><li>$I(x)$是获胜神经元索引</li><li>更新权重的方式</li></ul><p>$$<br>\Delta w_{j i}=\eta(t) \cdot T_{j, I(x)}(t) \cdot\left(x_{i}-w_{j i}\right)<br>$$</p><ul><li>初始化权重$w_j$，从输入空间抽取一个训练输入样本x，安全中匹配最近的神经元$I(x)$，更新拓扑邻域内权重$\Delta w_{j i}$</li><li>最终看某个范围内的值就是一类。拓扑半径的距离N=self.GetN(t).</li></ul></li></ul></li></ul></li></ul><h5 id="1-4特征匹配和融合"><a href="#1-4特征匹配和融合" class="headerlink" title="1.4特征匹配和融合"></a>1.4特征匹配和融合</h5><ul><li>$I_1$和$I_2$表示两个笔迹图像，$u=(u_1,u_2,\ldots,u_N)$和$v=(v_1,v_2,\ldots,v_N)$分别代表他们的SDSs，$x=\left(x_{1}, x_{2}, \ldots, x_{M}\right)$ 和$y=\left(y_{1}, y_{2}, \ldots, y_{M}\right)$分别代表他们的SOHs。</li><li>采用<strong>曼哈顿距离</strong>来测量两个样本的SDSs的u和v：</li></ul><p>$$<br>D_{1}(u, v)=\sum_{i=1}^{N}\left|u_{i}-v_{i}\right|<br>$$</p><ul><li>SOHs中索引大的组件的值的差异比索引小的组件的值小的多。如果我们仍然使用曼哈顿距离来衡量SOH之间的差异，那么大索引的差异将小于小索引的组件。所以采用卡方距离赋予小值分量更多的权重来提高他们的重要性：</li></ul><p>$$<br>D_{2}(x, y)=\sum_{j=1}^{M} \frac{\left(x_{j}-y_{j}\right)^{2}}{\left(x_{j}+y_{j}\right)}<br>$$</p><ul><li>将两个D归一化到$[0,1]$区间上，融合这两个距离形成新的距离，以比较两张图像之间的差异：</li></ul><p>$$<br>D\left(I_{1}, I_{2}\right)=w \times D_{1}(u, v)+(1-w) \times D_{2}(x, y)<br>$$</p><ul><li>$0 \leq w \leq 1$是一个权重，是依赖于数据库的，可以通过交叉验证来确定。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14年SIFT论文（二）</title>
      <link href="/posts/4e1.html/"/>
      <url>/posts/4e1.html/</url>
      
        <content type="html"><![CDATA[<h2 id="14年SIFT论文（二）"><a href="#14年SIFT论文（二）" class="headerlink" title="14年SIFT论文（二）"></a>14年SIFT论文（二）</h2><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><h5 id="3-2SIFT（Scale-Invariant-Feature-Transform）尺度不变特征变换特征提取"><a href="#3-2SIFT（Scale-Invariant-Feature-Transform）尺度不变特征变换特征提取" class="headerlink" title="3.2SIFT（Scale Invariant Feature Transform）尺度不变特征变换特征提取"></a>3.2SIFT（Scale Invariant Feature Transform）尺度不变特征变换特征提取</h5><ul><li>SIFT用于从图像中提取独特的尺度不变特征，主要分为四个计算阶段：尺度空间构造、关键点定位、方向分配和关键点特征提取。</li><li>在第一阶段制度空间构造，原始图像被分解成<strong>高斯金字塔</strong>，金字塔的每一层被叫做octave，octave通过使用具有不同方差的Dog滤波器在相应的金字塔层卷积初始图像而进一步分解成若干个子层。</li><li>第二阶段和第三阶段，检测出稳定关键点并计算关键点的位置、尺度和方向。</li><li>最后一个阶段，为每个关键点生成一个SIFT描述符/子。</li><li>使用SIFT来获取笔迹的关键点、再获取SIFT描述子SDs以及相应尺度和方向SOs。SDs具有尺度和旋转不变的性质，能够反映以关键点为中心的图像区域的结构。SOs能够保留这些结构的尺度和方向信息。这两个都是区分不同书写人的特征信息。</li></ul><h5 id="3-3码本生成"><a href="#3-3码本生成" class="headerlink" title="3.3码本生成"></a>3.3码本生成</h5><ul><li>给定一副手写文档图像，先通过分词得到多个单词区域WRs。对于每个WR，使用SIFT检测关键点，并提取关键点的描述子、尺度和方向。为了使特征的数量有限，将训练样本中提取的关键点SDs聚类成N个类，并用其中心表示每个类别。形成一个大小为N的码本。</li><li>在码本的基础上，在下一小节中计算一个有限维度和固定维度的直方图作为特征向量，用于识别书写人。</li><li>使用<strong>SOM聚类算法</strong>来生成SD码本，根据经验，选取N=300。</li></ul><h5 id="3-4特征提取"><a href="#3-4特征提取" class="headerlink" title="3.4特征提取"></a>3.4特征提取</h5><ul><li><p>因为是离线文本，内容可能完全不同，因此即使是同一人写的，关键点在不同图像中的布局也可能完全不同。</p></li><li><p>所以，我们不考虑关键点的位置，只考虑图像中每个SD描述子出现的频率</p></li><li><p><strong>SIFT描述子特征提取</strong>：让$SD={d_1,d_2,…,d_n}$代表第n个SIFT描述子SDs，他们是从离线笔迹图像$I$中提取的，$C={c_1,c_2,…,c_N}$代表大小为N的SD码本。则，SDS特征提取过程如下：</p><ul><li>初始化大小为N的SDS特征向量$SDS=(0,0,…,0)$</li><li>对于每个$d_i \in SD$，它和每个码本中的元素$c_j \in C$之间的欧氏距离，如下所示:</li></ul><p>$$<br>E D_{i j}=\sqrt{\sum_{k=1}^{L}\left(d_{i k}-c_{j k}\right)^{2}}<br>$$</p><ul><li>L=128是描述子的大小。并且$d_i$的欧式距离向量EDV如下所示：</li></ul><p>$$<br>E D V=\left(E D_{i 1}, E D_{i 2}, \ldots, E D_{i N}\right)<br>$$</p><ul><li>按升序对EDV的元素进行排序，并获得EDV中前t个元素：</li></ul><p>$$<br>I D X=\left{i d x_{1}, i d x_{2}, \ldots, i d x_{t}\right}<br>$$</p><ul><li>对于每个$idx \in IDX$，更新SDS特征向量：</li></ul><p>$$<br>S D S_{i d x}=S D S_{i d x}+\delta\left(E D V_{i d x}\right)<br>$$</p><ul><li>其中$\delta(x)$是一个非递增函数</li><li>重复步骤2～4，直到处理完所有的SDs。</li><li>最终计算SDS向量：</li></ul><p>$$<br>S D S_{i}=\frac{S D S_{i}}{\sum_{j=1}^{N} S D S_{j}}<br>$$</p></li><li><p>参数t依赖于数据库，可以通过<strong>对训练数据集进行交叉验证来确定</strong>。函数$\delta(x)$可以选择为一些递减函数。通过测试不同的函数，如反比例函数、指数函数和常函数等，我们发现常函数最好。</p></li><li><p>所以采用常函数$\delta(x)=1$来构建SDS特征。</p></li><li><p><strong>尺度比例和方向直方图（SOH）特征提取</strong>：使用SIFT将笔迹图像分解为X个octave和每个octave中有Y个层级。即Z=XxY个尺度。设$S={s_1,s_2,\ldots,s_n}$代表n个SIFT关键点的尺度，$1 \leq s_{i} \leq Z$，$O={o_1,o_2,\ldots,o_n}$代表这些SIFT关键点的方向。</p></li><li><p>给定一个角度步长$\phi$，方向$[0,360]$可以被量化为$Obin=[360/ \phi ]$个间隔。则SOH特征提取过程如下</p><ul><li>初始化大小为M=ZxObin的SOH特征向量$SOH=(0,0,…,0)$</li><li>比对每个关键点的尺度比例和方向，$s_i\in S,o_i \in O$，在SOH特征向量中计算其索引idx：</li></ul><p>$$<br>\begin{aligned}<br>\text { bin } &amp;=\left\lceil o_{i} / \phi\right\rceil \<br>i d x &amp;=\text { Obin } \times\left(s_{i}-1\right)+\text { bin }<br>\end{aligned}<br>$$</p><ul><li>更新SOH特征向量：</li></ul><p>$$<br>S O H_{i d x}=S O H_{i d x}+1<br>$$</p><ul><li>重复步骤2和3</li><li>计算最终的SOH特征向量：</li></ul><p>$$<br>S O H_{i}=\frac{S O H_{i}}{\sum_{j=1}^{M} S O H_{j}}<br>$$</p></li><li><p>通过大量实验，将参数X和Y设置为6和3，角度依赖于数据库，并且可以通过训练数据集上的交叉验证来确定。</p></li><li><p>图4显示了十个正对和负对之间SDS和SOH各成分的平均绝对差异。根据该图，对于SDS和SOH不同书写人之间的差异远大于相同书写人，这意味着SDS和SOHSOH对不同的书写人有很强的辨别力。</p></li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210830132238.png"></p><ul><li>SOH序号越大，差异越小。序号越大。尺度和比例越大，图像就越模糊</li></ul><h5 id="3-5特征匹配和融合"><a href="#3-5特征匹配和融合" class="headerlink" title="3.5特征匹配和融合"></a>3.5特征匹配和融合</h5><ul><li>$I_1$和$I_2$表示两个笔迹图像，$u=(u_1,u_2,\ldots,u_N)$和$v=(v_1,v_2,\ldots,v_N)$分别代表他们的SDSs，$x=\left(x_{1}, x_{2}, \ldots, x_{M}\right)$ 和$y=\left(y_{1}, y_{2}, \ldots, y_{M}\right)$分别代表他们的SOHs。</li><li>采用<strong>曼哈顿距离</strong>来测量两个样本的SDSs的u和v：</li></ul><p>$$<br>D_{1}(u, v)=\sum_{i=1}^{N}\left|u_{i}-v_{i}\right|<br>$$</p><ul><li>SOHs中索引大的组件的值的差异比索引小的组件的值小的多。如果我们仍然使用曼哈顿距离来衡量SOH之间的差异，那么大索引的差异将小于小索引的组件。所以采用卡方距离赋予小值分量更多的权重来提高他们的重要性：</li></ul><p>$$<br>D_{2}(x, y)=\sum_{j=1}^{M} \frac{\left(x_{j}-y_{j}\right)^{2}}{\left(x_{j}+y_{j}\right)}<br>$$</p><ul><li>将两个D归一化到$[0,1]$区间上，融合这两个距离形成新的距离，以比较两张图像之间的差异：</li></ul><p>$$<br>D\left(I_{1}, I_{2}\right)=w \times D_{1}(u, v)+(1-w) \times D_{2}(x, y)<br>$$</p><ul><li>$0 \leq w \leq 1$是一个权重，是依赖于数据库的，可以通过交叉验证来确定。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14年SIFT论文（一）</title>
      <link href="/posts/949b.html/"/>
      <url>/posts/949b.html/</url>
      
        <content type="html"><![CDATA[<h2 id="基于尺度不变特征变换的离线文本无关文本书写人识别"><a href="#基于尺度不变特征变换的离线文本无关文本书写人识别" class="headerlink" title="基于尺度不变特征变换的离线文本无关文本书写人识别"></a>基于尺度不变特征变换的离线文本无关文本书写人识别</h2><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h4><ul><li>提出了一种基于尺度不变特征变换（SIFT）的离线文本无关书写人的识别方法，该方法由训练、注册和识别（training, enrollment, and identification）三个阶段组成。</li><li>在所有阶段中，首先使用<strong>各向同性对数滤波器（isotropic LoG ）</strong>将手写图像分割为<strong>单词区域（WRs）</strong>。</li><li>然后，<strong>提取WRs的SIFT描述符（SDs：SIFT特征/描述符）</strong>以及相应的<strong>尺度和方向（SOs）</strong>。</li><li>在训练阶段，通过<strong>对训练样本的SDs</strong>进行聚类来<strong>构造SD码本</strong>。</li><li>在注册阶段，利用<strong>输入笔迹的SDs形成SD签名（SDS）</strong>来与<strong>SD码本</strong>作进行查找，并<strong>利用SOs生成尺度和方向直方图（SOH：尺度和方向直方图）</strong>。</li><li>在识别阶段，提取<strong>输入笔迹的SDS和SOH</strong>，并与<strong>注册笔迹进行匹配以进行识别</strong>。在六个公共数据集（包括三个英文数据集、一个中文数据集和两个混合语言数据集）上的实验结果表明，该方法优于现有的算法。</li></ul><h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h4><ul><li>一般来说，离线文本无关书写人的识别方法大致分为两大类：texture-based基于纹理的方法和structure-based基于结构的方法。</li><li>基于纹理的方法将笔迹作为一种特殊的纹理图像，提取笔迹文本的纹理特征进行笔迹识别。</li><li>与纹理特征相比，笔迹的结构特征更加直观、显著和稳定，更有利于笔迹的识别。</li><li>现有的方法都是基于笔迹的轮廓或者异体字片段，无法提取同一单词中异体字之间的结构特征。在书写文档时，单词作为一个整体，对于不同的书写人有很强的区分性。因此，同一个词中的异体字之间的结构对于书写人的特征也很重要。</li><li>所以本文，提出了一种基于尺度不变特征变换（SIFT）的笔迹图像字词级别的结构特征提取方法，包含整个词的结构信息。</li></ul><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><ul><li>训练，注册和识别</li><li>首先将笔迹图像分割成单词区域（WRs）。然后利用SIFT检测关键点。从WRs中提取关键点的SIFT描述子（SDs）以及相应的尺度和方向（SOs）。SDs和SOs将在不同的阶段以不同方式使用。</li><li>训练阶段，从训练数据集中提取SDs用于生成注册阶段和识别阶段的码本。</li><li>注册阶段，从注册笔迹图像中提取SD签名SDS和尺度和方向直方图SOH，储存用于识别。</li><li>识别阶段，从输入笔迹中提取SDS和SOH，分别于注册笔迹进行匹配。得到两个距离，然后进行融合，形成最终的距离。</li><li><strong><font color="red">个人理解</font>：</strong><ul><li>先使用<strong>各向同性对数滤波器（isotropic LoG ）</strong>进行分词，</li><li>利用SIFT提取关键点SDs用于生成码本。</li><li>注册样本进行分词，利用SIFT生成尺度和方向信息SO并用SO生成SO直方图SOH，同时也利用SIFT生成SIFT关键点描述子SDs并用SDs生成SD签名SDS与码本进行寻找。把这两个作为特征。</li><li>识别样本进行分词，利用SIFT生成尺度和方向信息SO并用SO生成SO直方图SOH，同时也利用SIFT生成SIFT关键点描述子SDs并用SDs生成SD签名SDS与码本进行寻找。</li><li>然后分别比较两个SDS和SOH的距离，然后进行特征融合，得到最终的距离。</li></ul></li></ul><h5 id="3-1分词"><a href="#3-1分词" class="headerlink" title="3.1分词"></a>3.1分词</h5><ul><li><p>为了提取笔迹中的字词级别的结构特征，先进行分词。</p></li><li><p>为了避免文本行分割和减少文本行方向的影响，采用同性LoG滤波器进行单词的分割</p><ul><li><p>使用<strong>Otsu‘s方法大津法—-最大类间方差法</strong>对笔迹样本的灰度图像转化为二值图像（a变为b）</p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829143931.png"></p><ul><li>最大类间方差：加入一幅图像有$L$个灰度级$[1,2,…,L]$。灰度级为$i$的像素点的个数为$n_j$，那么总的像素点个数应该为$N=n_1+n+2+…+n_L$。所以使用归一化的灰度直方图视为这幅图像的概率分布：</li></ul><p>$$<br>p_{i}=n_{i} / N, \quad p_{i} \geq 0, \sum_{i=1}^{L} p_{i}=1 .<br>$$</p><ul><li>现在假设我们通过一个灰度级为k的门限，将这类像素点划分为两类：$C_{0},C_1$（背景和目标），$C_0$表示灰度级1～k的像素点，$C_1$表示灰度级为k+1～L的像素点，那么每一类出现的概率以及各类的平均灰度级分别由下面的式子给出：</li></ul><p>$$<br>\omega_{0}=\operatorname{Pr}\left(C_{0}\right)=\sum_{i=1}^{k} p_{i}=\omega(k)<br>$$</p><p>$$<br>\omega_{1}=\operatorname{Pr}\left(C_{1}\right)=\sum_{i=k+1}^{L} p_{i}=1-\omega(k)<br>$$</p><ul><li>假设阈值T为图像背景与目标的分割界限，目标像素占图像总像素的比例为$w_0$，平均灰度为$u_0$；背景像素占比为$w_1$，平均灰度为$u_1$，图像总平均灰度为u，背景和目标的方差为g。则：</li></ul><p>$$<br>\begin{array}{c}<br>u=w_{0} \times u_{0}+w_{1} \times u_{1} \<br>g=w_{0} \times\left(u_{0}-u\right)^{2}+w_{1} \times\left(u_{1}-u\right)^{2} \<br>g=w_{0} \times w_{1} \times\left(u_{0}-u_{1}\right)^{2} \<br>g=\frac{w_{0}}{1-w_{0}} \times\left(u_{0}-u\right)^{2}<br>\end{array}<br>$$</p><ul><li>当方差g最大时，灰度T就是最佳阈值。</li><li>大津法，按照图像的灰度特性，将图像分成背景和目标两个部分。当取到最佳阈值时，两者之间的差别是最大的，背景和目标之间的类间方差如果越大，则说明构成图像的两个部分之间差别越大，出错概率就会越小。（<strong>使方差最大的那个阈值就是我们想要的</strong>）</li></ul></li><li><p>获取二值图像中的所有连接组件（CCS），然后计算他们的平均高度</p></li><li><p>使用同性对数滤波器对大津法二值图像进行滤波，得到的图像为图像c。由于相同字的连接组件（CCs）之间的间距远小于不同字之间的间距，因此具有适当方差的对数滤波器可以连接相同单词的CCs并分离不同的单词。由于同一个单词的CCs之间的间距与正常手写文档中单词的高度成正比，所以使用图像b中所有CCs的平均高度$h_a$来确定过滤器的方差$σ$为$σ = 2.5*h_a$</p></li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829145122.png"></p><ul><li>利用大津算法得到的阈值对图像c进行二值化得到二值化图像d</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829145512.png"></p><ul><li>将图像b中的每个连接组件分配到图像d中最近的连接区域，以形成半字词区域（SWRs），这些区域用不同颜色表示。如图e。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829145822.png"></p><ul><li>根据相邻的半字词区域SWRs之间的距离合并SWRs以得到字词区域（WRs），如图f。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829150050.png"></p><ul><li>从这些重叠连接组件OCC边界框中，拆分沿着多条文本线运行的重叠组件（把重叠的分开），如图g。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210829150312.png"></p><ul><li>经过这些分词后，得到的字词区间WRs用于特征提取</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07年PAMI总结</title>
      <link href="/posts/befa.html/"/>
      <url>/posts/befa.html/</url>
      
        <content type="html"><![CDATA[<h2 id="07年PAMI总结"><a href="#07年PAMI总结" class="headerlink" title="07年PAMI总结"></a>07年PAMI总结</h2><h4 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1.数据集"></a>1.数据集</h4><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210827152445.png" alt="歌剧魅影"></p><ul><li>一共用了四个数据集，所有数据集的书写人都有两个样本，书写人的分类<strong>使用遗漏一个方式执行</strong>。<ul><li>对于查询样本q，使用选定的特征，计算q到所有其他样本i不等于q的距离。每个人有两个样本， 不要那个人的查询样本就是遗漏一个的方式。</li></ul></li><li>Firemaker大写数据集，250个书写人</li><li>Firemaker小写数据集，250个书写人</li><li>IAM（650小写）和Firemaker（250小写）合并成一个Large（900小写）数据集</li><li>使用ImUnipen数据库中的65个书写人每人两个片段，共130个片段，用于计算异体字特征f4的码本。利用k-means距离生成了包含400个原型的码本。</li></ul><h4 id="2-特征分类"><a href="#2-特征分类" class="headerlink" title="2.特征分类"></a>2.特征分类</h4><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210827143111.png"></p><ul><li>方向概率分布函数$(f1,f2,f3h,f3v)$，形状基元产生概率分布函数$(f4)$，游程概率分布函数$(f5h,f5v)$和自相关$(f6)$</li><li>轮廓上计算：$(f1)$边缘方向概率分布函数、$(f2)$边缘铰链、$(f3h)$水平边缘共生、$(f3v)$垂直</li><li>连通组件：$(f4)$，基元发射pdf</li><li>二值化图像：f5h基于游程的水平pdf，f5v垂直</li><li>灰度图像：自相关水平和垂直</li></ul><h5 id="2-1边缘方向-pdf-f1"><a href="#2-1边缘方向-pdf-f1" class="headerlink" title="2.1边缘方向$pdf (f1)$"></a>2.1边缘方向$pdf (f1)$</h5><ul><li><p>建立角度直方图（角度出现的次数），将角度直方图归一化为概率分布$p(\phi)$，</p><ul><li>归一化，将区间[c，d]变为区间[a，b]上算法（即可以归一化角度，也可以用作图像灰度归一化）：</li></ul><p>$$<br>x_{o u t}=\left{\begin{array}{ll}<br>a &amp; \left(\text { if } \quad x_{i n}&lt;c\right) \<br>\frac{b-a}{d-c} \cdot\left(x_{i n}-c\right)+a &amp; \left(\text { else if } \quad c \leq x_{i n}&lt;d\right) \<br>b &amp; (\text { else })<br>\end{array}\right.<br>$$</p></li><li><p>这个概率分布$p(\phi)$代表角度$\phi$出现的概率，可以用角度$(\phi)$出现的概率来衡量一个人的书写特征。</p></li></ul><p>$$<br>\phi=\arctan \left(\frac{y_{k+\epsilon}-y_{k}}{x_{k+\epsilon}-x_{k}}\right)<br>$$</p><ul><li>$\epsilon$控制轮廓片段的长度，选择$\epsilon=5$，轮廓随便长度相当于墨水笔迹的六个像素。角度范围是$(0^\circ \sim 180^\circ)$，因为没有在线信息。将<strong>bin</strong>设置为$n=12$，每份$15^\circ$。<ul><li>直方图中bin的含义：例如颜色直方图，RGB每个通道有256种颜色，共计有$256<em>256</em>256$种色彩，一张图片中，按照每个像素去统计颜色，相同的值会很少，不能达到统计的目。所以采用合并的思想，引入了bin，在颜色中将每个通道划分为8个bin，可以组成512个组合。所以在直方图横坐标就有512个刻度，达到统计频率的目的。</li></ul></li></ul><h5 id="2-2边缘铰链方向-pdf-f2"><a href="#2-2边缘铰链方向-pdf-f2" class="headerlink" title="2.2边缘铰链方向$pdf(f2)$"></a>2.2边缘铰链方向$pdf(f2)$</h5><ul><li>计算连接在同一像素用相同距离$\epsilon=5$上的两条线的角度的联合概率密度。<ul><li>铰链方向范围是$(0^\circ \sim 360^\circ)$四个象限，将bin按照$2n=24$进行设置，两个角度的所有组合可能性为$2n*2n$种，只考虑角度2大于角度1的情况，则共有$24+23+\cdots+2+1=300$种维度（文章作者用的是$C_{2 n}^{2}+2 n=n(2 n+1),n=12$，所以一共也是300种维度，但不知道是怎么排列组合的）</li></ul></li></ul><h5 id="2-3边缘方向共生-pdf-f3h-f3v"><a href="#2-3边缘方向共生-pdf-f3h-f3v" class="headerlink" title="2.3边缘方向共生$pdf(f3h,f3v)$"></a>2.3边缘方向共生$pdf(f3h,f3v)$</h5><ul><li>在边缘方向的基础上，构造水平延伸和垂直延伸，碰到像素时，用相同的距离，获得的两个角度进行联合概率密度计算。</li><li>每个角度有12种可能，所以共有144种维度。</li></ul><h5 id="2-4游程长度-pdf-f5h-f5v"><a href="#2-4游程长度-pdf-f5h-f5v" class="headerlink" title="2.4游程长度$pdf(f5h,f5v)$"></a>2.4游程长度$pdf(f5h,f5v)$</h5><ul><li>游程长度在二值图上确定，利用两个黑色像素之间的水平和垂直距离的白色背景长度来做联合概率密度作为特征表示。</li><li>最多长度为60像素，以防止垂直测量到其他行的字母（默认书写人笔迹字高为120像素）</li></ul><h5 id="2-5自适应特征-pdf-f6-（没太搞懂）"><a href="#2-5自适应特征-pdf-f6-（没太搞懂）" class="headerlink" title="2.5自适应特征$pdf(f6)$（没太搞懂）"></a>2.5自适应特征$pdf(f6)$（没太搞懂）</h5><ul><li>笔迹的每一行都会以给定的偏移量去移动，然后计算原始行和改变后副本之间的标准化点积。使用原始灰度图像，最大偏移量对应60像素。</li><li>对于每个偏移，对所有图像行的自相关系数进行平均，看每个偏移的所有自相关系数的规律。</li><li>自相关系数计算需要使用欧几里得距离。</li></ul><h5 id="2-6异体字特征-f4"><a href="#2-6异体字特征-f4" class="headerlink" title="2.6异体字特征$(f4)$"></a>2.6异体字特征$(f4)$</h5><ul><li>三个阶段：笔迹分割、通过分割出的图形块聚类生成字形码本、在码本上计算笔迹的距离</li><li><strong>笔迹分割方法</strong>：在下轮廓的最细的地方进行分割，由下到上。将大小规范为$30*30$的像素并保留原有横纵比。</li><li><strong>通过聚类获得码本</strong>：利用65位书写人130个笔迹样本进行训练，从样本中分割出了41000个笔迹图形块。<ul><li>与04年文章相同</li></ul></li><li><strong>计算特定书写人的概率分布函数或距离</strong>：先将每个笔迹样本$i$用上文方法进行分割提取图形。对于样本中的每个图形元$g$，使用欧几里得距离来寻找最近的特定书写人的原型$w$，将出现情况记录到相应的直方图中。</li></ul><p>$$<br>w=\operatorname{argmin}<em>{n}\left[\operatorname{dist}\left(g, C</em>{n}\right)\right], h_{i w} \leftarrow h_{i w}+1,<br>$$</p><ul><li>$n$代表码本中的第几个，$C_n$代表第n个码本的形状，最后直方图$h_i$被标准化为概率分布函数$p_i$。</li></ul><h4 id="3-特征融合"><a href="#3-特征融合" class="headerlink" title="3.特征融合"></a>3.特征融合</h4><ul><li>对于特征$(f1,f2,f3,f4,f5)$进行卡方距离计算，匹配查询样本$q$和数据库中其他样本$i$的距离</li></ul><p>$$<br>\chi_{q i}^{2}=\sum_{n=1}^{N d i m s} \frac{\left(p_{q n}-p_{i n}\right)^{2}}{p_{q n}+p_{i n}}<br>$$</p><ul><li>$p$是概率分布函数的值，$n$是$bin$的索引，$Ndims$是$bin$的数量</li><li>引入了失误率FAR（两个样本是同一个人书写，但判断错了）和未命中率FRR（两个样本是同一个人书写，也是真的但你拒绝了）</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210827134609.png"></p><ul><li>最终距离为每个特征产生距离的平均值，特征组合中，汉明距离表现最好</li></ul><p>$$<br>H_{q i}=\sum_{n=1}^{N d i m s}\left|p_{q n}-p_{i n}\right| .<br>$$</p><ul><li>卡方距离中，分母为低概率区域提供了更高的权重，并使得每个特征最大化。而汉明距离没有这种缺点。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07年PAMI（二）</title>
      <link href="/posts/3781.html/"/>
      <url>/posts/3781.html/</url>
      
        <content type="html"><![CDATA[<h4 id="1-第六章，通过特征匹配和特征融合进行笔迹识别和验证"><a href="#1-第六章，通过特征匹配和特征融合进行笔迹识别和验证" class="headerlink" title="1.第六章，通过特征匹配和特征融合进行笔迹识别和验证"></a>1.第六章，通过特征匹配和特征融合进行笔迹识别和验证</h4><ul><li>在将手写笔迹映射到特征上后，需要在特征向量之间进行适当的距离度量，以计算两个样本之间的差异性或相似程度。我们在实验中使用了大量的距离的测试，Minkowski 5阶距离，卡方距离，Bhattacharya and Hausdorff距离。</li><li>对于pdf特征f12345， 卡方距离用于匹配查询样本q和数据库中的任何其他样本i：</li></ul><p>$$<br>\chi_{q i}^{2}=\sum_{n=1}^{N d i m s} \frac{\left(p_{q n}-p_{i n}\right)^{2}}{p_{q n}+p_{i n}}<br>$$</p><ul><li>p是pdf的一个元素？，n是bin索引，Ndims是pdf中<strong>bin的数量（特征的维度）</strong>，卡方用于pdf的距离度量，欧几里得距离用于自相关。</li><li><strong>书写人识别是使用漏掉一个的策略使用最近邻分类</strong>。对于查询样本q，使用所选特征计算到所有其他样本的i不等于q的距离。然后，所有样本i在排序的命中列表中排序，与查询q的距离增加。理想情况下，排名第一的样本应该是由同一个书写人书写人成对样本。如果一个人不仅考虑最近的邻居（排名第一的），而且也考虑从第一到第十更长的邻居列表，那么正确命中的概率会随着列表的长度增加而增加。</li><li>在实验中，我们没有将训练集和测试集分开，所有数据全都在一个套件中。这实际上是一个更加困难和真实的测试条件，有更多的干扰因素，不是一个，而是每个虚假作者两个，只有一个正确的命中。</li><li>书写人验证，与所有生物特征验证任务一样，可以完美地放入经典的**Neyman-Pearson框架统计决策理论[54]**。对于书写人验证，两个给定笔迹样本之间的距离是使用选定的特征去计算的。如果达到预定的阈值T，则认为距离最高地，一认为两个笔迹样本是同一个人书写。超过T的，被认为是不同人书写的。但可能存在两种错误：错误接受FA，两个样本是由同一个人写的，但这不是真的。错误拒绝FR，两个样本是同一个人写的，也是真的。相关错误率FAR和FRR，在文档中要找到疑似对象，FAR为失误率，FRR为未命中率。这些错误率可以通过将</li><li>这些错误率可以通过将同一人书写的样本之间距离的概率分布PS（x）和不同人书写的样本之间距离的概率分布PD（x）进行积分，直到/从决策阈值T进行积分计算：</li></ul><p>$$<br>F A R=\int_{0}^{T} P_{D}(x) d x, F R R=\int_{T}^{\infty} P_{S}(x) d x<br>$$</p><ul><li>通过改变阈值T，获得了 Receiver Operating Characteristic (ROC) 曲线，该曲线曲线说明两种错误率之间不可避免的权衡。**Equal Error Rate (EER)**对应于ROC曲线上的点，其中FAR=FRR，它以单个数字量化书写人验证性能。</li><li>在本研究中考虑的特征不是完全正交的，但是，他们在笔迹样本上提供了不同的观点。因此，尝试将他们结合起来，在我们的特征组合方案中，任意两个手写样本之间的最终唯一距离计算为由于参与组合的各个特征而产生的距离的平均距离（简单或加权平均值）</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210827134609.png"></p><ul><li>在特征组合中，汉明距离表现最好</li></ul><p>$$<br>H_{q i}=\sum_{n=1}^{N d i m s}\left|p_{q n}-p_{i n}\right| .<br>$$</p><ul><li>在卡方距离中，由于分母，卡方距离为概率分布函数中的低概率区域提供了更多权重，并且使每个特征的性能最大化。汉明距离，为不同的pdf特征生成可以比较的距离值，并提供了一个共同点，在特征组合方面略有优势。</li><li>本文提出的<strong>特征组合方案的贝叶斯框架</strong>包含两个基本假设：特征是独立的，并且两个样本由同一人编写的概率假设是由所选特征生成的两个样本之间距离的指数分布$P_{S}(x) \propto e^{-x / \sigma}$来表示。衰减常数$\sigma$控制不同特征在组合中的权重。</li></ul><h4 id="2-第七章，结果"><a href="#2-第七章，结果" class="headerlink" title="2.第七章，结果"></a>2.第七章，结果</h4><ul><li>验证top1和top10识别率以及错误率作为性能的度量结果。</li><li>所有数据集包含每个书写人的两个样本，书写人以<strong>遗漏一个</strong>的方式来搜索。</li><li>用ImUnipen来生成特征f4的码本，保证不污染数据。</li><li>我们使用了一个由k-means聚类生成的包含400个原型形状的码本</li></ul><h4 id="3-第八章，讨论"><a href="#3-第八章，讨论" class="headerlink" title="3.第八章，讨论"></a>3.第八章，讨论</h4><ul><li>f4特征相关的两个因素：码本大小和用于生成形状的聚类算法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07年PAMI（一）</title>
      <link href="/posts/a7fb.html/"/>
      <url>/posts/a7fb.html/</url>
      
        <content type="html"><![CDATA[<h2 id="纹理特征和异体字特征的文本无关书写人识别与鉴定"><a href="#纹理特征和异体字特征的文本无关书写人识别与鉴定" class="headerlink" title="纹理特征和异体字特征的文本无关书写人识别与鉴定"></a>纹理特征和异体字特征的文本无关书写人识别与鉴定</h2><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h4><ul><li><p>使用从笔迹图像中提取的概率分布函数（PDF）来表征笔迹的特征，使用纹理特征和字符形状（异体字），</p></li><li><p>纹理上：使用基于轮廓的联合方向概率密度对方向和曲率信息进行编码，以提供特征。</p></li><li><p>异体字：作者认为书写人书写笔迹时，是一个基元产生器，给定笔迹中这些特定形状的概率密度函数就是书写人的特征，并通过<strong>grapheme clustering</strong>一种聚类方法，来获得基础码本。</p></li><li><p>结合多种功能（方向directional，grapheme字母形状？，游程概率密度）可以提高书写人识别和验证的性能。</p></li><li><p>所提出的方法适用于自由笔迹（有弧度的和独立的笔迹）</p></li><li><p>在使用少量文本时，可以获得可靠的概率预测</p></li></ul><h4 id="2-关键词"><a href="#2-关键词" class="headerlink" title="2.关键词"></a>2.关键词</h4><ul><li>笔迹分析</li><li>书写人鉴定与识别</li><li>生物特征行为</li><li>联合方向概率分布</li><li>字符发射概率分布</li></ul><h4 id="3-引言"><a href="#3-引言" class="headerlink" title="3.引言"></a>3.引言</h4><ul><li><p>我们的方法是使用从900名书写人采集的笔迹样本数据集进行实验评估的。</p></li><li><p>我们的方法有两个显著特点：</p><ul><li>书写人的鉴别过程中尽量。</li><li>使用独立于笔迹样本的文本内容特征来对个人笔迹风格进行编码。</li><li>书写人的特点是使用从笔迹文本块中提取的概率分布函数。</li><li>计算机完全不知道样本中写了什么。</li></ul></li><li><p>书写人识别起源于更古老、更广泛的自动笔迹识别领域。</p></li><li><p>对于自动笔迹识别，寻找一种能够消除不同手写体之间的差异的不变的一种表示发放，以便于可靠的对字符和单词的形状进行分类。</p></li><li><p>书写人识别，还需要对这些变化的部分进行特定的增强以便确认是书写人。</p></li><li><p>笔迹识别和书写人识别代表了笔迹分析的两个对立面 。</p></li><li><p>笔迹识别，是为了找出某种特征，是每个人的字迹都可以用这个特征的大小来衡量。</p></li><li><p>书写人识别，是为了找出某种特征来区分不同人之间的差异。本质上这两个差不多。</p></li><li><p>在大型数据库中，执行一对多的寻找，已知书写人，返回可能的候选人列表。</p></li><li><p>第二章综述了 离线书写人识别和鉴定的最新研究工作。</p></li><li><p>第三章描述了实验的数据集。</p></li><li><p>第四章、第五章分别描述了提取纹理特征和异体字形状的算法。</p></li><li><p>第六章说明了用于特征匹配和特征融合技术的距离。</p></li><li><p>第七章给出了实验结果。</p></li><li><p>第八章进行讨论。</p></li><li><p>第九章得出结论。</p></li></ul><h4 id="4-第二章，该领域的最新研究"><a href="#4-第二章，该领域的最新研究" class="headerlink" title="4.第二章，该领域的最新研究"></a>4.第二章，该领域的最新研究</h4><ul><li><p>参考文献10对1989年前的自动书写人鉴别的研究工作进行了全面的回顾，现在，我们将调查最近几年中所提出的方法</p></li><li><p>书写人识别与验证分为两大方法</p><ul><li>文本相关：文本相关方法与签名验证技术十分相似，使用单个字符或已知语义内容的单词块之间进行比较。需要先对相关信息进行定位和分割，通常需要人来交互执行。</li><li>文本无关：从文本块的整个图像中提取统计特征，使用最少的笔迹从样本文本内容中获得不敏感的稳定特征。<strong>优点是把人为干预的可能性降到最低</strong></li></ul></li><li><p>Said提出了一种文本无关方法，使用<strong>多通道滤波Gabor滤波</strong>和<strong>共生灰度矩阵</strong>表示特定书写人的<strong>纹理特征</strong>。该方法需要修正偏移的字来生成统一的文字块，设置文本行/单词和文本兼具之间的预定义距离。</p><ul><li>数据集与方法：每个集合20个书写人，每个书写人写了25个样本用于评估。使用了加权欧式距离和Gabor特征的最近质心分类实现了96%的笔迹识别准确率。相同的方法也被用作与机器打印的笔迹文档和字体的识别。</li></ul></li><li><p>Zois和An使用单个单词进行书写人识别和验证。</p><ul><li>数据集与方法：数据集包括50位书写人，每个书写人用英语和希腊语写了45遍characteristic这个词，在对图像进行阈值化处理和曲线细化后，对水平轮廓投影重新取样，分割成10段，并在两个尺度上使用<strong>形态学算子</strong>进行处理，得到20维向量，使用<strong>贝叶斯分类器</strong>或者<strong>多层感知器</strong>进行分类。希腊语和英语的准确率都在95%左右。</li></ul></li><li><p>Srihari提出了大量特征，将其分为两类，宏观特征和微观特征。</p><ul><li>宏观特征在文档、段落和文字级别：<strong>灰度熵和阈值、墨水像素数、内部/外部轮廓数、四个方向的坡度分量、平均高度/斜度、段落纵横比和缩进、字长和上下区域比例</strong>。</li><li>微观特征应用在文字和字符级别：渐变、结构和凹度（GSC）属性，最初使用手写数字识别。文本相关的统计评估是包含1000名书写人的数据集，这些书写人将156个单词的固定文本复制了三次。</li><li>在识别的测试中，微观特征优于宏观特征，超过80%。<strong>多层感知器和参数分布用于笔迹鉴定</strong>，准确率为96%。</li></ul></li><li><p>Bensefia使用笔迹分割方法对生成的笔迹的特征进行编码，不依赖于文本内容，文本无关。</p><ul><li>Grapheme聚类用于定义数据集中所有文档的公共特征空间。数据集有三个，88位书写人、39位书写人（历史文献）和每个书写人有两个样本的150个书写人。作者识别是在信息检索框架中执行的，而作者验证是基于比较的两种手写体中的图形分布之间的互信息。</li></ul></li><li><p>Marti将文本行作为基本输入单元，涌过使用三个主要书写区域的高度、倾斜和字符宽度，连接组件的距离、墨水循环内的斑点、上下轮廓，计算与文本无关的特征。<strong>使用k-最近邻分类器</strong>。</p></li><li><p>Sch和Bunke使用<strong>基于HMM的手写识别器</strong>识别和验证书写人。识别器专门转对单个书写人，只使用来自所选人员的笔迹进行训练，输出HMM的对数似然分数来识别可变内容的单独文本行上的作者。</p></li><li><p>文献38提出了一种字符回溯和DTW匹配的交互方法</p></li><li><p><strong>本文提出</strong>，我们提出一种<strong>纹理级别的方法</strong>，使用边缘铰链的联合概率密度来评估特征。通过提取上本部分和下半部分的单独的概率密度，然后与特征向量拼接，还可以通过合并位置信息获得进一步的改进。我们<strong>异体字的方法</strong>，通过计算出码本，来解决问题。我们的方法是<strong>稀疏参数化设计</strong>，设计最少的训练。我们的实验数据集中，每个书写人只有两个样本。</p></li></ul><h4 id="5-第三章，实验数据集"><a href="#5-第三章，实验数据集" class="headerlink" title="5.第三章，实验数据集"></a>5.第三章，实验数据集</h4><ul><li>使用了三个数据集进行试验：Firemaker、IAM and ImUnipen</li><li>Firemaker数据集包括250名荷兰人的笔迹，主要是学生，写在四张不同的A4纸上。<ul><li>第一页，使用普通笔迹（主要是小写字母）抄写五段文字。</li><li>第二页，只用大写字母抄写其余两段文字。</li><li>第三页，包括伪造文本，这些样本没有被使用在当前研究中。</li><li>第四页，用自己的话描述给定的卡通内容。</li><li>这些样本主要由不同文本内容的小写笔迹组成，从两行到写满一整页的墨水量差异很大</li><li>文档<strong>以300dpi，8位像素进行灰度扫描</strong>。</li><li>在本实验中，对第一页和第四页小写内容和第二页第一段和第二段进行了搜索和匹配。</li></ul></li><li>IAM数据库包括可变内容手写英文文本，用300dpi，8位像素灰度扫描<ul><li>除了作者身份以外，图像还伴随着文本行、句子和单词层面的分割信息。</li><li>此数据集包括每个书写人的手写页面数量可变，从一页（350人）到59页（一个书写人）。</li><li>为了数据集具有可比性，修改了IAM数据集，使每个书写人始终包括两个样本：如果原有书写人在数据集中有两个以上的书写文档，只保留前两个；如果只有一个，就将文档分为一半。</li><li>改进后的IAM集包括650人的小写笔迹，每个书写人两个样本，同一个书写人的墨水量大致相等，不同的书写人墨水量从三行到一整页量不等。</li></ul></li><li>ImUnipen数据集包括215名书写人笔迹，每个书写人两个样本，这些图像来自Unipen在线手写数据库。使用<strong>Bresenham line generator和适当的brushing function</strong>将坐标的时间序列转换为模拟的300dpi图像。这些样本包含小写，文本内容和墨水量各不相同。使用数据集的65个书写人，130个样本，用于异体字书写方法中，训练计算书写人特定图形发射概率的形状码本。 </li><li>我们合并Firemaker小写和IAM数据集，将其命名为“Large”，包括900个书写人，每个书写人两个样本，都是小写笔迹。我们的书写人识别和验证方法是文本无关的，不需要人工打标。表1为测试使用的所有数据集。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210826143658.png"></p><h4 id="6-第四章，纹理层次特征"><a href="#6-第四章，纹理层次特征" class="headerlink" title="6.第四章，纹理层次特征"></a>6.第四章，纹理层次特征</h4><ul><li>三个阶段<ul><li>特征提取</li><li>特征匹配/特征结合</li><li>书写人识别与鉴定</li></ul></li><li>特征提取方法：我们使用从手写图像中提取的概率分布函数以文本无关的方式来描述书写人的个性。特征用于表示一个完整的概率分布函数pdf：不是一个单一的值，是一个完整的<strong>概率向量</strong>，它捕获了手写笔迹唯一性的一个方面。</li><li>在研究中使用的所有特征的概述都在表2中。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210826145045.png"></p><ul><li><strong>轮廓上计算：f1边缘方向概率分布函数、f2边缘铰链、f3h水平边缘共生、f3v垂直</strong></li><li><strong>连通组件：f4，基元发射pdf</strong></li><li><strong>二值化图像：f5h基于游程的水平pdf，f5v垂直</strong></li><li><strong>灰度图像：自相关水平和垂直</strong></li></ul><hr><ul><li>本文中，选择了最具辨别力的特征<ul><li><strong>归一化熵</strong></li><li><strong>墨水密度pdf</strong></li><li><strong>wavelet，子波？</strong></li></ul></li><li>使用<strong>Otsu‘s方法大津法—最大类间方差法</strong>对笔迹样本的厨师灰度图像进行二值化。</li><li>在二值图像中，只有有墨水的地方才能看得见，使用8邻域法进行轮廓标记，然后用摩尔法提取轮廓。轮廓将会对所有轮廓边界上所有像素标记坐标对（xk，yk）</li><li>手写文档的四种主要表示形式用于特征计算：灰度图像、二值图像、连接组件和轮廓。</li></ul><h5 id="6-1边缘方向概率分布函数（f1）"><a href="#6-1边缘方向概率分布函数（f1）" class="headerlink" title="6.1边缘方向概率分布函数（f1）"></a>6.1边缘方向概率分布函数（f1）</h5><ul><li>笔迹最突出的视觉属性是倾斜，他能显示个人的书写风格，笔迹倾斜也是一个人的稳定特征。</li><li>通过考虑局部轮廓碎片方向，提取边缘方向pdf。</li><li>分析连个相距一定距离的轮廓像素的方向和水平的夹角。当运行算法时，计算局部轮廓碎片的理论方向，建立<strong>角度直方图（每个角度出现的次数）</strong>。然后将角度直方图归一化为概率分布p，该概率分布给出了在手写笔记中找到从水平面测量角度的概率。</li></ul><p>$$<br>\phi=\arctan \left(\frac{y_{k+\epsilon}-y_{k}}{x_{k+\epsilon}-x_{k}}\right)<br>$$</p><ul><li><p>$\epsilon$控制分析轮廓片段的长度（两个像素之间的间隔），我们选择$\epsilon=5$，这个轮廓碎片的长度与墨水厚度6像素相当（在图片上是六个像素，六个小格子）。角度位于前两个象限，因为没有在线信息，我们不知道轮廓的书写顺序。<strong>通过实验将180度分为n=12个bin</strong>，十二份，每份15度可以详细的描述笔迹。（每一次x和y加5，直方图设置bin为12，最后统计每个角度区间的次数）</p><ul><li><p>直方图的bin：一个histogram，通常可以用一个列向量表示（例子中的a，b），列向量里面的每一个值就是一个bin（a,b），比如说列向量有个50个元素，那么就代表有50个bin。</p><p>对于彩色图像，一般是rgb，3个维度，每个颜色一般是0-255的灰度级，就是对应8个bin，每个维度8bin，8x8x8=512bin</p></li></ul></li></ul><h5 id="6-2边缘铰链f2"><a href="#6-2边缘铰链f2" class="headerlink" title="6.2边缘铰链f2"></a>6.2边缘铰链f2</h5><ul><li>计算连接在同一个像素上的<strong>两条</strong>线的方向的联合概率密度，按照长度找到两个铰链点的坐标。最终的归一化直方图给出了联合PDF，量化了在图像中找到两个分别以1和2角定向的“铰接”轮廓碎片的机会。</li><li>铰链的角度要跨越四个象限360度，在2n=24上进行量化。两个角度的组合数（4n的平方2n*2n），我们只考虑非冗余的（角度2大于角度1的）。<strong>最终两个角度组合数为$C_{2 n}^{2}+2 n=n(2 n+1)$，n=12，则共有300个维度</strong></li></ul><h5 id="6-3边缘方向共生（f3h，f3v）"><a href="#6-3边缘方向共生（f3h，f3v）" class="headerlink" title="6.3边缘方向共生（f3h，f3v）"></a>6.3边缘方向共生（f3h，f3v）</h5><ul><li>方向共生概率分布函数，在边缘方向上的基础，水平延伸直到碰到一个像素，以相同距离5，在找到角度。获得两个角度。</li><li>有n的平方的尺度，144。直方图。</li><li>由f1方向特征和f3水平垂直特征描述</li><li>联合概率密度表示笔迹风格的通用纹理特征，与文本无关</li></ul><h5 id="4-4其他纹理特征，游程长度5和自相关6"><a href="#4-4其他纹理特征，游程长度5和自相关6" class="headerlink" title="4.4其他纹理特征，游程长度5和自相关6"></a>4.4其他纹理特征，游程长度5和自相关6</h5><ul><li>游程长度在二值图像上确定，同时考虑对应于墨迹的黑色像素或对应于背景的白色像素，黑色的统计特性收到墨水宽度的显著影响，因此也受到书写时笔的影响。白色像素捕捉字母内部区域和字母和单词之间的空白。白色长度的概率分布（在背景上）将使用书写人识别和验证测试。</li><li>有两周基本扫描方法：沿着图像水平行扫描f5h和沿图像列的垂直扫描f5v。</li><li>与上述基于轮廓的方向特征类似，游程长度的直方图被归一化标准化并解释为概率分布。我们特定只考虑60像素的游程以防止垂直测量进入连续文本行之间（数据集的写入行高度为120像素）</li><li>为了计算自相关特征f6，图像的每一行都会以给定的偏移量移动到自身上，然后计算原始行和移动副本之间的<strong>标准化点积</strong>，计算中使用原始灰度图像，最大偏移量对应60像素。</li><li>对每个偏移，然后对所有图像行的自相关系数进行平均，然后检测自相关函数在书写中是否有规律。规则：垂直笔划将在原始行及其水平移动副本中重叠，偏移量等于手写<strong>空间波长spatial wavelength</strong>的整数倍。结果将导致自相关函数的大的点积。</li><li>自相关系数需要不同于其他特征的距离度量，应该是<strong>欧几里得距离而不是卡方距离</strong></li></ul><h4 id="7-第五章，异体字特征"><a href="#7-第五章，异体字特征" class="headerlink" title="7.第五章，异体字特征"></a>7.第五章，异体字特征</h4><ul><li>假设书写人是一个基元生产机器，每个书写人都有特定的书写概率，通过聚类获得形状的公共码本。</li><li>三个处理阶段<ul><li>笔迹分割</li><li>通过字形聚类生成码本</li><li>然后在生成的码本上进行笔迹的概率分布函数或距离的计算</li></ul></li></ul><h5 id="7-1笔迹分割方法"><a href="#7-1笔迹分割方法" class="headerlink" title="7.1笔迹分割方法"></a>7.1笔迹分割方法</h5><ul><li>在笔迹中，产生的组件可能包含多个字符，所以我们需要对其进行分割。</li><li>我们在下轮廓的最小值处进行分割，由下轮廓到上轮廓切分（取决于笔有多宽），切完后，提取问连接组件，然后将大小规范化为30x30像素并且保留原始图案的横纵比。</li></ul><h5 id="7-2通过聚类获得码本"><a href="#7-2通过聚类获得码本" class="headerlink" title="7.2通过聚类获得码本"></a>7.2通过聚类获得码本</h5><ul><li>从ImUnipen数据集采集了来自65位书写人的130个样本，生成了码本</li><li>从样本中生成了41000个规范大小30像素的训练集，用于聚类训练生成码本</li><li>比较三种生成字形码本的聚类技术：**k-means，Kohonen SOM 1D,and 2D.**我们使用这些方法的标准实现方式</li><li>产生最佳性能的码本，使用kmeans产生的码本是无序的，1d从左到右由上到下有顺序，2d是完整二维表示</li></ul><h5 id="7-3计算特定书写人的形状基元发射概率分布函数"><a href="#7-3计算特定书写人的形状基元发射概率分布函数" class="headerlink" title="7.3计算特定书写人的形状基元发射概率分布函数"></a>7.3计算特定书写人的形状基元发射概率分布函数</h5><ul><li>书写人被认为是随机样式生成器的特征，生成一些列基本形状。单个形状的发射率是通过执法图来计算的。在直方图中，一个bin备份给码本中的每个元素。</li><li>对于每个笔迹样本i，使用上文所说的方法进行分割、连接组件检测、大小规范过程提取图形。对于样本中的每个图形元g，使用欧几里得距离来找到最近的码本元素原型w（距离最小的赢家），并将出现的情况计入相应的<strong>直方图bin</strong>中：</li></ul><p>$$<br>w=\operatorname{argmin} _ {n}\left[\operatorname{dist}\left(g, C _ {n}\right)\right], h _ {i w} \leftarrow h _ {i w}+1,<br>$$</p><ul><li><p>n是索引，表示码本C中的形状。最后直方图$h_i$被标准化为概率分布函数$p_i$其总和为1。这个概率密度就是书写人的特征f4</p></li><li><p>该方法的本质是不包括所有可能的异体字零件的枚举。相反，通过为从给定的笔迹样本中提取笔迹碎片提供一组距离最近的吸引因子。码本跨过了一个形状空间去提供。基元出现的概率密度函数代表了书写人的特征。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04PAMI总结梳理</title>
      <link href="/posts/bb8d.html/"/>
      <url>/posts/bb8d.html/</url>
      
        <content type="html"><![CDATA[<h3 id="04PAMI梳理"><a href="#04PAMI梳理" class="headerlink" title="04PAMI梳理"></a>04PAMI梳理</h3><h4 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1.数据集"></a>1.数据集</h4><ul><li>使用100名书写人作为训练集的CO3码本，使用150名书写人计算CO3的概率密度。</li></ul><h4 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h4><ul><li>对于给定的字母表L存在一个有限的异体字列表S，每个异体字$S_{li}$都被认为是字母$l$第i个允许的样式变化。</li><li>设概率密度函数$p_w(S)$，书写人w书写出异体字的概率。</li><li>作者认为：书写人不同，则书写异体字的$pdf$就不同。</li></ul><p>$$<br>w \neq v \Rightarrow p_{w}(S) \neq p_{v}(S)<br>$$</p><ul><li>书写人w书写的手写样本u的特点是</li></ul><p>$$<br>\vec{x}<em>{w u}=p</em>{w u}(S),<br>$$</p><ul><li>如果样本u具有代表性，则样本u的特点就可以表示书写人w书写异体字的概率密度函数</li></ul><p>$$<br>\vec{x}<em>{w u} \approx p</em>{w}(S) \text {, }<br>$$</p><ul><li><strong>作者认为，如果两个书写人是不同的，那么相同书写人的任意两个书写样本之间的一个距离是小于不同书写人的任意两个样本之间的距离。</strong></li></ul><p>$$<br>\forall a, b, c, w, v \neq w: \Delta\left(\vec{x}<em>{w a}, \vec{x}</em>{w b}\right)&lt;\Delta\left(\vec{x}<em>{w a}, \vec{x}</em>{v c}\right),<br>$$</p><ul><li>$\Delta$是概率密度函数上的一个适当距离函数$\vec{x}$，v和w表示书写人，a，b，c是手写样本或者是手写的特征。</li><li>假设每个异形字符都由一组非空的连接组件$c_j$组成,$S_{l i}=\left{c_{1}, c_{2}, \ldots, c_{m}\right}$,我们<strong>假设</strong>所有可能的异形字符都可以由有限集或码本C的连通组件表示。此外，如果我们<strong>假设</strong>连通组件的形状是异体字符变体的信息，那么对于概率函数。<strong>书写人w书写的内容u的连通组件的概率密度等于书写人w书写内容u的概率密度。</strong></li></ul><p>$$<br>\vec{\xi}<em>{w u}=p</em>{w u}(C)<br>$$</p><ul><li>书写人w从手写样本u中导出连通组件，和公式4类似</li></ul><p>$$<br>\forall a, b, c, w, v \neq w: \Delta\left(\vec{\xi}<em>{w a}, \vec{\xi}</em>{w b}\right)&lt;\Delta\left(\vec{\xi}<em>{w a}, \vec{\xi}</em>{v c}\right)<br>$$</p><ul><li>假设样本u具有代表性，则：<strong>（连通组件的概率密度就可以表示书写人w的特征）</strong></li></ul><p>$$<br>\vec{\xi}<em>{w u} \approx p</em>{w}(C)<br>$$</p><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><h5 id="3-1数据"><a href="#3-1数据" class="headerlink" title="3.1数据"></a>3.1数据</h5><ul><li><strong>共250个段落。第一组为100个段落，尽可能多的书写人来训练。第二组为150个段落，由同样多的书写人但是不同书写人来作为测试组。</strong></li></ul><h5 id="3-2步骤一：用大写笔迹计算连通元件轮廓码本"><a href="#3-2步骤一：用大写笔迹计算连通元件轮廓码本" class="headerlink" title="3.2步骤一：用大写笔迹计算连通元件轮廓码本"></a>3.2步骤一：用大写笔迹计算连通元件轮廓码本</h5><ul><li>对100个段落进行图像预处理，使用3x3<strong>平滑</strong>窗口对灰度图像进行<strong>模糊</strong>处理。然后再使用中点灰度值进行二值化，对于每个连接的组件，使用<strong>摩尔计算法</strong>计算轮廓。从最左边像素逆时针开始，对轮廓坐标开始记录，生成100个（x，y）坐标对。得到200维向量被称作<strong>连接组件轮廓</strong>COnnected-COmponent COntour (COCOCO or CO^3^)。<strong>（一个点的轮廓有100个坐标，200维向量，为一个连接组件）</strong><ul><li>图像平滑的目的：<ul><li>模糊：在提取较大目标前，去除小细节或者将目标内的小间断连接起来（论文用的这个）</li><li>消除噪声：改善图片质量，降低干扰</li></ul></li><li>摩尔邻域计算法：<ul><li>摩尔邻域也称为8邻域</li><li>先找到一个黑色像素，将它认定为你的起始像素。</li><li>以顺时针方向搜索摩尔邻域内的每一个像素，直到遇到下一个黑色像素。</li><li>行走到初始点时，走过的黑色像素就是目标的边缘。</li></ul></li></ul></li><li>100个段落产生了26896个连接组件轮廓，这些连接组件轮廓被用于33x33的<strong>自组织特征映射SOFM神经网络</strong>（应用于竞争学习而不是纠错学习）。<ul><li>自组织特征映射SOFM：一个神经网络接受外界输入模式时， 将会分为不同的对应区域， 各区域对输入模式具有不同的响应特征，而且这个过程是自动完成的。 自组织特征映射正是根据这一看法提出来的 ，其特点与人脑的自组织特性相类似。（神经网络，最后一天看这个）<ul><li>拓扑结构：SOFM网有两层，输入层神经元通过权重向量将外界信息汇集到输出层的神经元。输入层的神经元数与样本维数相等。</li><li>SOFM采用的学习算法为<strong>Kohonen算法</strong>，用大量训练样本调整网络的权值。SOFM网获胜的神经元不仅获胜的神经元本身调整权重，周围神经元也要调整权重。</li><li>每个节点大概25个样本（26896/33/33=24.69），程序的目标是为了产生精确的CO3形状，而不是为了以<strong>拓扑保持</strong>为目标。</li></ul></li></ul></li></ul><h5 id="3-3步骤二：计算特定书写人的特征向量"><a href="#3-3步骤二：计算特定书写人的特征向量" class="headerlink" title="3.3步骤二：计算特定书写人的特征向量"></a>3.3步骤二：计算特定书写人的特征向量</h5><ul><li>150名书写人，计算每个书写人，利用<strong>欧几里得最近邻</strong>搜索计算笔迹中CO3特征在SOFM中的节点出现情况的直方图。（求出书写人的CO3特征，与码本进行比较，与谁最像就选谁，然后计算选出最像的距离，求出概率密度，直方图。最后再做比较）</li></ul><p>$$<br>\begin{array}{l}<br>\vec{\xi} \leftarrow 0 \<br>forall \quad i \in \mathcal{K} \<br>{ \<br>\quad \vec{x}<em>{i} \leftarrow\left(\vec{x}</em>{i}-\mu_{x}\right) / \sigma_{r} \<br>\quad \vec{y}<em>{i} \leftarrow\left(\vec{y}</em>{i}-\mu_{y}\right) / \sigma_{r} \<br>\quad \vec{f}<em>{i} \leftarrow\left(X</em>{i 1}, Y_{i 1}, X_{i 2}, Y_{i 2} \ldots, X_{i 100}, Y_{i 100}\right) \<br>\quad k \leftarrow \operatorname{argmin}<em>{l}\left|\vec{f}</em>{i}-\vec{\lambda}<em>{l}\right| \<br>\quad \Xi</em>{k} \leftarrow \Xi_{k}+1 / N \<br>}<br>\end{array}<br>$$</p><ul><li>$\vec{\xi}$是连接组件CO3的概率密度函数，$\mathcal{K}$是测试集样本中检测到的连接组件集<ul><li>首先，将连接组件概率密度设为0</li><li>每个轮廓的坐标归一化再标准化（x-u/方差）</li><li>$\overrightarrow{f_{i}}$为100个标准化后的轮廓xy值。</li><li>在学习完毕的Kohonen-SOFM向量权重表中，寻找f的欧氏最近邻的索引k</li><li>PDF的k中的对应值被更新以最终获得p（CO3）</li><li>该概率密度被假定为一个书写人的描述，包含给定书写人的连接组件形状。</li></ul></li></ul><h5 id="3-4步骤三：书写人识别"><a href="#3-4步骤三：书写人识别" class="headerlink" title="3.4步骤三：书写人识别"></a>3.4步骤三：书写人识别</h5><ul><li>150位书写人的150个段落被分成上半部A和下半部B。分别为每个书写人计算p（CO3）组件轮廓的概率，集合A和B都计算。使用卡方距离测量。对于集合B中的每个书写人描述符，搜索集合A中的最近邻。</li></ul><p>$$<br>\chi_{i j}^{2}=\sum_{k=1}^{n} \frac{\left(\xi_{k i}-\xi_{k j}\right)^{2}}{\xi_{k i}+\xi_{k j}}<br>$$</p><ul><li><p>i和j是样本索引，k是<strong>bin index</strong>，n表示pdf中<strong>bin</strong>的数量，${\xi}$表示CO3码本的概率。</p></li><li><p>使用卡方距离（点与期望的差除以期望的平方价格开根号）的优点是，概率密度函数中低概率区域的差异比简单欧几里德距离度量更好，也比<strong>Bhattacharya距离</strong>更好。</p><ul><li>巴式距离，测量的是两个离散或连续概率分布的相似性。</li></ul></li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210823130705.png"></p><ul><li>上图为提取出来的轮廓的密度图，每个单元表示33X33的Kohonen码本中的CO3的概率密度，相同书写人密度就大，不同书写人，相同的很少。</li></ul><h4 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h4><ul><li><p>根据100组训练集得出的码本，计算测试集笔迹所对应的连接组件的概率密度，比较即可。</p></li><li><p>使用N=150个书写人的独立测试集。测试方法如下：对于测试集中的每个书写人，一个段落设为A，不同的段落设为B。测试的目的是为每个书写人从A中找到相应的段落B。</p></li><li><p>名为AB的测试是指一种保留一个的方法，所有A和B样本集都在一个集合中，一个接一个的取出查询样本，这意味着对A查询，样本B将变成目标。（先算一个，然后慢慢找剩下的299个）</p></li><li><p>名为“AvsB”的测试基于传统的不相交集，其中目标集只包含来自每个书写人的单个样本。因此，查询的干扰因素数量要少得多：150-1，命中的先验概率等于1/150。因此，不相交的“a vs B”测试将产生比更现实的漏掉一个的“AB”测试更好的结果。（把A和B分开，算一个A，从剩下的150个B中找）</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04年PAMI（二）</title>
      <link href="/posts/c771.html/"/>
      <url>/posts/c771.html/</url>
      
        <content type="html"><![CDATA[<h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><h5 id="3-3-第二阶段，计算特定书写人特征向量"><a href="#3-3-第二阶段，计算特定书写人特征向量" class="headerlink" title="3.3 第二阶段，计算特定书写人特征向量"></a>3.3 第二阶段，计算特定书写人特征向量</h5><ul><li>与其他报告的方法类似，书写人被认为是有限数量的信号源发生器。在当前研究中，一个基本模式由$CO^3$组成。假设一个个体作者的特征是基本笔画模式发射的离散概率密度函数。因此，从150名书写人数据库中针对每个书写人，通过对手写CO3的<strong>欧几里得最近邻</strong>搜索，计算出书写人CO3的 Kohonen SOFM节点出现的直方图，已确定SOFM中存在的模式，该算法的伪代码如下所示：</li></ul><p>$$<br>\begin{array}{l}<br>\vec{\xi} \leftarrow 0 \<br>forall \quad i \in \mathcal{K} \<br>{ \<br>\quad \vec{x} _ {i} \leftarrow\left(\vec{x}<em>{i}-\mu</em>{x}\right) / \sigma_{r} \<br>\quad \vec{y}<em>{i} \leftarrow\left(\vec{y}</em>{i}-\mu_{y}\right) / \sigma_{r} \<br>\quad \vec{f}<em>{i} \leftarrow\left(X</em>{i 1}, Y_{i 1}, X_{i 2}, Y_{i 2} \ldots, X_{i 100}, Y_{i 100}\right) \<br>\quad k \leftarrow \operatorname{argmin}<em>{l}\left|\vec{f}</em>{i}-\vec{\lambda}<em>{l}\right| \<br>\quad \Xi</em>{k} \leftarrow \Xi_{k}+1 / N \<br>}<br>\end{array}<br>$$</p><ul><li>$\vec{\xi}$是CO3的概率密度函数，$\mathcal{K}$是样本中检测到的连接组件集。<strong>标量向量</strong>元素显示为索引大写字母。步骤：</li><li><strong>标量向量：只有大小，没有方向。如：重量、温度、长度、时间、热量等。</strong><ul><li>首先，将PDF初始化为零。</li><li>然后，各个连通分量轮廓$\left(\vec{x}<em>{i}, \vec{y}</em>{i}\right)$被归一化为原点0，0和半径$\sigma_{r}=1$的<strong>标准差</strong>，如论文30，32所将。</li><li>CO3矢量$\overrightarrow{f_{i}}$包括重新采样到100个点的标准化轮廓X和Y的值。在预规范化Kohonen SOFM 向量表$\lambda$中，寻找$\overrightarrow{f_{i}}$的欧几里得最近邻的索引k和更新N=k的绝对值的pdf的相应值，最终获得p（CO3）。</li><li>假定这个pdf是一个书写人描述器，包含给定书写人大写字符连接组件形状发射可能性。</li><li>$\vec{\xi}$代表切分出来的片段的概率密度函数，$\mathcal{K}$是在样本中检测到的连接组件集。将概率密度函数初始化为零，然后将连通分量轮廓坐标$\left(\vec{x}<em>{i}, \vec{y}</em>{i}\right)$归一化到原点并且和半径$\sigma_{r}=1$的<strong>标准差</strong>。将整理好的数据用$\overrightarrow{f_{i}}$表示，这里的100个点都已经是经过标准化的。</li></ul></li></ul><h5 id="3-4书写人识别"><a href="#3-4书写人识别" class="headerlink" title="3.4书写人识别"></a>3.4书写人识别</h5><ul><li>150位书写人的150个段落被分成上半部A和下半部B。分别为每个书写人计算p（CO3）组件轮廓的概率，集合A和B都计算。使用卡方距离测量。对于集合B中的每个书写人描述符，搜索集合A中的最近邻。</li></ul><p>$$<br>\chi_{i j}^{2}=\sum_{k=1}^{n} \frac{\left(\xi_{k i}-\xi_{k j}\right)^{2}}{\xi_{k i}+\xi_{k j}}<br>$$</p><ul><li>i和j是样本索引，k是<strong>bin index</strong>，n表示pdf中<strong>bin</strong>的数量，${\xi}$表示CO3码本的概率。</li><li>使用卡方距离（点与期望的差除以期望的平方价格开根号）的优点是，概率密度函数中低概率区域的差异比简单欧几里德距离度量更好，也比<strong>Bhattacharya距离</strong>更好。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210823130705.png"></p><ul><li>上图为提取出来的轮廓的密度图，每个单元表示33X33的Kohonen码本中的CO3的概率密度，相同书写人密度就大，不同书写人，相同的很少。</li></ul><h4 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h4><ul><li>使用N=150个书写人的独立测试集，进行了大量性能比较。测试将按如下方式组织：对于测试集中的每个书写人，一个段落设为A，不同的段落设为B。测试的目的是为每个书写人从A中找到相应的段落B。</li><li>名为AB的测试是指一种保留一个的方法，所有A和B样本集都在一个集合中，一个接一个的取出查询样本，这意味着对A查询，样本B将变成目标。</li><li>作为基线性能的衡量标准，使用了边缘方向（特征0）。引入新的特征P（CO3）最为特征1.最后单独展示最近基于边缘方向和曲率特征（特征2），并与特征1结合使用</li></ul><h5 id="4-1-边缘方向概率密度直方图"><a href="#4-1-边缘方向概率密度直方图" class="headerlink" title="4.1 边缘方向概率密度直方图"></a>4.1 边缘方向概率密度直方图</h5><ul><li>开发了一个离线的基于边缘方向分布的方法。</li><li>使用两个不同的正交sobel内核进行卷积，然后进行阈值处理。该过程生成一个二进制图像，其中只有边缘像素是有的。</li></ul><h5 id="4-2-CO3概率密度直方图"><a href="#4-2-CO3概率密度直方图" class="headerlink" title="4.2 CO3概率密度直方图"></a>4.2 CO3概率密度直方图</h5><h5 id="4-3边缘铰链概率密度直方图"><a href="#4-3边缘铰链概率密度直方图" class="headerlink" title="4.3边缘铰链概率密度直方图"></a>4.3边缘铰链概率密度直方图</h5><h4 id="5-讨论"><a href="#5-讨论" class="headerlink" title="5.讨论"></a>5.讨论</h4><ul><li>反对：数据太干净、太好了</li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04年PAMI（一）</title>
      <link href="/posts/570b.html/"/>
      <url>/posts/570b.html/</url>
      
        <content type="html"><![CDATA[<h3 id="基于连通分量轮廓和大写西文字符边缘特征的自动书写者识别（Automatic-Writer-Identification-Using-Connected-Component-Contours-and-Edge-Based-Features-of-Uppercase-Western-Script）"><a href="#基于连通分量轮廓和大写西文字符边缘特征的自动书写者识别（Automatic-Writer-Identification-Using-Connected-Component-Contours-and-Edge-Based-Features-of-Uppercase-Western-Script）" class="headerlink" title="基于连通分量轮廓和大写西文字符边缘特征的自动书写者识别（Automatic Writer Identification Using Connected-Component Contours and Edge-Based Features of Uppercase Western Script）"></a>基于连通分量轮廓和大写西文字符边缘特征的自动书写者识别（Automatic Writer Identification Using Connected-Component Contours and Edge-Based Features of Uppercase Western Script）</h3><hr><p><strong>我们将展示手写大写字符中存在的特定于书写者的异体字形状变化如何允许有效的书写者识别。</strong></p><hr><h4 id="1-基于形状基元特征的方法"><a href="#1-基于形状基元特征的方法" class="headerlink" title="1.基于形状基元特征的方法"></a>1.基于形状基元特征的方法</h4><h5 id="1-1假设前提"><a href="#1-1假设前提" class="headerlink" title="1.1假设前提"></a>1.1假设前提</h5><ul><li>书写人被视为一个随机但服从某种规律的基元产生器。</li><li>笔迹书写过程可以看作若干个形状基元组装成一段文本内容的过程。</li><li>当笔迹包含足够多字符时，每个形状基元的使用概率被认为是相对独立鱼文本内容的，然后书写人对不同基元的使用频率的差异就可以用来表示该书写人的书写风格。</li></ul><h5 id="1-2步骤"><a href="#1-2步骤" class="headerlink" title="1.2步骤"></a>1.2步骤</h5><ul><li>首先要生成书写人可能使用的形状基元，也就是码本（codebook）。</li><li>根据得到的codebook，可以计算得到不同笔迹所对应的形状基元分布直方图。</li><li>形状基元分布最为接近的笔迹则最有可能来自同一书写人。</li></ul><h4 id="2-大牛论文74"><a href="#2-大牛论文74" class="headerlink" title="2.大牛论文74"></a>2.大牛论文74</h4><ul><li>老师Lamber Schhomaker和学生Marius Bulacu</li><li>基于连通分量轮廓和大写西文字符边缘特征的自动书写者识别</li><li>提出用于异形字符形状基元的描述的连通组件轮廓（Connected-Component Contours）特征</li><li>本文提出了一种利用大写手写体样本中的连通分量轮廓（COCOCO<del>s</del>或CO^3^<del>s</del>）进行离线书写人识别的新技术。在我们的模型中，书写人被认为具有随机模式生成器的特征，为大写字符集生成一系列连通组件。使用来自100名书写人的独立训练集的CO^3^<del>s</del>码本，针对包含150名不可见书写人的独立测试集计算CO^3^s的概率密度函数（PDF）。结果显示，CO^3^<del>s</del>的PDF对根据由大写字母组成的句子识别单个书写人具有高度敏感性。所提出的自动方法弥补了一端的图像统计方法和另一端的单个字符的人工测量异形特征之间的差距。将CO^3^的PDF与基于独立边缘的方向和曲率PDF相结合，可获得非常高的正确识别率。</li><li>自动、离线书写人身份识别再次引起人们的兴趣[1]、[2]、[3]、[4]、[5]。在诸如DNA分型[6]、[7]、指纹分类[8]、[9]和虹膜识别[10]等“更难”的生物特征身份识别形式中，人们的生活令人担忧，基于手写样本的身份识别似乎仍然是一种有用的应用。与法医实验室中使用的其他形式的生物特征身份识别不同，自动书写者身份识别通常允许结合犯罪的故意方面来确定身份，例如在威胁信的情况下。这是与其他生物特征识别方法的根本区别，在其他生物特征识别方法中，证据材料与犯罪细节之间的关系可能非常遥远。与基于DNA或虹膜的身份识别相比，书写者身份识别系统的目标性能更具压力。在法医笔迹鉴定中，根据经验法则，我们力求在100名笔迹的命中列表中，几乎100%地召回正确的笔迹，这些笔迹是从数据库中以10^4^个样本的顺序计算出来的，这是当前欧洲法医数据库中搜索集的大小。100名嫌疑人的打击名单是基于这样一种务实的考虑，即在刑事调查过程中，这样数量的案件几乎是可控的。</li><li>图像处理、模式分类和计算机技术的最新进展使当前的法医实践程序有了实质性的改进。存在三组脚本形状特征，它们来自法医程序中扫描的手写样本：<ul><li>从图像中的感兴趣区域（ROI）计算的全自动特征。</li><li>由人类专家使用专用的图形用户界面工具以交互方式测量特征。</li><li>基于字符的特征，由每个书写人生成相关的异形字子集。</li></ul></li><li>鉴于实际采集的手写体扫描样本的复杂性，应用领域的从业者对第一组特征持怀疑态度。事实上，自动前景/背景分离会在有污染和纹理丰富的片段上失败，而墨水痕迹通常很难识别。然而，最近在使用“软计算”方法的图像处理方面取得了一些进展，即将模糊逻辑和遗传算法的工具结合起来，从而为前景/背景分离过程提供了先进的半交互式解决方案[2]。在这些条件下，并假设存在足够的计算能力，使用自动计算的图像特征（上文第1组）变得可行。在详细讨论方法和结果之前，我们将介绍所提出方法的基本原理和一般模型。</li><li>一般认为，大写字符包含的特定于书写者的信息比连接的草书手写笔迹少。这一假设得到了观察的证实，即大写孤立字符的自动分类比连体草书的识别更容易。然而，大写字母之间的识别性能差异很大，字符与自由字的区别可以归结为字符分割问题。图1显示了导致书写变化的四个因素。(第一是书写人控制的大小倾斜程度啥的，第二是精神状态)<ul><li>第一个因素涉及<strong>仿射变换</strong>,它由作者自愿控制。大小、平移、旋转和剪切的变换是令人讨厌的，但不是手写识别或书写者识别的基本障碍。特别是，倾斜（剪切）构成了一个习惯性参数，由笔握和手腕子系统相对于手指的方向决定[12]。</li><li>第二个因素涉及<strong>神经生物力学变异性</strong>，有时被称为“松散空间”：局部环境和生理状态决定了在字符形状形成上花费的努力量，并决定了书写样本的易读性。在实现预期形状时，作者必须发送运动控制模式，以补偿生物力学末端执行器的低通滤波效应。这类变异源还包括震颤和精神药物对书面运动控制过程的影响。因此，该因素与系统状态的关系比与系统标识的关系更大。</li><li>第三个因素也高度<strong>依赖于手写过程中的瞬时系统状态</strong>，并由<strong>顺序可变性表示</strong>（图1c）：笔划顺序可能随机变化，如大写字母E的产生。一个四冲程的E可以在4分钟内产生！24¼384个排列。在一些亚洲文字（如汉字）的书写过程中，笔画顺序的随机排列是手写识别中的一个众所周知的问题（尽管学校对笔画顺序的训练相当严格）。最后，可能会出现拼写错误，并导致在书写顺序中出现临时编辑笔划。尽管通常认为序列可变性仅对基于时间（在线）信号的手写识别造成问题，但事后编辑的示例（图1c）表明，静态、光学效应也是这种变化形式的可能结果。</li><li>第四个因素是<strong>异体变异</strong>（图1d），指的是特定于书写者的字符形状现象，这在自动手写体识别中产生了大部分问题，但同时也为自动书写者识别提供了信息。<strong>在本文中，我们将展示手写大写字符中存在的特定于书写者的异体字形状变化如何允许有效的书写者识别。</strong></li></ul></li></ul><h5 id="2-1识别大写字符的异体字变化的理论"><a href="#2-1识别大写字符的异体字变化的理论" class="headerlink" title="2.1识别大写字符的异体字变化的理论"></a>2.1识别大写字符的异体字变化的理论</h5><ul><li>两个基本因素促成了笔迹的个性，即异体变异：遗传（生物）和模因（文化）因素。<ul><li>第一个基本因素是书写人的基因构成。已知或可能假设遗传因素有助于书写风格的个性<ul><li>手的生物力学结构，即手腕和手指腕骨的相对大小及其对握笔的影响。</li><li>左撇子或右手</li><li>肌肉力量、疲劳、周围运动障碍</li><li>中枢神经系统（CNS）特性，精细运动控制能力和运动任务执行中中枢神经系统的稳定性</li></ul></li><li>第二个因素包括记忆或文化转移对笔握风格和人物造型（异体字）的影响[16]，这些影响是在教育过程中训练的，或者是通过观察他人的作品学习的。尽管模因性这个词经常被用来描述思想和知识的演变，将字符形状的演变和传播视为模因过程似乎没有根本的反对意见：字符形状的适应功能取决于1）易读性和2）书写工具的易用性[17]的相互冲突的影响，这在文化和社会中是可用的。异体字在作家群体中的分布很大程度上受学校教授的写作方法的影响，而学校教授的写作方法又取决于地理分布、宗教和学校类型等因素。例如，在荷兰，新教徒和天主教作家、不同世代的作家和移民作家之间可能存在异书差异。</li></ul></li><li>遗传因素和文化因素共同决定了一个习惯性的书写过程，在书写痕迹的局部层面，在整个字符形状层面，以及字符位置和页面布局层面，都有可识别的形状元素。<strong>在本论文中，我们将重点放在手写轨迹的局部级别和字符级别。</strong></li><li>书写人在书写表面上产生二维（x，y）的笔尖轨迹，通过垂直移动（z）调节笔尖在书写表面上方的高度。着陆时，位移控制由力控制（F）代替。笔尖在两个笔尖向下时之间的空中轨迹包含有价值的特定于书写者的信息，但对于离线扫描的手写样本，它的形状是未知的。类似地，笔力信息对作者的身份信息非常丰富，但无法直接从离线扫描中得知[18]。最后，使用手写形状识别书写者的一个重要理论基础是，手写不是一个反馈过程，它在很大程度上取决于环境中的外围因素。由于神经和神经机械传播延迟，仅基于连续反馈机制的手写过程将发展得太慢。因此，大脑在时间上持续规划一系列的弹道运动，也就是说，以前馈的方式。假设一个字符是由一个“**运动程序”[20]**产生的，即一个可配置的运动模式生成器，它需要在触发前指定一系列参数值，以通过墨水沉积[24]、[25]产生笔尖运动，从而产生字符形状[21]、[22]、[23]。尽管到目前为止描述的过程涉及连续变量，如位移、速度和力控制，笔迹的语言基础允许假定一个给定字符形状所指的字母表中的离散符号。</li></ul><h5 id="2-2模型"><a href="#2-2模型" class="headerlink" title="2.2模型"></a>2.2模型</h5><ul><li><p>假设对于给定的字母表L存在一个有限的异体字列表S，每个异体字$S_{li}$都被认为是字母$l$第i个允许的样式变化，原则上，该字母在书写-阅读通信线路的接收端应清晰可见[26]。异体变异的来源可能在于教学方法和个人偏好。因此，人类书写者被认为是一个模式生成器，在即将书写字母$l$时随机选择每个异体字形状$S_{li}$。假设概率密度函数$p_w(S)$，即书写人$w$发出异体字的概率，将在识别书写人$w$时提供信息。他认为:<br>$$<br>w \neq v \Rightarrow p_{w}(S) \neq p_{v}(S)<br>$$</p><ul><li>w和v代表两个书写人</li><li>S是一个常见的通用异体字码本（Common allograph codebook）</li><li>p代表发射异体字的离散概率密度函数</li></ul></li><li><p>公式一是可以实现的，如果书写人w发出的手写样本u的特点是<br>$$<br>\vec{ x } _ { w u } = p _ { w u } ( S ),<br>$$</p></li><li><p>假设样本u具有代表性，则样本u就被表示为书写人w的概率密度函数</p></li></ul><p>$$<br>\vec{x} _ {w u} \approx p_{w}(S) \text {, }<br>$$</p><ul><li>他认为</li></ul><p>$$<br>\forall a, b, c, w, v \neq w: \Delta\left(\vec{x} _ {w a}, \vec{x} _ {w b}\right)&lt;\Delta\left(\vec{x} _ {w a}, \vec{x} _ {v c}\right),<br>$$</p><ul><li>$\Delta$是概率密度函数上的一个适当距离函数$\vec{x}$，v和w表示书写人，a，b，c是手写样本标识符。等式4表明，在特征空间中，<strong>同一作者的任意两个样本之间的距离小于不同作者的任意两个样本之间的距离</strong>。在理想情况下，这种关系将始终保持，从而形成完美的书写人识别。在模型1中，含义是单向的，在伪造笔迹的情况下，$p_{w}(S)$不等于$p_{v}(S)$，但是把书写人w强制变为v。</li><li>在这一点上的一个问题是，为了实现这种随机异体字模型，很难获得特定笔迹和字母表的异体字的详尽列表S。然而，手写图像数据的数量（不存在字符背景真实性）远远超过了商业和学术训练集的大小，而商业和学术训练集是在单个字符的水平上进行标记的。目前，还不存在一份普遍接受的手写异体字列表（及其普遍接受的名称，如拉丁语，如生物学领域的物种分类）。在这方面，值得注意的是，对于机器打印字体，由于其形状与手写变体相比存在微小差异，因此存在命名字体类别（例如，Times Roman、Helvetica等），而我们不使用手写字符族的通用名称。</li><li>因此，使用一种有益的方法来避免在训练和操作阶段都需要昂贵的字符标签。<strong>与手写体中的字符分割相反，可以以非参数方式可靠地检测连接的组件。</strong>那么，问题是这样的子分配文本片段是否可以用于作者识别。</li><li>如果每个异形字符由一组非空的连接组件 $c_j$ 组成, $ s _ { l i } = \left { c _ { 1 } , c _ { 2 }, \ldots, c _ {m} \right } $ ,我们假设所有可能的异形字符都可以由有限集或码本C的连通组件估计。此外，如果我们假设连通组件的形状是其作为元素的异体字符变体的信息，那么对于概率函数</li></ul><p>$$<br>\vec{\xi} _ {w u}=p _ {w u}(C)<br>$$</p><ul><li>书写人w从手写样本u中导出连通组件，和公式4类似</li></ul><p>$$<br>\forall a, b, c, w, v \neq w: \Delta\left(\vec{\xi} _ {w a}, \vec{\xi} _ {w b}\right)&lt;\Delta\left(\vec{\xi} _ {w a}, \vec{\xi} _ {v c}\right)<br>$$</p><ul><li>假设样本u具有代表性，则：<strong>（连通组件的概率密度就可以表示书写人w的特征）</strong></li></ul><p>$$<br>\vec{\xi} _ {w u} \approx p _ {w}(C)<br>$$</p><ul><li>一个潜在的问题涉及触碰字符的现象（<strong>phenomenon of touching characters</strong>）。对于本文中提出的方法，，如果产生连接或重叠字母组合的倾向对于作者来说是典型的，那么这将不会构成真正的问题。在下一节中，我们将描述连接组件码本C的构造、特定书写人基元发射pdf的计算，以及pdf的适当距离函数$\Delta$</li></ul><h5 id="2-3-设计考虑"><a href="#2-3-设计考虑" class="headerlink" title="2.3 设计考虑"></a>2.3 设计考虑</h5><ul><li>在应用领域中，<strong>稀疏参数（sparse-parametric）方法有几个优点</strong>，因为新数据可以很容易地合并，而无需重新训练。在目前的研究中，由于使用了基于包含大量参数的<strong>自组织映射的码本</strong>，因此无法实现这一目标。<strong>然而，在处理管道中，特定于域的启发式的使用保持在最低限度。</strong>没有基于规则的图像增强功能。图像和轮廓规格化的数量也将保持在最低限度。将使用简单的距离计算，<strong>避免昂贵的权重使用</strong>（<strong>如多层感知器或基于支持向量机的训练相似性函数）</strong>。关于目标应用程序，应该注意，所提出的方法是大小不变的。而，在伪造笔迹的情况下，伪造者试图改变笔迹样式，通常是通过更改倾斜和/或所选的异体字。通过详细的手工分析，法医专家有时能够正确识别伪造的手写样本。然而，所提出的算法旨在从数据库中恢复正确的已知样本，以获得作者未知的查询样本，前提是这两个样本都是以可比的自然写作态度生成的</li></ul><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h4><h5 id="3-1数据"><a href="#3-1数据" class="headerlink" title="3.1数据"></a>3.1数据</h5><ul><li>从Firemaker1数据库中的250名作者的手写页面中，使用了“第2页”，即由大写手写文本复制而成的集合。该文本由两句话组成，共有65个文本块，即单词和金额（表1），以300 dpi的灰度扫描，在带消失线颜色（黄色）的划线纸上。字数相当于一段文字。该文本是在法医实践中设计的，涵盖了足够数量的字母表中的不同字母，同时对大多数嫌疑人来说仍然是可写的。图2显示了由单个作者编写的此类段落的片段。</li><li><strong>一组100个段落被尽可能多的书写人用于训练目的。剩下的150个段落被同样多但不同的作者用来测试书写人身份。</strong>处理需要三个步骤：<ul><li>以大写笔迹计算连接部件轮廓的码本。</li><li>计算特定书写人的特征向量</li><li>书写人识别</li></ul></li><li>在下文中使用特征（feature）一词时，都应理解为书写人特征向量（writer- feature vector）</li></ul><h5 id="3-2第一阶段，用大写笔迹计算连通元件轮廓码本"><a href="#3-2第一阶段，用大写笔迹计算连通元件轮廓码本" class="headerlink" title="3.2第一阶段，用大写笔迹计算连通元件轮廓码本"></a>3.2第一阶段，用大写笔迹计算连通元件轮廓码本</h5><ul><li><strong>对100个段落的图像进行处理</strong>，以提取代表手写墨水的连接组件。使用3x3平面平滑窗口对灰度图像进行模糊处理，然后使用中点灰度值进行二值化。对于每个连接的组件，使用<strong>摩尔算法计算其轮廓</strong>，以逆时针方式从最左边的像素开始。对生成的轮廓坐标进行重新采样，以便包括100个XY坐标对。得到固定（N=200）200维向量被称为连接组件轮廓COnnected-COmponent COntour $(COCOCO or CO^3)$</li><li>100个段落产生了26896个连接组件轮廓CO^3^，这些连接组件轮廓被呈现给33x33节点的<strong>自组织特征映射（SOFM）</strong>论文29。从而产生每个Kohonen节点约25个样本的先验均匀覆盖。目标是为了产生精确的co3形状表，而不是以<strong>拓扑保持</strong>为目标。因此使用了大量的<strong>500为时期epoch</strong>来训练网络，<strong>网络气泡</strong>大小从训练开始时的<strong>半径33</strong>（完整网络）到训练结束时的0（一个节点）不等。培训开始时学习率为0:9，培训结束时为0:015。通常，在训练Kohonen自组织图时，使用<strong>线性冷却计划（linear cooling schedules）</strong>。然而，如果目标是在可能的模式集合和有限的<strong>Kohonen单元集合</strong>之间获得验证性的最小均方根误差，则已证明使用急剧衰减的温度是有益的**[30]**。Kohonen放松过程大致可分为三个阶段。<ul><li><strong>chaotic oscillation 混沌震荡</strong></li><li><strong>structural consolidation 结构稳固</strong></li><li><strong>fine tuning 微调</strong></li></ul></li><li>使用线性温度冷却计划有助于在有限的时间段内获得具有<strong>拓扑保持特性</strong>的地图。然而，使用<strong>气泡半径</strong>和<strong>学习率的非线性和急剧衰减函数</strong>会导致长时间的微调阶段，在呈现足够多的训练时段后产生可靠的码本。</li><li>应该注意的是，过拟合在这里不是一个问题：在Kohonen自组织映射中，过拟合的程度主要取决于单元的数量。考虑到这些因素，根据以下功率函数（8），采用了快速冷却计划：</li></ul><p>$$<br>r_{k}=\left(\left(r_{m}^{1 / s}-r_{0}^{1 / s}\right) \frac{k}{m}+r_{0}^{1 / s}\right)^{s}<br>$$</p><ul><li>s是陡峭程度因子</li><li>r是<strong>递减训练参数（此处为学习率或Kohonen气泡半径）</strong></li><li>k=[0，m]是<strong>epoch时期计数器</strong>，m是最后一个训练时期</li><li>如果s=1，r<del>k</del>是线性函数</li><li>如果s=5，<strong>这种相对较高的陡度通过缩短最初不规则状态空间演化的持续时间来加速自组织过程。</strong></li><li>在结束训练时，产生的SOFM自组织特征映射如图所示</li><li>该表被认为是构成计算书写人连接组件轮廓cococo发射器概率所需的码本C。</li><li>Kohonen训练将轮廓的每个坐标x或y的初始均方根误差（0.036）减少到500个历元时的均方根误差（0.010）。当使用生成的码本对所有书写人的连接组件轮廓进行最近邻搜索时，Kohonen网络的PDF作为通信信道在33x33的离散符号，产生的所有无序状态大小为9.8位。</li></ul><h5 id="3-3第二阶段，计算特定书写人特征向量"><a href="#3-3第二阶段，计算特定书写人特征向量" class="headerlink" title="3.3第二阶段，计算特定书写人特征向量"></a>3.3第二阶段，计算特定书写人特征向量</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔迹鉴定PPT总结</title>
      <link href="/posts/7980.html/"/>
      <url>/posts/7980.html/</url>
      
        <content type="html"><![CDATA[<h3 id="笔迹鉴定PPT总结"><a href="#笔迹鉴定PPT总结" class="headerlink" title="笔迹鉴定PPT总结"></a>笔迹鉴定PPT总结</h3><p><a href="https://leng-bingo.synology.me:5001/d/s/l5hlhJJYhUkelZldzJsQW75XEQ3CsGYu/yNHc32VjcSllVh1_GJfLQzkYvTa3DZy8-ibSgTcvt2Ag" target="_blank" rel="noopener">文件链接</a></p><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182437.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182543.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182642.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182724.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182756.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182828.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819182904.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183039.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183059.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183123.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183140.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183213.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183228.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183257.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183312.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183330.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183348.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183411.png"><br><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/20210819183425.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔迹鉴定（三）</title>
      <link href="/posts/384b.html/"/>
      <url>/posts/384b.html/</url>
      
        <content type="html"><![CDATA[<h3 id="笔迹鉴定（三）"><a href="#笔迹鉴定（三）" class="headerlink" title="笔迹鉴定（三）"></a>笔迹鉴定（三）</h3><h4 id="9-SIFT字对相似度辅助识别"><a href="#9-SIFT字对相似度辅助识别" class="headerlink" title="9.SIFT字对相似度辅助识别"></a>9.SIFT字对相似度辅助识别</h4><ul><li><p>SIFT就是找到图片信息中一种关键点的算法。</p></li><li><p>某些高频字和词常会同时出现在查询笔迹和参考笔迹中。我们把出现在<strong>查询笔迹</strong>和<strong>参考笔迹</strong>的<strong>两个相同单字称为一个字对</strong>。如果字对中两个单字具有很高的相似度，那么查询笔迹和参考笔迹很有可能来自同一个人。</p></li><li><p>先从笔迹中<strong>提取边缘共生</strong>特征，并将其用<strong>文本无关相似度</strong>（两个之间的距离计算）做计算。</p></li><li><p>字对相似度计算：</p><ul><li>关键点及其SIFT描述子提取</li><li>关键点匹配：从同一字对中提取出关键点后，对不同单字的关键点进行匹配，匹配成功才会用于计算字对相似度</li><li>字对相似度计算</li></ul></li><li><p>与此同时，每个字对中两个单字图像的关键点及其 SIFT 描述被提取出来，并根据关键点的位置信息和 SIFT 描述子信息进行匹配。</p></li><li><p>每个出现在参考笔迹和查询笔迹中的字对的相似度由字对中匹配上的关键点对的 SIFT 描述子距离的平均值表示。</p></li><li><p>而笔迹间的字对相似度由所有的单个字对的相似度的平均值表示。</p></li><li><p>在文本无关相似度和字对相似度都完成计算后，它们将进行融合，并用于计算最终的笔迹相似度。</p></li><li><p>自我理解：<strong>边缘共生对提取出一组字对，进行相似度计算，然后再利用SIFT选出关键点，在进行相似度计算，最终将两个特征的相似度融合。</strong></p></li></ul><h4 id="10-位移场的字对检测"><a href="#10-位移场的字对检测" class="headerlink" title="10.位移场的字对检测"></a>10.位移场的字对检测</h4><ul><li>不依赖字符识别的基于位移场的字对检测和相似度计算方法，并将得到的字对相似度与基于边缘共生特征的文本无关相似度结合。</li><li>图像配准领域，图像配准是指通过某种空间变换将在不同条件下采集的同一场景或目标的多幅图像映射到同一坐标系下的过程</li><li><strong>图像配准技术的流程如下</strong>：<ul><li>首先对两幅图像进行特征提取得到特征点；</li><li>通过进行相似性度量找到匹配的特征点对；</li><li>然后通过匹配的特征点对得到图像空间坐标变换参数；</li><li>最后由坐标变换参数进行图像配准。</li></ul></li><li><strong>图像配准的方式：</strong><ul><li><strong>相对配准</strong>是指选择多图像中的一张图像作为参考图像，将其它的相关图像与之配准，其坐标系统是任意的。</li><li><strong>绝对配准</strong>是指先定义一个控制网格，所有的图像相对于这个网格来进行配准，也就是分别完成各分量图像的几何校正（消除误差，一般就是倾斜、平移和旋转啥的）来实现坐标系的统一。</li></ul></li><li>两个图像间的对应关系由位移场来表示。</li><li>常用求解办法基于Demons算法<ul><li>demons算法是一种全局坐标变换模型的配准算法，该算法使用参考图像的梯度以及参考图像与浮动图像的灰度差值来计算每一个点的坐标偏移量，从而得到参考图像与浮动图像的整幅图的坐标偏移量，并使用坐标偏移量对浮动图像进行重采样和插值，重复迭代此过程直到迭代次数达到设定次数或参考图像与浮动图像相似度达到设定阈值为止。</li></ul></li><li>同一书写人书写的相同字符比较相似，之间的差异较小，图像配准后的图像差异也较小。不同书写人的字符之间差异较大，图像配准后的差异也会很大。所以可以利用配准后图像的差异大小来衡量单字之间的相似程度。</li><li>先提取边缘共生特征，进行文本无关相似度测量。然后再用基于位移场的方法进行字对相似度计算。最终相似度融合，得出候选人名单。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔迹鉴定（二）</title>
      <link href="/posts/1276.html/"/>
      <url>/posts/1276.html/</url>
      
        <content type="html"><![CDATA[<h3 id="笔迹鉴定（二）"><a href="#笔迹鉴定（二）" class="headerlink" title="笔迹鉴定（二）"></a>笔迹鉴定（二）</h3><h4 id="1-论文9"><a href="#1-论文9" class="headerlink" title="1.论文9"></a>1.论文9</h4><p>State of the art in off-line writer identification of handwritten text and survey of writer identification of Arabic text </p><p><strong>离线书写人识别技术现状及阿拉伯文本书写人识别综述</strong>   </p><h5 id="1-1最小距离分类器"><a href="#1-1最小距离分类器" class="headerlink" title="1.1最小距离分类器"></a>1.1最小距离分类器</h5><ul><li><p>最小距离分类器通过测量从测试样本到训练模式的距离并选择最近邻所属的K-nearest classes（<strong>KNN</strong>）来对新模式进行分类。</p></li><li><p>K最近邻(kNN，k-NearestNeighbor)分类算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。</p></li><li><p><strong>当预测一个新的值 $ x$ 时，根据它距离最近的 $ K$ 个点是什么类别来判断 $ x$ 属于哪个类别</strong></p></li><li><p>绿色的点是我们要预测的点，假设 $ K=3$ 。那么KNN算法就会找到距离他最近的三个点，看看哪种类别多一些。图中蓝色三角形为两个，红色圆形为一个。所以新的绿色点就被归类到蓝色三角形了。</p></li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174428395-6404591.png" alt="K=3"></p><ul><li>但是，<strong>当 $ K=5$ 的时候，判定就变成不一样了</strong>。这次变成红圆多一些，所以新来的绿点被归类成红圆。所以$ K $的取值是很重要的。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/1011838-20190125174434360-1539590461.png" alt="K=5"></p><ul><li><p>K值的选取和点距离的计算是KNN中最重要的。</p></li><li><p>常见的有曼哈顿距离计算，欧式距离计算等等</p></li><li><p>二维空间两个点的欧式距离计算公式为：<br>$$<br>\rho = \sqrt { \left ( x _ { 2 } - x _ { 1 } \right ) ^ { 2 } + \left ( y _ { 2 } - y _ { 1 } \right ) ^ { 2 } }<br>$$</p></li><li><p>拓展到多维空间的欧式距离为：</p></li></ul><p>$$<br>d(x, y):=\sqrt{\left(x_{1}-y_{1}\right)^{2}+\left(x_{2}-y_{2}\right)^{2}+\cdots+\left(x_{n}-y_{n}\right)^{2}}=\sqrt{\sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}}<br>$$</p><ul><li>K值的选择：通过交叉验证，选取一个小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K。</li></ul><h4 id="2-论文10"><a href="#2-论文10" class="headerlink" title="2.论文10"></a>2.论文10</h4><p>Offline Text-Independent Writer Recognition: A Survey</p><p><strong>离线文本书写人识别</strong></p><ul><li>当作者数量增加时，基于频域特征的方法的性能严重下降，并且空间分布特征在捕获个体特征方面优于频域特征和形状特征。</li><li>频域特征：图像经过傅立叶变换后得到频谱图，就是图像梯度的分布图。设置手写体在频域中的全局特征。</li><li>空间分布特征设计手写体的局部空间结构特征。</li></ul><h4 id="3-论文12-Personal-identication-based-on-handwriting"><a href="#3-论文12-Personal-identication-based-on-handwriting" class="headerlink" title="3.论文12 Personal identication based on handwriting"></a>3.<span id="text12">论文12 Personal identication based on handwriting</span></h4><p>Personal identication based on handwriting</p><p><strong>书写人身份识别</strong></p><ul><li>图像归一化:归一化后所有像素值都在[0，1]之间。</li><li>特征提取：多通道Gabor滤波（MGF），灰度共生矩阵（GSCM？？？GLCM）</li><li>灰度共生矩阵：指的是一种通过研究灰度的空间相关特性来描述纹理的常用方法。由于纹理是由灰度分布在空间位置上反复出现而形成的，因而在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。</li><li>用了两种分类器：加权欧式距离（WED）和K-近邻分类器（KNN）</li></ul><h4 id="4-论文77-A-Comparison-of-Clustering-Methods-for-Writer-Identification-and-Verification"><a href="#4-论文77-A-Comparison-of-Clustering-Methods-for-Writer-Identification-and-Verification" class="headerlink" title="4.论文77 A Comparison of Clustering Methods for Writer Identification and Verification"></a>4.<span id="text77">论文77 <strong>A Comparison of Clustering Methods for Writer Identification and Verification</strong></span></h4><p>书写人识别和鉴定的聚类方法比较</p><ul><li>通过聚类获得给定笔迹样本的字形码本。（k-means（最简单的聚类，以k为距离划分）, Kohonen SOM 1D and 2D.）</li><li>分割方法：靠近上轮廓的下轮廓的最小值处分段，然后经过某种处理，储存下来。</li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/docdownpNCnLk.gif" alt="分割方法"></p><h4 id="5-论文96Offline-Writer-Identification-Using-Convolutional-Neural-Network-Activation-Features"><a href="#5-论文96Offline-Writer-Identification-Using-Convolutional-Neural-Network-Activation-Features" class="headerlink" title="5.论文96Offline Writer Identification Using Convolutional Neural Network Activation Features"></a>5.<span id="text96">论文96Offline Writer Identification Using Convolutional Neural Network Activation Features</span></h4><p>离线书写人识别，利用卷积神经网络</p><h5 id="5-1输入层"><a href="#5-1输入层" class="headerlink" title="5.1输入层"></a>5.1输入层</h5><ul><li>一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于卷积神经网络在CV领域应用较广，因此许多研究在介绍其结构时预先假设了三维输入数据，即平面上的二维像素点和<a href="https://baike.baidu.com/item/RGB/342517" target="_blank" rel="noopener">RGB</a>通道。</li><li>使用梯度下降算法学习（是迭代法的一种，用于求解最小二乘问题，在求解损失函数的最小值时，可以通过梯度下降法一步一步迭代求解，得到最小化的损失函数和模型参数值）</li><li>若输入数据为像素，可以将[0，25]的原始像素归一化为[0，1]区间，输入特征的标准化有利于提升卷积神经网络的学习效率和表现。</li><li>卷积神经网络的隐含层包含卷积层、池化层和全连接层3类常见构筑，</li><li>卷积层的功能是对输入数据进行特征提取，其内部包含多个卷积核，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector），类似于一个前馈神经网络的神经元（neuron）</li></ul><h4 id="6-常用的图像预处理手段"><a href="#6-常用的图像预处理手段" class="headerlink" title="6.常用的图像预处理手段"></a>6.常用的图像预处理手段</h4><ul><li>去噪：使用滤波器去除</li><li>二值化：小于阈值设置为0，大于设置为255</li><li>边缘检测：本质上是一种滤波算法。数组点乘边缘算子，然后再取绝对值，对x、y轴共进行两次滤波，得到的结果进行平方求和开根号得到当前像素点的图像梯度，就求出了边缘。</li><li>倾斜校正</li><li>文本提取</li></ul><h4 id="7-分类器的选择"><a href="#7-分类器的选择" class="headerlink" title="7.分类器的选择"></a>7.分类器的选择</h4><ul><li>小类别集且数据量够多时，可以训练数据得到优秀的模型</li><li>当类别多，但每个类别少时，基于距离度量的简单分类器性能更稳定</li><li></li></ul><h4 id="8-特征的分类"><a href="#8-特征的分类" class="headerlink" title="8.特征的分类"></a>8.特征的分类</h4><h5 id="8-1纹理特征"><a href="#8-1纹理特征" class="headerlink" title="8.1纹理特征"></a>8.1纹理特征</h5><h6 id="8-1-1频域特征"><a href="#8-1-1频域特征" class="headerlink" title="8.1.1频域特征"></a>8.1.1频域特征</h6><ul><li><p>在图像处理中，时域可以理解为空间域，处理对象为图像平面本身。频域就是频率域，是描述信号在频率方面特性时用到的一种坐标系。自变量是频率，即横轴是频率，纵轴是该频率信号的幅度，也就是通常说的频谱图。频谱图描述了信号的频率结构及频率与该频率信号幅度的关系；</p></li><li><p>将笔迹的图像转化为频域信号，通过提取频域信号中的若干属性作为笔迹的特征。</p></li></ul><h6 id="8-1-2空间分布特征"><a href="#8-1-2空间分布特征" class="headerlink" title="8.1.2空间分布特征"></a>8.1.2空间分布特征</h6><ul><li><p>空间分布特征是直接统计边缘像素、关键点以及文本行中特定的空间结构来表示笔迹的个性化差异。</p></li><li><p><a href="#text12">灰度协方差矩阵</a>，也是统计纹理特征的一种方法</p></li><li><p>灰度游程直方图/灰度游程矩阵：一幅图像的灰度游程矩阵反映了图像灰度关于方向，相邻间隔和变化幅度等综合信息。灰度游程矩阵是对分析影像的局部模式和其排列规则基础之一。灰度游程矩阵可以实现对一幅图像中同一方向同一灰度值连续出现个数的统计。在一幅图像上，在某一方向上连续的像素点具有相同的灰度值，灰度游程矩阵就是通过对这些像素点的分布进行统计得到纹理特征。</p></li><li><p>梯度：相邻两个像素之间的差值。可以利用求出来的梯度，增强图片对比度，清晰轮廓。（<strong>梯度加原有点像素</strong>）</p></li><li><p>边缘方向特征：一条边缘和中心夹角的概率分布直方图来表示特征</p></li><li><p>边缘铰链特征：两条与中心相连通的边缘像素的夹角</p></li><li><p>尺寸不变特征变换（Scale invariant feature Transform,SIFT）：目标是解决低层次特征提取及其图像匹配应用中的许多实际问题。SIFT算法主要包括两个阶段，一个是SIFT特征的生成，即从多幅图像中提取对尺度缩放、旋转、亮度变化无关的特征向量；第二阶段是SIFT特征向量的匹配。SIFT方法中的低层次特征提取是选取那些显特征，这些特征具有图像尺度(特征大小)和旋转不变性，而且对光照变化也具有一定程度的不变性。此外，SIFT方法还可以减少由遮挡、杂乱和噪声所引起的低提取概率。</p></li><li><p>加速鲁棒特征Surf（Speeded Up Robust Features）：Sift尺寸不变特征变换算法的优点是特征稳定，对旋转、尺度变换、亮度保持不变性，对视角变换、噪声也有一定程度的稳定性。缺点是实时性不高，并且对于边缘光滑目标的特征点提取能力较弱。<br> Surf改进了特征的提取和描述方式，用一种更为高效的方式完成特征的提取和描述。</p></li></ul><h5 id="8-2形状基元"><a href="#8-2形状基元" class="headerlink" title="8.2形状基元"></a>8.2形状基元</h5><ul><li>前提假设：书写人被视为一个随机但服从某种规律的基元产生器。而笔迹书写过程可以看作多个基础基元零件被组成一个个文字的过程。当笔迹的字足够多时，每个基元零件出现的概率就可以用来表示书写人的特征。</li><li><a href="#text77">论文77</a>：利用聚类讨论可能对基元码本可能产生的影响</li></ul><h5 id="8-3深度学习特征"><a href="#8-3深度学习特征" class="headerlink" title="8.3深度学习特征"></a>8.3深度学习特征</h5><ul><li><a href="#text96">论文96</a></li></ul><h4 id="9-公共数据库"><a href="#9-公共数据库" class="headerlink" title="9.公共数据库"></a>9.公共数据库</h4><h5 id="9-1中科院CASIA数据集"><a href="#9-1中科院CASIA数据集" class="headerlink" title="9.1中科院CASIA数据集"></a>9.1中科院CASIA数据集</h5><p>CASIA-OLHWDB1.0 ：手写单字，171 个英文数字符号，3866 个常用汉字(其中3740个属于GB2312 - -级汉字)，420套，分别为420个人书写。总共1,694,741个有效样本，分别存在420个POT文件中。</p><p>CASIA-OLHWDB1.1 ：手写单字，171个英文数字符号，3755个GB2312级汉字，300套，分别为300个人书写。总共1,174,364个有效样本。分别存在300个POT文件中。</p><p><a href="http://www.nlpr.ia.ac.cn/databases/handwriting/Download.html" target="_blank" rel="noopener">下载地址</a>其他的数据集需要申请。</p><h5 id="9-2哈工大HIT-OR3C数据集"><a href="#9-2哈工大HIT-OR3C数据集" class="headerlink" title="9.2哈工大HIT-OR3C数据集"></a>9.2哈工大HIT-OR3C数据集</h5><p>HIT-OR3C由5个子集组成 （GB1, GB2, Digit, Letter, 和Document），GB1和GB2是汉字标注库GB2312-80内2个子集的简写。GB1, GB2, Digit, 和 Letter子集已采集完成122套，共832,650 个手写汉字。Document子集包括10个从新浪网收集的文档，每个文档采集2套，共收集了20套。文档子集共有77,168个字符， 覆盖2,442个字符，其中2,286个来自GB1，97个来自GB2，49个来自Letter， 10个来自 Digit。</p><p><a href="http://www.iapr-tc11.org/mediawiki/index.php/Harbin_Institute_of_Technology_Opening_Recognition_Corpus_for_Chinese_Characters_(HIT-OR3C" target="_blank" rel="noopener">下载地址</a></p><h5 id="9-3华南理工SCUTCOUCH-2009数据集"><a href="#9-3华南理工SCUTCOUCH-2009数据集" class="headerlink" title="9.3华南理工SCUTCOUCH-2009数据集"></a>9.3华南理工SCUTCOUCH-2009数据集</h5><p>SCUT-COUCH2009是一款包括12个子集的完整数据，它们分别是：中文词组、国标一级汉字、国标二级汉字、国标一级汉字对应的繁体字、汉语拼音、英文字母、阿拉伯数字、常用符号、Word8888、Word17366、Word44208和联机文本行数据。每套完整的SCUT-COUCH2009包括6,763个GB2312-80单汉字，5401个Big5繁体字，1384个和GB2312-80一级字库相对应的繁体字，8,888个常用的中文词组，17,366个常用中文词组，摘自《现代汉语大辞典》（第四版）的44,208个词组，2,010个汉语拼音，184个其他符号（包括字母、数字和常用符号）和8,809行联机文本行；现在版本的SCUT-COUCH2009使用PDA或手写屏进行采集，已完成了由190多人书写的完整的数据，字符总数超过3.6百万个。</p><p><a href="http://www.hcii-lab.net/data/scutcouch/CN/download.html" target="_blank" rel="noopener">下载地址</a>（需要申请）</p><h4 id="10-边缘共生对"><a href="#10-边缘共生对" class="headerlink" title="10.边缘共生对"></a>10.边缘共生对</h4><p><strong>问题</strong>：怎样选择的边缘像素对，（45和135），（135和202.5）就是随便选的吗？为啥没有270度</p><h4 id="11-边缘共生特征与-SIFT-描述子直方图结合"><a href="#11-边缘共生特征与-SIFT-描述子直方图结合" class="headerlink" title="11.边缘共生特征与 SIFT 描述子直方图结合"></a>11.边缘共生特征与 SIFT 描述子直方图结合</h4><ul><li><p>SIFT：SIFT即尺度不变特征变换，是用于图像处理领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种<strong>局部特征描述子</strong>。</p></li><li><p>然后<strong>利用直方图</strong>统计领域内像素对应的梯度和幅值：梯度方向角为横轴刻度，取45度为一个单位，那么横轴就有8个刻度；纵轴是对应梯度的幅值累加值。</p></li><li><p>SIFT算法特点：</p><ul><li>具有较好的稳定性和不变性，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰</li><li>区分性好，能够在海量特征数据库中进行快速准确的区分信息进行匹配</li><li>多量性，就算只有单个物体，也能产生大量特征向量</li><li>高速性，能够快速的进行特征向量匹配</li><li>可扩展性，能够与其它形式的特征向量进行联合</li></ul></li><li><p>在不同的尺度空间上查找关键点，并计算出关键点的方向</p></li></ul><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-18%2016.05.50.png"></p><ul><li>SIFT关键流程：</li><li><strong>提取关键点</strong>：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的兴趣点。</li><li><strong>定位关键点并确定特征方向</strong>：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。然后基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</li><li><strong>通过各关键点的特征向量</strong>，进行两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。</li><li><strong>最后用SIFT提取到的关键点与边缘元共生对融合特征，就完成了特征提取。</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔迹鉴定（一）</title>
      <link href="/posts/820c.html/"/>
      <url>/posts/820c.html/</url>
      
        <content type="html"><![CDATA[<h2 id="笔迹鉴定（一）"><a href="#笔迹鉴定（一）" class="headerlink" title="笔迹鉴定（一）"></a>笔迹鉴定（一）</h2><ol><li><p>特征提取：特征提取是手写体汉字识别最关键的环节。</p><p>1.1纹理特征：纹理是一种不依赖于颜色或亮度变化的反映图像中同质现象的视觉特征，刻画了图像像素邻域灰度空间分布的规律。它是所有物体表面都具有的内在特征，不同物体具有不同的纹理，如云彩，树木，砖，织物等都有各自的纹理特征。</p><ul><li><p>根据每个人不同的书写习惯，会产生自己的书写纹理特征，通过纹理特征能够区分不同书写人的笔迹。</p></li><li><p>文本图像作为一种特殊的图像，其纹理具有很强的方向性和以行为周期的准准确性，基于空间/频率域联合分析的方法可以描述纹理表面灰度级的整体周期，适合于描述文本图像的纹理。频率域可以将纹理的局部特性和全局特性有机的结合起来。</p><ul><li><p>频域特征：Gabor滤波器可以在频域上不同尺度、不同方向上提取相关特征，Gabor滤波器是一个用于边缘检测的线性滤波器，可以在频域的不同尺度，不同方向上提取相关特征。</p></li><li><p>gabor算子由一个高斯函数和一个余弦函数调制而成。gabor算子由六个参数控制，其中三个与余弦函数有关，两个与高斯函数有关。</p></li><li><p><code>cv.getGaborKernel</code>函数可以定义内核，它接受内核大小、高斯标准差、波的方向、波长、空间比和相位等参数。</p></li><li><p>滤波公式：<br>$ g(x, y ; \lambda, \theta, \psi, \sigma, \gamma)=\exp \left(-\frac{x^{\prime 2}+\gamma^{2} y^{2}}{2 \sigma^{2}}\right) \exp \left(i\left(2 \pi \frac{x^{\prime}}{\lambda}+\psi\right)\right) $​ </p></li><li><p>（1） <em>x</em>,<em>y</em>分别表示像素坐标位置；<br>（2） <em>λ</em>表示滤波的波长<br>（3） <em>θ</em>表示Gabor核函数图像的倾斜角度；<br>（4） <em>ψ</em>表示相位偏移量，取值范围是-180~180；<br>（5） <em>σ</em>表示高斯函数的标准差；<br>（6） <em>γ</em>表示长宽比，决定这Gabor核函数图像的椭圆率。</p></li><li><table><thead><tr><th>ksize</th><th>Size of the filter returned. 滤波器的大小（图片尺寸）</th></tr></thead><tbody><tr><td>sigma(<strong>σ</strong>)</td><td>Standard deviation of the gaussian envelope. <strong>高斯函数标准差</strong></td></tr><tr><td>theta(<strong>θ</strong>)</td><td>Orientation of the normal to the parallel stripes of a Gabor function. <strong>高斯函数：垂直于Gabor函数平行条纹的方向。</strong></td></tr><tr><td>lambd(<strong>λ</strong>)</td><td>Wavelength of the sinusoidal factor. <strong>正弦因子的波长</strong></td></tr><tr><td>gamma(<strong>γ</strong>)</td><td>Spatial aspect ratio. <strong>高斯函数宽高比</strong></td></tr><tr><td>psi(<strong>ψ</strong>)</td><td>Phase offset. <strong>相位偏差</strong></td></tr><tr><td>ktype</td><td>Type of filter coefficients. It can be CV_32F or CV_64F . <strong>滤波器系数的类型</strong></td></tr></tbody></table><p>不同参数下测试，ksize：111，sigam：5，theta：90，lambd：10，gamma：1.2</p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132433303.png" style="zoom:50%;"><p>ksize：111，sigam：10，theta：90，lambd：10，gamma：1.2</p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817132709822.png" style="zoom:50%;"><p><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/image-20210817134252871.png" alt="6张对比图"></p></li><li><p>空间分布特征：</p><ul><li>灰度协方差矩阵：用于匹配图像，匹配一个图像是否包含于另一个图像中。在文字识别中，可以用作找两份文字是否出于同一个人写的，或者某个偏旁部首是否与文字中的相似。</li></ul></li></ul></li></ul></li><li><p>文献</p></li></ol><ul><li><p>Writer Identification and Verification，书写人识别与验证</p><ul><li>手写体生物识别需要在多个观察层次上具有广泛的知识</li><li>良好的生物特征具备普遍性、独特性、永久性和可收集性</li><li>四个导致书写变异的因素：<ul><li>仿射变换，是书写人自愿控制的。大小、平移、旋转和剪切的变换是笔迹识别中令人讨厌的问题。</li><li>神经生物学变异性，局部环境和生理状态决定了在书写时所花费的精力。</li><li>手写过程中的瞬时系统状态，也就是笔顺，笔顺会对图像产生明显的影响</li><li>异体字变异，特定于书写者的字符形状现象，也就是每个人对某个特定字会有自己独特的写法</li></ul></li></ul></li><li><p>8: <strong>Handwriting Identification: a Direction Review</strong>，笔迹鉴定：一个方向的回看？</p><ul><li><p>书写者识别是从一组书写者中识别作者的过程</p></li><li><p>而书写者验证是确定两个手写样本是由相同的书写者还是由不同的书写者书写的任务。</p></li><li><p>基于笔迹的书写者身份的证明基于三个传统步骤：数据采集和预处理、特征提取和分类</p><ul><li><p>首先对手写文本进行预处理（如二值化、分段和规范化）</p><ul><li><p>第一步，先将彩色图像转变灰度图像，</p><ul><li>平均法：将同一个像素位置3个RGB值进行平均</li><li>最大最小平均：取同一个像素位置的RGB中亮度最大的和最小的进行平均。</li><li>加权平均：这是最流行的方法。几个加权系数0.3,0.59,0.11是根据人的亮度感知系统调节出来的参数，是个广泛使用的标准化参数。</li></ul></li><li><p>二值化处理：</p><ul><li>最简单的做法：给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来的就是衣服黑白图像</li><li>最常见的二值处理方法：是计算像素的平均值K，扫描图像的每个像素值如像素值大于K像素值设为255(白色)，值小于等于K像素值设为0(黑色)。该方法相比方法一，阈值的选取稍微有点智商，可以解释。但是使用平均值作为二值化阈值同样有个致命的缺点，可能导致部分对象像素或者背景像素丢失。二值化结果不能真实反映源图像信息。</li><li>使用直方图来寻找二值化阈值：直方图方法选择二值化阈值主要是发现图像的两个最高的峰，然后在阈值取值在两个峰之间的峰谷最低处。<ul><li>直方图是图像中像素强度分布的图形表达方式。它统计了每一个强度值所具有的像素个数。</li></ul></li></ul></li><li><p>分段处理：好像就是边缘检测</p><ul><li><p>边缘检测的实质是采用某种<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法</a>来提取出图像中对象与背景间的交界线。我们将边缘定义为图像中<a href="https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6" target="_blank" rel="noopener">灰度</a>发生急剧变化的区域边界。图像灰度的变化情况可以用图像灰度分布的梯度来反映。</p></li><li><p>步骤</p><ul><li>滤波：边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能。需要指出，大多数滤波器在降低噪声的同时也导致了边缘强度的损失，因此，增强边缘和降低噪声之间需要折中。</li><li>增加：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将邻域(或局部)强度值有显著变化的点突显出来。边缘增强一般是通过计算梯度幅值来完成的。</li><li>检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域中并不都是边缘，所以应该用某种方法来确定哪些点是边缘点。最简单的边缘检测判据是梯度幅值阈值判据。</li><li>定位：如果某一应用场合要求确定边缘位置，则边缘的位置可在子像素分辨率上来估计，边缘的方位也可以被估计出来。在边缘检测算法中，前三个步骤用得十分普遍。这是因为大多数场合下，仅仅需要边缘检测器指出边缘出现在图像某一像素点的附近，而没有必要指出边缘的精确位置或方向。</li></ul></li><li><p>阈值越低，能够检测出的边线越多，结果也越容易受到图片噪声的影响，并且越容易从图像中挑出不相关的特性。与此相反，一个高的阈值将会遗失细的或者短的线段。</p></li></ul></li><li><p>图像标准化处理：</p><ul><li>image_standardization $ =\frac{\mathrm{x}-\mu}{\text { adjusted_stddev }}$​​,u是图像均值，X表示图像矩阵</li><li>adjusted_stddev $=\max \left(\sigma, \frac{1.0}{\sqrt{\mathrm{N}}}\right)$​​​，第一个是方差，N为图像X的像素数量</li><li><img src="https://leng-mypic.oss-cn-beijing.aliyuncs.com/iShot2021-08-17%2019.11.39.png" alt="标准化处理结果"></li></ul></li></ul></li><li><p>第二，通过特征提取一组鉴别特征来表示手写文本</p></li><li><p>第三，做出分类决策</p><ul><li>欧几里得距离</li><li>神经网络</li><li>SVM</li></ul></li></ul></li><li><p>在线笔迹：包括速度、加速度、笔压、书写方向和笔划顺序</p></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 笔迹鉴定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端设计原稿</title>
      <link href="/posts/51d4.html/"/>
      <url>/posts/51d4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="前端idea原稿（逐步更新）"><a href="#前端idea原稿（逐步更新）" class="headerlink" title="前端idea原稿（逐步更新）"></a>前端idea原稿（逐步更新）</h1><h3 id="1-首页（图表展示，数据总计，操作展示）"><a href="#1-首页（图表展示，数据总计，操作展示）" class="headerlink" title="1. 首页（图表展示，数据总计，操作展示）"></a>1. 首页（图表展示，数据总计，操作展示）</h3><h3 id="2-爬取设置"><a href="#2-爬取设置" class="headerlink" title="2. 爬取设置"></a>2. 爬取设置</h3><p> <a href="%E7%88%AC%E5%8F%96%E8%AE%BE%E7%BD%AE.pdf">爬取设置.pdf</a> </p><img src="爬取设置.png" alt="爬取设置" style="zoom: 50%;"><h3 id="3-数据表格展示，以及增删改查操作"><a href="#3-数据表格展示，以及增删改查操作" class="headerlink" title="3. 数据表格展示，以及增删改查操作"></a>3. 数据表格展示，以及增删改查操作</h3><p> <a href="%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC%E5%B1%95%E7%A4%BA.pdf">数据表格展示.pdf</a> </p><img src="数据表格1.png" alt="数据表格1" style="zoom:67%;"><img src="数据表格2.png" alt="数据表格2" style="zoom:67%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫数据库bug</title>
      <link href="/posts/5fd7.html/"/>
      <url>/posts/5fd7.html/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫数据存入数据库bug修改"><a href="#爬虫数据存入数据库bug修改" class="headerlink" title="爬虫数据存入数据库bug修改"></a>爬虫数据存入数据库bug修改</h1><ul><li>问题：微博所有数据爬取正常，但存入数据库的数据很少，有时还会重复获取同一时间段的文章，导致微博ID一样，无法存入数据库</li><li>解决：修改search.py的parse_by_hour为：</li></ul><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">parse_by_hour</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""以小时为单位筛选"""</span>        keyword <span class="token operator">=</span> response<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'keyword'</span><span class="token punctuation">)</span>        is_empty <span class="token operator">=</span> response<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span>            <span class="token string">'//div[@class="card card-no-result s-pt20b40"]'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> is_empty<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前页面搜索结果为空'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 解析当前页面</span>            <span class="token keyword">for</span> weibo <span class="token keyword">in</span> self<span class="token punctuation">.</span>parse_weibo<span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>check_environment<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">yield</span> weibo            next_url <span class="token operator">=</span> response<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span>                <span class="token string">'//a[@class="next"]/@href'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>extract_first<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> next_url<span class="token punctuation">:</span>                next_url <span class="token operator">=</span> self<span class="token punctuation">.</span>base_url <span class="token operator">+</span> next_url                <span class="token keyword">yield</span> scrapy<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token operator">=</span>next_url<span class="token punctuation">,</span>                                     callback<span class="token operator">=</span>self<span class="token punctuation">.</span>parse_page<span class="token punctuation">,</span>                                     meta<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'keyword'</span><span class="token punctuation">:</span> keyword<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后台部署</title>
      <link href="/posts/c728.html/"/>
      <url>/posts/c728.html/</url>
      
        <content type="html"><![CDATA[<h1 id="NodeJS后台环境部署"><a href="#NodeJS后台环境部署" class="headerlink" title="NodeJS后台环境部署"></a>NodeJS后台环境部署</h1><h3 id="1-建立环境"><a href="#1-建立环境" class="headerlink" title="1. 建立环境"></a>1. 建立环境</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 建立nodejs后台环境</span>node create 项目名称var express <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //express框架模块var path <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //系统路径模块var fs <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //文件模块var bodyParser <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'body-parser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //对post请求的请求体进行解析模块var app <span class="token operator">=</span> express<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var mysql <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">'mysql'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //导入mysql包var cors <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">"cors"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // 解决跨域问题.npm <span class="token function">install</span> cors 装一下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-连接mysql数据库"><a href="#2-连接mysql数据库" class="headerlink" title="2. 连接mysql数据库"></a>2. 连接mysql数据库</h3><pre class="line-numbers language-bash"><code class="language-bash">//连接mysql数据库var connection <span class="token operator">=</span> mysql.createConnection<span class="token punctuation">(</span><span class="token punctuation">{</span>    host: <span class="token string">'localhost'</span>,    user: <span class="token string">'root'</span>,    password: <span class="token string">'lgn970722'</span>,    port: <span class="token string">'3306'</span>,    database: <span class="token string">'mySpider'</span>,    useConnectionPooling: true,    timezone: <span class="token string">'08:00'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connection.connect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-分页complex-table-data-mysql数据"><a href="#3-分页complex-table-data-mysql数据" class="headerlink" title="3. 分页complex_table_data mysql数据"></a>3. 分页complex_table_data mysql数据</h3><pre class="line-numbers language-bash"><code class="language-bash">app.get<span class="token punctuation">(</span><span class="token string">'/complex-table_data'</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span>req, res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var response <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"page"</span>:req.query.page,        <span class="token string">"limit"</span>:req.query.limit,    <span class="token punctuation">}</span><span class="token punctuation">;</span>    console.log<span class="token punctuation">(</span>req.query.page<span class="token punctuation">)</span>    //  var selectSQL <span class="token operator">=</span> <span class="token string">"SELECT * from alarmData"</span><span class="token punctuation">;</span>    //    a <span class="token operator">=</span> <span class="token punctuation">(</span>response.page - 1<span class="token punctuation">)</span> * req.query.limit<span class="token punctuation">;</span>    console.log<span class="token punctuation">(</span><span class="token string">'a:'</span> + a<span class="token punctuation">)</span><span class="token punctuation">;</span>    var selectSQL <span class="token operator">=</span> <span class="token string">"select * from complex_table_data limit "</span>+  req.query.limit +<span class="token string">" offset "</span> + a<span class="token punctuation">;</span>connection.query<span class="token punctuation">(</span>selectSQL, <span class="token keyword">function</span> <span class="token punctuation">(</span>err, result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">'[data ERROR] - '</span>, err.message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  //console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">"数据没了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res.end<span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//如果登录失败就给客户端返回0，  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    // console.log<span class="token punctuation">(</span>selectSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>    console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    // res.json<span class="token punctuation">(</span><span class="token punctuation">{</span>success_code: 200, message: <span class="token string">'获取分页数据成功'</span>, data: results <span class="token punctuation">}</span><span class="token punctuation">)</span>    // <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>    //   result<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.alarmGrade <span class="token operator">=</span> +result<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.alarmGrade    // <span class="token punctuation">}</span><span class="token punctuation">;</span>    console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    //解决中文乱码，加入头文件    // res.writeHead<span class="token punctuation">(</span>200, <span class="token punctuation">{</span> <span class="token string">'Content-Type'</span><span class="token keyword">:</span> <span class="token string">'text/html;charset=utf-8'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    res.end<span class="token punctuation">(</span>JSON.stringify<span class="token punctuation">(</span><span class="token punctuation">{</span>        code :20000,        data: <span class="token punctuation">{</span>            total: 100,            items: result        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    // res.json<span class="token punctuation">(</span>data:result<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//  console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>//res.end<span class="token punctuation">(</span>JSON.stringify<span class="token punctuation">(</span>response<span class="token punctuation">))</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-创建get接口，获取本地json数据，以便用于测试"><a href="#4-创建get接口，获取本地json数据，以便用于测试" class="headerlink" title="4. 创建get接口，获取本地json数据，以便用于测试"></a>4. 创建get接口，获取本地json数据，以便用于测试</h3><pre class="line-numbers language-bash"><code class="language-bash">//创建get接口app.get<span class="token punctuation">(</span><span class="token string">'/api'</span>, function<span class="token punctuation">(</span>req, res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    //console.log<span class="token punctuation">(</span>req.body<span class="token punctuation">)</span><span class="token punctuation">;</span> //获取请求参数var <span class="token function">file</span> <span class="token operator">=</span> path.join<span class="token punctuation">(</span>__dirname, <span class="token string">'data/test.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //文件路径，__dirname为当前运行js文件的目录//var <span class="token function">file</span> <span class="token operator">=</span> <span class="token string">'f:\\nodejs\\data\\test.json'</span><span class="token punctuation">;</span> //也可以用这种方式指定路径//读取json文件fs.readFile<span class="token punctuation">(</span>file, <span class="token string">'utf-8'</span>, function<span class="token punctuation">(</span>err, data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res.send<span class="token punctuation">(</span><span class="token string">'文件读取失败'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        res.send<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        console.log<span class="token punctuation">(</span><span class="token string">'数据读取成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-运行端口"><a href="#5-运行端口" class="headerlink" title="5. 运行端口"></a>5. 运行端口</h3><pre class="line-numbers language-bash"><code class="language-bash">var server <span class="token operator">=</span> app.listen<span class="token punctuation">(</span>8080, <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    var host <span class="token operator">=</span> server.address<span class="token punctuation">(</span><span class="token punctuation">)</span>.address    var port <span class="token operator">=</span> server.address<span class="token punctuation">(</span><span class="token punctuation">)</span>.port    console.log<span class="token punctuation">(</span><span class="token string">"应用实例，访问地址为 http://%s:%s"</span>, host, port<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> NodeJS </tag>
            
            <tag> API </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫部署</title>
      <link href="/posts/b77d.html/"/>
      <url>/posts/b77d.html/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫部署API服务"><a href="#爬虫部署API服务" class="headerlink" title="爬虫部署API服务"></a>爬虫部署API服务</h1><h3 id="1-部署流程"><a href="#1-部署流程" class="headerlink" title="1. 部署流程"></a>1. 部署流程</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装scrapyd框架，用于部署scrapy框架的服务，可将其转化为API接口的形式去运行以及配置参数</span>$ pip <span class="token function">install</span> scrapyd<span class="token comment" spellcheck="true"># 在项目根目录下先运行scrapyd，单独运行在一个终端中，这里将显示访问接口的信息</span>$ scrapyd<span class="token comment" spellcheck="true"># 更改scrapy.cfg中[deploy]，更改为[deploy:first_deploy]，启动服务后可以看见部署服务的名称，first_deploy         http://localhost:6800</span>$ scrapyd-deploy -l<span class="token comment" spellcheck="true"># 再执行list语句，显示出scrapy的spider名称MyMooc，即为打包成功</span>$ scrapy list<span class="token comment" spellcheck="true"># 开始项目部署，这个命令会将项目打包成egg文件，会在根目录下创建一个setup.py，会返回一个addversion.json，出现即为部署成功</span>$ scrapyd-deploy <span class="token punctuation">(</span>部署名称<span class="token punctuation">)</span>first_deploy -p <span class="token punctuation">(</span>项目名称<span class="token punctuation">)</span>MyMooc<span class="token comment" spellcheck="true"># 运行一次代码，</span>$ curl http://localhost:6800/schedule.json -d project<span class="token operator">=</span>first_deploy -d spider<span class="token operator">=</span>MyMooc<span class="token comment" spellcheck="true"># 定义变量</span><span class="token comment" spellcheck="true"># 加入可选参数，这样在运行scrapy crawl MyMooc在后面就可以添加-a设置参数，</span><span class="token comment" spellcheck="true"># scrapy crawl MyMooc -a p=xxx -a test=xxx</span><span class="token comment" spellcheck="true"># 这样就解决的scrapyd中可以设置参数的问题，非常nice，perfect！！！</span><span class="token comment" spellcheck="true"># 在后面的程序中就可以使用self.p，self.test引入参数</span>def __init__<span class="token punctuation">(</span>self, p<span class="token operator">=</span>None, test<span class="token operator">=</span>None, *args, **kwargs<span class="token punctuation">)</span>:  super<span class="token punctuation">(</span>MySpider, self<span class="token punctuation">)</span>.__init__<span class="token punctuation">(</span>*args, **kwargs<span class="token punctuation">)</span>  self.p <span class="token operator">=</span> p  self.test <span class="token operator">=</span> <span class="token function">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-利用postman加入参数测试接口"><a href="#2-利用postman加入参数测试接口" class="headerlink" title="2. 利用postman加入参数测试接口"></a>2. 利用postman加入参数测试接口</h3><ul><li><p><strong>运行scrapyd，在127.0.0.1:6800访问</strong></p></li><li><p><strong>查看scrapyd服务器运行状态，get方法，（scrapyd_status）</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">curl http://127.0.0.1:6800/daemonstatus.json<span class="token comment" spellcheck="true">#返回</span><span class="token punctuation">{</span>    <span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>,    <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span>,    <span class="token string">"pending"</span><span class="token keyword">:</span> 0,    <span class="token string">"running"</span><span class="token keyword">:</span> 0,    <span class="token string">"finished"</span><span class="token keyword">:</span> 0<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>获取scrapyd服务器上已经发布的工程列表，get方法，（scrapyd_project）</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">curl http://127.0.0.1:6800/listprojects.json<span class="token punctuation">{</span>    <span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>,    <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span>,    <span class="token string">"projects"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token string">"MyMooc"</span>,        <span class="token string">"default"</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>获取scrapyd服务器上名为MyMooc的工程下的爬虫清单，get方法，（project_spider）</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">curl http://127.0.0.1:6800/listspiders.json?project<span class="token operator">=</span>mooc<span class="token punctuation">{</span>    <span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>,    <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span>,    <span class="token string">"spiders"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token string">"MyMooc"</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>spider是爬虫文件中spiders文件夹中那个爬虫py文件的name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>获取scrapyd服务器上名为MyMooc的工程下的各爬虫的版本，get方法，（project_all_version）</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">curl http://127.0.0.1:6800/listversions.json?project<span class="token operator">=</span>MyMooc<span class="token punctuation">{</span>    <span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>,    <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span>,    <span class="token string">"versions"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token string">"1620801044"</span>,        <span class="token string">"1620819352"</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>获取scrapyd服务器上的所有任务清单，包括已结束，正在运行的，准备启动的。get方法，（scrapyd_all_jobs）</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">curl http://127.0.0.1:6800/listjobs.json?project<span class="token operator">=</span>mooc<span class="token punctuation">{</span>    <span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>,    <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span>,    <span class="token string">"pending"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,    <span class="token string">"running"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,    <span class="token string">"finished"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>启动 scrapyd服务器上myproject工程下的myspider爬虫，使myspider立刻开始运行 ，注意必须以post方式，（run_project_spider）</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">http://127.0.0.1:6800/schedule.json -d project<span class="token operator">=</span>myproject -d spider<span class="token operator">=</span>myspiderhttp://127.0.0.1:6800/schedule.json -d project<span class="token operator">=</span>5.13.01 -d spider<span class="token operator">=</span>MyMooc<span class="token punctuation">{</span><span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>, <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span>, <span class="token string">"project"</span><span class="token keyword">:</span> <span class="token string">"MyMooc"</span>, <span class="token string">"version"</span><span class="token keyword">:</span> <span class="token string">"1620885389"</span>, <span class="token string">"spiders"</span><span class="token keyword">:</span> 1<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>删除scrapyd服务器上myproject的工程下的版本名为version的爬虫 ，注意必须以post方式</p></li><li><pre class="line-numbers language-bash"><code class="language-bash">http://127.0.0.1:6800/delversion.json -d project<span class="token operator">=</span>myproject -d version<span class="token operator">=</span>r99'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>删除scrapyd服务器上myproject工程，注意该命令会自动删除该工程下所有的spider，注意必须以post方式</strong></p></li><li><pre class="line-numbers language-bash"><code class="language-bash">http://127.0.0.1:6800/delproject.json -d project<span class="token operator">=</span>myproject<span class="token punctuation">{</span>    <span class="token string">"node_name"</span><span class="token keyword">:</span> <span class="token string">"MM-202104301802"</span>,    <span class="token string">"status"</span><span class="token keyword">:</span> <span class="token string">"ok"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><pre class="line-numbers language-bash"><code class="language-bash">curl http://127.0.0.1:6800/schedule.json -d project<span class="token operator">=</span>MyMooc -d spider<span class="token operator">=</span>MyMooc -d p<span class="token operator">=</span><span class="token string">'["123"]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> scrapyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博爬虫功能</title>
      <link href="/posts/5774.html/"/>
      <url>/posts/5774.html/</url>
      
        <content type="html"><![CDATA[<h2 id="微博爬虫功能"><a href="#微博爬虫功能" class="headerlink" title="微博爬虫功能"></a>微博爬虫功能</h2><p>连续获取一个或多个<strong>微博关键词搜索</strong>结果，并将结果写入文件（可选）、数据库（可选）等。所谓微博关键词搜索即：<strong>搜索正文中包含指定关键词的微博</strong>，可以指定搜索的时间范围。<br><br>本程序可以获得几乎全部的微博信息，如微博正文、发布者等。支持输出多种文件类型，具体如下：</p><ul><li>写入<strong>csv文件</strong>（默认）</li><li>写入<strong>MySQL数据库</strong>（可选）</li><li>下载微博中的<strong>图片</strong>（可选），还未测试储存路径</li><li>下载微博中的<strong>视频</strong>（可选），还未测试储存路径</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>微博id：微博的id，为一串数字形式</li><li>微博bid：微博的bid</li><li>微博内容：微博正文</li><li>头条文章url：微博中头条文章的url</li><li>原始图片url：原创微博图片和转发微博转发理由中图片的url，若某条微博存在多张图片，则每个url以英文逗号分隔</li><li>视频url: 微博中的视频url和Live Photo中的视频url，若某条微博存在多个视频，则每个url以英文分号分隔</li><li>微博发布位置：位置微博中的发布位置</li><li>微博发布时间：微博发布时的时间，精确到天</li><li>点赞数：微博被赞的数量</li><li>转发数：微博被转发的数量</li><li>评论数：微博被评论的数量</li><li>微博发布工具：微博的发布工具，如iPhone客户端、HUAWEI Mate 20 Pro等，若没有则值为’’</li><li>话题：微博话题，即两个#中的内容，若存在多个话题，每个url以英文逗号分隔，若没有则值为’’</li><li>@用户：微博@的用户，若存在多个@用户，每个url以英文逗号分隔，若没有则值为’’</li><li>原始微博id：为转发微博所特有，是转发微博中那条被转发微博的id，那条被转发的微博也会存储，字段和原创微博一样，只是它的本字段为空</li><li>结果文件：保存在当前目录“结果文件”文件夹下以关键词为名的文件夹里</li><li>微博图片：微博中的图片，保存在以关键词为名的文件夹下的images文件夹里</li><li>微博视频：微博中的视频，保存在以关键词为名的文件夹下的videos文件夹里</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>本程序的所有配置都在setting.py文件中完成，该文件位于“weibo-search\weibo\settings.py”。</p><h3 id="1-下载Python"><a href="#1-下载Python" class="headerlink" title="1.下载Python"></a>1.下载Python</h3><p>官网安装稳定版本LTS</p><h3 id="2-安装Scrapy"><a href="#2-安装Scrapy" class="headerlink" title="2.安装Scrapy"></a>2.安装Scrapy</h3><p>本程序依赖Scrapy，要想运行程序，需要安装Scrapy。如果系统中没有安装Scrapy，请根据自己的系统安装Scrapy，以Ubuntu为例，可以使用如下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ pip <span class="token function">install</span> scrapy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3.安装依赖"></a>3.安装依赖</h3><pre class="line-numbers language-bash"><code class="language-bash">$ pip <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-设置cookie"><a href="#4-设置cookie" class="headerlink" title="4.设置cookie"></a>4.设置cookie</h3><p>DEFAULT_REQUEST_HEADERS中的cookie是我们需要填的值，如何获取cookie详见最后，获取后将”your cookie”替换成真实的cookie即可。</p><h3 id="5-设置搜索关键词"><a href="#5-设置搜索关键词" class="headerlink" title="5.设置搜索关键词"></a>5.设置搜索关键词</h3><p>修改setting.py文件夹中的KEYWORD_LIST参数。<br>如果你想搜索一个关键词，如“迪丽热巴”：<br><strong>目前只实现一个关键词的爬取</strong></p><pre><code>KEYWORD_LIST = ['迪丽热巴']</code></pre><p>如果你想分别搜索多个关键词，如想要分别获得“迪丽热巴”和“杨幂”的搜索结果：</p><pre><code>KEYWORD_LIST = ['迪丽热巴', '杨幂']</code></pre><p>如果你想搜索同时包含多个关键词的微博，如同时包含“迪丽热巴”和“杨幂”微博的搜索结果：</p><pre><code>KEYWORD_LIST = ['迪丽热巴 杨幂']</code></pre><p>如果你想搜索微博话题，即包含#的内容，如“#迪丽热巴#”：</p><pre><code>KEYWORD_LIST = ['#迪丽热巴#']</code></pre><h3 id="6-设置搜索时间范围"><a href="#6-设置搜索时间范围" class="headerlink" title="6.设置搜索时间范围"></a>6.设置搜索时间范围</h3><p>START_DATE代表搜索的起始日期，END_DATE代表搜索的结束日期，值为“yyyy-mm-dd”形式，程序会搜索包含关键词且发布时间在起始日期和结束日期之间的微博（包含边界）。比如我想筛选发布时间在2021-05-01到2021-05-07这两天的微博：</p><pre><code>START_DATE = '2021-05-01'END_DATE = '2021-05-07'</code></pre><h3 id="7-设置等待时间（可选）"><a href="#7-设置等待时间（可选）" class="headerlink" title="7.设置等待时间（可选）"></a>7.设置等待时间（可选）</h3><p>DOWNLOAD_DELAY代表访问完一个页面再访问下一个时需要等待的时间，默认为10秒。如我想设置等待15秒左右，可以修改setting.py文件的DOWNLOAD_DELAY参数：</p><pre><code>DOWNLOAD_DELAY = 15</code></pre><h3 id="8-设置微博类型（可选）"><a href="#8-设置微博类型（可选）" class="headerlink" title="8.设置微博类型（可选）"></a>8.设置微博类型（可选）</h3><p>WEIBO_TYPE筛选要搜索的微博类型，0代表搜索全部微博，1代表搜索全部原创微博，2代表热门微博，3代表关注人微博，4代表认证用户微博，5代表媒体微博，6代表观点微博。比如我想要搜索全部原创微博，修改setting.py文件的WEIBO_TYPE参数：</p><pre><code>WEIBO_TYPE = 1</code></pre><h3 id="9-设置包含内容（可选）"><a href="#9-设置包含内容（可选）" class="headerlink" title="9.设置包含内容（可选）"></a>9.设置包含内容（可选）</h3><p>CONTAIN_TYPE筛选结果微博中必需包含的内容，0代表不筛选，获取全部微博，1代表搜索包含图片的微博，2代表包含视频的微博，3代表包含音乐的微博，4代表包含短链接的微博。比如我想筛选包含图片的微博，修改setting.py文件的CONTAIN_TYPE参数：</p><pre><code>CONTAIN_TYPE = 1</code></pre><h3 id="10-筛选微博发布地区（可选）"><a href="#10-筛选微博发布地区（可选）" class="headerlink" title="10.筛选微博发布地区（可选）"></a>10.筛选微博发布地区（可选）</h3><p>REGION筛选微博的发布地区，精确到省或直辖市，值不应包含“省”或“市”等字，如想筛选北京市的微博请用“北京”而不是“北京市”，想要筛选安徽省的微博请用“安徽”而不是“安徽省”，可以写多个地区，具体支持的地名见region.py文件，注意只支持省或直辖市的名字，省下面的市名及直辖市下面的区县名不支持，不筛选请用”全部“。比如我想要筛选发布地在山东省的微博：</p><pre><code>REGION = ['山东']</code></pre><h3 id="11-配置数据库（可选）"><a href="#11-配置数据库（可选）" class="headerlink" title="11.配置数据库（可选）"></a>11.配置数据库（可选）</h3><p>MONGO_URI是MongoDB数据库的配置；<br><br>MYSQL开头的是MySQL数据库的配置。</p><h3 id="12-运行程序"><a href="#12-运行程序" class="headerlink" title="12.运行程序"></a>12.运行程序</h3><pre class="line-numbers language-bash"><code class="language-bash">$ scrapy crawl search -s JOBDIR<span class="token operator">=</span>crawls/search<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只运行“scrapy crawl search”也可以，只是上述方式在结束时可以保存进度，下次运行时会在程序上次的地方继续获取。注意，如果想要保存进度，请使用“Ctrl + C”<strong>一次</strong>，注意是<strong>一次</strong>。按下“Ctrl + C”一次后，程序会继续运行一会，主要用来保存获取的数据、保存进度等操作，请耐心等待。下次再运行时，只要再运行上面的指令就可以恢复上次的进度。</p><ul><li>但也不是很稳定，目前还需多次测试，先爬取数据再说，这个不急</li></ul><h3 id="13-待完成"><a href="#13-待完成" class="headerlink" title="13. 待完成"></a>13. 待完成</h3><ul><li>利用scrapyd部署，好像是可以形成API去操作，具体还需学习</li><li>重新做一个小的网站demo爬取，测试scrappd部署环境，昨天主要做的事情，但还没成功</li><li>需完善：多个参数同时存储数据库，<strong>最后再搞</strong>，目前可以实现单个关键词存入数据库，以满足任务要求</li></ul><h2 id="如何获取cookie"><a href="#如何获取cookie" class="headerlink" title="如何获取cookie"></a>如何获取cookie</h2><p>1.用Chrome打开<a href="https://passport.weibo.cn/signin/login" target="_blank" rel="noopener">https://passport.weibo.cn/signin/login</a>；<br><br>2.输入微博的用户名、密码，登录，如图所示：<br><img src="https://picture.cognize.me/cognize/github/weibospider/cookie1.png"><br>登录成功后会跳转到<a href="https://m.weibo.cn/" target="_blank" rel="noopener">https://m.weibo.cn</a>;<br><br>3.按F12键打开Chrome开发者工具，在地址栏输入并跳转到<a href="https://weibo.cn/" target="_blank" rel="noopener">https://weibo.cn</a>，跳转后会显示如下类似界面:<br><img src="https://picture.cognize.me/cognize/github/weibospider/cookie2.png"><br>4.依此点击Chrome开发者工具中的Network-&gt;Name中的weibo.cn-&gt;Headers-&gt;Request Headers，”Cookie:”后的值即为我们要找的cookie值，复制即可，如图所示：<br><img src="https://picture.cognize.me/cognize/github/weibospider/cookie3.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> scrapy </tag>
            
            <tag> 微博 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.7-5.16学习记录</title>
      <link href="/posts/19e3.html/"/>
      <url>/posts/19e3.html/</url>
      
        <content type="html"><![CDATA[<center> <h2>5.7-5.16学习情况</h2><h2></h2></center><p>PS</p><ul><li><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span>为顺利完成</p></li><li><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span>为休息一天</p></li><li><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span>为尚未完成</p></li></ul><table><thead><tr><th><center>日期</center></th><th><center>学习情况</center></th><th><center>完成度</center></th></tr></thead><tbody><tr><td>5/7</td><td>1.学习了tensorflow库，初步掌握句子分词，构建模型，训练模型，以及预测简单流程。<br>     2.使用miniforge3安装python虚拟环境，适配M1芯片，并可以使用conda install -n py38  包名，进行快速安装，简单的一批。</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>5/8</td><td></td><td></td></tr><tr><td>5/9</td><td></td><td></td></tr><tr><td>5/10</td><td></td><td></td></tr><tr><td>5/11</td><td></td><td></td></tr><tr><td>5/12</td><td></td><td></td></tr><tr><td>5/13</td><td></td><td></td></tr><tr><td>5/14</td><td></td><td></td></tr><tr><td>5/15</td><td></td><td></td></tr><tr><td>5/16</td><td></td><td></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow（一）</title>
      <link href="/posts/bd21.html/"/>
      <url>/posts/bd21.html/</url>
      
        <content type="html"><![CDATA[<h1 id="tensorflow入门（一）"><a href="#tensorflow入门（一）" class="headerlink" title="tensorflow入门（一）"></a>tensorflow入门（一）</h1><p>数据集和py文件 <a href="https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.py" target="_blank" rel="noopener">训练模型及使用.py</a> ， <a href="https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/Sarcasm_Headlines_Dataset.json" target="_blank" rel="noopener">Sarcasm_Headlines_Dataset.json</a>  ，<a href="https://lengblog.oss-cn-hangzhou.aliyuncs.com/blog%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/tensorflow%EF%BC%88%E4%B8%80%EF%BC%89/sarcasm.json" target="_blank" rel="noopener">sarcasm.json</a> </p><hr><ol><li><p>初始定义参数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分词保留的最大单词数</span>vocab_size <span class="token operator">=</span> <span class="token number">10000</span><span class="token comment" spellcheck="true"># 每个词创建的向量维度</span>embedding_dim <span class="token operator">=</span> <span class="token number">16</span><span class="token comment" spellcheck="true"># 数据最大长度</span>max_length <span class="token operator">=</span> <span class="token number">100</span><span class="token comment" spellcheck="true"># 数据长度大于所设定句子长度maxlen，可加入截断参数，truncating='post'，</span>trunc_type <span class="token operator">=</span> <span class="token string">'post'</span><span class="token comment" spellcheck="true"># 在句子后边补齐</span>padding_type <span class="token operator">=</span> <span class="token string">'post'</span><span class="token comment" spellcheck="true"># oov_token属性，将语料库中没有的单词标记出来</span>oov_tok <span class="token operator">=</span> <span class="token string">"&lt;OOV>"</span><span class="token comment" spellcheck="true"># 两万训练数据</span>training_size <span class="token operator">=</span> <span class="token number">20000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li>从本地读取json文件</li></ol><ul><li><p>json.load()和json.loads()都实现了反序列化，变量内容从序列化的对象重新读到内存里称之为反序列化，反序列化是流转换为对象。也就是由json（双引号）转变为dict（键值对用单引号包起来的就是dict）字典可供python操作。</p><ul><li><p>load：针对文件句柄，将json格式的字符转换为dict，从文件中读取（将string转换为dict）</p><p><code>a_json = json.load(open('demo.json','r'))</code></p></li><li><p>loads：针对内存对象，将string转化为dict</p><p><code>a = json.loads('{'a':'1111','b':'2222'}')</code></p></li></ul></li><li><p>json.dump()和json.dumps()都实现了序列化，变量从内存中变成可存储或传输的过程称之为序列化，序列化是将对象状态转化为可保存或可传输格式的过程。</p><ul><li>dump：将dict类型转化为json字符串格式，写入到文件<strong>（易存储）</strong></li></ul><pre class="line-numbers language-python"><code class="language-python">a_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token string">'1111'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token string">'2222'</span><span class="token punctuation">}</span>json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>a_dict<span class="token punctuation">,</span> open<span class="token punctuation">(</span><span class="token string">'demo.json'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>dumps：将dict转化为string<strong>（易传输）</strong></li></ul><pre class="line-numbers language-python"><code class="language-python">a_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token string">'1111'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token string">'2222'</span><span class="token punctuation">}</span>a_str <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>a_dict<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ul><li><p>方法一：适用于少量数据规整，标准json格式</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"data/sarcasm.json"</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># json.load将json转化为python可操作的dict字典</span>        datastore <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义空数组      </span>sentences <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># json数据样式</span><span class="token comment" spellcheck="true"># {"article_link": "https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5", "headline": "former versace store clerk sues over secret 'black code' for minority shoppers", "is_sarcastic": 0},</span><span class="token comment" spellcheck="true"># 循环将数据插入格式化</span><span class="token keyword">for</span> item <span class="token keyword">in</span> datastore<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true">#append，字符串插入操作</span>      sentences<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token string">'headline'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      labels<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token string">'is_sarcastic'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        urls<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token string">'article_link'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法二：适用于大量冗余数据</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 先定义打开文件操作，这个文件不标准，不是标准json，中间没有逗号</span>file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"data/Sarcasm_Headlines_Dataset.json"</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义空数组      </span>sentences <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># json数据样式</span><span class="token comment" spellcheck="true"># {"article_link": "https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5", "headline": "former versace store clerk sues over secret 'black code' for minority shoppers", "is_sarcastic": 0},</span><span class="token comment" spellcheck="true"># 调用readlines()方法逐行扫描json并插入数组，规范化数据</span><span class="token keyword">for</span> line <span class="token keyword">in</span> file<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 将每次扫描到的那一行转化为dict数据，然后再插入到数组中</span>    datastore <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>line<span class="token punctuation">)</span>    sentences<span class="token punctuation">.</span>append<span class="token punctuation">(</span>datastore<span class="token punctuation">[</span><span class="token string">'headline'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    labels<span class="token punctuation">.</span>append<span class="token punctuation">(</span>datastore<span class="token punctuation">[</span><span class="token string">'is_sarcastic'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># urls.append(datastore['article_link'])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="2"><li><p>进行分片，使训练集和测试集互不影响</p><pre class="line-numbers language-python"><code class="language-python">training_sentences <span class="token operator">=</span> sentences<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>training_size<span class="token punctuation">]</span>testing_sentences <span class="token operator">=</span> sentences<span class="token punctuation">[</span>training_size<span class="token punctuation">:</span><span class="token punctuation">]</span>training_labels <span class="token operator">=</span> labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>training_size<span class="token punctuation">]</span>testing_labels <span class="token operator">=</span> labels<span class="token punctuation">[</span>training_size<span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实例化分词器，然后用训练集training_sentences创建字典并对应编号。再生成每个训练集句子的对应数字编号所组成的每个句子的token序列，然后设置训练集数据格式，最大长度，位数不够时补零方式以及位数超出时截断方式</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 要保证创建的神经网络只见过训练集，没有见过训练集</span><span class="token comment" spellcheck="true"># 分词保留的最大单词数，为了显示语料库中没有的单词，利用oov_token属性，将其设置为语料库中无法识别的内容显示为1</span><span class="token comment" spellcheck="true"># 实例化分词器</span>tokenizer <span class="token operator">=</span> Tokenizer<span class="token punctuation">(</span>num_words<span class="token operator">=</span>vocab_size<span class="token punctuation">,</span>                      oov_token<span class="token operator">=</span>oov_tok<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 用这个训练集创建token字典</span>tokenizer<span class="token punctuation">.</span>fit_on_texts<span class="token punctuation">(</span>training_sentences<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 分词并编号</span>word_index <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>word_index<span class="token comment" spellcheck="true"># 每个句子的token序列</span>training_sequences <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>texts_to_sequences<span class="token punctuation">(</span>training_sentences<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 填充序列变为同样长度，以最长的为基准</span><span class="token comment" spellcheck="true"># 如果添加参数 padding='post'，代表在token序列后方加入0补齐</span><span class="token comment" spellcheck="true"># 也可以加入参数maxlen，指定所需句子长度，如 maxlen=5</span><span class="token comment" spellcheck="true"># 如果数据长度大于所设定句子长度maxlen，可加入截断参数，post从后面截断，默认是pre，truncating='post'，</span>training_padded <span class="token operator">=</span> pad_sequences<span class="token punctuation">(</span>training_sequences<span class="token punctuation">,</span>maxlen<span class="token operator">=</span>max_length<span class="token punctuation">,</span>padding<span class="token operator">=</span>padding_type<span class="token punctuation">,</span>truncating<span class="token operator">=</span>trunc_type<span class="token punctuation">)</span>testing_sequences <span class="token operator">=</span>tokenizer<span class="token punctuation">.</span>texts_to_sequences<span class="token punctuation">(</span>testing_sentences<span class="token punctuation">)</span>testing_padded <span class="token operator">=</span> pad_sequences<span class="token punctuation">(</span>testing_sequences<span class="token punctuation">,</span>maxlen<span class="token operator">=</span>max_length<span class="token punctuation">,</span>padding<span class="token operator">=</span>padding_type<span class="token punctuation">,</span>truncating<span class="token operator">=</span>trunc_type<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="4"><li><p>引入科学计算库numpy，训练模型中的训练数据只支持numpy数组</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># numpy一个科学计算库</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># np.array将数组等其他形式转化为numpy数组，以便进行矩阵等运算</span>training_padded_after <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>training_padded<span class="token punctuation">)</span>training_labels_after <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>training_labels<span class="token punctuation">)</span>testing_padded_after <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>testing_padded<span class="token punctuation">)</span>testing_labels_after <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>testing_labels<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="5"><li><p>建立模型</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 建立模型</span>model <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token comment" spellcheck="true"># 每个单词的情感方向都会被一次又一次的学习</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>vocab_size<span class="token punctuation">,</span> embedding_dim<span class="token punctuation">,</span> input_length<span class="token operator">=</span>max_length<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 将向量进行相加</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>GlobalAveragePooling1D<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 然后嵌入到一个普通的神经网络中，24输出维度大小units（该层有多少个神经元），activation激活函数</span>    <span class="token comment" spellcheck="true"># 输入层和隐层，输出层等等,下面Dense就是神经网络的两层</span>    <span class="token comment" spellcheck="true"># https://blog.csdn.net/ybdesire/article/details/85217688</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看https://blog.csdn.net/chaojishuai123/article/details/114580892</span><span class="token comment" spellcheck="true"># loss目标函数，'binary_crossentropy'对数损失；metrics评价函数（acc和val_acc就是通过定义评价函数得到的）</span>model<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>loss<span class="token operator">=</span><span class="token string">'binary_crossentropy'</span><span class="token punctuation">,</span> optimizer<span class="token operator">=</span><span class="token string">'adam'</span><span class="token punctuation">,</span> metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过model.summary()输出模型各层的参数情况</span>model<span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="6"><li><p>输入训练数据以及测试数据进行模型的训练以及评估</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 30次迭代训练</span>num_epochs <span class="token operator">=</span> <span class="token number">30</span><span class="token comment" spellcheck="true"># 训练以及检测</span><span class="token comment" spellcheck="true"># training_padded训练集输入特征，training_labels训练集标签</span><span class="token comment" spellcheck="true"># epochs迭代次数，validation_data = (测试集的输入特征，测试集的标签），verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</span><span class="token comment" spellcheck="true"># https://blog.csdn.net/LuYi_WeiLin/article/details/88555813</span><span class="token comment" spellcheck="true"># numpy格式数组</span>history <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>training_padded_after<span class="token punctuation">,</span> training_labels_after<span class="token punctuation">,</span>epochs<span class="token operator">=</span>num_epochs<span class="token punctuation">,</span>validation_data<span class="token operator">=</span><span class="token punctuation">(</span>testing_padded_after<span class="token punctuation">,</span> testing_labels_after<span class="token punctuation">)</span><span class="token punctuation">,</span>verbose<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#训练以及评估结果</span>Epoch <span class="token number">30</span><span class="token operator">/</span><span class="token number">30</span><span class="token number">625</span><span class="token operator">/</span><span class="token number">625</span> <span class="token operator">-</span> 0s <span class="token operator">-</span> loss<span class="token punctuation">:</span> <span class="token number">0.0199</span> <span class="token operator">-</span> accuracy<span class="token punctuation">:</span> <span class="token number">0.9945</span> <span class="token operator">-</span> val_loss<span class="token punctuation">:</span> <span class="token number">1.1787</span> <span class="token operator">-</span> val_accuracy<span class="token punctuation">:</span> <span class="token number">0.8109</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="%E6%A8%A1%E5%9E%8B%E6%83%85%E5%86%B5.png" alt="模型情况"></p></li><li><p>matlabplot画图</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 画图</span><span class="token keyword">def</span> <span class="token function">plot_graphs</span><span class="token punctuation">(</span>history<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>history<span class="token punctuation">.</span>history<span class="token punctuation">[</span>string<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>history<span class="token punctuation">.</span>history<span class="token punctuation">[</span><span class="token string">'val_'</span> <span class="token operator">+</span> string<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"Epochs"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">[</span>string<span class="token punctuation">,</span> <span class="token string">'val_'</span> <span class="token operator">+</span> string<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>plot_graphs<span class="token punctuation">(</span>history<span class="token punctuation">,</span> <span class="token string">"accuracy"</span><span class="token punctuation">)</span>plot_graphs<span class="token punctuation">(</span>history<span class="token punctuation">,</span> <span class="token string">"loss"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="%E4%B8%8B%E8%BD%BD1.png" alt="accuracy"></p><p><img src="%E4%B8%8B%E8%BD%BD2.png" alt="loss"></p></li><li><p>转化key和value，返回该层的权重，有多少个神经元，可以不写代码里</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 将value和key转化，可以互相反查</span>reverse_word_index <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> word_index<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decode_sentence</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 字典dict.get,返回指定键i的值，如果没有返回'？'。</span>    <span class="token comment" spellcheck="true"># join用法，把？，用空格连接</span>    <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>reverse_word_index<span class="token punctuation">.</span>get<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> text<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 测试一下对不对</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'training_padded[0]为：'</span><span class="token punctuation">,</span>training_padded<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>decode_sentence<span class="token punctuation">(</span>training_padded<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>training_sentences<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>e <span class="token operator">=</span> model<span class="token punctuation">.</span>layers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 返回该层的权重</span>weights <span class="token operator">=</span> e<span class="token punctuation">.</span>get_weights<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>weights<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># shape: (vocab_size, embedding_dim)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="9"><li><p>利用训练好的模型，传入新句子，判断情感色彩</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 利用神经网络，判断新句子的情感色彩</span>new_sentence <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"granny starting to fear spiders in the garden might be real"</span><span class="token punctuation">,</span>                <span class="token string">"game of thrones season finale showing this sunday night"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 求出新句子的token序列，分词编号用的是训练集</span>new_sequences <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>texts_to_sequences<span class="token punctuation">(</span>new_sentence<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 规范化序列</span>padded <span class="token operator">=</span> pad_sequences<span class="token punctuation">(</span>new_sequences<span class="token punctuation">,</span> maxlen<span class="token operator">=</span>max_length<span class="token punctuation">,</span>                       padding<span class="token operator">=</span>padding_type<span class="token punctuation">,</span>                       truncating<span class="token operator">=</span>trunc_type<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出预测结果</span><span class="token keyword">print</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>padded<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 结果 [[9.8276615e-01] [3.8519531e-04]]，表示第一句话负面性概率为98.2%，第二句负面性为38.5%</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（十）</title>
      <link href="/posts/9be8.html/"/>
      <url>/posts/9be8.html/</url>
      
        <content type="html"><![CDATA[<h1 id="SimCSE归纳总结"><a href="#SimCSE归纳总结" class="headerlink" title="SimCSE归纳总结"></a>SimCSE归纳总结</h1><ol><li><p>SimCSE，运用了dropout的方法替换了原有的数据增强方法，将输入两次dropout产生的结果当作学习的正例</p><ul><li><p>为什么要进行数据增强：在深度学习中，一般要求样本的数量要充足，样本数量越多，训练出来的模型效果越好，模型的泛化能力越强。但是实际中，样本数量不足或者样本质量不够好，这就要对样本做数据增强，来提高样本质量</p></li><li><p>传统数据增强方法：</p><ul><li>图片：如果数据集都是图片类，可以运用翻转，旋转，缩放，剪裁，平移，添加噪声</li><li>文本：数据是文本类的，可以使用回译，替换同义词，随机插入一个词语，随机交换词语，p概率删除一个词语</li></ul></li></ul></li><li><p>用<strong>自然语言推理NLI</strong>的数据用于有监督的对比学习：自然语言推理研究一个假设是否可以从一个前提中推断出来，假设和前提都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三类：       </p><ul><li><p>蕴涵：假设可以从前提中推断出来。       </p></li><li><p>矛盾：假设的否定可以从前提推断出来。       </p></li><li><p>中立：所有其情况。       </p></li></ul></li></ol><p>自然语言推理也被称为识别文本蕴涵任务。例如，下面的一对会被标记为蕴涵，因为假设中的“示爱”可以从前提中的“拥抱”中推断出来。       </p><p>前提：两个女人互相拥抱。       </p><p>假设：两个女人在表达爱意。       </p><p>下面是一个矛盾的例子，因为“运行代码”表示“不睡觉”而不是“睡眠”。       </p><p>前提：一个男人正在运行一个代码示例</p><p>假设：这个人正在睡觉。       </p><p>第三个例子显示了一种中立关系，因为“为演出”的事实不能推断出“著名”和“不出名”。       </p><p>前提：音乐家正在表演。       </p><p>假设：音乐家是有名的。       </p><ol start="3"><li><p>有监督学习(supervised learning)和无监督学习(unsupervised learning)</p><ul><li>supervised learning：通过已有的样本去群里安处一个最优模型，再利用这个模型将就可以将其他的未知数据输入，得到已知的分类。就像小时候父母告诉我们这个是苹果，这个是狗，这就是已构建好的模型和函数以及分类，当身边没有大人时，当我们看到类似的东西时，也可以分辨出其他的水果以及动物。经典有监督学习（KNN，SVM以后学习一下）</li><li>unsupervised learning：我们没有任何训练样本，直接利用已有数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别（比如哪些更朦胧一点，哪些更写实一些，即使我们不知道什么叫做朦胧派，什么叫做写实派，但是至少我们能把他们分为两个类）。无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。</li><li>有训练样本就用有监督学习，没有训练样本肯定用不了有监督学习。但现实中，在没有训练样本的情况下，我们可以通过人工标注一些样本，然后去用有监督的方法去做</li></ul></li><li><p>泛化误差：对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为<strong>泛化误差</strong>。</p><ul><li>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络<strong>过度拟合了训练集</strong>，对训练集以外的数据却不work。</li></ul><img src="拟合对比.png" alt="拟合对比"><ul><li>具体过拟合欠拟合等解决办法见<a href="http://blog.bangbangbangbang.top/posts/5c43.html/">http://blog.bangbangbangbang.top/posts/5c43.html/</a></li></ul></li><li><p>Dropout：是一种防止过拟合的方法，处理过后也可作为新数据加入数据集中，增加数据集的多样性。</p><ul><li>在每次训练中，减少每个相关元素之间一半的关联，就可以明显减少过拟合现象。通过这种方法，可以减少相关元素之间的相互作用，可以使模型的泛化能力更强，因为不会过于依赖某些局部特征</li></ul><img src="dropout.jpeg" alt="dropout" style="zoom:50%;"></li><li><p>对比表示学习（Contrastive Representation Learning）</p><ul><li>主要是要**构建正样本$x^+$和负样本$x^-$**，正例就是与x相似的数据，负例就是与x不同的数据</li><li>在论文<a href="http://blog.bangbangbangbang.top/posts/3b4c.html/ICML2020.pdf">Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</a>中指出了对比学习的两个指标</li><li><strong>Alignment</strong>对齐性，针对正例：计算正例对之间的向量距离的期望，越相似的正例对之间的alignment程度越高，距离越小。</li><li><strong>Uniformity</strong>均匀性，针对负例：所有数据的向量分布越均匀，保留的信息越多。最极端的反例，所有数据都映射到单位超球面的同一点上，这就极度违背了uniformity原则，这代表数据的所有信息都没了，只有一个点的信息了。负例对之间，距离越远愈好</li><li>这篇论文也采用这两个指标来衡量生成的句子向量，alignment和uniformity越低，向量的质量越高，在STS任务上的Spearman相关系数越高。spearman是一种相关系数方法</li></ul></li><li><p>论文中的SimCSE方法</p><ul><li><p>Unsupervised SimCSE：引入dropout给输入加入噪声，假设加入噪声后的输入与原始输入在语义空间上距离相近。然后将相同的语句输入两次给预训练模型，得到一个正例对。因为dropout每次是以p概率隐去一半的相关性，所以相同输入所传出的值每次都是不同的，可以用作正例。</p></li><li><p>supervised SimCSE：利用标注数据来构造对比学习的正负例子，最终选择NLI作为数据集</p></li></ul></li><li><p>熵entropy</p><ul><li>熵**(Entropy)**：可以表示一个事件A的自信息量，也就是A包含多少信息。</li><li>KL散度**(Kullback-Leibler Divergence)**：可以用来表示从事件A的角度来看，事件B有多大不同。</li><li>交叉熵**(Cross Entropy)**：可以用来表示从事件A的角度来看，如何描述事件B。</li><li><strong>KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价</strong>。</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（九）</title>
      <link href="/posts/1e5f.html/"/>
      <url>/posts/1e5f.html/</url>
      
        <content type="html"><![CDATA[<h1 id="SimCSE运行"><a href="#SimCSE运行" class="headerlink" title="SimCSE运行"></a>SimCSE运行</h1><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><img src="训练结果.png" alt="训练结果" style="zoom:67%;"><hr><ul><li><p>先安装好torch和所需库</p></li><li><p>先下载评估数据，并且要安装wegt以便运行bash语句</p></li><li><pre class="line-numbers language-sh"><code class="language-sh">cd SentEval/data/downstream/bash download_dataset.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>经向作者发邮件咨询如何运行以及参数调试</strong></p></li><li><pre class="line-numbers language-python"><code class="language-python">python evaluation<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span>model_name_or_path princeton<span class="token operator">-</span>nlp<span class="token operator">/</span>sup<span class="token operator">-</span>simcse<span class="token operator">-</span>bert<span class="token operator">-</span>base<span class="token operator">-</span>uncased<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>运行语句设置</p></li><li><pre class="line-numbers language-python"><code class="language-python">python evaluation<span class="token punctuation">.</span>py \    <span class="token operator">-</span><span class="token operator">-</span>model_name_or_path princeton<span class="token operator">-</span>nlp<span class="token operator">/</span>sup<span class="token operator">-</span>simcse<span class="token operator">-</span>bert<span class="token operator">-</span>base<span class="token operator">-</span>uncased \    <span class="token operator">-</span><span class="token operator">-</span>pooler cls \    <span class="token operator">-</span><span class="token operator">-</span>task_set sts \    <span class="token operator">-</span><span class="token operator">-</span>mode test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>Arguments for the evaluation script are as follows,</p><ul><li><code>--model_name_or_path</code>: The name or path of a <code>transformers</code>-based pre-trained checkpoint. You can directly use the models in the above table, e.g., <code>princeton-nlp/sup-simcse-bert-base-uncased</code>.</li><li><code>--pooler</code>: Pooling method. Now we support<ul><li><code>cls</code> (default): Use the representation of <code>[CLS]</code> token. A linear+activation layer is applied after the representation (it’s in the standard BERT implementation). If you use SimCSE, you should use this option.</li><li><code>cls_before_pooler</code>: Use the representation of <code>[CLS]</code> token without the extra linear+activation.</li><li><code>avg</code>: Average embeddings of the last layer. If you use checkpoints of SBERT/SRoBERTa (<a href="https://arxiv.org/abs/1908.10084" target="_blank" rel="noopener">paper</a>), you should use this option.</li><li><code>avg_top2</code>: Average embeddings of the last two layers.</li><li><code>avg_first_last</code>: Average embeddings of the first and last layers. If you use vanilla BERT or RoBERTa, this works the best.</li></ul></li><li><code>--mode</code>: Evaluation mode<ul><li><code>test</code> (default): The default test mode. To faithfully reproduce our results, you should use this option.</li><li><code>dev</code>: Report the development set results. Note that in STS tasks, only <code>STS-B</code> and <code>SICK-R</code> have development sets, so we only report their numbers. It also takes a fast mode for transfer tasks, so the running time is much shorter than the <code>test</code> mode (though numbers are slightly lower).</li><li><code>fasttest</code>: It is the same as <code>test</code>, but with a fast mode so the running time is much shorter, but the reported numbers may be lower (only for transfer tasks).</li></ul></li><li><code>--task_set</code>: What set of tasks to evaluate on (if set, it will override <code>--tasks</code>)<ul><li><code>sts</code> (default): Evaluate on STS tasks, including <code>STS 12~16</code>, <code>STS-B</code> and <code>SICK-R</code>. This is the most commonly-used set of tasks to evaluate the quality of sentence embeddings.</li><li><code>transfer</code>: Evaluate on transfer tasks.</li><li><code>full</code>: Evaluate on both STS and transfer tasks.</li><li><code>na</code>: Manually set tasks by <code>--tasks</code>.</li></ul></li><li><code>--tasks</code>: Specify which dataset(s) to evaluate on. Will be overridden if <code>--task_set</code> is not <code>na</code>. See the code for a full list of tasks.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 代码 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（八）</title>
      <link href="/posts/4201.html/"/>
      <url>/posts/4201.html/</url>
      
        <content type="html"><![CDATA[<h1 id="SimCSE代码Mac配置"><a href="#SimCSE代码Mac配置" class="headerlink" title="SimCSE代码Mac配置"></a>SimCSE代码Mac配置</h1><ul><li><p>安装conda虚拟环境<a href="https://github.com/conda-forge/miniforge/#download" target="_blank" rel="noopener">https://github.com/conda-forge/miniforge/#download</a></p></li><li><pre class="line-numbers language-shell"><code class="language-shell">bash Miniforge3-MacOSX-arm64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置环境变量</p></li><li><pre class="line-numbers language-shell"><code class="language-shell">vim ~/.bash_profileexport PATH="/Users/leng/miniforge3/bin:$PATH"#刷新变量source $HOME/.bash_profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建python虚拟环境</p></li><li><pre class="line-numbers language-shell"><code class="language-shell">conda create -n py38 python=3.8# 激活环境source activate# 打开虚拟环境conda activate py38# 退出环境source deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创造Virtualenv虚拟环境</p></li><li><pre class="line-numbers language-shell"><code class="language-shell"># 在项目目录下生成venv目录python -m venv venv# 将下载好的安装脚本放在venv同级目录下，安装bash download_and_install.sh# 输入虚拟环境的路径，注意要以venv结尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 代码 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（七）</title>
      <link href="/posts/f664.html/"/>
      <url>/posts/f664.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（七）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（七）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（七）"></a>Simple Contrastive Learning of Sentence Embeddings（七）</h1><h3 id="5-Connection-to-Anisotropy-各向异性连接"><a href="#5-Connection-to-Anisotropy-各向异性连接" class="headerlink" title="5 Connection to Anisotropy 各向异性连接"></a>5 Connection to Anisotropy 各向异性连接</h3><h4 id="还需学习的知识点"><a href="#还需学习的知识点" class="headerlink" title="还需学习的知识点"></a><font color="red">还需学习的知识点</font></h4><ul><li>anisotropy（各向异性）是什么意思</li><li>isotropic distribution 各向同性分布</li><li>奇异值singular是什么东西</li><li>这些公式都要再看一下</li></ul><hr><blockquote><p>Recent work identifies an anisotropy problem in language representations (Ethayarajh, 2019; Li et al., 2020), i.e., the learned embeddings occupy a narrow cone in the vector space, which largely limits their expressiveness. </p></blockquote><ul><li>最近的研究发现了语言表征中的“各向异性”问题，即学习到的嵌入在向量空间中占据了一个狭窄的圆锥体，这在很大程度上限制了它们的表达能力。</li></ul><blockquote><p>Gao et al. (2019) term it as a <em>representation degeneration</em> problem and demonstrate that language models trained with tied input/output embeddings lead to anisotropic word embeddings, and this is further observed by Ethayarajh (2019) in pretrained contextual embeddings. </p></blockquote><ul><li>Gao将其称为“表征退化”问题，并证明使用捆绑输入/输出嵌入训练的语言模型会导致各向异性的单词嵌入，Ethayarajh在预先训练的上下文嵌入中进一步观察到了这一点。</li></ul><blockquote><p>Wang et al. (2020) show that the singular values of the word embedding matrix decay drastically. In other words, except for a few dominating singular values, all others are close to zero.</p></blockquote><ul><li>Wang证明单词嵌入矩阵的奇异值急剧衰减。换言之，除了少数占主导地位的奇异值外，其他所有奇异值都接近于零。</li></ul><blockquote><p>A simple way to alleviate the problem is postprocessing, either to eliminate the dominant principal components (Arora et al., 2017; Mu and Viswanath, 2018), or to map embeddings to an isotropic distribution (Li et al., 2020; Su et al., 2021). </p></blockquote><ul><li>缓解问题的一个简单方法是后处理，即消除主要的主成分，或将嵌入映射到各向同性分布。</li></ul><blockquote><p>Alternatively, one can add regularization during training (Gao et al., 2019; Wang et al., 2020). </p></blockquote><ul><li>或者，可以在训练期间添加正则化。</li></ul><blockquote><p>In this section, we show that the contrastive objective can inherently “flatten” the singular value distribution of the sentence-embedding matrix.</p></blockquote><ul><li>在这一节中，我们证明了对比目标可以内在地“平坦”句子嵌入矩阵的奇异值分布。</li></ul><blockquote><p>Following Wang and Isola (2020), the asymptotics of the contrastive learning objective can be expressed by the following equation when the number of negative instances approaches infinity (assuming f(x) is normalized):</p></blockquote><ul><li>在Wang和Isola的基础上，对比学习目标的渐近性可以用以下等式表示，当负实例的数量接近无穷大时（假设f（x）是标准化的）：</li></ul><p>$$<br>\begin{array}{l}<br>-\frac{1}{\tau} \underset{\left(x, x^{+}\right) \sim p_{\mathrm{pos}}}{\mathbb{E}}\left[f(x)^{\top} f\left(x^{+}\right)\right]<br>+\underset{x \sim p_{\text {data }}}{\mathbb{E}}\left[\log \underset{x^{-} \sim p_{\text {data }}}{\mathbb{E}}\left[e^{f(x)^{\top} f\left(x^{-}\right) / \tau}\right]\right]<br>\end{array}<br>$$</p><blockquote><p>where the first term keeps positive instances similar and the second pushes negative pairs apart. When $p_{data}$ is uniform over finite samples ${x_i}_{i=1}^m$ , with $h_i=f(x)$, we can derive the following formula from the second term with Jensen’s inequality:</p></blockquote><ul><li>其中第一项保持正的实例相似，第二项将负的对分开。当$p_{data}$在有限样本${x_i}_{i=1}^m$上是一致的，且$h_i=f（x）$，我们可以从第二项和詹森不等式导出以下公式：</li></ul><p>$$<br>\begin{aligned}<br>&amp; \underset{x \sim p_{\text {data }}}{\mathbb{E}}\left[\log \underset{x^{-} \sim p_{\text {data }}}{\mathbb{E}}\left[e^{f(x)^{\top} f\left(x^{-}\right) / \tau}\right]\right] \<br>=&amp; \frac{1}{m} \sum_{i=1}^{m} \log \left(\frac{1}{m} \sum_{j=1}^{m} e^{\mathbf{h}<em>{i}^{\top} \mathbf{h}</em>{j} / \tau}\right) \<br>\geq &amp; \frac{1}{\tau m^{2}} \sum_{i=1}^{m} \sum_{j=1}^{m} \mathbf{h}<em>{i}^{\top} \mathbf{h}</em>{j}<br>\end{aligned}<br>$$</p><blockquote><p>Let $W$ be the sentence embedding matrix corresponding to ${x_i}_{i=1}^m$, i.e., the i-th row of $W$ is $h_i$. </p></blockquote><ul><li>设$W$为${x_i}_{i=1}^m$对应的句子嵌入矩阵，即W的第i行为$h_i$。</li></ul><blockquote><p>Ignoring the constant terms, optimizing the second term in Eq essentially minimizes an upper bound of the summation of all elements in $WW^T$, i.e., $\operatorname{Sum}\left(\mathbf{W} \mathbf{W}^{\top}\right)=\sum_{i=1}^{m} \sum_{j=1}^{m} \mathbf{h}<em>{i}^{\top} \mathbf{h}</em>{j}$</p></blockquote><ul><li>忽略常量项，优化了等式1中的第二项实质上最小化了$WW^T$中所有元素之和的上限，即$\operatorname{Sum}\left(\mathbf{W} \mathbf{W}^{\top}\right)=\sum_{i=1}^{m} \sum_{j=1}^{m} \mathbf{h}<em>{i}^{\top} \mathbf{h}</em>{j}$</li></ul><blockquote><p>Since we normalize $h_i$, all elements on the diagonal of $WW^T$ are 1 and then $tr(WW^T)$, also the sum of all eigenvalues, is a constant. </p></blockquote><ul><li>因为我们规范化了$h_i$，所以$WW^T$对角线上的所有元素都是1，$tr（WW^T）$，也是所有特征值的总和，是一个常数。</li></ul><blockquote><p>According to Merikoski (1984), if all elements in $WW^T$ are positive, which is the case in most times from Gao et al. (2019), then $Sum(WW^T)$ is an upper bound for the largest eigenvalue of $WW^T$. </p></blockquote><ul><li>根据Merikoski，如果$WW^T$中的所有元素都是正的，这在Gao的大多数情况下都是这样，那么$Sum（WW^T）$是最大特征值$WW^T$的上界。</li></ul><blockquote><p>Therefore, when minimizing the second term in Eq1, we are reducing the top eigenvalue of $WW^T$ and inherently “flattening” the singular spectrum of the embedding space.</p></blockquote><ul><li>因此，当最小化Eq1中的第二项时，我们减少了$WW^T$的顶部特征值，并且固有地“平坦”了嵌入空间的奇异谱。</li></ul><blockquote><p>Hence contrastive learning can potentially tackle the representation degeneration problem and improve the uniformity.</p></blockquote><ul><li>因此，对比学习有可能解决表征退化问题，提高一致性。</li></ul><blockquote><p>Compared to postprocessing methods in Li et al. (2020); Su et al. (2021), which only aim to encourage isotropic representations, contrastive learning also optimizes for aligning positive pairs by the first term in Eq. 6, which is the key to the success of SimCSE (a quantitative analysis is given in §7).</p></blockquote><ul><li>与Li等人（2020）的后处理方法相比；Su等人（2021年）只致力于鼓励各向同性表征，对比学习还优化了等式1中第一项的正对对齐，这是SimCSE成功的关键（定量分析见第七章表1）.</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（六）</title>
      <link href="/posts/ca01.html/"/>
      <url>/posts/ca01.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（六）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（六）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（六）"></a>Simple Contrastive Learning of Sentence Embeddings（六）</h1><h3 id="3-Unsupervised-SimCSE-and-supervised-SimCSE"><a href="#3-Unsupervised-SimCSE-and-supervised-SimCSE" class="headerlink" title="3 Unsupervised SimCSE and supervised SimCSE"></a>3 Unsupervised SimCSE and supervised SimCSE</h3><hr><h4 id="还需学习的知识点"><a href="#还需学习的知识点" class="headerlink" title="还需学习的知识点"></a><font color="red">还需学习的知识点</font></h4><ul><li><p>dropout mask，mask是什么意思</p></li><li><p>STS-B（Semantic Textual Similarity Benchmark）：语义文本相似度基准</p></li><li><p>write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). </p></li></ul><hr><blockquote><p>In this section, we describe our unsupervised SimCSE model. </p></blockquote><ul><li>在本节中，我们将介绍我们的无监督SimCSE模型。</li></ul><blockquote><p>The idea is extremely simple: we take a collection of sentences $\left{x_{i}\right}_{i=1}^{m}$ and use $x_i^+=x_i$. </p></blockquote><ul><li>这个想法非常简单：我们取一组句子$\left{x_{i}\right}_{i=1}^{m}$，然后使$x_i^+=x_i$。</li></ul><blockquote><p>The key ingredient to get this to work with identical positive pairs is through the use of independently sampled <em>dropout masks</em>. </p></blockquote><ul><li>关键的因素是通过使用独立取样的“dropout masks”，使这项工作与相同的正对。</li></ul><blockquote><p>In standard training of Transformers (Vaswani et al., 2017), there is a dropout mask placed on fully-connected layers as well as attention probabilities (default p = 0.1). </p></blockquote><ul><li>在Transformers的标准训练中，在完全连接的层上以及注意概率（默认p=0.1）上放置了一个dropout mask。</li></ul><blockquote><p>We denote $\mathbf{h}<em>{i}^{z}=f</em>{\theta}\left(x_{i}, z\right)$ where $z$ is a random mask for dropout. </p></blockquote><ul><li>我们用$\mathbf{h}<em>{i}^{z}=f</em>{\theta}\left(x_{i}, z\right)$表示，$z$是一个随机的dropout mask</li></ul><blockquote><p>We simply feed the same input to the encoder twice by applying different dropout masks  $z, z^{\prime}$ and the training objective becomes:</p></blockquote><ul><li>我们只需通过应用不同的dropout mask，$z，z^{\prime}$将相同的输入输入输入编码器两次，训练目标就变成：</li></ul><blockquote><p>for a mini-batch with N sentences. </p></blockquote><ul><li>对于少量的句子N</li></ul><blockquote><p>Note that z is just the standard dropout mask in Transformers and we do not add any additional dropout.</p></blockquote><ul><li>注意，z只是转变中的标准dropout mask，我们没有添加任何额外的dropout。</li></ul><h4 id="Dropout-noise-as-data-augmentation-作为数据增强的dropout噪声"><a href="#Dropout-noise-as-data-augmentation-作为数据增强的dropout噪声" class="headerlink" title="Dropout noise as data augmentation 作为数据增强的dropout噪声"></a>Dropout noise as data augmentation 作为数据增强的dropout噪声</h4><blockquote><p>We view this approach as a minimal form of data augmentation: the positive pair takes exactly the same sentence, and their embeddings only differ in dropout masks. </p></blockquote><ul><li>我们将这种方法视为数据扩充的一种最小形式：正例对采用完全相同的句子，它们的嵌入只在dropout mask上有所不同。</li></ul><blockquote><p>We compare this approach to common augmentation techniques and other training objectives on the STS-B development set (Cer et al., 2017).</p></blockquote><ul><li>我们将这种方法与常见的增强技术和STS-B开发集上的其他训练目标进行了比较。</li></ul><blockquote><p>We use $N=512$ and $m = 10^6$ sentences randomly drawn from English Wikipedia in these experiments. </p></blockquote><p>在这些实验中，我们使用从英文维基百科中随机抽取的$N=512$ 和 $m = 10^6$ 个句子。</p><blockquote><p><strong>Table 2</strong> compares our approach to common data augmentation techniques such as crop, word deletion and replacement, which can be viewed as $\mathbf{h}=f_{\theta}(g(x), z)$ and $g$ is a (random) discrete operator on $x$. </p></blockquote><ul><li><p><strong>表2</strong>将我们的方法与常见的数据扩充技术（如裁剪、字删除和替换）进行了比较，这些技术可以看作是$\mathbf{h}=f_{\theta}(g(x), z)$ ，而$g$是$x$上的（随机）离散运算符。</p><img src="Table 2.png" alt="Table 2" style="zoom:50%;"></li></ul><blockquote><p>We find that even deleting one word would hurt performance and none of the discrete augmentations outperforms basic dropout noise.</p></blockquote><ul><li>我们发现，即使删除一个单词也会影响性能，并且没有一个离散增强比基本的丢失噪声更好。</li></ul><blockquote><p>We also compare this self-prediction training objective to next-sentence objective used in Logeswaran and Lee (2018), taking either one encoder or two independent encoders. </p></blockquote><ul><li>我们还将这个自我预测训练目标与Logeswaran和Lee中使用的下一个句子目标进行比较，选择一个编码器或两个独立的编码器。</li></ul><blockquote><p>As shown in Table 3, we find that SimCSE performs much better than the next-sentence objectives (79.1 vs 69.7 on STS-B) and using one encoder instead of two makes a significant difference in our approach.</p></blockquote><ul><li><p>如表3所示，我们发现SimCSE比下一个句子目标（79.1 vs STS-B为69.7）的表现要好得多，并且使用一个编码器而不是两个编码器使我们的方法有显著的不同。</p><img src="Table 3.png" alt="Table 3" style="zoom:50%;"></li></ul><hr><h4 id="Why-does-it-work"><a href="#Why-does-it-work" class="headerlink" title="Why does it work?"></a>Why does it work?</h4><blockquote><p>To further understand the role of dropout noise in unsupervised SimCSE, we try out different dropout rates in Table 4 and observe that all the variants underperform the default dropout probability p = 0.1 from Transformers. </p></blockquote><ul><li>为了进一步了解在无监督SimCSE中丢失噪声的作用，我们在表4中尝试了不同的丢失率，并观察到所有变体都低于Transformers的默认丢失概率p=0.1。</li></ul><img src="Table 4.png" alt="Table 4" style="zoom:50%;"><blockquote><p>We find two extreme cases particularly interesting: “no dropout” (p = 0) and “fixed 0.1” (using default dropout p = 0.1 but the same dropout masks for the pair).</p></blockquote><ul><li>我们发现两个极端的情况特别有趣：“无dropout”（p=0）和“固定0.1”（使用默认的dropoutp=0.1，但对这两种情况使用相同的dropout mask）。</li></ul><p> In both cases, the resulting embeddings for the pair are exactly the same, and it leads to a dramatic performance degradation. </p><ul><li>在这两种情况下，生成的嵌入对完全相同，这会导致性能急剧下降。</li></ul><blockquote><p>We take the checkpoints of these models every 10 steps during training and visualize the alignment and uniformity metrics2 in Figure 2, along with a simple data augmentation model “delete one word”. </p></blockquote><ul><li>在训练过程中，我们每10步对这些模型进行一次检查点检查，并在图2中可视化对齐和一致性度量2，以及一个简单的数据处理模型“删除一个单词”。</li></ul><img src="Figure 2.png" alt="Figure 2" style="zoom:50%;"><blockquote><p>As is clearly shown, all models largely improve the uniformity. </p></blockquote><ul><li>如图所示，所有模型在很大程度上改善了均匀性。</li></ul><blockquote><p>However, the alignment of the two special variants also degrades drastically, while our unsupervised SimCSE keeps a steady alignment, thanks to the use of dropout noise. </p></blockquote><ul><li>然而，这两种特殊变体的对齐也会急剧下降，而我们的无监督SimCSE由于使用了衰减噪声，保持了稳定的对齐。</li></ul><blockquote><p>On the other hand, although “delete one word” slightly improves the alignment, it has a smaller gain on the uniformity, and eventually underperforms unsupervised SimCSE.</p></blockquote><ul><li>另一方面，虽然“删除一个单词”稍微提高了对齐度，但它在一致性方面的增益较小，最终表现不如无监督SimCSE。</li></ul><hr><h3 id="4-Supervised-SimCSE"><a href="#4-Supervised-SimCSE" class="headerlink" title="4 Supervised SimCSE"></a>4 Supervised SimCSE</h3><blockquote><p>We have demonstrated that adding dropout noise is able to learn a good alignment for positive pairs $\left(x, x^{+}\right) \sim p_{\text {pos }}$. </p></blockquote><ul><li>我们已经证明，对于正对$\left(x, x^{+}\right) \sim p_{\text {pos }}$，添加dropout噪声能够学习良好的对齐性。</li></ul><blockquote><p>In this section, we study whether we can leverage supervised datasets to provide better training signals for improving alignment of our approach.</p></blockquote><ul><li>在本节中，我们将研究是否可以利用监督数据集来提供更好的训练信号，以改进方法的一致性。</li></ul><blockquote><p>Prior work (Conneau et al., 2017; Reimers and Gurevych, 2019) has demonstrated that supervised natural language inference (NLI) datasets (Bowman et al., 2015; Williams et al., 2018) are effective for learning sentence embeddings, by predicting whether the relationship between two sentences is <em>entailment</em>, <em>neutral</em> or <em>contradiction</em>. </p></blockquote><ul><li>前期工作已经证明了有监督的自然语言推理（NLI）数据集通过预测两个句子之间的关系是蕴涵、中性还是矛盾，来有效地学习句子嵌入。</li></ul><blockquote><p>In our contrastive learning framework, we instead directly take $(x_i,x_i^+)$pairs from supervised datasets and use them to optimize Eq. 1.</p></blockquote><ul><li>在我们的对比学习框架中，我们直接从有监督的数据集中提取$(x_i,x_i^+)$对，并使用它们来优化等式1。</li></ul><p>$$<br>\ell_{i}=\log \frac{e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{i}^{+}\right) / \tau}}{\sum_{j=1}^{N} e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{j}^{+}\right) / \tau}}<br>$$</p><hr><h4 id="Exploiting-supervised-data利用监督数据"><a href="#Exploiting-supervised-data利用监督数据" class="headerlink" title="Exploiting supervised data利用监督数据"></a>Exploiting supervised data利用监督数据</h4><blockquote><p>We first explore which annotated datasets are especially suitable for constructing positive pairs $(x_i,x_i^+)$. </p></blockquote><ul><li>我们首先探讨哪些带注释的数据集特别适合于构造正对$(x_i,x_i^+)$。</li></ul><blockquote><p>We exiperiment with a number of datasets with sentence-pair examples, including QQP4: Quora question pairs; Flickr30k (Young et al., 2014): each image is annotated with 5 human-written captions and we consider any two captions of the same image as a positive pair; ParaNMT (Wieting and Gimpel, 2018): a large-scale back-translation paraphrase dataset; and finally NLI datasets: SNLI (Bowman et al., 2015) and MNLI (Williams et al., 2018).</p></blockquote><ul><li>我们用一些句子对的例子进行了实验，包括QQP问题对；Flickr：每幅图像都有5个人类书写的字幕注释，我们将同一幅图像的任意两个字幕视为正对；ParaNMT：大规模反译释义数据集；最后是NLI数据集：SNLI和MNLI。</li></ul><blockquote><p>We train the contrastive learning model (Eq. 1) with different datasets and compare the results in Table 5 （for a fair comparison, we also run experiments with the same # of training pairs）. </p></blockquote><ul><li>我们用不同的数据集训练对比学习模型（等式1），并比较表5中的结果（为了公平比较，我们还用相同的训练对进行实验）。</li></ul><img src="Table 5.png" alt="Table 5" style="zoom:50%;"><blockquote><p>We find that most of these models using supervised datasets outperform our unsupervised approach, showing a clear benefit from supervised signals. </p></blockquote><ul><li>我们发现，大多数使用监督数据集的模型都比我们的无监督方法有更好的性能，显示出监督信号的明显优势。</li></ul><blockquote><p>Among all the options, using entailment pairs from the NLI (SNLI + MNLI) datasets perform the best. </p></blockquote><p>在所有选项中，使用NLI（SNLI+MNLI）数据集entailment对表现最好。</p><blockquote><p>We think this is reasonable, as the NLI datasets consist of high-quality and crowd-sourced pairs, and human annotators are expected to write the hypotheses manually based on the premises, and hence two sentences tend to have less lexical overlap. </p></blockquote><ul><li>我们认为这是合理的，因为NLI数据集由高质量和众包的成对数据组成，并且人类注释者需要根据前提手工编写假设，因此两句话的词汇重叠较少。</li></ul><blockquote><p>For instance, we find that the lexical overlap (F1 measured between two bags of words) for the entailment pairs (SNLI + MNLI) is 39%, while they are 60% and 55% for QQP and ParaNMT.</p></blockquote><ul><li>例如，我们发现蕴涵对（SNLI+MNLI）的词汇重叠（两袋词之间的F1）为39%，而QQP和ParaNMT分别为60%和55%。</li></ul><hr><h4 id="Contradiction-as-hard-negatives否定的矛盾"><a href="#Contradiction-as-hard-negatives否定的矛盾" class="headerlink" title="Contradiction as hard negatives否定的矛盾"></a>Contradiction as hard negatives否定的矛盾</h4><blockquote><p>Finally, we further take the advantage of the NLI datasets by using its contradiction pairs as hard negatives. </p></blockquote><ul><li>最后，我们进一步利用NLI数据集的矛盾对作为硬否定。</li></ul><blockquote><p>In NLI datasets, given one premise, annotators are required to manually write one sentence that is absolutely true (entailment), one that might be true (neutral), and one that is definitely false (contradiction). </p></blockquote><ul><li>在NLI数据集中，给定一个前提，注释者需要手动编写一个绝对正确的句子（蕴涵），一个可能正确的句子（中性），一个绝对错误的句子（矛盾）。</li></ul><blockquote><p>Thus for each premise and its entailment hypothesis, there is an accompanying contradiction hypothesis7 (see Figure 1 for an example).</p></blockquote><ul><li>因此，对于每个前提及其蕴涵假设，都有一个伴随的矛盾假设（参见图1中的示例）。</li></ul><blockquote><p>Formally, we extend $(x_i,x_i^+)$ to $(x_i,x_i^+,x_i^-)$ where $x_i$ is the premise, $x_i^+$and $x_i^-$ are entailment and contradiction hypotheses. </p></blockquote><ul><li>形式上，我们将$（x_i，x_i^+）$扩展到$(x_i,x_i^+,x_i^-)$，其中$x_i$是前提，$x_i^+$和$x_i^-$是蕴涵和矛盾假设</li></ul><blockquote><p>The training objective $\ell_{i}$ is then defined by (N is the mini-batch size):</p></blockquote><ul><li>训练目标$\ell{i}$由（N是最小批量大小）定义：</li></ul><p>$$<br>-\log \frac{e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{i}^{+}\right) / \tau}}{\sum_{j=1}^{N}\left(e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{j}^{+}\right) / \tau}+e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{j}^{-}\right) / \tau}\right)}<br>$$</p><blockquote><p>As shown in Table 5, adding hard negatives can further improve performance (84.9 $\rightarrow$ 86.2) and this is our final supervised SimCSE. </p></blockquote><ul><li>如表5所示，添加消极可以进一步提高性能（84.9$\rightarrow$86.2），这是我们的最终有监督SimCSE。</li></ul><blockquote><p>We also tried to add the ANLI dataset (Nie et al., 2020) or combine it with our unsupervised SimCSE approach, but didn’t find a meaningful improvement. </p></blockquote><ul><li>我们还尝试添加ANLI数据集或将其与我们的无监督SimCSE方法相结合，但没有发现有意义的改进。</li></ul><blockquote><p>We also considered a dual encoder framework in supervised SimCSE and it hurt performance (86.2$\rightarrow$ 84.2).</p></blockquote><ul><li>我们还考虑了监督SimCSE中的双编码器框架，它会影响性能（86.2$\rightarrow$84.2）。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（五）</title>
      <link href="/posts/8218.html/"/>
      <url>/posts/8218.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（五）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（五）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（五）"></a>Simple Contrastive Learning of Sentence Embeddings（五）</h1><h3 id="2-Background-Contrastive-Learning"><a href="#2-Background-Contrastive-Learning" class="headerlink" title="2 Background: Contrastive Learning"></a>2 Background: Contrastive Learning</h3><hr><h4 id="还需学习的知识点"><a href="#还需学习的知识点" class="headerlink" title="还需学习的知识点"></a><font color="red">还需学习的知识点</font></h4><ul><li><p>交叉熵（cross-entropy）<a href="https://www.zhihu.com/question/65288314" target="_blank" rel="noopener">https://www.zhihu.com/question/65288314</a></p></li><li><p>批次内负采样 （in-batch negatives）</p></li><li><p>博客中的公式显示问题，以后都改为图片引用，不使用代码操作</p></li></ul><hr><blockquote><p>Contrastive learning aims to learn effective representation by pulling semantically close neighbors together and pushing apart non-neighbors. </p></blockquote><ul><li>对比学习的目的是通过把语义相近的邻域拉近在一起，把非邻域分开来学习有效的表达。</li></ul><blockquote><p>It assumes a set of paired examples $ \mathcal{D}=\left{\left(x_{i}, x_{i}^{+}\right)\right}_{i=1}^{m} $ , where $x_i$ and $x_{i}^{+}$ are semantically related. </p></blockquote><ul><li>它假设一组成对的例子$\mathcal{D}=\left{\left(x_{i}, x_{i}^{+}\right)\right}_{i=1}^{m}$，$x_i$和$x_{i}^{+}$ 是语义相关的</li></ul><blockquote><p>We follow the contrastive framework in Chen and take a cross-entropy objective with in-batch negatives : </p></blockquote><ul><li>取一个批次内负采样 (in-batch negatives)作为的交叉熵（cross-entropy）目标</li></ul><blockquote><p>let $h_i$ and $h_{i}^{+}$ denote the representations of $x_i$ and $x_{i}^{+}$, for a mini-batch with N pairs, the training objective for ($x_i,x_{i}^{+}$) is:</p></blockquote><ul><li>假设$h{i}$和$h{i}^{+}$表示$x{i}$和$x{i}^{+}$，对于N对的小批量， $(x_i,x_{i}^{+})$ 的训练目标是：</li></ul><p>$$<br>\ell_{i}=\log \frac{e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{i}^{+}\right) / \tau}}{\sum_{j=1}^{N} e^{\operatorname{sim}\left(\mathbf{h}<em>{i}, \mathbf{h}</em>{j}^{+}\right) / \tau}}<br>$$</p><blockquote><p>where $\mathcal{T}$ is a temperature hyperparameter and sim$(h_1,h_2)$ is the cosine similarity $\frac{\mathbf{h}<em>{1}^{\top} \mathbf{h}</em>{2}}{\left|\mathbf{h}<em>{1}\right| \cdot\left|\mathbf{h}</em>{2}\right|}$. </p></blockquote><ul><li>其中$\mathcal{T}$是温度超参数,sim$(h_1，h_2)$是余弦相似性$\frac{\mathbf{h}<em>{1}^{\top} \mathbf{h}</em>{2}}{\left|\mathbf{h}<em>{1}\right| \cdot\left|\mathbf{h}</em>{2}\right|}$</li></ul><blockquote><p>In this work, we encode input sentences using a pre-trained language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019): $\mathbf{h}=f_{\theta}(x)$, </p></blockquote><ul><li>在这项工作中，我们使用预先训练的语言模型（如BERT或RoBERTa）对输入句子进行编码：$\mathbf{h}=f_{\theta}(x)$</li></ul><blockquote><p>and then fine-tune all the parameters using the contrastive learning objective (Eq. 1).</p></blockquote><ul><li>然后使用对比学习目标（等式1）微调所有参数。</li></ul><hr><h4 id="Positive-instances-正例"><a href="#Positive-instances-正例" class="headerlink" title="Positive instances 正例"></a>Positive instances 正例</h4><blockquote><p>One critical question in contrastive learning is how to construct  ($x_i,x_{i}^{+}$)  pairs. </p></blockquote><ul><li>对比学习中的一个关键问题是如何构建（$x_i，x_{i}^{+}$）对。</li></ul><blockquote><p>In visual representations, an effective solution is to take two random transformations of the same image (e.g., cropping, flipping, distortion and rotation) as $x_i$ and $x_{i}^{+}$.</p></blockquote><ul><li>在视觉表示中，一个有效的解决方案是对同一个图像进行两次随机变换（例如，裁剪、翻转、失真和旋转），分别为$x_i$和$x_{i}^{+}$。</li></ul><blockquote><p>A similar approach has been recently adopted in language representations (Wu et al., 2020; Meng et al., 2021), by applying augmentation techniques such as word deletion, reordering, and substitution.</p></blockquote><ul><li>最近在语言表征中也采用了类似的方法，通过应用增广技术，如单词删除，重新排序和替代。</li></ul><blockquote><p>However, data augmentation in NLP is inherently difficult because of its discrete nature.</p></blockquote><ul><li>然而，NLP中的数据扩充由于其离散性而具有固有的困难性。</li></ul><blockquote><p>As we will see in §3, using standard dropout on intermediate representations outperforms these discrete operators.</p></blockquote><ul><li>我们将在§3中看到.在中间表示上使用dropout优于这些离散运算符。</li></ul><blockquote><p>In NLP, a similar contrastive learning objective has been also explored in different contexts. </p></blockquote><ul><li>在自然语言处理中，在不同的语境中也探讨了类似的对比学习目标。</li></ul><blockquote><p>In these cases,$(x_i，x_{i}^{+})$are collected from supervised datasets such as mention-entity, or question-passage pairs. </p></blockquote><ul><li>在这些情况下，$（x_i，x_{i}^{+}）$是从有监督的数据集（如提及实体或问题通道对）收集的。</li></ul><blockquote><p>Because of the distinct nature of $x_i$ and $x_{i}^{+}$ by definition, these approaches always use a dual- encoder framework, i.e., using two independent encoders $f_{\theta_{1}}$ and $f_{\theta_{2}}$ for $x_i$ and $x_{i}^{+}$. </p></blockquote><ul><li>由于定义上$x_{i}$和$x_{i}^{+}$的不同性质，这些方法总是使用双编码器框架，即使用两个独立的编码器$f{\theta{1}}$和$f{\theta{2}}$来表示$x_{i}$和$x_{i}^{+}$。</li></ul><blockquote><p>For sentence embeddings, Logeswaran and Lee (2018) also use contrastive learning with a dual-encoder approach, by forming (current sentence, next sentence) as $（x_i，x_{i}^{+}）$. </p></blockquote><ul><li>对于句子嵌入，Logeswaran和Lee（2018）也使用了双编码器方法的对比学习，将（当前句子，下一个句子）形成$（x_i，x_{i}^{+}）$。</li></ul><blockquote><p>Zhang et al. (2020) consider global sentence representations and local token representations of the same sentence as positive instances.</p></blockquote><ul><li>Zhang将同一句子的整体句子表征和局部标记表征视为正例。</li></ul><h4 id="Alignment-and-uniformity-对齐性和一致性"><a href="#Alignment-and-uniformity-对齐性和一致性" class="headerlink" title="Alignment and uniformity 对齐性和一致性"></a>Alignment and uniformity 对齐性和一致性</h4><blockquote><p>Recently, Wang and Isola (2020) identify two key properties related to contrastive learning: alignment and uniformity and propose metrics to measure the quality of representations. </p></blockquote><ul><li>最近，Wang和Isola确定了与对比学习相关的两个关键属性：对齐性和一致性并提出了衡量表征质量的指标。</li></ul><blockquote><p>Given a distribution of positive pairs $p_{pos}$, alignment calculates expected distance between embeddings of the paired instances (assuming representations are already normalized),</p></blockquote><ul><li>给定正对分布$p_{pos}$，alignment计算成对实例的嵌入之间的预期距离（假设表示已经规范化），</li></ul><p>$$<br>\ell_{\text {align }} \triangleq \underset{\left(x, x^{+}\right) \sim p_{\text {pos }}}{\mathbb{E}}\left|f(x)-f\left(x^{+}\right)\right|^{2}<br>$$</p><blockquote><p>On the other hand, uniformity measures how well the embeddings are uniformly distributed:</p></blockquote><ul><li>另一方面，uniformity衡量嵌入物均匀分布的程度：</li></ul><p>$$<br>\ell_{\text {uniform }} \triangleq \log \quad \underset{\quad x, y^\stackrel{i . i . d .}{\sim}p_{data}}{\mathbb{E}} e^{-2|f(x)-f(y)|^{2}}<br>$$</p><blockquote><p>where $p_{data}$ denotes the data distribution. These two metrics are well aligned with the objective of contrastive learning: positive instances should stay close and embeddings for random instances should scatter on the hypersphere.</p></blockquote><ul><li>其中，$p_{data}$表示数据分布。这两个指标很好地符合对比学习的目标：正例应该保持紧密，随机实例的嵌入应该分散在超球体上。</li></ul><blockquote><p>In the following sections, we will also use the two metrics to justify the inner workings of our approaches.</p></blockquote><ul><li>在下面的部分中，我们还将使用这两个度量来证明我们的方法的内部工作。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（四）</title>
      <link href="/posts/40a6.html/"/>
      <url>/posts/40a6.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（四）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（四）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（四）"></a>Simple Contrastive Learning of Sentence Embeddings（四）</h1><p><strong>SimCSE</strong>有两个变体：<strong>Unsupervised SimCSE</strong>和<strong>Supervised SimCSE</strong>，主要不同在于对比学习的正负例的构造。下面详细介绍下他们的构造方式。</p><hr><h4 id="还需学习的知识点"><a href="#还需学习的知识点" class="headerlink" title="还需学习的知识点"></a><font color="red">还需学习的知识点</font></h4><ul><li><p><strong>in-batch和negatives方法还不懂，需要学习</strong></p></li><li><p><strong>正例和负例具体指什么数据</strong></p></li><li><p><strong>自然语言推理（NLI）数据集</strong></p></li><li><p><strong>句子嵌入是什么意思以及如何实现</strong></p></li><li><p><strong>有监督和无监督是什么意思</strong></p></li></ul><hr><h2 id="无监督SimCSE"><a href="#无监督SimCSE" class="headerlink" title="无监督SimCSE"></a>无监督SimCSE</h2><blockquote><p>Learning universal sentence embeddings is a fundamental problem in natural language processing and has been studied extensively in the literature.</p></blockquote><ul><li>通用句嵌入的学习是自然语言处理中的一个基本问题，已有文献对此进行了广泛的研究。</li></ul><blockquote><p>In this work, we advance state-of-the-art sentence embedding methods and demonstrate that a contrastive objective can be extremely effective in learning sentence embeddings, coupled with pre-trained language models such as BERT and RoBERTa. </p></blockquote><ul><li>在这项工作中，我们提出了最先进的句子嵌入方法，并证明对比目标在学习句子嵌入时是非常有效的，再加上预先训练的语言模型，如BERT和RoBERTa。</li></ul><blockquote><p>We present SimCSE, a simple contrastive sentence embedding framework, which can be used to produce superior sentence embeddings, from either unlabeled or labeled data.</p></blockquote><ul><li>我们提出了一个简单的对比句子嵌入框架SimCSE，它可以用来从未标记或标记的数据中产生更好的句子嵌入。</li></ul><blockquote><p>Our <em>unsupervised</em> SimCSE simply predicts the input sentence itself, with only <em>dropout</em> (Srivastava et al., 2014) used as noise （Figure 1（a））.</p></blockquote><ul><li>我们的无监督SimCSE只是预测输入句子本身，只有<em>dropout</em>用作噪声（图1（a））。</li></ul><img src="Unsupervised SimCSE.png" alt="Unsupervised SimCSE" style="zoom:50%;"><blockquote><p>In other words, we pass the same input sentence to the pretrained encoder twice and obtain two embeddings as “positive pairs”, by applying independently sampled dropout masks. </p></blockquote><ul><li><p>换言之，我们将相同的输入语句传递给预训练的编码器两次，并通过应用独立采样的dropout掩码获得两个作为“正对”的嵌入。</p></li><li><p>对于<strong>Unsupervised SimCSE</strong>，核心在于如何生成dropout mask。因为BERT内部每次dropout都随机会生成一个不同的dropout mask。所以SimCSL不需要改变原始BERT，只需要将同一个句子喂给模型两次，得到的两个向量就是应用两次不同dropout mask的结果。然后将两个向量作为正例对。（真的simple）</p></li></ul><blockquote><p>Although it may appear strikingly simple, we find that this approach largely outperforms training objectives such as predicting next sentences and common data augmentation techniques, e.g., word deletion and replacement.</p></blockquote><ul><li>虽然它看起来非常简单，但是我们发现这种方法在很大程度上优于训练目标，例如预测下一句话和常用的数据增强技术，例如单词删除和替换。</li></ul><blockquote><p>More surprisingly, this unsupervised embedding method already matches all the previous supervised approaches. </p></blockquote><ul><li>更令人惊讶的是，这种无监督的嵌入方法已经匹配了所有以前的监督方法。</li></ul><blockquote><p>Through careful analysis, we find that dropout essentially acts as minimal data augmentation, while removing it leads to a representation collapse.</p></blockquote><ul><li>通过仔细的分析，我们发现退dropout本质上是作为最小的数据扩充，而删除它会导致表示崩溃。</li></ul><p><strong>Unsupervised SimCSE</strong> 引入dropout给输入加噪声，假设加噪后的输入仍与原始输入在语义空间距离相近。其正负例的构造方式如下：</p><blockquote><p>正例：给定输入，用预训练语言模型编码两次得到的两个向量和作为正例对。我理解的正例就是大于平均值的数据，负例就是低于平均值的数据</p></blockquote><blockquote><p>负例：使用in-batch negatives的方式，即随机采样一个batch中另一个输入作为的负例。</p></blockquote><hr><h2 id="有监督SimCSE"><a href="#有监督SimCSE" class="headerlink" title="有监督SimCSE"></a>有监督SimCSE</h2><p><strong>Supervised SimCSE</strong>，利用标注数据来构造对比学习的正负例子。为探究哪种标注数据更有利于句子向量的学习，文中在多种数据集上做了实验，最后发现NLI数据最有利于学习句子表示。下面以NLI数据为例介绍Supervised SimCSE的流程。</p><p>Supervised SimCSE 引入了NLI任务来监督对比学习过程。该模型假设如果两个句子存在蕴含关系，那么它们之间的句子向量距离应该较近；如果两个句子存在矛盾关系，那么它们的距离应该较远。因此NLI中的蕴含句对和矛盾句对分别对应对比学习中的正例对和负例对。所以在Supervised SimCSE中，正负例的构造方式如下:</p><blockquote><p>正例：NLI中entailment关系样例对。负例：a) in-batch negatives b)NLI中关系为contradiction的样例对。</p></blockquote><hr><blockquote><p>In our <em>supervised</em> SimCSE, we build upon the recent success of leveraging natural language inference （NLI） datasets for sentence embeddings （Conneau et al., 2017; Reimers and Gurevych, 2019） and incorporate supervised sentence pairs in contrastive learning （Figure 1(b)）. </p></blockquote><ul><li>在我们的有监督SimCSE中，我们建立在利用自然语言推理（NLI）数据集进行句子嵌入的最新成功基础上，并将有监督句对纳入对比学习（图1（b））。</li></ul><img src="Supervised SimCSE.png" alt="Supervised SimCSE" style="zoom:50%;"><blockquote><p>Unlike previous work that casts it as a 3-way classification task （entailment/neutral/contradiction）, we take advantage of the fact that <strong>entailment</strong> pairs can be naturally used as positive instances.</p></blockquote><ul><li>与以前的工作不同的是，我们将它作为一个三向分类任务（蕴涵/中立/矛盾），我们利用了蕴涵对可以自然地用作正实例这一事实。</li></ul><blockquote><p>We also find that adding corresponding contradiction pairs as hard negatives further improves performance. </p></blockquote><ul><li>我们还发现，添加相应的矛盾对作为硬否定进一步提高了性能。</li></ul><blockquote><p>This simple use of NLI datasets achieves a greater performance compared to prior methods using the same datasets. </p></blockquote><ul><li>与以前使用相同数据集的方法相比，NLI数据集的这种简单使用实现了更高的性能。</li></ul><blockquote><p>We also compare to other (annotated) sentence-pair datasets and find that NLI datasets are especially effective for learning sentence embeddings.</p></blockquote><ul><li>我们还比较了其他（带注释的）句子对数据集，发现NLI数据集对于学习句子嵌入特别有效。</li></ul><blockquote><p>To better understand the superior performance of SimCSE, we borrow the analysis tool from Wang and Isola (2020), which takes <em>alignment</em> between semantically-related positive pairs and <em>uniformity</em> of the whole representation space to measure the quality of learned embeddings. </p></blockquote><ul><li>为了更好地理解SimCSE的优越性能，我们借用了Wang和Isola（2020）的分析工具，它采用语义相关正对之间的对齐度和整个表示空间的一致度来衡量学习嵌入的质量。</li></ul><blockquote><p>We prove that theoretically the contrastive learning objective “flattens” the singular value distribution of the sentence embedding space, hence improving the uniformity. </p></blockquote><ul><li>我们从理论上证明了对比学习目标“平坦”了句子嵌入空间的奇异值分布，从而提高了一致性。</li></ul><blockquote><p>We also draw a connection to the recent findings that pre-trained word embeddings suffer from anisotropy (Ethayarajh, 2019; Li et al., 2020).</p></blockquote><ul><li>我们还与最近的研究结果相联系，即预先训练的单词嵌入会受到各向异性的影响。</li></ul><blockquote><p>We find that our unsupervised SimCSE essentially improves uniformity while avoiding degenerated alignment via dropout noise, thus greatly improves the expressiveness of the representations. </p></blockquote><ul><li>我们发现，我们的无监督SimCSE本质上改善了一致性，同时避免了通过丢失噪声退化对齐，从而大大提高了表示的表达能力。</li></ul><blockquote><p>We also demonstrate that the NLI training signal can further improve alignment between positive pairs and hence produce better sentence embeddings.</p></blockquote><ul><li>我们还证明，NLI训练信号可以进一步改善正对之间的对齐，从而产生更好的句子嵌入。</li></ul><p>第三段</p><blockquote><p>We conduct a comprehensive evaluation of SimCSE, along with previous state-of-the-art models on 7 semantic textual similarity (STS) tasks and 7 transfer tasks.</p></blockquote><ul><li>我们对SimCSE进行了综合评价，并对7个语义-文本相似度（STS）任务和7个迁移任务进行了分析。</li></ul><blockquote><p>On STS tasks, we show that our unsupervised and supervised models achieve a 74.5% and 81.6% averaged Spearman’s correlation respectively using BERTbase , largely outperforming previous best (Table 1). </p></blockquote><ul><li>在STS任务中，我们发现我们的无监督和有监督模型使用BERTbase分别达到了74.5%和81.6%的平均Spearman相关性，在很大程度上优于以前的最佳（表1）。</li></ul><blockquote><p>We also achieve competitive performance on the transfer tasks. Additionally, we identify an incoherent evaluation issue in existing work and consolidate results of different evaluation settings for future research.</p></blockquote><ul><li>我们在转移任务上也取得了有竞争力的表现。此外，我们在现有工作中发现了一个不连贯的评估问题，并将不同评估设置的结果进行了整合，以备将来研究之用。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（三）</title>
      <link href="/posts/3b4c.html/"/>
      <url>/posts/3b4c.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（三）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（三）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（三）"></a>Simple Contrastive Learning of Sentence Embeddings（三）</h2><h4 id="还需学习的知识点"><a href="#还需学习的知识点" class="headerlink" title="还需学习的知识点"></a><font color="red">还需学习的知识点</font></h4><ul><li><strong>Alignment</strong></li><li><strong>Uniformity</strong></li></ul><hr><h4 id="对比表示学习（Contrastive-Representation-Learning）"><a href="#对比表示学习（Contrastive-Representation-Learning）" class="headerlink" title="对比表示学习（Contrastive Representation Learning）"></a>对比表示学习（Contrastive Representation Learning）</h4><p>对比学习的核心思想是将正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。</p><blockquote><p><strong>Title</strong>: 《Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere》<br><strong>Author</strong>:Tongzhou Wang ; Phillip Isola</p></blockquote><p><a href="ICML2020.pdf">Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</a> （通过超球面上的对齐和一致性理解对比表示学习）指出了Contrastive representation learning的两个重要属性：</p><ul><li><strong>Alignment（计算正例对之间的向量距离的期望）:</strong> two samples forming a positive pair should be mapped to nearby features, and thus be （mostly） invariant to unneeded noise factors. <strong>Similar samples have similar features.</strong> （正例之间表示保持较近距离）<ul><li>越相似的样例之间的alignment程度越高。因为alignment使用距离来衡量，所以距离越小，表示alignment的程度越高。</li></ul></li><li><strong>Uniformity（评估所有数据的向量均匀分布的程度，越均匀，保留的信息越多）:</strong> feature vectors should be roughly uniformly distributed on the unit hypersphere, pre-serving as much information of the data as possible. <strong>Illustration of alignment and uniformity of feature distributions on the output unit hypersphere.</strong> （随机样例的表示应分散在超球面上）<ul><li>可以想象任意从表示空间中采样两个数据和, 希望他们的距离比较远。他们的距离越远，证明空间分布越uniform。所以uniformity的值也是越低越好。</li></ul></li></ul><p><img src="%E5%AF%B9%E6%AF%94%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0.webp" alt="对比表示学习"></p><p>SimCSE也采用这两个指标来衡量生成的句子向量，并证明了文本的语义空间也满足：alignment值越低且uniformity值越低，向量表示的质量越高，在STS任务上的Spearman相关系数越高。</p><ul><li>作者证明了现有的一些对比学习的算法正是较好地满足了这两条性质才取得了不错的效果。</li><li>作者提出了一个可优化的 metric (策略方法)来直接量化这两条属性。通过直接优化该loss（损失），也取得了较好的效果。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE完成情况</title>
      <link href="/posts/939d.html/"/>
      <url>/posts/939d.html/</url>
      
        <content type="html"><![CDATA[<center> <h2>SimCSE完成情况</h2><h2></h2></center><p>PS</p><ul><li><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span>为顺利完成</p></li><li><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span>为休息一天</p></li><li><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span>为尚未完成</p></li></ul><table><thead><tr><th><center>日期</center></th><th><center>学习情况</center></th><th><center>完成度</center></th></tr></thead><tbody><tr><td>4/27</td><td>1.学习拟合，过拟合，欠拟合基础含义以及对应解决方法，误差和Dropout等基础知识<br>2.逐字翻译论文摘要，详细理解摘要内容<br>3.输出两篇整理文章SimCSE（一）和SimCSE（二）</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>4/28</td><td>1.学习了SimCSE文章中Introduce章节，逐句翻译查看中英文，了解将相同的输入语句传递给预训练的编码器两次获取正对嵌入，使用in-batch  negatives的方式作为负例，还需学习blog开篇知识点<br>     2.看论文Contrastive Representation Learning对比表示学习，《Understanding Contrastive  Representation Learning through Alignment and Uniformity on the  Hypersphere》。还需继续了解Alignment和Uniformity信息</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>4/29</td><td>1.学习了SimCSE文章中的Background章节，逐句翻译，     了解了它采用了两个参数x和x+，他两个是语义相关的，     利用h和h+对其训练，用h去表示他们的相关性。     将图像进行两次随机变换得到x和x+，我的理解是x是h计算过后的结果。     Alignment和uniformity是关键属性，一个来计算期望距离，一个来计算均匀分布程度。</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>4/30</td><td>1.学习了SimCSE文章中的Unsupervised  SimCSE and supervised SimCSE章节，逐句翻译<br>      2.实验结果很明显的可以看出，SimCSE是远超其余数据增强方法的。传统数据增强的方法是对原始输入直接进行改变，在编码后，增强的数据与原始数据在语义空间的距离是要比直接用dropout的方式要远,所以这样语义度更匹配，而且这种方法它可以让alingnment和uniformity的值逐渐降低，非常nice</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>5/1</td><td>CBA，辽宁队必胜！！！！！</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>5/2</td><td>休息，躺着，玩</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>5/3</td><td>休息，躺着，玩</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>5/4</td><td>1.学习了SimCSE文章中的Connection to  Anisotropy章节，逐句翻译<br>     2.安装pytroch包以及配置conda虚拟环境，以及各种库<br>     3.看论文github代码，啥也不懂。。。。</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span></center></td></tr><tr><td>5/5</td><td>1.成功运行SimCSE  GitHub代码，成功运行Evaluation评估代码，并下载好训练模型</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>5/6</td><td>1.整理一周所学论文知识点，汇总制作PPT<br>     2.浏览智能对话诊疗评测比赛信息</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 计划 </tag>
            
            <tag> SimCSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（二）</title>
      <link href="/posts/221e.html/"/>
      <url>/posts/221e.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（二）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（二）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（二）"></a>Simple Contrastive Learning of Sentence Embeddings（二）</h2><h4 id="单词预览"><a href="#单词预览" class="headerlink" title="单词预览"></a>单词预览</h4><ul><li>contrastive，对比</li><li>state-of-the-art，最先进的</li><li>unsupervise，无监督</li><li>predict，预测</li><li>objective，目标</li><li>contrastive，对比</li><li>on par with，与……同一水平</li><li>represent，代表，表示</li><li>inspiration，灵感</li><li>incorporate，包含</li><li>annotate，注释</li><li>pairs from，来自</li><li>entailment，蕴含</li><li>semantic，语义</li><li>correlate，有关系的</li><li>respective，分别，各自</li></ul><hr><blockquote><p>两端对齐并调整行间距: style=”text-align:justify”;line-height:1.8rem</p><p>html斜体使用i标签</p></blockquote><h4 id="英文摘要Abstract"><a href="#英文摘要Abstract" class="headerlink" title="英文摘要Abstract"></a>英文摘要Abstract</h4><div style="text-align:justify;line-height:1.8rem">This paper presents SimCSE, a simple contrastive learning framework that greatly advances the state-of-the-art sentence embeddings. We first describe an unsupervised approach, which takes an input sentence and predicts <i>itself</i> in a contrastive objective, with only standard dropout used as noise. This simple method works surprisingly well, performing on par with previous supervised counterparts. We hypothesize that dropout acts as minimal data augmentation and removing it leads to a representation collapse. Then, we draw inspiration from the recent success of learning sentence embeddings from natural language inference（NLI）datasets and incorporate annotated pairs from NLI datasets into contrastive learning by using “entailment” pairs as pos- itives and “contradiction” pairs as hard negatives. We evaluate SimCSE on standard semantic textual similarity（STS）tasks, and our unsupervised and supervised models using BERTbase achieve an average of 74.5% and 81.6% Spearman’s correlation respectively, a 7.9 and 4.6 points improvement compared to previous best results. We also show that contrastive learning theoretically regularizes pretrained embeddings’ anisotropic space to be more uniform, and it better aligns positive pairs when supervised signals are available.</div><hr><h4 id="详细翻译中文摘要"><a href="#详细翻译中文摘要" class="headerlink" title="详细翻译中文摘要"></a>详细翻译中文摘要</h4><div style="text-align:justify;line-height:1.8rem">文章主要介绍了SimCSE，一种简单对比学习框架，SimCSE对比学习框架极大的提高了最先进的句子嵌入技术。我们首先描述了一种无监督的方法，这种方法采用一个输入语句，并根据一个对比目标进行预测，仅使用标准的dropout作为噪声。这种简单方法非常好，表现的与以前的可监督方法水平不相上下。我们假设，dropout做为最小的数据增加和删除，它会导致表示崩溃。然后，我们从最近的自然语言推理（NLI）数据集的成功经验获得灵感，将来自NLI数据集中的注释合并到对比学习中，并使用“蕴含”作为正向，“矛盾”作为负向。我们在标准的语义-文本相似度（STS）任务中对SimSCE进行了评估，使用Bear的无监督和有监督模型的相关度平均达到74.5%和81.6%的Spearman相关度，与以前的最佳结果分别提高了7.9和4.6个点。我们也展示了相对学习理论使预训练嵌入的各向异性空间更加均匀，并在有监督信号的情况下可以更好的对其正向嵌入。</div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimCSE（一）</title>
      <link href="/posts/5c43.html/"/>
      <url>/posts/5c43.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Simple-Contrastive-Learning-of-Sentence-Embeddings（一）"><a href="#Simple-Contrastive-Learning-of-Sentence-Embeddings（一）" class="headerlink" title="Simple Contrastive Learning of Sentence Embeddings（一）"></a>Simple Contrastive Learning of Sentence Embeddings（一）</h2><p>SimCSE的全称为 <em>Simple Contrastice  Learning of Sentence Embeddings</em>。<strong>Sim代表Simple，就是简单</strong>。</p><p>他简单的运用了 <strong><font color="red">dropout</font></strong> 的方法替换了传统的数据增强方法，将同一个输入dropout两次作为对比学习的正例，而且效果甚好。</p><hr><p><strong><font color="red">红色：</font></strong> 名词第一次出现</p><p><strong><font color="#6638F0">紫色：</font></strong> 解释专有名词</p><p><strong><font color="#F78AE0">粉色：</font></strong> 原因以及解决方法</p><hr><ul><li><strong><font color="#6638F0">拟合：</font></strong> 拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示，根据这个函数的不同有不同的拟合名字。</li><li><strong><font color="#6638F0">泛化误差：</font></strong> 对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为<strong>泛化误差</strong>。</li></ul><img src="拟合图片.jpeg" alt="拟合图片" style="zoom: 67%;"><ul><li>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络<strong>过度拟合了训练集</strong>，对训练集以外的数据却不work。</li></ul><img src="拟合对比.png" alt="拟合对比"><ul><li><strong><font color="#6638F0">欠拟合：</font></strong> 欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。<ul><li><strong><font color="#F78AE0">如何解决欠拟合：</font></strong> 欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<strong>增加网络复杂度</strong>或者在模型中 <strong><font color="red">增加特征</font></strong> ，这些都是很好解决欠拟合的方法。</li><li><strong><font color="#6638F0">增加特征：</font></strong> 添加高次多项式，使模型泛化能力更强</li></ul></li><li><strong><font color="#6638F0">过拟合：</font></strong> 过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<strong>模型在训练集上表现很好，但在测试集上却表现很差</strong>。模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，<strong>泛化能力差</strong>。<ul><li><strong><font color="#F78AE0">造成原因：</font></strong> <strong>训练数据集样本单一，样本不足</strong>。所以训练样本要尽可能的全面，覆盖所有的数据类型。<strong>训练数据中噪声干扰过大</strong>。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。<strong>模型过于复杂。</strong>模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</li><li><strong><font color="#F78AE0">防止过拟合：</font></strong> 要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。<strong>正则化是指修改学习算法，使其降低泛化误差而非训练误差</strong>。</li><li>常用的正则化方法根据具体的使用策略不同可分为：（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和 <strong><font color="red">Dropout</font></strong> ；（3）不直接提供约束的隐式正则化方法，如数据增强等。 <strong>目前主要学习Dropout方法</strong> 。</li></ul></li></ul><hr><h3 id="1-Dropout简介"><a href="#1-Dropout简介" class="headerlink" title="1. Dropout简介"></a>1. Dropout简介</h3><h4 id="1-1-Dropout出现的原因"><a href="#1-1-Dropout出现的原因" class="headerlink" title="1.1 Dropout出现的原因"></a>1.1 Dropout出现的原因</h4><p>在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。</p><p>过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。</p><p>综上所述，训练深度神经网络的时候，总是会遇到两大缺点：</p><p>（1）容易过拟合</p><p>（2）费时</p><p>Dropout可以比较有效的缓解过拟合的发生，在一定程度上达到 <strong><font color="red">正则化</font></strong> 的效果。</p><ul><li><strong><font color="#6638F0">正则化</font></strong> （regularization）是指为解决适定性问题或过拟合而加入额外信息的过程。</li></ul><h4 id="1-2-什么是Dropout"><a href="#1-2-什么是Dropout" class="headerlink" title="1.2 什么是Dropout"></a>1.2 什么是Dropout</h4><p>Dropout可以作为训练深度神经网络的 <strong><font color="red">一种trick</font></strong> 供选择。在每个训练批次中，通过 <strong>忽略一半</strong> 的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。</p><p>Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图所示。</p><img src="dropout.jpeg" alt="dropout" style="zoom:50%;"><h3 id="2-Dropout工作流程及使用"><a href="#2-Dropout工作流程及使用" class="headerlink" title="2. Dropout工作流程及使用"></a>2. Dropout工作流程及使用</h3><p>输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：</p><ol><li>首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）</li></ol><blockquote><p>还没有搞懂，下次再看到dropout时，再回来对应学习</p></blockquote><ol start="2"><li><p>然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。</p></li><li><p>然后继续重复这一过程：</p></li></ol><ul><li>恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）</li><li>从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。</li><li>对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> SimCSE </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-979</title>
      <link href="/posts/6918.html/"/>
      <url>/posts/6918.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2018-979-软学"><a href="#2018-979-软学" class="headerlink" title="2018-979-软学"></a>2018-979-软学</h2><h4 id="1-第一题"><a href="#1-第一题" class="headerlink" title="1.第一题"></a>1.第一题</h4><ul><li>在Head为头指针的单链表中查找结点DATA域值为K的结点</li><li>并将该结点与其前驱结点（如果存在）交换位置</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">jiaohuan</span><span class="token punctuation">(</span>LinkList Head<span class="token punctuation">,</span><span class="token keyword">int</span> K<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>pre <span class="token operator">=</span> Head<span class="token punctuation">,</span><span class="token operator">*</span>p <span class="token operator">=</span> Head <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> data <span class="token operator">==</span> K<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果第一个就对</span>        pre <span class="token operator">-></span> next <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        p <span class="token operator">-></span> next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//之后的元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> data <span class="token operator">==</span> K<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre <span class="token operator">-></span> next <span class="token operator">-></span> next <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>            p <span class="token operator">-></span> next <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>            pre <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-第二题"><a href="#2-第二题" class="headerlink" title="2.第二题"></a>2.第二题</h4><ul><li>给定二叉树的根指针为Root</li><li>对二叉树自下而上、自左而右的层次遍历</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiTNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//数据域</span>    <span class="token keyword">struct</span> BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//左、右孩子指针</span><span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bianli</span><span class="token punctuation">(</span>BiTree Root<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Stack<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈初始化</span>    BiTree Queue<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    BiTree p <span class="token operator">=</span> Root<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Queue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-第三题"><a href="#3-第三题" class="headerlink" title="3.第三题"></a>3.第三题</h3><ul><li>长度为n的数组A</li><li>已知前$m(m&lt;n)$个元素按升序有序排列，后$n-m$个元素按降序有序排列</li><li>编写算法在$O(n)$时间内对数组A的元素按降序排序</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> C<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">,</span>high <span class="token operator">=</span> m<span class="token punctuation">,</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> high <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">>=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">.</span>data<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>            high<span class="token operator">++</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>            low<span class="token operator">--</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>high <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        high<span class="token operator">++</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>        low<span class="token operator">--</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2012-941</title>
      <link href="/posts/5e81.html/"/>
      <url>/posts/5e81.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2012-941"><a href="#2012-941" class="headerlink" title="2012-941"></a>2012-941</h2><h4 id="1-求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算"><a href="#1-求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算" class="headerlink" title="1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算"></a>1.求出无向无权连通图中距离顶点v的最短路径长度k的所有顶点，路径长度以边数为单位计算</h4><ul><li><font color="red">复习，理解，重点</font></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> VNode<span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//顶点表结点</span>    <span class="token keyword">int</span> len0<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//距离初始顶点v0的距离</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//顶点编号</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//邻接表的顶点类型</span><span class="token keyword">void</span> <span class="token function">bfsPrintNode</span><span class="token punctuation">(</span>ALGraph <span class="token operator">*</span>g<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node Queue<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个顶点类型的队列</span>    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队头</span>    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队尾</span>    <span class="token keyword">int</span> flag<span class="token punctuation">[</span>v0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问后则将其置为1</span>    Queue<span class="token punctuation">[</span>rear<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span>v0<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始顶点v0入队</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node node <span class="token operator">=</span> Queue<span class="token punctuation">[</span>front<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//v接收出队元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>ArcNode <span class="token operator">*</span>p <span class="token operator">=</span> g<span class="token punctuation">.</span>vexset<span class="token punctuation">[</span>node<span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p <span class="token operator">-></span> nextarc<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>p <span class="token operator">-></span> nextarc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">visit</span><span class="token punctuation">(</span>p <span class="token operator">-></span> adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//若p对应的邻接顶点没被访问，则访问它</span>                flag<span class="token punctuation">[</span>p <span class="token operator">-></span> adjvex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                Queue<span class="token punctuation">[</span>rear<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>node<span class="token punctuation">.</span>len0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>p <span class="token operator">-></span> adjvex<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//邻接顶点入队</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> rear<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>len0 <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//打印出距离初始顶点距离为k的所有顶点</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>Queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013-941</title>
      <link href="/posts/9ebc.html/"/>
      <url>/posts/9ebc.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2013-941"><a href="#2013-941" class="headerlink" title="2013-941"></a>2013-941</h2><h4 id="1-找出二叉树先根序列的最后一个结点"><a href="#1-找出二叉树先根序列的最后一个结点" class="headerlink" title="(1).找出二叉树先根序列的最后一个结点"></a>(1).找出二叉树先根序列的最后一个结点</h4><ul><li>二叉查找树由3个域构成</li><li>key：给出结点数据项的值，为正整数</li><li>left：结点的左子结点地址</li><li>right：结点的右子结点地址</li><li>根结点地址为root</li><li>不能使用递归</li><li>不能使用栈</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">last</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree <span class="token operator">*</span>p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">-></span> right <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> p <span class="token operator">-></span> left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">-></span> right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               p <span class="token operator">=</span> p <span class="token operator">-></span> right<span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>           p <span class="token operator">=</span> p <span class="token operator">-></span> left<span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-将key域的值大于等于给定x的值的结点全部删除"><a href="#2-将key域的值大于等于给定x的值的结点全部删除" class="headerlink" title="(2)将key域的值大于等于给定x的值的结点全部删除"></a>(2)将key域的值大于等于给定x的值的结点全部删除</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Del</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//递归删除树算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">Del</span><span class="token punctuation">(</span>T <span class="token operator">-></span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Del</span><span class="token punctuation">(</span>T <span class="token operator">-></span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">DeleteX</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    BiTree <span class="token operator">*</span>p <span class="token operator">=</span> root<span class="token punctuation">;</span>    BiTree <span class="token operator">*</span>pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">-></span> right <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> key <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> p <span class="token operator">-></span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> key <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>rear <span class="token operator">!=</span> front<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> key <span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> left<span class="token punctuation">;</span>            pre <span class="token operator">-></span> right <span class="token operator">=</span> p <span class="token operator">-></span> left<span class="token punctuation">;</span>            p <span class="token operator">-></span> left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">Del</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014-941</title>
      <link href="/posts/5e09.html/"/>
      <url>/posts/5e09.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2014-941"><a href="#2014-941" class="headerlink" title="2014-941"></a>2014-941</h2><h4 id="1-将整数数组-1…n-中所有的偶数放到所有奇数之前，并求时间复杂度"><a href="#1-将整数数组-1…n-中所有的偶数放到所有奇数之前，并求时间复杂度" class="headerlink" title="1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度"></a>1.将整数数组[1…n]中所有的偶数放到所有奇数之前，并求时间复杂度</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">shuzu</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//奇数</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//偶数</span>            <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span>；            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-按递减次序打印所有左子树非空，右子树为空的结点的关键字"><a href="#2-按递减次序打印所有左子树非空，右子树为空的结点的关键字" class="headerlink" title="2.按递减次序打印所有左子树非空，右子树为空的结点的关键字"></a>2.按递减次序打印所有左子树非空，右子树为空的结点的关键字</h4><ul><li><p><strong><font color="red">重要</font></strong></p></li><li><p>二叉查找树采用链式存储</p></li><li><p>各个结点的关键词均不相同</p></li><li><p>非递归算法</p></li></ul><hr><ul><li>利用栈，先一路走到最右边，然后判断该结点是否符合题意</li><li>若不符合转向左子树，继续在左子树的右子树里依次寻找</li></ul><hr><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">guanjianzi</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">int</span> Stack<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> top <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>            Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右分支向下</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span>p <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左分支</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//if</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化-计网第三章-数据链路层</title>
      <link href="/posts/2fcb.html/"/>
      <url>/posts/2fcb.html/</url>
      
        <content type="html"><![CDATA[<h2 id="强化-计网第三章-数据链路层"><a href="#强化-计网第三章-数据链路层" class="headerlink" title="强化 计网第三章 数据链路层"></a>强化 计网第三章 数据链路层</h2><h3 id="1-线路规划"><a href="#1-线路规划" class="headerlink" title="1.线路规划"></a>1.线路规划</h3><h4 id="1-1询问-应答（ENQ-ACK）"><a href="#1-1询问-应答（ENQ-ACK）" class="headerlink" title="1.1询问/应答（ENQ/ACK）"></a>1.1询问/应答（ENQ/ACK）</h4><ul><li>一条链路两端的<strong>设备级别相同</strong>，任意一个设备都可以启动一个会话过程（<strong>点对点</strong>）</li><li>工作方式</li><li>启动方首先发送一个<strong>询问帧（ENQ）</strong>询问接收方是否可以接收数据</li><li>接收方如果已经<strong>准备好接收</strong>，必须应答一个<strong>确认帧（ACK）</strong></li><li>如果没用做好准备，就必须应答一个否定帧（NAK）</li></ul><h4 id="1-2轮询（Poll）-选择（Select）方式"><a href="#1-2轮询（Poll）-选择（Select）方式" class="headerlink" title="1.2轮询（Poll）/选择（Select）方式"></a>1.2轮询（Poll）/选择（Select）方式</h4><ul><li>有一个设备为主设备，其他设备为从设备的拓补结构中采用（<strong>多点系统</strong>）</li><li>每个设备都有一个地址标识自身</li><li>信息传输必须通过主设备</li></ul><h5 id="1-2-1轮询"><a href="#1-2-1轮询" class="headerlink" title="1.2.1轮询"></a>1.2.1轮询</h5><ul><li>如果主设备希望<strong>接收</strong>数据，它将逐个询问从设备是否有数据发送，这个功能称为轮询</li></ul><h5 id="1-2-2选择"><a href="#1-2-2选择" class="headerlink" title="1.2.2选择"></a>1.2.2选择</h5><ul><li>如果主设备希望<strong>发送</strong>数据，它告知目标从设备准备好接收数据，这个功能称为选择</li></ul><h3 id="2-流量控制与差错控制"><a href="#2-流量控制与差错控制" class="headerlink" title="2.流量控制与差错控制"></a>2.流量控制与差错控制</h3><ul><li>两者是结合在一起实现的，共有两种技术：停止等待协议和滑动窗口协议</li></ul><h4 id="2-1差错控制"><a href="#2-1差错控制" class="headerlink" title="2.1差错控制"></a>2.1差错控制</h4><ul><li>差错控制主要指错误检测和重传方法</li></ul><h4 id="2-2自动重复请求（ARQ）"><a href="#2-2自动重复请求（ARQ）" class="headerlink" title="2.2自动重复请求（ARQ）"></a>2.2自动重复请求（ARQ）</h4><ul><li>在一个帧中出现任何一个错误，接收方就返回一个否认帧，出错的帧就被发送方重新传送。这个过程被称为自动重复请求（ARQ）</li></ul><h4 id="2-3停止等待协议"><a href="#2-3停止等待协议" class="headerlink" title="2.3停止等待协议"></a>2.3停止等待协议</h4><ul><li>发送方每发送一帧后就等待一个确认帧。<strong>只有当接收到确认帧后，发送方才发送下一帧</strong>，这种过程不断交替，直到发送方发送一个传输结束帧（EOT）</li><li>优点：简单</li><li>缺点：效率低，每次都要等待</li></ul><h5 id="2-3-1信道利用率"><a href="#2-3-1信道利用率" class="headerlink" title="2.3.1信道利用率"></a>2.3.1信道利用率</h5><ul><li>无差错的情况下完成一帧的发送时间为一个<strong>窗口时间WT</strong>:</li></ul><p>$$<br>WT=t_I+2t_p+2t_{Proc}+t_s<br>$$</p><ul><li><p><strong>$t_I$是发送一个数据帧的时间</strong>，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒</p></li><li><p><strong>$t_S$是确认帧的发送时间</strong>，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒</p></li><li><p><strong>$ t_P $是电信号在物理链路上的传播延迟</strong></p></li><li><p><strong>$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间</strong></p></li><li><p>无差错信道利用率：</p></li></ul><p>$$<br>F=(t_I+t_p)/WT<br>$$</p><ul><li>有效数据传送速率：</li></ul><p>$$<br>S=N/WT,N:一帧的有效数据位数<br>$$</p><ul><li>$t_W \approx t_I+2t_P$</li></ul><h5 id="2-3-2差错控制"><a href="#2-3-2差错控制" class="headerlink" title="2.3.2差错控制"></a>2.3.2差错控制</h5><h6 id="2-3-2-1帧破坏"><a href="#2-3-2-1帧破坏" class="headerlink" title="2.3.2.1帧破坏"></a>2.3.2.1帧破坏</h6><ul><li>自动重复请求（ARQ）</li></ul><h6 id="2-3-2-2帧丢失"><a href="#2-3-2-2帧丢失" class="headerlink" title="2.3.2.2帧丢失"></a>2.3.2.2帧丢失</h6><ul><li>定时器，判断数据帧在传输中丢失，超时自动重发</li></ul><h6 id="2-3-2-3应答帧丢失"><a href="#2-3-2-3应答帧丢失" class="headerlink" title="2.3.2.3应答帧丢失"></a>2.3.2.3应答帧丢失</h6><ul><li>先重传数据帧</li><li>数据帧和应答帧以交替的标识0和1出现在数据帧中，每次发送一个新的数据帧，编号信息和上次发送的不一样。这样就可以区分重复的数据帧</li><li>丢弃重复帧</li></ul><h4 id="2-4滑动窗口协议"><a href="#2-4滑动窗口协议" class="headerlink" title="2.4滑动窗口协议"></a>2.4滑动窗口协议</h4><h5 id="2-4-1流量控制"><a href="#2-4-1流量控制" class="headerlink" title="2.4.1流量控制"></a>2.4.1流量控制</h5><ul><li>在滑动窗口协议中，发送方在收到确认消息前可以发送若干帧。帧可以直接依次发送</li><li>接收方使用一个应答帧来对多个数据帧的接收进行确认</li><li>在发送方，只要窗口未填满就可以在未收到确认帧的情况下继续发送数据帧</li><li><strong>发送方窗口用于存放已经发送但未确认的数据帧和在收到确认帧之前可以发送的数据帧</strong></li><li>例如：</li><li>接收方发送了一个编号为5的确认帧，表示接收方收到了5号帧以前的所有帧，希望发送方发送5号帧</li></ul><h5 id="2-4-2差错控制"><a href="#2-4-2差错控制" class="headerlink" title="2.4.2差错控制"></a>2.4.2差错控制</h5><h6 id="2-4-2-1回退N自动重复请求"><a href="#2-4-2-1回退N自动重复请求" class="headerlink" title="2.4.2.1回退N自动重复请求"></a>2.4.2.1回退N自动重复请求</h6><ul><li>如果有一帧丢失或者损坏了，未被确认帧确认的帧都必须进行重传</li><li><font color="red">窗口大小：</font>如果帧的编号范围是$0 \sim n-1$，则窗口尺寸为$n-1$</li></ul><h6 id="2-4-2-2选择拒绝自动重复请求"><a href="#2-4-2-2选择拒绝自动重复请求" class="headerlink" title="2.4.2.2选择拒绝自动重复请求"></a>2.4.2.2选择拒绝自动重复请求</h6><ul><li>只有特定的丢失或损坏帧被重发。接收方收到的数据帧可以是不按顺序到达的</li><li>与回退n协议自动重传请求有以下不同：</li><li>接收设备必须具有排序的逻辑功能</li><li><font color="red">窗口大小：</font>如果帧的编号范围是$0 \sim n-1$，则窗口尺寸小于等于$n/2$</li></ul><h5 id="2-4-3滑动窗口协议的效率"><a href="#2-4-3滑动窗口协议的效率" class="headerlink" title="2.4.3滑动窗口协议的效率"></a>2.4.3滑动窗口协议的效率</h5><h5 id="2-4-4窗口大小的选择"><a href="#2-4-4窗口大小的选择" class="headerlink" title="2.4.4窗口大小的选择"></a>2.4.4窗口大小的选择</h5><p>$$<br>nt_I&gt;2(t_I+t_P)<br>$$</p><ul><li>$t_I$：一个帧的发送时间</li><li>$t_P$：传播时间</li></ul><h3 id="3-HDLC高级数据链路控制协议"><a href="#3-HDLC高级数据链路控制协议" class="headerlink" title="3.HDLC高级数据链路控制协议"></a>3.HDLC高级数据链路控制协议</h3><h4 id="3-1HDLC帧格式"><a href="#3-1HDLC帧格式" class="headerlink" title="3.1HDLC帧格式"></a>3.1HDLC帧格式</h4><ul><li>信息帧（I-帧）：用来传输用户数据以及与用户数据有关的控制信息</li><li>监控帧（S-帧）：用来传输控制信息，主要是数据链路层流量控制和错误控制信息</li><li>无编号帧（U-帧）：用来进行链路管理服务的</li></ul><h5 id="3-1-1标志字段"><a href="#3-1-1标志字段" class="headerlink" title="3.1.1标志字段"></a>3.1.1标志字段</h5><ul><li>标志字段为一个字节（8位），其位模式为01111110</li><li>它用来<strong>表示一个帧的开始和结束，并且为接收方提供同步手段</strong></li></ul><h5 id="3-1-2地址字段"><a href="#3-1-2地址字段" class="headerlink" title="3.1.2地址字段"></a>3.1.2地址字段</h5><ul><li>可以有1个或几个字节的长度</li></ul><h5 id="3-1-2控制字段"><a href="#3-1-2控制字段" class="headerlink" title="3.1.2控制字段"></a>3.1.2控制字段</h5><ul><li>有一个或两个字节</li><li>用来进行<strong>流量管理</strong></li></ul><h3 id="4-数据链路层网络互联"><a href="#4-数据链路层网络互联" class="headerlink" title="4.数据链路层网络互联"></a>4.数据链路层网络互联</h3><h4 id="4-1网桥"><a href="#4-1网桥" class="headerlink" title="4.1网桥"></a>4.1网桥</h4><ul><li>网桥是一种存储转发设备，用于连接局域网</li><li>网桥常用于局域网之间的互联</li><li>是数据链路层上的互连设备，网桥同时作用在$OSI$的物理层和数据链路层</li><li>网桥具有隔离通信的功能</li></ul><h4 id="4-2网桥路由算法"><a href="#4-2网桥路由算法" class="headerlink" title="4.2网桥路由算法"></a>4.2网桥路由算法</h4><h5 id="4-2-1固定路由策略-—-固定路由网桥"><a href="#4-2-1固定路由策略-—-固定路由网桥" class="headerlink" title="4.2.1固定路由策略 — 固定路由网桥"></a>4.2.1固定路由策略 — 固定路由网桥</h5><h5 id="4-2-2路由学习策略-—-透明网桥"><a href="#4-2-2路由学习策略-—-透明网桥" class="headerlink" title="4.2.2路由学习策略 — 透明网桥"></a>4.2.2路由学习策略 — 透明网桥</h5><h6 id="4-2-2-1生成树算法"><a href="#4-2-2-1生成树算法" class="headerlink" title="4.2.2.1生成树算法"></a>4.2.2.1生成树算法</h6><h5 id="4-2-3源路由策略-—-源路由网桥"><a href="#4-2-3源路由策略-—-源路由网桥" class="headerlink" title="4.2.3源路由策略 — 源路由网桥"></a>4.2.3源路由策略 — 源路由网桥</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
            <tag> 数据链路层 </tag>
            
            <tag> 强化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015-941</title>
      <link href="/posts/9e34.html/"/>
      <url>/posts/9e34.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2015-941"><a href="#2015-941" class="headerlink" title="2015-941"></a>2015-941</h2><h4 id="1-判断两个单链表是否相交"><a href="#1-判断两个单链表是否相交" class="headerlink" title="1.判断两个单链表是否相交"></a>1.判断两个单链表是否相交</h4><ul><li>两个单链表的头指针分别为head1和head2</li><li>如果相交则返回第一个交点</li><li>要求算法的时间复杂度为$O(length1+length2)$</li></ul><p>（1）算法思想</p><ul><li>先创建一个子函数求出链表长度</li><li>主函数：</li><li>因为两个链表如果相交，则两个链表中从某一结点开始往后一定全一样</li><li>所以长链表比锻炼表前面多出的部分不可能存在交点</li><li>利用链表的长度差值n，长链表从第n+1个结点，短链表从第一个结点开始，同时开始遍历</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">len</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>LNode <span class="token function">Search</span><span class="token punctuation">(</span>LinkList head1<span class="token punctuation">,</span>LinkList head2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> length1 <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length2 <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>head2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    LNode <span class="token operator">*</span>q <span class="token operator">=</span> head1<span class="token punctuation">;</span>    LNode <span class="token operator">*</span>s <span class="token operator">=</span> head2<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>length1 <span class="token operator">></span> length2<span class="token punctuation">)</span><span class="token punctuation">{</span>        n <span class="token operator">=</span> length1 <span class="token operator">-</span> length2<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>length1 <span class="token operator">&lt;</span> length2<span class="token punctuation">)</span><span class="token punctuation">{</span>        n <span class="token operator">=</span> length2 <span class="token operator">-</span> length1<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            s <span class="token operator">=</span> s <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">-></span> data <span class="token operator">!=</span> s <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>        q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        s <span class="token operator">=</span> s <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-二叉树各层独生叶结点的数目"><a href="#2-二叉树各层独生叶结点的数目" class="headerlink" title="2.二叉树各层独生叶结点的数目"></a>2.二叉树各层独生叶结点的数目</h4><ul><li>独生叶结点（既是叶结点又无兄弟结点）</li><li>root指向二叉树根结点的指针</li><li>输出各层独生叶结点的数目</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shumu</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//层数</span>    <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> Queue<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front <span class="token operator">!=</span> rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> lchild <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">{</span>               Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span><span class="token punctuation">{</span>                level<span class="token operator">++</span><span class="token punctuation">;</span>                last <span class="token operator">=</span> rear<span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> lchild <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>            num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span><span class="token punctuation">{</span>                level<span class="token operator">++</span><span class="token punctuation">;</span>                last <span class="token operator">=</span> rear<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> rchild <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>            num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span><span class="token punctuation">{</span>                level<span class="token operator">++</span><span class="token punctuation">;</span>                last <span class="token operator">=</span> rear<span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016-941</title>
      <link href="/posts/9e70.html/"/>
      <url>/posts/9e70.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2016-941"><a href="#2016-941" class="headerlink" title="2016-941"></a>2016-941</h2><h4 id="1-查找倒数第k个值"><a href="#1-查找倒数第k个值" class="headerlink" title="1.查找倒数第k个值"></a>1.查找倒数第k个值</h4><ul><li>一个带有表头结点的<strong>单链表</strong>，结点结构为（data，link）</li><li>链表只给出了头指针list</li><li>在不改变链表的前提下，查找出链表中倒数第k个位置上的结点</li><li>若查找成功，输出该结点的data域的值，并返回1；否则，只返回0</li></ul><p>（1）描述算法基本思想</p><ul><li>先求出链表的长度</li><li>再用链表长度减去倒数第k个，就为倒数第k个的正向下标</li><li>例如：链表长度为6，求倒数第2个值，即正数6-2=4下标</li><li>在正向循环得出即可</li></ul><p>（2）写出代码</p><p>（3）分析时间复杂性</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LNode<span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//定义单链表结点类型</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//数据域</span>    <span class="token keyword">struct</span> LNode <span class="token operator">*</span>link<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//指针域，指向下一个结点的指针</span><span class="token punctuation">}</span>LNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//LNode是结构体的别名，用LNode即可代替typedef struct LNode</span>                          <span class="token comment" spellcheck="true">//LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next</span><span class="token keyword">int</span> <span class="token function">DaoshuK</span><span class="token punctuation">(</span>LinkList list，<span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> list<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> list<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//p用来求链表长度,q开始查找倒数第k个值的下标</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//求链表长度</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p <span class="token operator">-></span> link<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">{</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> len<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//找倒数第k个值</span>            <span class="token keyword">int</span> data <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>            <span class="token keyword">return</span> data<span class="token punctuation">,</span><span class="token number">1</span>；        <span class="token punctuation">}</span>        q <span class="token operator">=</span> q <span class="token operator">-></span> link<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-输出二叉树序列S"><a href="#2-输出二叉树序列S" class="headerlink" title="2.输出二叉树序列S"></a>2.输出二叉树序列S</h4><ul><li>输出二叉树序列，以r为树根</li><li>给出二叉树序列，输出二叉树</li></ul><p>（1）算法思想</p><ul><li>引入一个辅助栈，以树的先序非递归遍历思想为基础，根据所给序列正向建树。</li><li>若当前p指向结点非空，对应序号为0，则他的左右孩子赋值为空；</li><li>对应序号为1，则创建一个结点，其左指针指向新创建的结点；</li><li>若对应序号为2，则创建两个结点，其左右指针分别指向两个结点</li></ul><p>（2）代码</p><pre class="line-numbers language-c"><code class="language-c">BiTree <span class="token function">CreateTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>r<span class="token punctuation">,</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//该算法根据数组A中序建树，序列长度就是数组长度len</span>    BiTree Stack<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈初始化</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计数值，判断序列结束</span>    BiTree p <span class="token operator">=</span> r<span class="token punctuation">,</span> bt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p用来遍历，bt用来辅助创造结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> MULL<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                p <span class="token operator">-></span> lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                P <span class="token operator">-></span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                bt <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">-></span> lchild <span class="token operator">=</span> bt<span class="token punctuation">;</span>                P <span class="token operator">-></span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                bt <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">-></span> lchild <span class="token operator">=</span> bt<span class="token punctuation">;</span>                bt <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                P <span class="token operator">-></span> rchild <span class="token operator">=</span> bt<span class="token punctuation">;</span>                Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> lchild        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017-941</title>
      <link href="/posts/5e4d.html/"/>
      <url>/posts/5e4d.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2017-941"><a href="#2017-941" class="headerlink" title="2017-941"></a>2017-941</h2><h4 id="1-（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。"><a href="#1-（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。" class="headerlink" title="1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。"></a>1.（15分）A和B是长度为n的两个数组。设计一个算法，该算法输出长度为n的数组C。</h4><ul><li>要求1：数组C中的每一个元素$C[i] = ||  { A[j]|A[j]≤B[i],1≤j≤n}||$，其中$||S||$表示集合S中的元素个数。例如：下表给出了长度为4的两个数组A和B，以及满足要求的数组C</li><li>要求2：所设计算法的时间复杂性低于$O(n^2)$</li></ul><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>A[i]</td><td>6</td><td>17</td><td>9</td><td>10</td></tr><tr><td>B[i]</td><td>8</td><td>2</td><td>17</td><td>13</td></tr><tr><td>C[i]</td><td>1</td><td>0</td><td>4</td><td>3</td></tr></tbody></table><p>（1）描述算法的基本设计思想（3分）；</p><p>C[1]的意思就是，A数组中小于等于B[1]的个数；C[2]就是，A数组中小于等于B[2]的个数。以此类推</p><p>先将A利用快速排序排好顺序，再用b进行折半查找</p><p>（2）用算法描述语言描述算法（8分）；</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//折半查找来确定有序序列A中有多少元素不大于x</span><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">,</span>m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>            r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后l为小于等于x元素的个数</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//先采用快速排序排列A数组，时间复杂度（nlogn），要求不能超过n方</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//一趟划分</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//将当前表中第一个元素设为枢轴，对表进行划分</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>        low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//从前往后找到一个比枢轴大的数</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//从后往前找到一个比枢轴小的数</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//用临时变量w储存值，交换两个数</span>            A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//用临时变量w储存值，交换两个数</span>            A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//用临时变量w储存值，交换两个数</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    A<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//找到枢轴的正确位置，交换这两个元素</span>    A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>    <span class="token keyword">return</span> high<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//返回枢轴正确的位置</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//开始快排</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//枢轴左半边继续快排</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">getArrayC</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> B<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> C<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//快排排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">,</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查找</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）给出算法的时间复杂性分析（4分）。</p><ul><li>排序时间$O(nlogn)+$查找时间$O(logn)$，符合要求</li></ul><h4 id="2-（10分）写出求二叉树宽度的非递归算法"><a href="#2-（10分）写出求二叉树宽度的非递归算法" class="headerlink" title="2.（10分）写出求二叉树宽度的非递归算法"></a>2.（10分）写出求二叉树宽度的非递归算法</h4><ul><li><strong>二叉树的宽度定义为具有结点数最多的那一层上的结点总数。如下图所示，以a为根的二叉树宽度为3。假设二叉树以链接结构存储，指针T指向二叉树的根，树中结点的结构为（left，data，right）</strong></li></ul><p>（1）描述算法的基本设计思想（3分）；</p><ul><li><p>利用主要层次遍历</p></li><li><p>再加上last指针：指向当前层数最右结点</p></li></ul><p>（2）用算法描述语言描述算法（7分）；</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MaxBreadth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队头尾指针</span>    <span class="token keyword">int</span> level <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//last指向当前层数最右结点，level为当前层数</span>    <span class="token keyword">int</span> width<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//储存每层最大宽度的数组</span>    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用p遍历二叉树</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根结点入队</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    width<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一层一个结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>rear <span class="token operator">></span> front<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//队列不为空</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//层次遍历，出队元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子树不为空，则左子树根结点入队 </span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右子树不为空，则右子树根节点入队 </span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//出队元素和last所指向的最右结点相同时</span>            width<span class="token punctuation">[</span><span class="token operator">++</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> rear <span class="token operator">-</span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//该层元素个数等于此时队列的尾指针减去上一层最右结点的位置</span>            last <span class="token operator">=</span> rear<span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最后得到的层数会多一层 </span>    <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>level<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>width<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">{</span>            max<span class="token operator">=</span>width<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>     <span class="token keyword">return</span> max<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-941</title>
      <link href="/posts/5f19.html/"/>
      <url>/posts/5f19.html/</url>
      
        <content type="html"><![CDATA[<h2 id="2018-941-学硕-其他-数组"><a href="#2018-941-学硕-其他-数组" class="headerlink" title="2018-941-学硕-其他-数组"></a>2018-941-学硕-其他-数组</h2><h4 id="1-已知k阶斐波那契数列的定义为："><a href="#1-已知k阶斐波那契数列的定义为：" class="headerlink" title="1.已知k阶斐波那契数列的定义为："></a>1.已知k阶斐波那契数列的定义为：</h4><p>​    $f_0=0,f_1=0,…f_{k-2}=0,f_{k-1}=1,$</p><p>​    $f_n=f_{n-1}+f_{n-2}+…+f_{n-k},n=k,k+1,…$</p><p>（1）试编写求$k$阶斐波那契序列的第$m$项值的非递归函数$F(k,m)$</p><p>（2）计算$F(5,8)$的值</p><ul><li>算法思想：$k$阶斐波那契数列从第$0$项到$k-2$项全为$0$，$k-1$项为$1$，从第$k$项开始每项为前$2$项之和</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a为第一项f0=1</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m ≤ <span class="token punctuation">(</span>k<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> k<span class="token number">-1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        b <span class="token operator">=</span> f<span class="token punctuation">;</span>        f <span class="token operator">=</span> f <span class="token operator">+</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C语言可执行代码</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a为第一项f0=1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        b <span class="token operator">=</span> f<span class="token punctuation">;</span>        f <span class="token operator">=</span> f <span class="token operator">+</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//printf("%d", f);</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">IsDescendant</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//return printf("%s","没有");</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> u <span class="token operator">||</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//return printf("%s","有");</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IsDescendant</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> n<span class="token punctuation">,</span> u<span class="token punctuation">,</span> L<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">IsDescendant</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> n<span class="token punctuation">,</span> u<span class="token punctuation">,</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//return printf("%s","有");</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//return printf("%s","没有");</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> Fibonacci <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fibonacci: %d\n"</span><span class="token punctuation">,</span>Fibonacci<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>u<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> B<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    bool status <span class="token operator">=</span> <span class="token function">IsDescendant</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>n<span class="token punctuation">,</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"是否为子孙: %d"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-假定用两个一维数组-L-1-n-和-R-1-n-作为有-n-个结点二叉树的存储结构，-L-i-和-R-i-分别指示结点-i-的左儿子和右儿子，-0-表示空。试写一个算法判断结点u是否为结点-v-的子孙"><a href="#2-假定用两个一维数组-L-1-n-和-R-1-n-作为有-n-个结点二叉树的存储结构，-L-i-和-R-i-分别指示结点-i-的左儿子和右儿子，-0-表示空。试写一个算法判断结点u是否为结点-v-的子孙" class="headerlink" title="2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙"></a>2.假定用两个一维数组$L[1:n]$和$R[1:n]$作为有$n$个结点二叉树的存储结构，$L[i]$和$R[i]$分别指示结点$i$的左儿子和右儿子，$0$表示空。试写一个算法判断结点u是否为结点$v$的子孙</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//递归方法</span>bool <span class="token function">IsDescendant</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> false<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> u <span class="token operator">||</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span>  u<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> true<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Dencendant</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>R<span class="token punctuation">,</span>n<span class="token punctuation">,</span>u<span class="token punctuation">,</span>L<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">Dencendant</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>R<span class="token punctuation">,</span>n<span class="token punctuation">,</span>u<span class="token punctuation">,</span>R<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> true<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> false<span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//非递归方法</span>bool <span class="token function">IsDescendant</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> Queue<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> u <span class="token operator">!=</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//v的左孩子入队</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>R<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> u <span class="token operator">!=</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//v的右孩子入队</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front <span class="token operator">!=</span> rear<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//队不为空时</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>R<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C语言可执行代码</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a为第一项f0=1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//k阶斐波那契数列，k-1项为1（第二项），k-2项为0（第二项），所以m≥k-2</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        b <span class="token operator">=</span> f<span class="token punctuation">;</span>        f <span class="token operator">=</span> f <span class="token operator">+</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//printf("%d", f);</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//递归</span>bool <span class="token function">IsDescendant</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//return printf("%s","没有");</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> u <span class="token operator">||</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//return printf("%s","有");</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">IsDescendant</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> n<span class="token punctuation">,</span> u<span class="token punctuation">,</span> L<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">IsDescendant</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> n<span class="token punctuation">,</span> u<span class="token punctuation">,</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//return printf("%s","有");</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//return printf("%s","没有");</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//非递归</span>bool <span class="token function">IsDescendant1</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> Queue<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> u <span class="token operator">!=</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//v的左孩子入队</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>R<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> u <span class="token operator">!=</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//v的右孩子入队</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front <span class="token operator">!=</span> rear<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//队不为空时</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>R<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> Fibonacci <span class="token operator">=</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fibonacci: %d\n"</span><span class="token punctuation">,</span>Fibonacci<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>u<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> B<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    bool status <span class="token operator">=</span> <span class="token function">IsDescendant</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>n<span class="token punctuation">,</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool status1 <span class="token operator">=</span> <span class="token function">IsDescendant1</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>n<span class="token punctuation">,</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"（非递归）是否为子孙: %d"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"（递归）是否为子孙: %d"</span><span class="token punctuation">,</span>status1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化-计网第二章-物理层</title>
      <link href="/posts/f655.html/"/>
      <url>/posts/f655.html/</url>
      
        <content type="html"><![CDATA[<h2 id="强化-计网第二章-物理层"><a href="#强化-计网第二章-物理层" class="headerlink" title="强化 计网第二章 物理层"></a>强化 计网第二章 物理层</h2><h3 id="1-通信系统"><a href="#1-通信系统" class="headerlink" title="1.通信系统"></a>1.通信系统</h3><h4 id="1-1组成"><a href="#1-1组成" class="headerlink" title="1.1组成"></a>1.1组成</h4><h5 id="1-1-1信源"><a href="#1-1-1信源" class="headerlink" title="1.1.1信源"></a>1.1.1信源</h5><ul><li>产生要发送数据的设备</li></ul><h5 id="1-1-2发送设备"><a href="#1-1-2发送设备" class="headerlink" title="1.1.2发送设备"></a>1.1.2发送设备</h5><ul><li>对数据信息编码的设备</li></ul><h5 id="1-1-3传输系统"><a href="#1-1-3传输系统" class="headerlink" title="1.1.3传输系统"></a>1.1.3传输系统</h5><ul><li>传输线路或网络</li></ul><h5 id="1-1-4接收设备"><a href="#1-1-4接收设备" class="headerlink" title="1.1.4接收设备"></a>1.1.4接收设备</h5><ul><li>将接受的信号变成数据</li></ul><h5 id="1-1-5信宿"><a href="#1-1-5信宿" class="headerlink" title="1.1.5信宿"></a>1.1.5信宿</h5><ul><li>从接收设备接收数据信息。就是目的系统</li></ul><h3 id="2-编码与调制"><a href="#2-编码与调制" class="headerlink" title="2.编码与调制"></a>2.编码与调制</h3><h4 id="2-1信号类型"><a href="#2-1信号类型" class="headerlink" title="2.1信号类型"></a>2.1信号类型</h4><h5 id="2-1-1模拟信号"><a href="#2-1-1模拟信号" class="headerlink" title="2.1.1模拟信号"></a>2.1.1模拟信号</h5><ul><li>随时间连续变化的电磁波形式（信号）</li></ul><h6 id="2-1-1-1波特率"><a href="#2-1-1-1波特率" class="headerlink" title="2.1.1.1波特率"></a>2.1.1.1波特率</h6><ul><li>每秒发送的波数</li></ul><h5 id="2-1-2数字信号"><a href="#2-1-2数字信号" class="headerlink" title="2.1.2数字信号"></a>2.1.2数字信号</h5><ul><li>离散的，数值的变化是瞬时的</li></ul><h6 id="2-1-2-1比特间隙"><a href="#2-1-2-1比特间隙" class="headerlink" title="2.1.2.1比特间隙"></a>2.1.2.1比特间隙</h6><ul><li>发送一比特所需要的时间</li></ul><h6 id="2-1-2-2比特率"><a href="#2-1-2-2比特率" class="headerlink" title="2.1.2.2比特率"></a>2.1.2.2比特率</h6><ul><li>一秒钟内的比特间隙个数，是每秒发送的比特数，单位是bps（位每秒）</li></ul><h6 id="2-1-2-3有效带宽"><a href="#2-1-2-3有效带宽" class="headerlink" title="2.1.2.3有效带宽"></a>2.1.2.3有效带宽</h6><ul><li>数字信号的频谱包括不同振幅的无数多个频率，如果根据一定的门限，只传输那些具有重要振幅的分量，仍然可以以合理的精度在接收端还原出数字信号，则数字信号频谱中的这一部分称作有效频谱，有效频谱的带宽称为有效带宽</li></ul><h4 id="2-2信道数据传输率"><a href="#2-2信道数据传输率" class="headerlink" title="2.2信道数据传输率"></a>2.2信道数据传输率</h4><h5 id="2-2-1奈奎斯特定理（奈氏准则）"><a href="#2-2-1奈奎斯特定理（奈氏准则）" class="headerlink" title="2.2.1奈奎斯特定理（奈氏准则）"></a>2.2.1奈奎斯特定理（奈氏准则）</h5><h5 id="2-2-2香农定理"><a href="#2-2-2香农定理" class="headerlink" title="2.2.2香农定理"></a>2.2.2香农定理</h5><h4 id="2-3数字-数字编码"><a href="#2-3数字-数字编码" class="headerlink" title="2.3数字-数字编码"></a>2.3数字-数字编码</h4><h5 id="2-3-1单极性编码"><a href="#2-3-1单极性编码" class="headerlink" title="2.3.1单极性编码"></a>2.3.1单极性编码</h5><ul><li>电压只有一极，高电平表示1，低电平表示0</li></ul><img src="单极性编码.png" alt="单极性编码" style="zoom: 67%;"><h5 id="2-3-2极化编码"><a href="#2-3-2极化编码" class="headerlink" title="2.3.2极化编码"></a>2.3.2极化编码</h5><ul><li>一个正电压，一个负电压。通过使用两个电压，减轻了单极性编码中的直流分量问题</li></ul><h6 id="2-3-2-1非归零编码"><a href="#2-3-2-1非归零编码" class="headerlink" title="2.3.2.1非归零编码"></a>2.3.2.1非归零编码</h6><ul><li>正电压为1，负电压为0</li></ul><h6 id="2-3-2-2归零编码"><a href="#2-3-2-2归零编码" class="headerlink" title="2.3.2.2归零编码"></a>2.3.2.2归零编码</h6><ul><li>电平翻转一次为1，没有电平变化为0</li><li>电平的翻转能提供一种同步机制</li></ul><img src="非归零编码.png" alt="非归零编码" style="zoom:67%;"><h6 id="2-3-2-3双相位编码"><a href="#2-3-2-3双相位编码" class="headerlink" title="2.3.2.3双相位编码"></a>2.3.2.3双相位编码</h6><ul><li>曼彻斯特编码：一个<strong>负电平到正电平</strong>的跳边<strong>代表1</strong>，由<strong>正到负代表0</strong></li><li>差分曼彻斯特编码：每个比特间隙的开始位置<strong>有跳变代表0</strong>，<strong>没有跳变代表1</strong></li></ul><h4 id="2-4数字-模拟编码"><a href="#2-4数字-模拟编码" class="headerlink" title="2.4数字-模拟编码"></a>2.4数字-模拟编码</h4><h5 id="2-4-1幅移键控（ASK）"><a href="#2-4-1幅移键控（ASK）" class="headerlink" title="2.4.1幅移键控（ASK）"></a>2.4.1幅移键控（ASK）</h5><img src="ASK.png" alt="ASK" style="zoom:67%;"><h5 id="2-4-2频移键控（FSK）"><a href="#2-4-2频移键控（FSK）" class="headerlink" title="2.4.2频移键控（FSK）"></a>2.4.2频移键控（FSK）</h5><img src="FSK.png" alt="FSK" style="zoom:67%;"><h5 id="2-4-3相移键控（PSK）"><a href="#2-4-3相移键控（PSK）" class="headerlink" title="2.4.3相移键控（PSK）"></a>2.4.3相移键控（PSK）</h5><img src="PSK.png" alt="PSK" style="zoom:67%;"><h5 id="2-4-4正交调幅（QAM）"><a href="#2-4-4正交调幅（QAM）" class="headerlink" title="2.4.4正交调幅（QAM）"></a>2.4.4正交调幅（QAM）</h5><ul><li>ASK和PSK结合起来的编码方式</li></ul><img src="QAM.png" alt="QAM" style="zoom: 67%;"><h3 id="3-线路配置与传输模式"><a href="#3-线路配置与传输模式" class="headerlink" title="3.线路配置与传输模式"></a>3.线路配置与传输模式</h3><h4 id="3-1传输模式"><a href="#3-1传输模式" class="headerlink" title="3.1传输模式"></a>3.1传输模式</h4><h5 id="3-1-1点到点连接"><a href="#3-1-1点到点连接" class="headerlink" title="3.1.1点到点连接"></a>3.1.1点到点连接</h5><ul><li>提供了两个设备之间的专用链路。整个信道的容量都被用于这两个设备之间的传输</li></ul><h5 id="3-1-2多点连接"><a href="#3-1-2多点连接" class="headerlink" title="3.1.2多点连接"></a>3.1.2多点连接</h5><ul><li>两个以上的设备共享一条链路的配置方式。信道的容量是通过某种途径共享的</li><li>实现<strong>信道共享</strong>的技术称为<strong>复用技术</strong></li></ul><h5 id="3-1-3单工、半双工、双工"><a href="#3-1-3单工、半双工、双工" class="headerlink" title="3.1.3单工、半双工、双工"></a>3.1.3单工、半双工、双工</h5><ul><li>单工：<strong>通信单向进行</strong>，两个站点中只有一个可以进行传输，另一个只能接收</li><li>半双工：每个站点都可以发送和接收数据，但是<strong>不能同时发送和接收数据</strong>。</li><li>双工：两个站点<strong>都可以同时发送和接收数据</strong></li></ul><h5 id="3-1-4串行、并行"><a href="#3-1-4串行、并行" class="headerlink" title="3.1.4串行、并行"></a>3.1.4串行、并行</h5><ul><li>并行：在每个时钟脉冲到来时，多个比特被同时发送，每个比特使用单独的一条线路</li><li>串行：每个时钟脉冲只发送一个比特，它只使用一条线路，逐个传送</li></ul><h5 id="3-1-5同步、异步"><a href="#3-1-5同步、异步" class="headerlink" title="3.1.5同步、异步"></a>3.1.5同步、异步</h5><ul><li>异步：比特流划分成多个小组独立传送。随时发，有开始位，终止位，用于低速设备。开销大，先发开始位0，发送一个字节，在发送终止位1，如此循环</li><li>同步：成块的发送比特流，字符之间不加开始位和停止位。先二进制同步（法一：接收端和发送端之间单设一条线传送时钟脉冲；法二：采用自同步编码，曼彻斯特编码等），再数据帧同步，在数据帧前后加上起始和结束标志</li></ul><h4 id="3-2多路复用"><a href="#3-2多路复用" class="headerlink" title="3.2多路复用"></a>3.2多路复用</h4><h5 id="3-2-1频分多路复用（FDM）"><a href="#3-2-1频分多路复用（FDM）" class="headerlink" title="3.2.1频分多路复用（FDM）"></a>3.2.1频分多路复用（FDM）</h5><ul><li><strong>模拟信号</strong></li></ul><h5 id="3-2-1时分多路复用（TDM）"><a href="#3-2-1时分多路复用（TDM）" class="headerlink" title="3.2.1时分多路复用（TDM）"></a>3.2.1时分多路复用（TDM）</h5><ul><li><strong>数字信号</strong></li></ul><h5 id="3-2-1波分多路复用（WDM）"><a href="#3-2-1波分多路复用（WDM）" class="headerlink" title="3.2.1波分多路复用（WDM）"></a>3.2.1波分多路复用（WDM）</h5><ul><li><strong>模拟信号</strong></li><li>光纤</li></ul><h5 id="3-2-1码分多路复用（CDM）-码分多址复用（CDMA）"><a href="#3-2-1码分多路复用（CDM）-码分多址复用（CDMA）" class="headerlink" title="3.2.1码分多路复用（CDM）/码分多址复用（CDMA）"></a>3.2.1码分多路复用（CDM）/码分多址复用（CDMA）</h5><ul><li>根据码型结构的不同来实现信号分割</li><li>在CDMA每个比特被分成m个不同码片，每个站点被指定一个唯一的m位码片（码型）。当发送比特1时，站点就发送其码片，想发送0时，站点就发送其码片的补码</li></ul><h4 id="3-3数据交换技术"><a href="#3-3数据交换技术" class="headerlink" title="3.3数据交换技术"></a>3.3数据交换技术</h4><h5 id="3-3-1电路交换"><a href="#3-3-1电路交换" class="headerlink" title="3.3.1电路交换"></a>3.3.1电路交换</h5><ul><li>在两个设备之间创建一条临时的物理连接</li><li>通讯过程：电路建立、数据传输、电路拆除</li></ul><h5 id="3-3-2报文交换（存储转发）"><a href="#3-3-2报文交换（存储转发）" class="headerlink" title="3.3.2报文交换（存储转发）"></a>3.3.2报文交换（存储转发）</h5><ul><li>在报文的传输过程中，由网络的中间结点将报文暂时存储起来，检查它的正确性和完整性，然后再发往下一个结点</li></ul><h5 id="3-3-3分组交换"><a href="#3-3-3分组交换" class="headerlink" title="3.3.3分组交换"></a>3.3.3分组交换</h5><ul><li>在分组交换中，较长的报文被分为较短的数据单元，然后每个数据单元被加上一些通信控制信息等内容，形成一个信息包（packet）。通信时以包为单位发送、存储和转发。信息包包含数据和包头，包头由通信控制信息、差错控制信息等组成</li><li>信息包比报文短得多，因此可以在中间结点存储，不必访问外存。而且只要整个信息包到达后就可以转发，不必等待很长的报文全部到达，大大缩短了信息传输过程中的延迟时间</li></ul><h6 id="3-3-3-1数据报"><a href="#3-3-3-1数据报" class="headerlink" title="3.3.3.1数据报"></a>3.3.3.1数据报</h6><ul><li>数据报方法中，包被称为数据报，在传输中每个包都将独立于其他包进行处理</li><li><strong>到达的顺序可能不同</strong>，对数据报进行重排的任务可以由网络层的上层（传输层）来完成</li></ul><h6 id="3-3-3-2虚电路"><a href="#3-3-3-2虚电路" class="headerlink" title="3.3.3.2虚电路"></a>3.3.3.2虚电路</h6><ul><li>虚电路方法中，属于同一次通信的所有包之间的关系得以维持。当数据开始时，将按照预定好的路线一个接一个的传送</li><li>任何一条链路可以同时为多对设备之间的通信服务</li><li>在需要的时候被创建、通信传输、拆除</li><li>仅在建立虚电路时需要目的地址，在进行数据传送时，每个包不需要携带完整的目的地址，只需要一个虚电路的号码标识。减少了包的控制信息长度，从而减少了额外开销</li></ul><h4 id="3-4错误检验和控制"><a href="#3-4错误检验和控制" class="headerlink" title="3.4错误检验和控制"></a>3.4错误检验和控制</h4><ul><li>见题型即可</li></ul><h5 id="3-4-1奇偶校验码"><a href="#3-4-1奇偶校验码" class="headerlink" title="3.4.1奇偶校验码"></a>3.4.1奇偶校验码</h5><h6 id="3-4-1-1垂直（纵向）奇偶校验"><a href="#3-4-1-1垂直（纵向）奇偶校验" class="headerlink" title="3.4.1.1垂直（纵向）奇偶校验"></a>3.4.1.1垂直（纵向）奇偶校验</h6><h6 id="3-4-1-2水平（横向）奇偶校验"><a href="#3-4-1-2水平（横向）奇偶校验" class="headerlink" title="3.4.1.2水平（横向）奇偶校验"></a>3.4.1.2水平（横向）奇偶校验</h6><h5 id="3-4-1循环校验码CRC"><a href="#3-4-1循环校验码CRC" class="headerlink" title="3.4.1循环校验码CRC"></a>3.4.1循环校验码CRC</h5><h5 id="3-4-2校验和"><a href="#3-4-2校验和" class="headerlink" title="3.4.2校验和"></a>3.4.2校验和</h5><h3 id="4-传输介质"><a href="#4-传输介质" class="headerlink" title="4.传输介质"></a>4.传输介质</h3><h4 id="4-1有线介质"><a href="#4-1有线介质" class="headerlink" title="4.1有线介质"></a>4.1有线介质</h4><h5 id="4-1-1双绞线"><a href="#4-1-1双绞线" class="headerlink" title="4.1.1双绞线"></a>4.1.1双绞线</h5><ul><li>由扭在一起的两根绝缘铜线组成</li><li>用于传输平衡信号</li></ul><h5 id="4-1-2同轴电缆"><a href="#4-1-2同轴电缆" class="headerlink" title="4.1.2同轴电缆"></a>4.1.2同轴电缆</h5><h5 id="4-1-3光纤"><a href="#4-1-3光纤" class="headerlink" title="4.1.3光纤"></a>4.1.3光纤</h5><ul><li>光的速度依赖于它所穿越的传输介质的密度，密度越大，速度越低</li></ul><h6 id="4-1-3-1多模传播"><a href="#4-1-3-1多模传播" class="headerlink" title="4.1.3.1多模传播"></a>4.1.3.1多模传播</h6><ul><li><p>多束光线在芯材中通过不同的路径</p></li><li><p>多模阶跃：密度突变，不同角度，速度不同，</p></li><li><p>多模渐变：密度渐变，速度相同，中心密度最大，并向外逐步变小</p></li></ul><h6 id="4-1-3-2单模传播"><a href="#4-1-3-2单模传播" class="headerlink" title="4.1.3.2单模传播"></a>4.1.3.2单模传播</h6><ul><li>单模光纤采用阶跃材质和高度集中的光源。芯材直径比多模光纤小得多</li></ul><h4 id="4-2无线介质"><a href="#4-2无线介质" class="headerlink" title="4.2无线介质"></a>4.2无线介质</h4><h5 id="4-2-1卫星、微波、红外线"><a href="#4-2-1卫星、微波、红外线" class="headerlink" title="4.2.1卫星、微波、红外线"></a>4.2.1卫星、微波、红外线</h5><h3 id="5-物理连接"><a href="#5-物理连接" class="headerlink" title="5.物理连接"></a>5.物理连接</h3><ul><li>在数据通信中涉及4个基本功能单元：两端各有一个数据终端设备（DTE）和一个数据电路终接设备</li></ul><h4 id="5-1数据终端设备（DTE）"><a href="#5-1数据终端设备（DTE）" class="headerlink" title="5.1数据终端设备（DTE）"></a>5.1数据终端设备（DTE）</h4><ul><li>DTE是具有数据处理能力及发送和接收数据信息能力的设备</li><li>DTE一般不直接连接网络，它通过一台DCE进行通信。</li><li>我们把DTE和DCE的连接称为DTE-DCE接口</li><li>在DTE-DCE接口上既有数据信息又有控制信息，为了<strong>使各个计算机公司生产的DTE可以方便的和DCE连接</strong>，就<strong>必须对DTE-DCE接口进行标准化</strong>，这些就是<strong>物理层的协议</strong></li></ul><h4 id="5-2数据电路终接设备（DCE）"><a href="#5-2数据电路终接设备（DCE）" class="headerlink" title="5.2数据电路终接设备（DCE）"></a>5.2数据电路终接设备（DCE）</h4><ul><li>DCE是能够通过网络发送和接收模拟或数字信号形式数据的设备</li><li><strong>总结</strong></li><li>数据从上层数据链路层传来</li><li>DTE处理数据，并交给DCE转换成能通过传输介质的电磁信号</li><li>电磁信号通过传输介质传输</li><li>各端的DCE接收这些电磁信号形成数据交给DTE处理</li><li>DTE处理完数据，交给上层的数据链路层</li></ul><h3 id="6-物理层协议"><a href="#6-物理层协议" class="headerlink" title="6.物理层协议"></a>6.物理层协议</h3><h4 id="6-1EIA232"><a href="#6-1EIA232" class="headerlink" title="6.1EIA232"></a>6.1EIA232</h4><h5 id="6-1-1机械特性"><a href="#6-1-1机械特性" class="headerlink" title="6.1.1机械特性"></a>6.1.1机械特性</h5><h5 id="6-1-2电气特性"><a href="#6-1-2电气特性" class="headerlink" title="6.1.2电气特性"></a>6.1.2电气特性</h5><h5 id="6-1-3功能特性"><a href="#6-1-3功能特性" class="headerlink" title="6.1.3功能特性"></a>6.1.3功能特性</h5><h5 id="6-1-4规程特性"><a href="#6-1-4规程特性" class="headerlink" title="6.1.4规程特性"></a>6.1.4规程特性</h5><h4 id="6-2X-21"><a href="#6-2X-21" class="headerlink" title="6.2X.21"></a>6.2X.21</h4><h3 id="7-工作的设备"><a href="#7-工作的设备" class="headerlink" title="7.工作的设备"></a>7.工作的设备</h3><h4 id="7-1中继器或转发器"><a href="#7-1中继器或转发器" class="headerlink" title="7.1中继器或转发器"></a>7.1中继器或转发器</h4><ul><li>中继器是一个再生器，不是一个增幅器，只是将受损的信号重新还原成原始的形式，会导致局域网性能下降</li></ul><h4 id="7-2集线器"><a href="#7-2集线器" class="headerlink" title="7.2集线器"></a>7.2集线器</h4><ul><li>多端口中继器，建立星状、树状网络结构</li></ul><h3 id="8-考题类型"><a href="#8-考题类型" class="headerlink" title="8.考题类型"></a>8.考题类型</h3><h4 id="8-1-111000111000的曼彻斯特编码和差分曼彻斯特编码？"><a href="#8-1-111000111000的曼彻斯特编码和差分曼彻斯特编码？" class="headerlink" title="8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？"></a>8.1 111000111000的曼彻斯特编码和差分曼彻斯特编码？</h4><h4 id="8-2-CRC校验码"><a href="#8-2-CRC校验码" class="headerlink" title="8.2 CRC校验码"></a>8.2 CRC校验码</h4><ul><li>是x的几次多项式，就在带传送数据后加几个0</li><li><font color="red"><strong>同0异1</strong></font></li><li>做除法，得出来的余数，加到带传输的数据后即可</li></ul><h4 id="8-3电路交换网络和包交换（分组交换）网络的主要区别是什么？"><a href="#8-3电路交换网络和包交换（分组交换）网络的主要区别是什么？" class="headerlink" title="8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？"></a>8.3电路交换网络和包交换（分组交换）网络的主要区别是什么？</h4><h4 id="8-4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽"><a href="#8-4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽" class="headerlink" title="8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽"></a>8.4已知信道速率为1Mbps，离散电平数目为16，根据奈奎斯特定理，求信道带宽</h4><ul><li><p><strong>W</strong>：理想低通信信道的<strong>带宽</strong>，单位为Hz</p></li><li><p><strong>V</strong>：表示每个码元离散电平的数目</p></li><li><p>则理想低通信道下的极限数据传输率 = <strong>$2Wlog_2V$</strong></p></li><li><p>$1<em>10^6=2H</em>1<em>4, H=1</em>10^6/8=125000Hz$</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
            <tag> 强化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/232f.html/"/>
      <url>/posts/232f.html/</url>
      
        <content type="html"><![CDATA[<h2 id="排序问题整理"><a href="#排序问题整理" class="headerlink" title="排序问题整理"></a>排序问题整理</h2><blockquote><ul><li><p>排序的时候能用快速排序尽量用快排</p></li><li><p>整理排序算法的复杂度以及优缺点</p></li></ul></blockquote><h4 id="1-快速排序（交换排序）"><a href="#1-快速排序（交换排序）" class="headerlink" title="1.快速排序（交换排序）"></a>1.快速排序（交换排序）</h4><ul><li>需要一个递归栈来保存信息</li><li>最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(n^{2})$</li><li>空间复杂度：$O(log_2{n})$</li><li>是否稳定：否（快的排序都不稳定）</li><li>每排一次，枢轴被放入最终位置</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//一趟划分</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//将当前表中第一个元素设为枢轴，对表进行划分</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>        low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//从前往后找到一个比枢轴大的数</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//从后往前找到一个比枢轴小的数</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//用临时变量w储存值，交换两个数</span>            A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//用临时变量w储存值，交换两个数</span>            A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//用临时变量w储存值，交换两个数</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    A<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//找到枢轴的正确位置，交换这两个元素</span>    A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>    <span class="token keyword">return</span> high<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//返回枢轴正确的位置</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//开始快排</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//枢轴左半边继续快排</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-冒泡排序（交换排序）"><a href="#2-冒泡排序（交换排序）" class="headerlink" title="2.冒泡排序（交换排序）"></a>2.冒泡排序（交换排序）</h4><blockquote><ul><li>注意返回值类型以及函数以及flag的使用</li></ul></blockquote><ul><li>从后往前比较两两相邻元素的值，若为逆序，则交换他们，直到序列比较完成。这成为第一趟冒泡。</li><li>结果是将最小的元素交换到待排序列的第一个位置</li><li>下一趟冒泡时，前一趟确定的最小元素不再参与比较，这样最多$n-1$趟冒泡就能排好序</li><li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li><li>是否稳定：是</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        bool flag <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> j<span class="token operator">></span>i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//从后往前</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//交换两个元素</span>                flag <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> false<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//没有发生交换，这说明有序</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//网上找的swap函数，仅供参考</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h4><ul><li>从前往后依次插入到前面的序列</li><li>最好情况是表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素</li><li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li><li>是否稳定：是</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InserSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//依次将A[2]~A[n]插入到前面已排序序列</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//若A[i]关键词小于其前驱，将A[i]插入有序表</span>            A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//复制为哨兵，A[0]不存放元素</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token number">-1</span><span class="token punctuation">;</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从后往前查找待插入位置</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向后挪位</span>            <span class="token punctuation">}</span>            A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//复制到插入位置</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-折半插入排序"><a href="#4-折半插入排序" class="headerlink" title="4.折半插入排序"></a>4.折半插入排序</h4><ul><li>只适用于<strong>顺序表</strong></li><li>最好情况：$O({n})$；平均情况：$O(n^{2})$；最坏情况：$O(n^{2})$</li><li>是否稳定：是</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//依次将A[2]~A[n]插入到前面的已排序序列</span>        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//将A[i]暂存到A[0]</span>        low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//设置折半查找的范围</span>        high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置折半查找的范围</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//折半查找（默认递增有序）</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取中间点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//查找左半子表</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//查找右半子表</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//统一后移元素，空出插入位置</span>        <span class="token punctuation">}</span>        A<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//插入操作</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5.希尔排序"></a>5.希尔排序</h4><ul><li>只适用于<strong>顺序表</strong></li><li>是否稳定：否</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>dk<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>dk<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>dk<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>dk<span class="token operator">=</span>dk<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//步长变化 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需将A[i]插入有序增量字表</span>                A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//暂存A[0]</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>dk<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">=</span>j<span class="token operator">-</span>dk<span class="token punctuation">)</span><span class="token punctuation">{</span>                    A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//记录后移，查找插入位置</span>                <span class="token punctuation">}</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//插入</span>            <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//if</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h4><ul><li>每排列一次，都有一个正确结点</li><li>最好情况$O(nlog_2{n})$；平均情况$O(nlog_2{n})$；最坏情况$O(nlog_2{n})$</li><li>是否稳定：否</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//反复调整堆</span>        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeadAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">*</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>            k <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//放入最终位置</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//建立初始堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//n-1趟的交换和建堆</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//堆顶和堆底元素交换</span>        A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续调整剩余元素</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图相关代码</title>
      <link href="/posts/ad5b.html/"/>
      <url>/posts/ad5b.html/</url>
      
        <content type="html"><![CDATA[<h2 id="图相关代码"><a href="#图相关代码" class="headerlink" title="图相关代码"></a>图相关代码</h2><blockquote><h4 id="1-邻接矩阵存储结构定义"><a href="#1-邻接矩阵存储结构定义" class="headerlink" title="1.邻接矩阵存储结构定义"></a>1.邻接矩阵存储结构定义</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MaxVertexNum 100                   </span><span class="token comment" spellcheck="true">//顶点数目的最大值</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//顶点的数据类型</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> EdgeType<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//带权图中边上权值的数据类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> Vex<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//顶点表</span>    <span class="token keyword">int</span> Edge<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//邻接矩阵，边表</span>    <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//图的当前顶点数和弧数</span><span class="token punctuation">}</span>MGraph<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="2-邻接表存储结构定义"><a href="#2-邻接表存储结构定义" class="headerlink" title="2.邻接表存储结构定义"></a>2.邻接表存储结构定义</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MaxVertexNum 100                   </span><span class="token comment" spellcheck="true">//顶点数目的最大值</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> ArcNode<span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//边表结点</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//邻接顶点</span>    <span class="token keyword">struct</span> ArcNode <span class="token operator">*</span>nextarc<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//指向下一条边</span>    <span class="token comment" spellcheck="true">//InfoType info;                       //网的边权值</span><span class="token punctuation">}</span>ArcNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//邻接表的边类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> VNode<span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//顶点表结点</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//顶点信息</span>    ArcNode <span class="token operator">*</span>firstarc<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//指向第一条邻接边的指针</span><span class="token punctuation">}</span>VNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//邻接表的顶点类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    VNode vexset<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//顶点集，每个顶点都有指向第一条边的指针，所以不用定义边集</span>    <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//顶点数和边数</span><span class="token punctuation">}</span>ALGraph<span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">//ALGraph是以邻接表存储的图类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="3-广度优先搜索（BFS）"><a href="#3-广度优先搜索（BFS）" class="headerlink" title="3.广度优先搜索（BFS）"></a>3.广度优先搜索（BFS）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c">bool visited<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//标记访问数组</span><span class="token keyword">void</span> <span class="token function">BFSTraverse</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//对图G进行广度优先遍历</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//访问标记数组初始化</span>    <span class="token punctuation">}</span>    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//初始化辅助队列Q</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">==</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//从0号顶点开始遍历</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//对每个连通分量调用一次BFS</span>            <span class="token function">BFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//vi从未被访问过，从vi开始BFS</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//从定点v出发，广度优先遍历图G</span>    <span class="token function">visit</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//访问初始顶点v</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//对v做已访问标记</span>    <span class="token function">Enqueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//顶点v入队列Q</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">Dequeue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//顶点v出队列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                     <span class="token comment" spellcheck="true">//检测v所有邻接点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//w为v的尚未访问的邻接结点</span>                <span class="token function">visit</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//访问顶点w</span>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//对w做已访问标记</span>                <span class="token function">Enqueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//顶点w入队列</span>            <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//if</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="4-BFS算法求解单元最短路径"><a href="#4-BFS算法求解单元最短路径" class="headerlink" title="4.BFS算法求解单元最短路径"></a>4.BFS算法求解单元最短路径</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BFS_MIN_Distance</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//d[i]表示从u到i的最短路径</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//初始化路径长度</span>    <span class="token punctuation">}</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//BFS算法主过程</span>        <span class="token function">Dequeue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//对头元素u出队</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>u<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                     <span class="token comment" spellcheck="true">//检测u所有邻接点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//w为u的尚未访问的邻接结点</span>                <span class="token function">visit</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//访问顶点w</span>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//对w做已访问标记</span>                d<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//路径长度加1</span>                <span class="token function">Enqueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//顶点w入队列</span>            <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//if</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="5-深度优先搜索（DFS）递归"><a href="#5-深度优先搜索（DFS）递归" class="headerlink" title="5.深度优先搜索（DFS）递归"></a>5.深度优先搜索（DFS）递归</h4></blockquote><pre class="line-numbers language-c"><code class="language-c">bool visited<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//标记访问数组</span><span class="token keyword">void</span> <span class="token function">DFSTraverse</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//对图G进行广度优先遍历</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">++</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//访问标记数组初始化</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">++</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//从0号顶点开始遍历</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//对每个连通分量调用一次BFS</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//vi从未被访问过，从vi开始BFS</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">visit</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//访问顶点v</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//设已访问标记</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                     <span class="token comment" spellcheck="true">//检测v所有邻接点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//w为v的尚未访问的邻接结点</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//if</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="6-深度优先搜索（DFS）非递归"><a href="#6-深度优先搜索（DFS）非递归" class="headerlink" title="6.深度优先搜索（DFS）非递归"></a>6.深度优先搜索（DFS）非递归</h4></blockquote><ul><li>因为使用了栈，使得遍历的方式从右到左进行，但仍然是深度优先遍历</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">DFS_Non_Rc</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//从顶点v开始进行深度优先搜索，一次遍历一个连通分量的所有顶点</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//顶点序号</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//初始化栈S</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//初始化visited</span>    <span class="token punctuation">}</span>    <span class="token function">push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//v入栈</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//并且置visited[v]为真</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        k <span class="token operator">=</span> <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//栈中退出一个顶点</span>        <span class="token function">visit</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//先访问，再将其子结点入栈</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>k<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                       <span class="token comment" spellcheck="true">//检测k所有邻接点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//w为k的尚未访问的邻接结点</span>                <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//访问顶点w</span>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//对w做已访问标记</span>            <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//if</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//DFS_Non_Rc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="7-判断图是否为一棵树"><a href="#7-判断图是否为一棵树" class="headerlink" title="7.判断图是否为一棵树"></a>7.判断图是否为一棵树</h4></blockquote><ul><li>如果有环，则失败，不是一棵树</li></ul><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">BFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">visit</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>    <span class="token function">Enqueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">Dequeue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                       <span class="token comment" spellcheck="true">//检测k所有邻接点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//w为k的尚未访问的邻接结点</span>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//对w做已访问标记</span>                <span class="token function">Enqueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="8-找出u结点到v结点的所有路径"><a href="#8-找出u结点到v结点的所有路径" class="headerlink" title="8.找出u结点到v结点的所有路径"></a>8.找出u结点到v结点的所有路径</h4></blockquote><ul><li>基于深度优先遍历算法，从结点u出发，递归深度优先遍历图中结点，若访问到结点v，则输出该搜索路径上的结点。</li><li>为此，设置一个path数组来存放路径上的结点（初始为空），d表示路径长度（初始为-1）。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">FindPath</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> path<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> w<span class="token punctuation">,</span>i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//邻接表定义方法</span>    d<span class="token operator">++</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//路径长度加一</span>    path<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//写入路径数组</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//已访问过标记</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//输出路径</span>    <span class="token punctuation">}</span>    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//找到相邻接点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//w未被访问，则递归访问</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">FindPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">,</span>V<span class="token punctuation">,</span>path<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//指向u的下一个结点</span>    <span class="token punctuation">}</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//恢复环境，使该顶点可重新使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9月8号计划</title>
      <link href="/posts/51cd.html/"/>
      <url>/posts/51cd.html/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 计网绪论强化知识点<br>2. 图相关代码整理<br>3. 政治两课<br>4. 数学概率第一章<br>5. 英语真题加单词</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 男男 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树相关代码</title>
      <link href="/posts/3849.html/"/>
      <url>/posts/3849.html/</url>
      
        <content type="html"><![CDATA[<h2 id="树相关代码"><a href="#树相关代码" class="headerlink" title="树相关代码"></a>树相关代码</h2><blockquote><h4 id="1-二叉树链式存储结构描述"><a href="#1-二叉树链式存储结构描述" class="headerlink" title="1. 二叉树链式存储结构描述"></a>1. 二叉树链式存储结构描述</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiTNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//数据域</span>    <span class="token keyword">struct</span> BiTree <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//左、右孩子指针</span><span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="2-先序遍历"><a href="#2-先序遍历" class="headerlink" title="2. 先序遍历"></a>2. 先序遍历</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//访问根节点</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归遍历左子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="3-中序遍历"><a href="#3-中序遍历" class="headerlink" title="3. 中序遍历"></a>3. 中序遍历</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//访问根节点</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归遍历左子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="4-后序遍历"><a href="#4-后序遍历" class="headerlink" title="4. 后序遍历"></a>4. 后序遍历</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归遍历左子树</span>        <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//访问根节点</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="5-层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）"><a href="#5-层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）" class="headerlink" title="5. 层次遍历（层次遍历是利用队列作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）"></a>5. 层次遍历（层次遍历是利用<strong>队列</strong>作为辅助结构，并且只有层次遍历时循环语句是只用队列是否为空作为判断条件的，其他遍历方式均为判定结点不为空或者栈不为空）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//初始化辅助队列</span>    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    BiTree p<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//p用于遍历二叉树</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//将根节点入队Q</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front<span class="token operator">!=</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//队列不为空则循环</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//队头结点出队</span>        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//访问出队结点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//左子树不为空，则左子树根结点入队</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//右子树不为空，则右子树根节点入队</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="6-先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）"><a href="#6-先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）" class="headerlink" title="6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）"></a>6. 先序非递归（使用栈来辅助存储的，切勿与层次遍历搞混了）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Stack<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//初始化辅助栈S</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//栈的下标</span>    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//p是遍历指针</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>top<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//栈不空或p不为空时，开始循环</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//一路向左</span>            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//访问当前结点</span>            Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//入栈元素</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//左孩子不为空，一直向左走</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//出栈，并转向出栈结点的右子树</span>            p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//栈顶元素出栈</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//向右子树走，p赋值为当前结点的右孩子</span>                               <span class="token comment" spellcheck="true">//返回while循环继续进入if-else语句</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="7-中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）"><a href="#7-中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）" class="headerlink" title="7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）"></a>7. 中序非递归（使用栈来辅助储存的。先序与中序的区别便是：先序是先访问再压栈，中序是出栈后再访问）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//初始化栈S</span>    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//p是遍历指针</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span>IsEmpty<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//栈不空或p不为空时，开始循环</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//一路向左</span>            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//入栈元素</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//左孩子不为空，一直向左走</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//出栈，并转向出栈结点的右子树</span>            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//栈顶元素出栈</span>            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//访问出栈结点</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//向右子树走，p赋值为当前结点的右孩子</span>                               <span class="token comment" spellcheck="true">//返回while循环继续进入if-else语句</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="8-后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）"><a href="#8-后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）" class="headerlink" title="8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）"></a>8. 后序非递归（后序非递归遍历是最重要的。一定要记住当遍历到某一结点时，栈里存在的元素是其所有的祖先结点）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> T<span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">//p是遍历指针</span>    r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">//走到最左边</span>            <span class="token function">push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>             p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">//向右</span>            <span class="token function">GetTop</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//读栈顶结点（非出栈）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">!=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若右子树存在，且未被访问过</span>                p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//向右转</span>                <span class="token function">push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//压入栈</span>                p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//再走到最走</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                              <span class="token comment" spellcheck="true">//否则，弹出结点并访问</span>                <span class="token function">pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//将结点弹出</span>                <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//访问该节点</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//记录最近访问过的结点</span>                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//结点访问完后，重置p指针</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//else</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="9-递归求树的高度"><a href="#9-递归求树的高度" class="headerlink" title="9.递归求树的高度"></a>9.递归求树的高度</h4></blockquote><ul><li>写递归时首先需要考虑的便是递归运行到什么时候终止</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Btdepth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ldep <span class="token operator">=</span> <span class="token function">Btdepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rdep <span class="token operator">=</span> <span class="token function">Btdepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ldep <span class="token operator">></span> rdep<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> ldep <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> rdep <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="10-递归交换二叉树的左右子树"><a href="#10-递归交换二叉树的左右子树" class="headerlink" title="10.递归交换二叉树的左右子树"></a>10.递归交换二叉树的左右子树</h4></blockquote><ul><li>此代码暗含着结点为递归出口</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//本算法递归的交换二叉树的左、右子树</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        BiTree temp <span class="token operator">=</span> b <span class="token operator">-></span> lchild<span class="token punctuation">;</span>        b<span class="token operator">-></span>lchild <span class="token operator">=</span> b<span class="token operator">-></span>rhcild<span class="token punctuation">;</span>        b<span class="token operator">-></span>rchild <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="11-递归删除以某一结点为根节点的子树并释放其存储空间"><a href="#11-递归删除以某一结点为根节点的子树并释放其存储空间" class="headerlink" title="11.递归删除以某一结点为根节点的子树并释放其存储空间"></a>11.递归删除以某一结点为根节点的子树并释放其存储空间</h4></blockquote><ul><li>此代码暗含着节点为空时为递归出口</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">DeleteXTree</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">DeleteXTree</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DeleteXTree</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="12-利用层次遍历求树的高度（这里还没看）"><a href="#12-利用层次遍历求树的高度（这里还没看）" class="headerlink" title="12.利用层次遍历求树的高度（这里还没看）"></a>12.利用层次遍历求树的高度（这里还没看）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">LeverOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>rear<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>level<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>last<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    BiTree p<span class="token punctuation">;</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front <span class="token operator">!=</span> rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> P<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> P<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>front<span class="token operator">==</span>last<span class="token punctuation">)</span><span class="token punctuation">{</span>            level<span class="token operator">++</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> rear<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="13-利用层次遍历求树的宽度"><a href="#13-利用层次遍历求树的宽度" class="headerlink" title="13.利用层次遍历求树的宽度"></a>13.利用层次遍历求树的宽度</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token operator">=</span>rear<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>width<span class="token operator">=</span>last<span class="token operator">=</span>max<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    BiTree p<span class="token punctuation">;</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front<span class="token operator">!=</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        width<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>max <span class="token operator">&lt;</span> width<span class="token punctuation">)</span><span class="token punctuation">{</span>                max <span class="token operator">=</span> width<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            last <span class="token operator">=</span> rear<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="14-求二叉树中叶子结点的个数"><a href="#14-求二叉树中叶子结点的个数" class="headerlink" title="14.求二叉树中叶子结点的个数"></a>14.求二叉树中叶子结点的个数</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token operator">=</span>rear<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    BiTree p<span class="token punctuation">;</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front<span class="token operator">!=</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">==</span> NUll <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> NUll<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> NUll<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="15-求树中独生叶结点的个数（既是叶结点又无兄弟结点）"><a href="#15-求树中独生叶结点的个数（既是叶结点又无兄弟结点）" class="headerlink" title="15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）"></a>15.求树中独生叶结点的个数（既是叶结点又无兄弟结点）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token operator">=</span>rear<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    BiTree p<span class="token punctuation">;</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front<span class="token operator">!=</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> NUll <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token operator">-></span>lchild <span class="token operator">==</span> NUll <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>lchild<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">==</span> NUll <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token operator">-></span>lchild <span class="token operator">==</span> NUll <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> NUll<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> NUll<span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> T<span class="token operator">-</span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        num<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="16-求一棵二叉树是否为平衡二叉树"><a href="#16-求一棵二叉树是否为平衡二叉树" class="headerlink" title="16.求一棵二叉树是否为平衡二叉树"></a>16.求一棵二叉树是否为平衡二叉树</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">High</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> llen <span class="token operator">=</span> <span class="token function">High</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rlen <span class="token operator">=</span> <span class="token function">High</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>llen <span class="token operator">>=</span> rlen<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> llen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> rlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>bool <span class="token function">PostOrder1</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Stack<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    BiTree p <span class="token operator">=</span> T<span class="token punctuation">,</span>r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p为遍历二叉树指针，r指向最近访问结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild<span class="token operator">!=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//p的右孩子不为空，且未被访问过</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>                Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">High</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">High</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> false<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="17-给出二叉树的自下而上、从右到左的层次遍历算法"><a href="#17-给出二叉树的自下而上、从右到左的层次遍历算法" class="headerlink" title="17.给出二叉树的自下而上、从右到左的层次遍历算法"></a>17.给出二叉树的自下而上、从右到左的层次遍历算法</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InverLevel</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree Queue<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token operator">=</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    BiTree Stack<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    BiTree p<span class="token punctuation">;</span>    Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>front<span class="token operator">!=</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Queue<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild！<span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild！<span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>top<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> Stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">Visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="18-线索二叉树的构造，结构描述"><a href="#18-线索二叉树的构造，结构描述" class="headerlink" title="18.线索二叉树的构造，结构描述"></a>18.线索二叉树的构造，结构描述</h4></blockquote><ul><li>对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左右指针域是否为空，若为空，讲他们改为指向前驱结点或后继结点的线索</li><li>ltag=0，lchild域指示结点的左孩子；ltag=1，lchild域指示结点的前驱</li><li>ltag=0，rchild域指示结点的右孩子；ltag=1，rchild域指示结点的后继</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> ThreadNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//数据元素</span>    <span class="token keyword">struct</span> ThreadNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//左、右孩子指针</span>    <span class="token keyword">int</span> ltag<span class="token punctuation">,</span>rtag<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//左、右线索标志</span><span class="token punctuation">}</span>ThreadNode<span class="token punctuation">,</span><span class="token operator">*</span>ThreadTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="19-中序二叉树线索化"><a href="#19-中序二叉树线索化" class="headerlink" title="19.中序二叉树线索化"></a>19.中序二叉树线索化</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>ThreadTree <span class="token operator">&amp;</span>p<span class="token punctuation">,</span> ThreadTree <span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">Inthread</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">,</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token operator">-></span>lchild <span class="token operator">=</span> pre<span class="token punctuation">;</span>            p<span class="token operator">-></span>ltag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pre<span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>            pre<span class="token operator">-></span>rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token function">InThread</span><span class="token punctuation">(</span>pre<span class="token operator">-></span>rchild<span class="token punctuation">,</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="20-二叉排序树的查找"><a href="#20-二叉排序树的查找" class="headerlink" title="20.二叉排序树的查找"></a>20.二叉排序树的查找</h4></blockquote><ul><li>二叉排序树：左＜根＜右</li></ul><pre class="line-numbers language-c"><code class="language-c">BSTNode <span class="token operator">*</span><span class="token function">BST_Search</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key<span class="token operator">!=</span>T<span class="token operator">-</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="21-二叉排序树的插入"><a href="#21-二叉排序树的插入" class="headerlink" title="21.二叉排序树的插入"></a>21.二叉排序树的插入</h4></blockquote><pre class="line-numbers language-c"><code class="language-c">BSTNode <span class="token operator">*</span><span class="token function">BST_Search</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key<span class="token operator">!=</span>T<span class="token operator">-</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    BiTree Bt <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        p<span class="token operator">-></span>lchild <span class="token operator">=</span> BT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">></span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        p<span class="token operator">-></span>rchild <span class="token operator">=</span> BT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="22-二叉排序树的构造"><a href="#22-二叉排序树的构造" class="headerlink" title="22.二叉排序树的构造"></a>22.二叉排序树的构造</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Creat_BST</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span>KeyType str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化计网第一章-概述</title>
      <link href="/posts/3689.html/"/>
      <url>/posts/3689.html/</url>
      
        <content type="html"><![CDATA[<h2 id="（强化）计网第一章-绪论"><a href="#（强化）计网第一章-绪论" class="headerlink" title="（强化）计网第一章 绪论"></a>（强化）计网第一章 绪论</h2><blockquote><p><strong>计算机网络：是由多个独立的计算机通过通信线路和通信设备互联起来的系统，以便实现彼此交换信息和共享资源的目的</strong>。</p></blockquote><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><h5 id="1-1数据通信"><a href="#1-1数据通信" class="headerlink" title="1.1数据通信"></a>1.1数据通信</h5><ul><li>网络系统中相连的计算机能够相互传送数据信息，使相距很远的用户之间能够直接交换数据</li></ul><h5 id="1-2资源共享"><a href="#1-2资源共享" class="headerlink" title="1.2资源共享"></a>1.2资源共享</h5><ul><li>网络中的软件和硬件资源，如外部设备、文件系统和数据等可分为多个用户所共享</li></ul><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2. 组成"></a>2. 组成</h4><h5 id="2-1资源子网"><a href="#2-1资源子网" class="headerlink" title="2.1资源子网"></a>2.1资源子网</h5><ul><li>负责全网的信息处理，向网络用户提供各种网络资源与网络服务</li></ul><h5 id="2-2通信子网"><a href="#2-2通信子网" class="headerlink" title="2.2通信子网"></a>2.2通信子网</h5><ul><li>完成数据传输和转发等通讯业务</li></ul><h4 id="3-网络拓扑结构（背！）"><a href="#3-网络拓扑结构（背！）" class="headerlink" title="3.网络拓扑结构（背！）"></a>3.网络拓扑结构（<font color="red">背！</font>）</h4><h5 id="3-1网状拓扑（全连接拓扑）"><a href="#3-1网状拓扑（全连接拓扑）" class="headerlink" title="3.1网状拓扑（全连接拓扑）"></a>3.1网状拓扑（全连接拓扑）</h5><ul><li>避免拥塞问题</li><li>具有很好的健壮性</li><li>具有私有性和安全性</li><li>便于管理</li><li>安装费用高</li></ul><h5 id="3-2星状拓扑"><a href="#3-2星状拓扑" class="headerlink" title="3.2星状拓扑"></a>3.2星状拓扑</h5><ul><li>拓扑结构简单</li><li>具有较好的健壮性</li><li>便于管理</li><li>中央控制器是整个网络性能的瓶颈</li></ul><h5 id="3-3树状拓扑"><a href="#3-3树状拓扑" class="headerlink" title="3.3树状拓扑"></a>3.3树状拓扑</h5><ul><li>允许更多的设备相连并且增加了在设备间的传输距离</li><li>允许网络隔离不同计算机的通信</li></ul><h5 id="3-4总线型拓扑"><a href="#3-4总线型拓扑" class="headerlink" title="3.4总线型拓扑"></a>3.4总线型拓扑</h5><ul><li>信息传输不存在路由和转发的问题</li><li>易安装</li><li>故障隔离和重新配置困难</li><li>总线长度和连接的设备数会受到限制</li></ul><h5 id="3-5环形拓扑"><a href="#3-5环形拓扑" class="headerlink" title="3.5环形拓扑"></a>3.5环形拓扑</h5><ul><li>易安装和重新配置</li><li>故障隔离比较简单</li><li>对于最大长度和设备的数量有一定的限制</li><li>一个故障就会引起整个网络瘫痪</li></ul><h5 id="3-6混合型拓扑"><a href="#3-6混合型拓扑" class="headerlink" title="3.6混合型拓扑"></a>3.6混合型拓扑</h5><h4 id="4-网络分类"><a href="#4-网络分类" class="headerlink" title="4.网络分类"></a>4.网络分类</h4><h5 id="4-1按作用范围分类"><a href="#4-1按作用范围分类" class="headerlink" title="4.1按作用范围分类"></a>4.1按作用范围分类</h5><ul><li>局域网（一般为私有的）、城域网和广域网</li></ul><h5 id="4-2按通讯介质分类"><a href="#4-2按通讯介质分类" class="headerlink" title="4.2按通讯介质分类"></a>4.2按通讯介质分类</h5><ul><li>有线网（同轴电缆、双绞线和光纤）和无线网</li></ul><h5 id="4-3按通信传播方式分类"><a href="#4-3按通信传播方式分类" class="headerlink" title="4.3按通信传播方式分类"></a>4.3按通信传播方式分类</h5><ul><li>点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）</li></ul><h5 id="4-4按通信速率分类"><a href="#4-4按通信速率分类" class="headerlink" title="4.4按通信速率分类"></a>4.4按通信速率分类</h5><ul><li>低速网、中速网和高速网</li></ul><h5 id="4-5按使用范围分类"><a href="#4-5按使用范围分类" class="headerlink" title="4.5按使用范围分类"></a>4.5按使用范围分类</h5><ul><li>公用网和专用网</li></ul><h5 id="4-6按网络控制方式分类"><a href="#4-6按网络控制方式分类" class="headerlink" title="4.6按网络控制方式分类"></a>4.6按网络控制方式分类</h5><ul><li>集中式网络和分布式网络（无处理中心，每个结点地位平等）</li></ul><h5 id="4-7按网络环境分类"><a href="#4-7按网络环境分类" class="headerlink" title="4.7按网络环境分类"></a>4.7按网络环境分类</h5><ul><li>部门网、企业网和校园网</li></ul><h4 id="5-分层体系结构"><a href="#5-分层体系结构" class="headerlink" title="5. 分层体系结构"></a>5. 分层体系结构</h4><h5 id="5-1网络协议"><a href="#5-1网络协议" class="headerlink" title="5.1网络协议"></a>5.1网络协议</h5><ul><li>通信双方必须需遵守的规则、标准和约定</li></ul><h5 id="5-2语法"><a href="#5-2语法" class="headerlink" title="5.2语法"></a>5.2语法</h5><ul><li>数据与控制信息的结构或格式</li></ul><h5 id="5-3语义"><a href="#5-3语义" class="headerlink" title="5.3语义"></a>5.3语义</h5><ul><li>控制信息的功能和动作</li></ul><h5 id="5-4时序"><a href="#5-4时序" class="headerlink" title="5.4时序"></a>5.4时序</h5><ul><li>信息的同步，速度匹配</li></ul><h5 id="5-5体系结构"><a href="#5-5体系结构" class="headerlink" title="5.5体系结构"></a>5.5体系结构</h5><ul><li>计算机网络的各个层次及其相关协议的集合</li></ul><h4 id="6-OSI-ISO（七层）"><a href="#6-OSI-ISO（七层）" class="headerlink" title="6. OSI ISO（七层）"></a>6. OSI ISO（<strong>七层</strong>）</h4><h5 id="6-1-物理层（比特）"><a href="#6-1-物理层（比特）" class="headerlink" title="6.1 物理层（比特）"></a>6.1 物理层（比特）</h5><ul><li>设备：中继器、集线器</li></ul><h5 id="6-2-数据链路层（帧）"><a href="#6-2-数据链路层（帧）" class="headerlink" title="6.2 数据链路层（帧）"></a>6.2 数据链路层（帧）</h5><ul><li>可靠通信</li></ul><h5 id="6-3-网络层（分组或包）"><a href="#6-3-网络层（分组或包）" class="headerlink" title="6.3 网络层（分组或包）"></a>6.3 网络层（分组或包）</h5><ul><li>选择路由、交换结点、拥塞控制、网络互联</li></ul><h5 id="6-4-传输层（报文）"><a href="#6-4-传输层（报文）" class="headerlink" title="6.4 传输层（报文）"></a>6.4 传输层（报文）</h5><ul><li>实现了端到端的通信</li></ul><h5 id="6-5-会话层"><a href="#6-5-会话层" class="headerlink" title="6.5 会话层"></a>6.5 会话层</h5><ul><li>提供同步点机制</li></ul><h5 id="6-6-表示层"><a href="#6-6-表示层" class="headerlink" title="6.6 表示层"></a>6.6 表示层</h5><ul><li>解决用户信息的语法表示问题</li></ul><h5 id="6-7-应用层"><a href="#6-7-应用层" class="headerlink" title="6.7 应用层"></a>6.7 应用层</h5><ul><li>处理用户的数据和信息</li></ul><h4 id="7-TCP-IP"><a href="#7-TCP-IP" class="headerlink" title="7. TCP/IP"></a>7. TCP/IP</h4><p><font color="red">必须掌握TCP，UDP报文要熟记</font></p><h5 id="7-1-物理层和数据链路层"><a href="#7-1-物理层和数据链路层" class="headerlink" title="7.1 物理层和数据链路层"></a>7.1 物理层和数据链路层</h5><h5 id="7-2-网络层"><a href="#7-2-网络层" class="headerlink" title="7.2 网络层"></a>7.2 网络层</h5><ul><li>寻址、数据打包和路由选择</li><li>核心协议：IP协议</li><li>IP协议是无连接的，不保证传输的可靠性</li></ul><h5 id="7-3-传输层"><a href="#7-3-传输层" class="headerlink" title="7.3 传输层"></a>7.3 传输层</h5><ul><li>核心协议：传输控制协议TCP和用户数据报协议UDP（<font color="red">TCP，UDP报文要熟记</font>）</li><li>TCP是一个可靠的面向连接的传输层协议</li><li>UDP是一个不可靠的面向无连接的传输层协议，适用于延迟较小的场合</li></ul><h5 id="7-4-应用层"><a href="#7-4-应用层" class="headerlink" title="7.4 应用层"></a>7.4 应用层</h5><ul><li>各种协议</li></ul><h4 id="8-实体间通信与服务"><a href="#8-实体间通信与服务" class="headerlink" title="8. 实体间通信与服务"></a>8. 实体间通信与服务</h4><h5 id="8-1通信"><a href="#8-1通信" class="headerlink" title="8.1通信"></a>8.1通信</h5><h6 id="8-1-1-层间通信"><a href="#8-1-1-层间通信" class="headerlink" title="8.1.1 层间通信"></a>8.1.1 层间通信</h6><ul><li>同一个网络结点上相邻层次中实体之间的通信称为层间通信</li></ul><h6 id="8-1-2-对等层间通信"><a href="#8-1-2-对等层间通信" class="headerlink" title="8.1.2 对等层间通信"></a>8.1.2 对等层间通信</h6><ul><li>不同的网络结点上对等层实体间的通信称为对等层间通信</li></ul><h6 id="8-1-3-实通信"><a href="#8-1-3-实通信" class="headerlink" title="8.1.3 实通信"></a>8.1.3 实通信</h6><ul><li>层间通信以及物理层之间的通信叫做实通信</li></ul><h6 id="8-1-4虚通信"><a href="#8-1-4虚通信" class="headerlink" title="8.1.4虚通信"></a>8.1.4虚通信</h6><ul><li>除物理层外，对等层之间的通信叫做虚通信</li></ul><h5 id="8-2服务于数据单元"><a href="#8-2服务于数据单元" class="headerlink" title="8.2服务于数据单元"></a>8.2服务于数据单元</h5><h6 id="8-2-1服务访问点SAP（Service-Access-Point）"><a href="#8-2-1服务访问点SAP（Service-Access-Point）" class="headerlink" title="8.2.1服务访问点SAP（Service Access Point）"></a>8.2.1服务访问点SAP（Service Access Point）</h6><ul><li>层间接口处提供服务的地方</li></ul><h6 id="8-2-2服务数据单元SDU（Service-Data-Unit）"><a href="#8-2-2服务数据单元SDU（Service-Data-Unit）" class="headerlink" title="8.2.2服务数据单元SDU（Service Data Unit）"></a>8.2.2服务数据单元SDU（Service Data Unit）</h6><ul><li>相邻层在提供服务的过程中要传递的信息</li></ul><h6 id="8-2-3协议数据单元PDU（Protocol-Data-Unit）"><a href="#8-2-3协议数据单元PDU（Protocol-Data-Unit）" class="headerlink" title="8.2.3协议数据单元PDU（Protocol Data Unit）"></a>8.2.3协议数据单元PDU（Protocol Data Unit）</h6><ul><li>对等层间交换的信息单位</li></ul><h6 id="8-2-4协议控制信息PCI"><a href="#8-2-4协议控制信息PCI" class="headerlink" title="8.2.4协议控制信息PCI"></a>8.2.4协议控制信息PCI</h6><ul><li>N层的PDU = N层的SDU加上该层的PCI</li></ul><h5 id="8-3服务原语"><a href="#8-3服务原语" class="headerlink" title="8.3服务原语"></a>8.3服务原语</h5><h6 id="8-3-1请求原语"><a href="#8-3-1请求原语" class="headerlink" title="8.3.1请求原语"></a>8.3.1请求原语</h6><ul><li>由N+1层实体向N层实体发出，要求这个N层实体向它提供指定的N层服务，如进行一次数据传送</li></ul><h6 id="8-3-2指示原语"><a href="#8-3-2指示原语" class="headerlink" title="8.3.2指示原语"></a>8.3.2指示原语</h6><ul><li>由N层实体向N+1层实体发出，通知这个N+1层实体某个特定的N层服务已经开始</li></ul><h6 id="8-3-3响应原语"><a href="#8-3-3响应原语" class="headerlink" title="8.3.3响应原语"></a>8.3.3响应原语</h6><ul><li>由N+1层实体向N层实体发出，表示对这个N层实体送来的指示原语的响应</li></ul><h6 id="8-3-4证实原语"><a href="#8-3-4证实原语" class="headerlink" title="8.3.4证实原语"></a>8.3.4证实原语</h6><ul><li>由N层实体向N+1层实体发出，表示它请求的N层服务已经完成</li></ul><h6 id="8-3-5证实性服务"><a href="#8-3-5证实性服务" class="headerlink" title="8.3.5证实性服务"></a>8.3.5证实性服务</h6><ul><li><h6 id="8-3-6非证实性服务"><a href="#8-3-6非证实性服务" class="headerlink" title="8.3.6非证实性服务"></a>8.3.6非证实性服务</h6></li><li></li></ul><h6 id="8-3-7面向连接的服务"><a href="#8-3-7面向连接的服务" class="headerlink" title="8.3.7面向连接的服务"></a>8.3.7面向连接的服务</h6><ul><li>建立连接阶段</li><li>数据交换阶段</li><li>释放连接阶段</li></ul><h6 id="8-3-8面向无连接的服务"><a href="#8-3-8面向无连接的服务" class="headerlink" title="8.3.8面向无连接的服务"></a>8.3.8面向无连接的服务</h6><ul><li>数据报</li><li>证实交付，又称可靠地数据报</li><li>请求/响应</li></ul><h5 id="8-4性能指标"><a href="#8-4性能指标" class="headerlink" title="8.4性能指标"></a>8.4性能指标</h5><h6 id="8-4-1吞吐量"><a href="#8-4-1吞吐量" class="headerlink" title="8.4.1吞吐量"></a>8.4.1吞吐量</h6><ul><li>信道吞吐量是信道上单位时间成功发送的信息量，用bps（位每秒）表示</li></ul><h6 id="8-4-2信道利用率"><a href="#8-4-2信道利用率" class="headerlink" title="8.4.2信道利用率"></a>8.4.2信道利用率</h6><ul><li>是除去全部控制信息后的数据率与信道吞吐量之比。控制部分开销越大，利用率越低</li></ul><h6 id="8-4-3延迟时间"><a href="#8-4-3延迟时间" class="headerlink" title="8.4.3延迟时间"></a>8.4.3延迟时间</h6><h6 id="8-4-4排队时间"><a href="#8-4-4排队时间" class="headerlink" title="8.4.4排队时间"></a>8.4.4<strong>排队时间</strong></h6><h6 id="8-4-5访问延时"><a href="#8-4-5访问延时" class="headerlink" title="8.4.5访问延时"></a>8.4.5<strong>访问延时</strong></h6><h6 id="8-4-6发送时延"><a href="#8-4-6发送时延" class="headerlink" title="8.4.6发送时延"></a>8.4.6<strong>发送时延</strong></h6><ul><li>数据块长度（b）</li><li>信道带宽（s）</li></ul><h6 id="8-4-7传输延时"><a href="#8-4-7传输延时" class="headerlink" title="8.4.7传输延时"></a>8.4.7<strong>传输延时</strong></h6><ul><li>信道长度（m）</li><li>信号在信道上的传播速率（m/s）</li></ul><h4 id="9-考题类型"><a href="#9-考题类型" class="headerlink" title="9.考题类型"></a>9.考题类型</h4><h5 id="9-1计算机网络系统的主要通信性能指标有哪些？"><a href="#9-1计算机网络系统的主要通信性能指标有哪些？" class="headerlink" title="9.1计算机网络系统的主要通信性能指标有哪些？"></a>9.1计算机网络系统的主要通信性能指标有哪些？</h5><h5 id="9-2网络延迟的4个主要原因是什么？"><a href="#9-2网络延迟的4个主要原因是什么？" class="headerlink" title="9.2网络延迟的4个主要原因是什么？"></a>9.2网络延迟的4个主要原因是什么？</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
            <tag> 强化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表代码</title>
      <link href="/posts/d09f.html/"/>
      <url>/posts/d09f.html/</url>
      
        <content type="html"><![CDATA[<h2 id="链表相关代码"><a href="#链表相关代码" class="headerlink" title="链表相关代码"></a>链表相关代码</h2><blockquote><h4 id="1-单链表结点类型描述"><a href="#1-单链表结点类型描述" class="headerlink" title="1.单链表结点类型描述"></a>1.单链表结点类型描述</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LNode<span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//定义单链表结点类型</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//数据域</span>    <span class="token keyword">struct</span> LNode <span class="token operator">*</span>next<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//指针域，指向下一个结点的指针</span><span class="token punctuation">}</span>LNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkList<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//LNode是结构体的别名，用LNode即可代替typedef struct LNode</span>                          <span class="token comment" spellcheck="true">//LinkList是结构体指针的别名，用LinkList指针代替struct LNode *next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="2-链表创建（头插法）"><a href="#2-链表创建（头插法）" class="headerlink" title="2.链表创建（头插法）"></a>2.链表创建（头插法）</h4><p>每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$</p></blockquote><blockquote><ul><li><code>sizeof</code>函数计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示</li><li><code>malloc</code>函数用于在内存开辟了一段地址，而这段地址的首地址存在返回的那个指针变量里，由于不知道到底这段地址有多长，可以存什么变量，所以它的类型是空的，你可以强制类型转换，使其变成确定长度，固定存放一种数据类型的地址，而不管它是哪种类型，其首地址还是原来那个，还是存在一个指针变量中，指针变量就是放指针的嘛，指针是一个地址，指针变量是一个我们定义的，用来放那个地址的变量。</li></ul><p><strong>那么代码的意思就是说：</strong></p><ul><li>分配一个内存，大小是LNode的大小，并将这个内存地址转化为Linklist型，然后将赋给L，所以L为地址。是给L赋值，也就是L被改为指向malloc()新分配的地址</li></ul></blockquote><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">CreatList</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>s<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">//待插入的数据x</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建LNode型头结点，并强制转换成LinkList类型，头结点</span>                                            <span class="token comment" spellcheck="true">//L是一个指针的地址，所以要转化成指针类型</span>    L <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//初始为空链表</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//输入结点的值</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                         <span class="token comment" spellcheck="true">//输入9999表示结束</span>        <span class="token comment" spellcheck="true">//申请一个LNode大小的空间,得到的指针强制转换为指向Lnode类型的指针,然后赋值给s</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建新节点，这句话的作用是由系统生成一个LNode型链表</span>                                            <span class="token comment" spellcheck="true">//的结点，同时将该结点的起始位置赋给指针变量s</span>                                            <span class="token comment" spellcheck="true">//，s为LNode型的指针</span>        s <span class="token operator">-></span> data <span class="token operator">=</span> x<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//赋值</span>        s <span class="token operator">-></span>next <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">;</span>        L <span class="token operator">-></span> next <span class="token operator">=</span> s<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//将新结点插入表中，L为头指针，注意头插法的代码顺序</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">//继续输入值</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="3-链表创建（尾插法）"><a href="#3-链表创建（尾插法）" class="headerlink" title="3.链表创建（尾插法）"></a>3.链表创建（尾插法）</h4><p>每个结点插入的时间为$O(1)$，设单链表长度为n，则总时间复杂度为$O(n)$</p></blockquote><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">CreatList</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">//待插入数据</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">maclloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//创建头结点</span>    LNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token operator">*</span>r <span class="token operator">=</span> L<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//r为表尾指针</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//输入结点的值</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建新结点</span>        s <span class="token operator">-></span> data <span class="token operator">=</span> x<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//赋值</span>        r <span class="token operator">-></span> next <span class="token operator">=</span> s<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//尾插法，插入的结点在尾指针的后边</span>        r <span class="token operator">=</span> s<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//尾指针r再指向新插入尾部的结点s</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//继续输入值</span>    <span class="token punctuation">}</span>    r <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//尾结点指针置空</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="4-链表的排序（重点）不理解，要复习"><a href="#4-链表的排序（重点）不理解，要复习" class="headerlink" title="4.链表的排序（重点）不理解，要复习"></a>4.链表的排序（<strong>重点</strong>）不理解，要复习</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>    LNode <span class="token operator">*</span>r <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>    p <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        pre <span class="token operator">=</span> L<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-></span>next<span class="token operator">-></span>data <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">-></span> next <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>        pre <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="5-链表的插入"><a href="#5-链表的插入" class="headerlink" title="5.链表的插入"></a>5.链表的插入</h4></blockquote><ul><li><p>将元素x插入到第n个位置上，需要先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点（链表带头结点）</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">Insert</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//链表L引用型</span>    LNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span><span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//LNode型pre指针指向头结点L，p指针指向next</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">//开始计数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">//直到到达n，找到前驱pre</span>        p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        LNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//新建指针s指向结点</span>        s <span class="token operator">-></span> data <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//赋值为e</span>        s <span class="token operator">-></span> next <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//新插入的s的后继指向pre的后继</span>        pre <span class="token operator">-></span> next <span class="token operator">=</span> s<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//pre的后继指向s</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//完成插入</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将元素x插入到有序链表中，使其仍然有序（链表带头结点）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span><span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>                                     <span class="token comment" spellcheck="true">//判断p指针的数据和元素e的大小</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">&lt;</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//直到找到</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//当找到后，跳出循环</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    LNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//分配s指针的结点</span>    s <span class="token operator">-></span> data <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//插入数据</span>    s <span class="token operator">-></span> next <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>    pre <span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><h4 id="5-链表的删除"><a href="#5-链表的删除" class="headerlink" title="5.链表的删除"></a>5.链表的删除</h4></blockquote><ul><li><p>删除链表中值为x的结点</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Del</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//pre指针指向头结点</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//p指针指向头结点的next</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>                         <span class="token comment" spellcheck="true">//p不为空时</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//如果没有查询到</span>            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//两个指针依次往后移</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//直到p指针的值与x的相同</span>            pre <span class="token operator">-></span> next <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除节点</span>            <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//free多余的结点</span>            p <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除链表中最大值的结点（多加入两个确定最大值的指针即可）</p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Del</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>mpre <span class="token operator">=</span> pre<span class="token punctuation">,</span> <span class="token operator">*</span>mp <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//建立结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">></span> mp<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                           <span class="token comment" spellcheck="true">//比较数据的大小</span>            mpre <span class="token operator">=</span> pre<span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">//如果大于，最大值指向p</span>            mp <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">//一次往后查找</span>        p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mpre <span class="token operator">-></span> next <span class="token operator">=</span> mp <span class="token operator">-></span> next<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//删除节点</span>    <span class="token function">free</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除<strong>有序</strong>链表中重复值节点</p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Del</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-></span>next<span class="token operator">-></span>data <span class="token operator">==</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre <span class="token operator">-></span> next <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> pre <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><h4 id="6-链表的逆置"><a href="#6-链表的逆置" class="headerlink" title="6. 链表的逆置"></a>6. 链表的逆置</h4></blockquote><ul><li><p>将链表L的所有结点逆置（采用头插法）</p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Inversion</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    L <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        p <span class="token operator">-></span> next <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">;</span>        L <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><h4 id="7-链表的合并"><a href="#7-链表的合并" class="headerlink" title="7. 链表的合并"></a>7. 链表的合并</h4></blockquote><ul><li><p>将两个有序链表合并为一个有序链表</p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Merge</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L1<span class="token punctuation">,</span> LinkList <span class="token operator">&amp;</span>L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L1 <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> L2 <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r <span class="token operator">=</span> L1<span class="token punctuation">;</span>    L1 <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">&lt;</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            r <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            r <span class="token operator">-></span> next <span class="token operator">=</span> q<span class="token punctuation">;</span>            r <span class="token operator">=</span> q<span class="token punctuation">;</span>            q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将两个有序链表合并为一个有序链表（取交集）</p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Merge</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L1<span class="token punctuation">,</span> LinkList <span class="token operator">&amp;</span>L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L1 <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> L2 <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r <span class="token operator">=</span> L1<span class="token punctuation">;</span>    L1 <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">&lt;</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">></span> q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            r <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>            q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将两个有序链表合并为一个有序链表（并集）</p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Merge</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L1<span class="token punctuation">,</span> LinkList <span class="token operator">&amp;</span>L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L1 <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> L2 <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r <span class="token operator">=</span> L1<span class="token punctuation">;</span>    L1 <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">&lt;</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            r <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">></span> q<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            r <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>            r <span class="token operator">=</span> q<span class="token punctuation">;</span>            q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            r <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>            q <span class="token operator">=</span> q <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">-></span> next <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> L1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><h4 id="8-链表拆分问题"><a href="#8-链表拆分问题" class="headerlink" title="8. 链表拆分问题"></a>8. 链表拆分问题</h4></blockquote><ul><li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得<code>A={a1,a2,...,an},B={bn,...,b2,b1}</code></p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Merge</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    LinkList A <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>s <span class="token operator">=</span> A<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//尾插需要个尾指针，指向头指针</span>    LinkList B <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建B表表头</span>    B <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//B表的初始化</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//基数位时</span>            s <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//尾插法，正序</span>            s <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> r<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                   <span class="token comment" spellcheck="true">//偶数时</span>            p <span class="token operator">-></span> next <span class="token operator">=</span> B <span class="token operator">-></span> next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//头插法，因为要倒序</span>            B <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                  p <span class="token operator">=</span> r<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    s <span class="token operator">-></span> next <span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> A<span class="token punctuation">,</span>B<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，计一个就地算法，讲其拆分为两个线性表，使得<code>A={a1,a2,...,an},B={b1,...,bn-1,bn}</code></p><ul><li>与上一题相比，只有链表B变为尾插（保证正序即可）</li></ul><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Merge</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    LinkList A <span class="token operator">=</span> L<span class="token punctuation">;</span> <span class="token operator">*</span>s <span class="token operator">=</span> A<span class="token punctuation">;</span>    LinkList B <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>s1 <span class="token operator">=</span> b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建B表表头,并指向头指针</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//基数位时</span>            s <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//尾插法，正序</span>            s <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> r<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                   <span class="token comment" spellcheck="true">//偶数时</span>            s1 <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//尾插法，正序</span>            s <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> r<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    s <span class="token operator">-></span> next <span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    s1 <span class="token operator">-></span> next <span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> A<span class="token punctuation">,</span>B<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>设<code>C = {a1,b1,a2,b2,...,an,bn}</code>为线性表，采用带头结点的hc单链表存放，设计一个就地算法，讲其拆分为两个线性表，使得<code>A={an,an-1,...,a1},B={bn,...,b2,b1}</code></p><pre class="line-numbers language-c"><code class="language-c">LinkList <span class="token function">Merge</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    LNode <span class="token operator">*</span>p <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    LinkList A <span class="token operator">=</span> L<span class="token punctuation">;</span>     LinkList B <span class="token operator">=</span> <span class="token punctuation">(</span>LNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建B表表头</span>    A <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    A <span class="token operator">-></span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">=</span> p <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//基数位时</span>            p <span class="token operator">-></span> next <span class="token operator">=</span> A <span class="token operator">-></span> next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//头插法，因为要倒序</span>            A <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                  p <span class="token operator">=</span> r<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                   <span class="token comment" spellcheck="true">//偶数时</span>            p <span class="token operator">-></span> next <span class="token operator">=</span> B <span class="token operator">-></span> next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//头插法，因为要倒序</span>            B <span class="token operator">-></span> next <span class="token operator">=</span> p<span class="token punctuation">;</span>                                  p <span class="token operator">=</span> r<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> A<span class="token punctuation">,</span>B<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><h4 id="9-判断两个链表是否有相同结点（找出相同结点）"><a href="#9-判断两个链表是否有相同结点（找出相同结点）" class="headerlink" title="9. 判断两个链表是否有相同结点（找出相同结点）"></a>9. 判断两个链表是否有相同结点（找出相同结点）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//计算链表长度</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        num<span class="token operator">++</span><span class="token punctuation">;</span>        L <span class="token operator">=</span> L <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">Judeg</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L1<span class="token punctuation">,</span> LinkList <span class="token operator">&amp;</span>L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">Length</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">Length</span><span class="token punctuation">(</span>L2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len1 <span class="token operator">></span> len2<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//让两个链表拥有相同的尾部长度</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> len1 <span class="token operator">-</span> len2<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            L1 <span class="token operator">=</span> L1 <span class="token operator">-></span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> len2 <span class="token operator">-</span> len1<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            L2 <span class="token operator">=</span> L2 <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L1 <span class="token operator">==</span> L2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        L1 <span class="token operator">=</span> L1 <span class="token operator">-></span> next<span class="token punctuation">;</span>        L2 <span class="token operator">=</span> L2 <span class="token operator">-></span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="10-栈的基本操作"><a href="#10-栈的基本操作" class="headerlink" title="10. 栈的基本操作"></a>10. 栈的基本操作</h4></blockquote><ul><li><p>栈的顺序存储类型描述</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> Maxsize 50       </span><span class="token comment" spellcheck="true">//定义栈中元素的最大个数</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//存放栈中元素</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//栈顶指针</span><span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>Sqstack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//初始化栈顶指针</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>判断栈空</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>进栈</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> MaxSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    S<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token operator">++</span>S<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//指针先加1，再入栈</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>出栈</p><pre class="line-numbers language-c"><code class="language-c">bool Pop（SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    x <span class="token operator">=</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>S<span class="token punctuation">.</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>读栈顶元素</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> MaxSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    x <span class="token operator">=</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>S<span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第八章-TCP/IP协议</title>
      <link href="/posts/156a.html/"/>
      <url>/posts/156a.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章-TCP-IP协议"><a href="#第八章-TCP-IP协议" class="headerlink" title="第八章 TCP/IP协议"></a>第八章 TCP/IP协议</h2><ol><li><p>TCP/IP体系结构</p><ul><li>TCP/IP协议的网络层的主要功能是寻址、数据打包和路由选择</li><li>主要协议有：地址解析协议（ARP）、反向地址解析协议（RARP）、网际协议（IP）、Internet控制消息协议（ICMP）和Internet组管理协议（IGMP）</li><li>ARP负责将IP地址解析为结点的物理地址，以便于物理设备（如网卡）按该地址接收数据</li><li>RARP负责将物理地址解析成IP地址，这个协议主要是针对无盘工作站获得IP地址而设计的</li><li>ICMP用于传送差错报文及其他控制信息</li></ul></li><li><p>网际协议IP</p><ul><li>IP协议是TCP/IP协议族中的核心协议。所有的TCP、UDP、ICMP、IGMP数据都是以IP数据报格式传输的</li><li>IP协议为高层提供不可靠、无连接的数据报通信。尽最大努力交付</li></ul></li><li><p>IP地址：网络中的每个独立主机的每个接口必须有一个唯一的Internet地址，也称为<strong>IP地址</strong>。IP地址长度为<strong>32位</strong>。表示地址空间是$2^{32}$</p></li><li><p>IP地址的表示方法</p><ul><li>二进制表示方法</li><li>点分十进制表示方法：为了使32位地址更加简介和更容易阅读，因特网的地址通常写成用小数点把各字节分隔开的形式。每个字节用一个十进制数表示，这个数小于256</li><li>十六进制表示方法</li><li>二进制表示方法：在二进制表示方法中，用一个32位的比特序列表示IP地址，为了使这个地址有更好的可读性，通常在每个字节之间加上一个或多个空格做分割。例如：<code>10000001 00001110 00000110 00011111</code>，但不便于记忆</li></ul></li><li><p>分类IP地址：IP地址按照层次结构划分成五类：A、B、C、D、E类。每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志一个主机地址。</p><p><img src="ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="ip地址分类"></p></li><li><p>各类IP地址的范围</p><p><img src="IP%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4.png" alt="IP地址范围"></p><p><strong>助记：</strong><code>0～A(128)～B(28+64)～C(128+64+32)～D(128+64+32+16)~E(128+64+32+16+8)</code></p></li><li><p>IPv4报文格式</p><p><img src="IP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="IP报文格式"></p><ul><li><p>总长度：占16位，指首部和数据之和的长度，单位为字节。因此数据报的最大长度为65535字节。总长度必须不超过最大传送单元MTU</p></li><li><p>标识（identification）：占16位，它是一个计数器，用来产生数据报的标识</p></li><li><p>标志（flag）：占3位，目前只有前两位有意义。</p><ul><li>标识字段的<strong>MF（More Fragment）</strong>。**MF=1表示后面”还有分片”**，MF=0表示最后一个分片</li><li>标识字段的<strong>DF（Don’t Fragment）</strong>。<strong>DF=0时表示允许分片</strong></li></ul></li><li><p>片偏移13位（偏移量）：较长的分组在分片后某片在原分组中的相对位置。<strong>片偏移以8个字节为偏移单位</strong></p><ul><li>例：以太网的MTU（最大传输单位）为1400字节，路由器将把到达的一个4000字节数据的报文为3段，第一段有1400字节数据，分段偏移为0；第二段有1400字节数据，分段偏移位1400÷8=175；第三段有1200字节数据，分段偏移位350</li></ul></li></ul></li><li><p><strong>子网掩码（待补充）</strong>：IP地址 + 子网掩码 = 网络地址</p></li><li><p>特殊的IP地址</p><ul><li><p>网络地址（NET-ID）：主机标识部分为全”0”的IP地址不分配给任何主机，而是作为网络本身的标识</p><ul><li>例：主机 202.198.151.136所在网段的网络地址为：202.198.151.0（主机位变为0）；主机130.100.100.136（B类地址）所在网段的网络地址为：130.100.0.0</li></ul></li><li><p>直接广播地址：主机标识全为”1”的IP地址不分配给任何主机，用做广播地址</p><ul><li>例：主机 202.198.151.136所在网段的直接广播地址为：202.198.151.255（主机位变为1）；主机130.100.100.136（B类地址）所在网段的直接广播地址为：130.100.255.25</li></ul></li><li><p>有限广播地址：32位为全为1的IP地址称为有限广播地址</p><ul><li>例：有限广播地址为：255.255.255.255</li></ul></li><li><p>主机本身地址：32位为全0的IP地址称为主机本身地址</p><ul><li>例：主机本身地址：0.0.0.0</li></ul></li></ul></li><li><p>划分子网：从1985年起在IP地址中又增加了一个”子网号字段”，使两级的IP地址变成为三级的IP地址。这种做法叫做划分子网（SubNetting）。划分子网已成为因特网的正式标准协议</p><ul><li><p>目前所有的主机都要求支持子网编址。子网编址不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号进一步划分为一个子网号和一个主机号</p><p><img src="B%E7%B1%BB%E5%AD%90%E7%BD%91%E7%BC%96%E7%A0%81.png" alt="B类子网编码"></p></li><li><p>当没有划分子网时，IP地址是两级结构。划分子网后，IP地址就变成了三级结构</p></li><li><p>划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id</p></li></ul></li><li><p><strong>子网掩码（有待补充）</strong>：从一个IP地址中无法解析源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码（Subnet Mask）可以找出IP地址中的子网部分</p></li><li><p>ARP地址解析协议：就是将主机IP地址映射为硬件地址。在局域网中，网络中实际传输的单元是”数据帧”，数据帧的首部有目的主机的MAC地址。在以太网中，一个主机要和另一个主机进行直接通信，必须通过地址解析协议获得目的主机的MAC地址。<strong>ARP协议的基本功能就是通过目的设备的IP地址，查询目标设备的MAC地址（物理地址）</strong></p></li><li><p>Internet控制报文协议ICMP[网络层]：IP协议是一种不可可靠无连接的包传输。当数据包经过多个网络传输过程中，可能出现错误、目的主机不响应、包拥塞和包丢失等。为了处理这些问题，在IP层引入了一个子协议：ICMP（Internet Control Message Protocol）</p></li><li><p>Internet组管理协议IGMP：IP地址有三种类型，分别是单播地址、广播地址和多播地址。广播和多播地址仅应用于UDP协议，它们主要应用在报文同时传送到多个接收者的情况</p><ul><li>多播使用多播地址（D类IP地址）</li><li>当把多播通信扩展到单个网络段以外需要通过路由器转发多播数据时，复杂性就增加了。需要一个协议让多播路由器了解确定网络中属于多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP）</li></ul></li><li><p>用户数据报协议（UDP）：UDP采用非连接的方式提供应用层的事务处理，UDP不提供可靠性，也就是说，UDP协议不提供端到端的确认和重传功能，他不保证数据包一定能达到目的地，因此称为不可靠协议。UDP必须在IP上运行。他的下层协议是以IP作为前提的</p></li><li><p>传输控制协议TCP：TCP提供了一种可靠的面向连接的字节流传输层服务，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检查和。尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。</p><ul><li>TCP连接的建立和释放：建立一个TCP连接需要三次握手，而释放一个TCP连接需要经过4次握手</li><li>TCP连接的建立采用客户/服务器方式</li><li>主动发起连接建立的应用进程叫做客户（client）</li><li>被动等待连接的应用进程叫做服务器（server）</li></ul><blockquote><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手:"></a>三次握手:</h4><p>TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。</p></blockquote><img src="三次挥手.gif" alt="三次挥手" style="zoom: 67%;"><blockquote><p>​    张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。张三看到李四微笑后确认了李四成功辨认出了自己(进入estalished状态)。</p><p>​    但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入established状态)。</p><p>​    于是两人加快步伐，走到了一起，相互拥抱。</p></blockquote><img src="三次握手建立过程.gif" alt="三次握手建立过程" style="zoom: 50%;"><blockquote><p>​    我们看到这个过程中一共是四个动作，张三招手–李四点头微笑–李四招手–张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。于是四个动作就简化成了三个动作，张三招手–李四点头微笑并招手–张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。</p><p>​    我们看到有两个中间状态，syn_sent和syn_rcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。syn_sent是主动打开方的「半打开」状态，syn_rcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。</p></blockquote><blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手:"></a>四次挥手:</h4><p>​    TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。</p></blockquote><img src="四次挥手.gif" alt="四次挥手" style="zoom:67%;"><blockquote><p>​    之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。</p></blockquote><img src="四次挥手过程.gif" alt="四次挥手过程"><blockquote><p>上面有一个非常特殊的状态<code>time_wait</code>，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。</p><p>它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的<code>time_wait</code>状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。</p><p>它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。</p><p>同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。</p><p>4分钟就是2个MSL，每个MSL是2分钟。MSL就是<code>maximium segment lifetime</code>——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。</p><p>四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从<code>fin_wait_1</code>状态直接进入到<code>time_wait</code>状态，跳过了<code>fin_wait_2</code>状态。</p></blockquote></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表代码</title>
      <link href="/posts/f4b7.html/"/>
      <url>/posts/f4b7.html/</url>
      
        <content type="html"><![CDATA[<h2 id="线性表代码"><a href="#线性表代码" class="headerlink" title="线性表代码"></a>线性表代码</h2><blockquote><h4 id="1-顺序表创建"><a href="#1-顺序表创建" class="headerlink" title="1.顺序表创建"></a>1.顺序表创建</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MaxSize 50</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//定义线性表的最大长度</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//顺序表的元素</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//顺序表的当前长度</span><span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//顺序表类型定义</span>SqList L<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//自行比较整型浮点型等简单数据类型的定义方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="2-顺序表排序（冒泡排序）"><a href="#2-顺序表排序（冒泡排序）" class="headerlink" title="2.顺序表排序（冒泡排序）"></a>2.顺序表排序（冒泡排序）</h4></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//因为顺序表L将要改变，所以使用引用型。</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//i指针指向表头，从0开始，直到顺序表长度减一</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span> j<span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//j指针指向表尾，从长度减一开始，直到i指针</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//如果前一位比后一位大</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//就把前一位存入临时变量temp中</span>                L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//把j指针的数据赋值给j-1</span>                L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//再把临时变量中的数据存入j指针中</span>                                            <span class="token comment" spellcheck="true">//最终完成从小到大的排序过程</span>            <span class="token punctuation">}</span>                               <span class="token comment" spellcheck="true">//交换数据的三行代码不要省略</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="3-顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置"><a href="#3-顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置" class="headerlink" title="3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置"></a>3.顺序表插入问题（注意插入）：讲元素e插入到顺序表的第i个位置</h4></blockquote><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//因为顺序表L将要改变，所以使用引用型。又定义指针i和元素e</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">||</span> i <span class="token operator">></span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//验证插入的合法性，只能插入数列的有效位</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">>=</span> MaxSize<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">//验证顺序表长度是否超过最大限制</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//从最后一位，一次往后移一位，直到要插入的位置</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//把元素e插入第i个位置</span>    L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//最终顺序表长度加1</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="4-将元素e插入到递增的顺序表中，并让其仍然有序"><a href="#4-将元素e插入到递增的顺序表中，并让其仍然有序" class="headerlink" title="4.将元素e插入到递增的顺序表中，并让其仍然有序"></a>4.将元素e插入到递增的顺序表中，并让其仍然有序</h4></blockquote><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">ListInster</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//顺序表L会改变，所以用引用型。定义整型变量元素e</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//初始化指针i，指向顺序表头部</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> e <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//从头开始判断顺序表元素与元素e的大小关系，如果指针没有超过</span>                                           <span class="token comment" spellcheck="true">//顺序表长度并且指针所指元素小于元素e</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//那么指针i向后移一位</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//定义指针j指向顺序表元素+1的位置，直到i指针的位置停止</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//依次向后移动</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//元素e插入到指针i的位置</span>    L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//顺序表长度加一</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h4 id="5-顺序表删除"><a href="#5-顺序表删除" class="headerlink" title="5.顺序表删除"></a>5.顺序表删除</h4></blockquote><ul><li><p>删除顺序表L中第<code>i(1≤i≤L.length)</code>个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。（这是删除某一位置的元素）</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//顺序表L会发生改变，所以使用引用型</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//判断i位置是否合法</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    e <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//把要删除的元素赋值给变量e</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//依次补齐空缺，后一位往前移一位</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//顺序表长度减一</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除顺序表L中值为X的元素（这是删除某一值的方式）</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> X<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//记录有多少个值为X的元素（有可能有相同的元素）</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//从头到尾一次匹配看是否存在元素X</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//有的话计数器就加一</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//没有的话就将后一位依次向前移动，直到再次匹配到或退出</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//更新顺序表长度</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除顺序表L中所有素数</p><pre class="line-numbers language-c"><code class="language-c">bool <span class="token function">Prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">//求素数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//计数器</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//从头到尾依次查找</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Prime</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//如果是素数，计数器加一        </span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果没有，则补齐空缺位置</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//更新顺序表长度</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除顺序表L中最大值（最小值，此处注意与删除奇偶数的区别）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//记录最大值所在位置</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//从头开始扫描，把最大的值存入max中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>max <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//如果max中的值小于后面的元素</span>            pos <span class="token operator">=</span> i<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//存储最大值的位置</span>            max <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//就把比max大的那个值赋予给max</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">fot</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//依次把最大值的后一位往前移动，补全空缺</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                        L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//长度减一</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除<strong>顺序表</strong>L中重复的值（<strong>表已经有序</strong>）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//计数器count</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//从第一个数开始比较是否有相同的值</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//从头到尾依次扫描</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//如果之后有值与num相等</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//计数器加一</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            num <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//否则，更新num的值</span>            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//并更新顺序表</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    L<span class="token punctuation">.</span>length <span class="token operator">=</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>逆置：将顺序表L中的所有元素逆置过来</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Inversion</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//分别两个指针指向首尾</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//把第一个元素赋值给临时变量temp</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//把high的值赋予low</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//在把temp中的值赋予给high</span>        low<span class="token operator">++</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//完成一次交换，然后依次交换           </span>        high<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>平台：找出顺序表中最大的平台值（<strong>什么是平台值？</strong>）</p><hr></li><li><p>顺序表合并：将两个升序顺序表合并为一个升序的顺序表</p><blockquote><p>i++   先执行i=0 再进行i=i+1,也就是i会是0,执行完了再变为1<br>++i   先执行i=i+1,i会是1</p></blockquote><pre class="line-numbers language-c"><code class="language-c">SqList <span class="token function">Merge</span><span class="token punctuation">(</span>Sqlist L1<span class="token punctuation">,</span> Sqlist L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    Sqlist L3<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//L1和L2长度要大于0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果L1的一位比L2的一位小</span>            L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//就把L1的一位放入L3中，并且i和k自增1</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                              <span class="token comment" spellcheck="true">//如果L1的一位比L2的一位大</span>            L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//就把L2的一位放入L3中，并且j和k自增1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">//当其中一个被放完时，再单独对另一个顺序表操作即可</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    L3<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>    <span class="token keyword">return</span> L3<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将两个升序顺序表合并为一个升序的顺序表<strong>（只求∩交集）</strong></p><pre class="line-numbers language-c"><code class="language-c">SqList <span class="token function">Merge</span><span class="token punctuation">(</span>Sqlist L1<span class="token punctuation">,</span> Sqlist L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    Sqlist L3<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//L1和L2长度要大于0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果L1的一位比L2的一位小</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//i++</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果L1的一位比L2的一位大</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//j++</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果L1的一位和L2的一位相等，则放入L3中</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//j++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>                                           L3<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>    <span class="token keyword">return</span> L3<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将两个升序顺序表合并为一个升序的顺序表<strong>（∪并集，没有重复元素）</strong></p><pre class="line-numbers language-c"><code class="language-c">SqList <span class="token function">Merge</span><span class="token punctuation">(</span>Sqlist L1<span class="token punctuation">,</span> Sqlist L2<span class="token punctuation">)</span><span class="token punctuation">{</span>    Sqlist L3<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//L1和L2长度要大于0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//如果L1的一位比L2的一位小</span>            L3<span class="token punctuation">.</span>length<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把L1放入L3，并且i和k自增</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果L1的一位比L2的一位大</span>            L3<span class="token punctuation">.</span>length<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把L2放入L3，并且j和k自增</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//如果L1的一位和L2的一位相等，则把L1放入L3中</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//j++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>                                         <span class="token comment" spellcheck="true">//当其中一个被放完时，再单独对另一个顺序表操作即可</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        L3<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> L2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    L3<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>    <span class="token keyword">return</span> L3<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第七章-局域网和广域网技术</title>
      <link href="/posts/93d0.html/"/>
      <url>/posts/93d0.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章-局域网和广域网技术"><a href="#第七章-局域网和广域网技术" class="headerlink" title="第七章 局域网和广域网技术"></a>第七章 局域网和广域网技术</h2><ol><li><p>IEEE802.2：它是LLC协议标准，分为两个功能子集，<strong>数据链路控制（LLC）子层</strong>和<strong>媒体访问控制（MAC）子层</strong></p></li><li><p>逻辑链路控制（LLC）子层是IEEE802数据链路层的上子层，它对于所有的LAN协议来说都是相同的</p></li><li><p>MAC子层解决共享介质的竞争使用问题。它包含了将数据从一个地方传送到另一个地方所必须的同步、标记、流量和差错控制的规范，同时也包括下一个站点的物理地址。不同的局域网具有不同的MAC协议</p></li><li><p>IEEE802各个标准和OSI模型的层次对应关系</p></li></ol><p><img src="img.png" alt="对应关系"></p><ol start="5"><li>逻辑链路控制（LLC）子层</li></ol><p><img src="img2.png" alt="对应关系"></p><ul><li>LLC-PDU与HDLC类似，包含四个域：目的服务访问点（DSAP）、源服务访问点（SSAP）、控制域和信息域</li><li>DASP和SSAP是LLC所使用的地址，SAP叫服务访问点。用来标明接收和发送数据的计算机上的协议栈</li></ul><ol start="6"><li><p>LLC地址与MAC地址</p><ul><li>在MAC帧的帧首中，有目的站地址和源站地址，它们是6字节长。MAC帧中的地址是站点的物理地址</li><li>在LLC帧的帧首中，用DSAP和SSAP，该地址是逻辑地址，是数据链路层的不同服务访问点</li></ul></li><li><p>以太网</p><ul><li>IEEE 讲基带划分为5个不同的标准：10Base5、10base-T和100base-T等</li><li>开头数字指明了数据传输速率：最后的数字或字母（5,2，T（双绞线））指明了最大电缆长度或电缆类别；base指明的是基带传输</li><li>IEEE只定义了一个宽带类标准：10Broad36，用于小区网络连接</li><li>IEEE 802.3定义了两类标准：基带和宽带</li><li>基带类使用数字信号传输数据，用以太网使用曼彻斯特编码</li><li>宽带类使用模拟信号传输数据</li></ul></li><li><p>以太网访问模式</p><ul><li><p>在LAN中，多个用户在没有任何控制的情况下同时访问一条线路时，会存在由于不同信号叠加而相互破坏的情况。这就是<strong>冲突</strong>。为了使冲突发生的可能性最小，需要有一种机制来协调通信</p></li><li><p>以太网的媒体访问控制机制称为<strong>带有冲突检测</strong>的载波帧听多路访问（<strong>CSMA/CD</strong>）</p></li><li><p><strong>多路访问（MA）</strong>：不提供通信管制（<strong>不听就说</strong>）</p></li><li><p><strong>载波监听多路访问（CSMA）</strong>：首先监听链路上是否已经存在通信。由于存在传输延迟，还是会出现冲突<strong>（先听后说）</strong></p></li><li><p><strong>带有冲突检测的载波监听多路访问（CSMA/CD）</strong>：发送是同CSMA一样，在传输的时候继续监听链路是否发生冲突（<strong>边听边说</strong>）</p><ul><li>如果链路是空闲的，则可以发送并同时检测冲突</li><li>如果链路的忙的，则继续监听，直到检测到链路空闲</li><li>如果在发送过程中检测到冲突，则停止当前帧的发送，发阻塞信号，等待一段选定的时间（退避间隔）</li><li><strong>先听后发，也听也发，冲突停发，随机重发</strong></li></ul></li></ul></li><li><p>CSMA可分为三种</p><ul><li>非坚持CSMA：如果链路是空闲的，则可以发送。如果链路是忙的，则等待一段时间。等待时间的长短在一个时间范围内随机选择</li><li>坚持CSMA（1-坚持）：如果链路是空闲的，则可以发送。如果链路是忙的，则继续帧听，直到检测到链路空闲，立即发送</li><li>P-坚持CSMA：如果链路是空闲的，则以P的概率发送，而以（1-P）的概率延迟一个单位时间。如果链路是忙的，继续监听直至链路空闲。（例如，当有N个站点时，试图传输的站点的期望值为NP，为避免冲突应使<strong>NP&lt;1</strong>）</li></ul></li><li><p>退避算法（二进制指数退避）</p><ul><li>对每一个帧，当第一次发生冲突时，设置参数<code>L=2</code>；</li><li>退避间隔取1到L个时间片中的一个随机数。一个时间片等于链路上最大传输延迟的两倍</li><li>当帧重复发生一次冲突时，则将参数L加倍。L的最大值为1024.即当L增加到1024时，L不再增加</li><li>帧的最大重传次数为16，超过这个次数，则该帧不再重传，并报告出错</li></ul></li><li><p>最短帧长公式：$L_{min} =2×S÷V×R$ </p><ul><li>$L_{min}$：最短数据帧长（$bit$）</li><li>$S$：任意两站点间的最大距离（$m$）</li><li>$R$：数据传输速率（$Mbps$）</li><li>$V$：电子传播速度（$200m/us$）</li></ul></li><li><p>以太网$MAC$帧格式</p><table><thead><tr><th align="center">前导码</th><th align="center">SFD</th><th align="center">目标地址</th><th align="center">源地址</th><th align="center">LLC-PDU长度/类型</th><th align="center">LLC-PDU</th><th align="center">CRC</th></tr></thead><tbody><tr><td align="center">7字节</td><td align="center">1字节</td><td align="center">6字节</td><td align="center">6字节</td><td align="center">2字节</td><td align="center">46-1500字节</td><td align="center">4字节</td></tr></tbody></table><ul><li>前导码：包含7个字节，在这个域中，1和0交替出现，警告系统接收即将到来的数据帧，同时使系统能够调整同步输入时钟</li><li>帧起始分界符（SFD）：帧起始分界符标记了<strong>帧的开始</strong>。它只有一个字节，模式是<code>10101011</code>，SFD通知接收方后面所有内容都是数据</li><li>目的地址（DA）：DA域为6个字节，标记了数据帧下一个结点的物理地址</li><li>源地址（SA）：SA域也分配了6个字节。它包含了最后一个转发此帧的设备的物理地址。也是上个结点的物理地址</li><li>LLC-PDU的长度/类型：该字节指出了LLC-PDU的字节数，即LLC-PDU域中的有效字节数</li><li>LLC-PDU：以太网MAC帧讲802.2的整个帧作为透明数据包含了进来。该域的长度可以从46到1500字节不等</li><li>CRC：MAC帧的最后一个域是差错检测，占32位，用CRC</li></ul></li><li><p>以太网种类</p><ul><li>10base5粗缆以太网（总线）</li><li>10base2细缆以太网（总线）</li><li>10base-T双绞线以太网（星型）</li><li>100base-T快速以太网（星型）</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第六章-传输层</title>
      <link href="/posts/2140.html/"/>
      <url>/posts/2140.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-传输层"><a href="#第六章-传输层" class="headerlink" title="第六章 传输层"></a>第六章 传输层</h2><ol><li>在OSI参考模型中，传输层位于通信子网和资源子网之间，是整个协议层次中最核心的一层</li><li>传输层的作用：在优化网络服务的基础上，为源主机上的进程和目的主机上的进程之间<strong>提供可靠地透明数据传送</strong>，使高层用户在相互通信时不必关心通信子网实现的细节</li><li>拥塞控制<ul><li>Cwnd — 拥塞窗口（发送端窗口的大小，不和Rwnd一致）</li><li>Rwnd — 接收端窗口</li><li>SMSS — 发送端最大数据段尺寸（单个数据段的大小上限，不包括TCP/IP报文的头）</li><li>Ssthresh — 慢启动阀值（调整拥塞窗口增长）</li></ul></li><li>慢启动</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第五章-网络层</title>
      <link href="/posts/8cfd.html/"/>
      <url>/posts/8cfd.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-网络层"><a href="#第五章-网络层" class="headerlink" title="第五章 网络层"></a>第五章 网络层</h2><ol><li><p>网络层的主要功能：交换和路由</p></li><li><p>距离向量路由算法：在距离向量路由中，每个路由器周期性的将自己关于整个网络的信息发送给他的邻居</p><ul><li>每个路由都保存关于整个网络的信息</li><li>仅仅和邻居交换网络信息</li><li>信息的交换是通过有规律的时间间隔来进行的</li></ul></li><li><p>链路状态路由算法：链路状态路由中，每个路由器和互联网络中的所有其他路由器共享关于其邻居的信息</p><ul><li>共享关于邻居的信息</li><li>共享的信息发送给所有的路由器</li><li>信息的共享在有规律的时间间隔内进行</li></ul></li><li><p>链路状态数据库</p><ul><li><p>$Dijkstra$<strong>算法</strong>：从路由器到网络的链路的费用才有效，而从网络到路由器的链路的费用总是0</p><ul><li><p>每个路由器在使用$Dijkstra$算法时，根据下面四个步骤来形成自己的最短路径树（最小支撑树）</p><p>①选择自己作为根的结点，并将根标记为永久性结点。算法接着从根出发连接其所有邻居结点。这种结点是临时性的</p><p>②算法比较所有的临时连接，找出费用最小的路径，该路径上的所有弧和结点被标记为最短路径树上的永久部分</p><p>③算法考察链路状态数据库，找出从这个选定的最短路径向外延伸所能连接的所有非永久性结点，将这些结点临时性地加到最短路径树上</p><p>④如果所有的结点已经成为最短路径树上的永久部分，则算法结束，去掉非永久性的弧。否则，转步骤②继续执行。</p></li></ul></li><li><p>$Dijkstra$算法总结</p><p>①初始化：设$N$表示网络结点集合，先令$N={1}$，对所有不在$N$中的结点写出：</p><p>$$<br>S(V)= \begin{cases} L(1,V) &amp; \text {;若结点V与结点1相邻}  \ \infty &amp; \text {;若结点V与结点1不相邻} \end{cases}<br>$$</p><p>②找出一个不在$N$中的结点W，使$S(W)$值为最小，把$W$加入$N$中，然后对所有不在$N$中的结点按下式更新：<br>$$<br>S(V) \leftarrow min[S(V),S(W)+L(W,V)]<br>$$</p><p>③重复步骤②，直到所有的网络结点都在$N$中为止</p></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8月份学习计划</title>
      <link href="/posts/b074.html/"/>
      <url>/posts/b074.html/</url>
      
        <content type="html"><![CDATA[<center> <h2>8月份学习计划</h2><h2></h2></center><table><thead><tr><th><center>8月份</center></th><th><center>数学</center></th><th><center>专业课</center></th><th><center>英语</center></th><th><center>政治</center></th><th><center>完成度</center></th></tr></thead><tbody><tr><td>8.1</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.2</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.3</td><td>1.看线代第3章讲解 <br>2.闭关修炼第一章</td><td>1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td><td>1.做真题2015.4并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会形态 <br>2.做1000剩余第二章单选</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>8.4</td><td>1.看线代第4章讲解 <br>2.闭关修炼第二章 <br>3.18讲第三讲</td><td>1.2012年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈</td><td>1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词</td><td>社会的基本矛盾</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span></center></td></tr><tr><td>8.5</td><td>玩耍</td><td>玩耍</td><td>玩耍</td><td>玩耍</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.6</td><td>1.看线代第五章前三课讲解 <br>2.闭关修炼第三章</td><td>1.2011年软专数据结构基础题 <br>2.整理计网基础第五章blog <br>3.冲刺讲义数据结构看4.5 <br>4.每日一题 栈</td><td>1.做真题2012.4并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会的基本矛盾 <br>2.1000第二章单选对答案</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>8.7</td><td>1.看线代第五章后两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲</td><td>1.2010年软专数据结构基础题 <br>2.整理计网基础第六章blog <br>3.冲刺讲义数据结构看4.6 <br>4.每日一题 栈</td><td>1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会形态-1 <br>2.1000第二章单选对答案</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>8.8</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.9</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.10</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.11</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.12</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.13</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.14</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.15</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.16</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.17</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.18</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.19</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.20</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.21</td><td>1.线代第六章前两课讲解 <br>2.闭关修炼第四章 <br>3.18讲第四讲</td><td>1.整理计网基础第七章blog <br>2.算法讲义1页blog整理理解</td><td>1.做真题2013.1并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会形态-1</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>8.22</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.23</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>8.24</td><td>1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲</td><td>1.整理计网基础第八章blog <br>2.算法讲义1、2、3页blog整理理解</td><td>1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词</td><td>1.马原第五章 <br>2.1000第二章单选对答案</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span></center></td></tr><tr><td>8.25</td><td>1.线代第六章三四课讲解 <br>2.闭关修炼第五章 <br>3.18讲第五讲</td><td>1.整理计网基础第八章blog剩余部分 <br>2.算法讲义顺序表blog整理</td><td>1.做真题2013.2并看李旭相应视频 <br>２.背所学课程单词</td><td>1.马原第四章 <br>2.1000第二章单选对答案</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>8.26</td><td>1.线代第七章一二课讲解 <br>2.18讲第六讲34课 <br>3.闭关修炼第六章</td><td>1.整理计网强化部分 <br>2.算法讲义链表blog整理理解</td><td>1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词</td><td>1.马原商品的二因素 <br>2.1000第二章单选对答案</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span></center></td></tr><tr><td>8.27</td><td>1.线代第七章C组讲解 <br>2.18讲第7讲12课 <br>3.闭关修炼第七章</td><td>1.整理计网强化部分 <br>2.算法讲义链表剩余blog整理理解</td><td>1.做真题2013.3并看李旭相应视频 <br>２.背所学课程单词</td><td>1.马原商品的二因素 <br>2.1000第二章单选对答案</td><td></td></tr><tr><td>8.28</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8.29</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8.30</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 男男 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题(四) 8.3</title>
      <link href="/posts/dde7.html/"/>
      <url>/posts/dde7.html/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一题（四）-8-3"><a href="#每日一题（四）-8-3" class="headerlink" title="每日一题（四） 8.3"></a>每日一题（四） 8.3</h2><h5 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h5><h5 id="给定一个二叉树，返回他的中序遍历"><a href="#给定一个二叉树，返回他的中序遍历" class="headerlink" title="给定一个二叉树，返回他的中序遍历"></a>给定一个二叉树，返回他的中序遍历</h5><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre class="line-numbers language-c"><code class="language-c">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>   <span class="token number">1</span>    \     <span class="token number">2</span>    <span class="token operator">/</span>   <span class="token number">3</span>输出<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre class="line-numbers language-c"><code class="language-c">一<span class="token punctuation">.</span>递归实现     <span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token function">InOrder</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">visit</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">InOrder</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 二<span class="token punctuation">.</span>中序遍历非递归实现<span class="token punctuation">(</span>利用栈来辅助储存，先出栈，在访问<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">NRInOrder</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span><span class="token punctuation">{</span>     BiTree Stack<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化辅助栈 </span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈的下标 </span>    BiTree p <span class="token operator">=</span> bt<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用p遍历二叉树 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span>p<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//p不为空或栈不为空 </span>       <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//左孩子不为空 </span>           Stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//入栈 </span>           p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//往左走 </span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>             p <span class="token operator">=</span> tack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出栈 </span>            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问节点 </span>            P<span class="token operator">-></span>rchild<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//往右走 </span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题(三) 7.29</title>
      <link href="/posts/7624.html/"/>
      <url>/posts/7624.html/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一题-三-7-29"><a href="#每日一题-三-7-29" class="headerlink" title="每日一题(三) 7.29"></a>每日一题(三) 7.29</h2><h5 id="给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效。"><a href="#给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效。" class="headerlink" title="给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。"></a>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</h5><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><h5 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h5><p>使用数组做栈，两个指针i和j，分别代表字符串和栈顶+1，先判断是否是({[,如果是进栈，不是则判断栈是否为空，空则返回false；如果栈顶是相对应字符，j–；否则，返回false。<br>最后再判断栈中是否还有元素，没有元素则false，否则true。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>bool <span class="token function">isValid1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> stack<span class="token punctuation">[</span><span class="token number">100000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">')'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'}'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'{'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'}'</span><span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"chenggong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>bool <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"字符串长度为奇数：%s"</span><span class="token punctuation">,</span><span class="token string">"失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"字符串长度为0:%s"</span><span class="token punctuation">,</span><span class="token string">"成功\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token string">"进入循环"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d次循环\n"</span><span class="token punctuation">,</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"l为:%d\n"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i为:%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s[l]为:%c\ts为:%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            continue;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"l为:%d\n"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i为:%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i为:%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j为:%d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改后的字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                        i<span class="token operator">--</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span><span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i为:%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j为:%d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span>  <span class="token punctuation">)</span><span class="token punctuation">{</span>                        str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改后的字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                        i<span class="token operator">--</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span><span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token string">"进入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i为:%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j为:%d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str字符串为:%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>                        i<span class="token operator">--</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span><span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> false<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token string">"成功\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"zheli%s"</span><span class="token punctuation">,</span><span class="token string">"失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//    isValid("{[]}");</span>    <span class="token function">isValid1</span><span class="token punctuation">(</span><span class="token string">"{[]}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第四章-数据链路层</title>
      <link href="/posts/2693.html/"/>
      <url>/posts/2693.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-数据链路层"><a href="#第四章-数据链路层" class="headerlink" title="第四章 数据链路层"></a>第四章 数据链路层</h2><ol><li><p>线路规程：</p><ul><li><p>询问/确认模式</p><ul><li><p>使用场合：一条链路的两端的设备级别相同，任意一个设备都可以启动一个会话过程</p></li><li><p>工作方式：启动方首先发送一个询问帧（ENQ）询问接收方是否可以接收数据。接收方如果已经准备好接收，必须回答一个确认帧（ACK）。一旦讲所有数据发送完毕，发送系统以一个传输结束帧（EOT）结束传输</p></li></ul></li></ul></li></ol><ul><li>轮询/选择模式<ul><li>使用场合：在有一个设备作为主设备，其他设备为从设备的多点连接系统</li><li>工作方式</li><li>选择：当主设备有数据发送时就采用选择模式。在发送数据前，主设备产生并发送一个选择帧（SEL），并在帧的地址域中填入接收数据的从设备的地址。如果从设备是激活的并且正在运行，其地址和选择帧中的地址域中的地址相同，它向主设备返回一个确认帧（ACK）。</li><li>轮询：轮询功能是主设备请求从设备进行传输。在没有接到请求前，从设备是不允许发送数据的。当主设备收到否认帧，主设备就轮询下一个从设备，直到他发现一个要发送的从设备为止。当回应是数据帧时，从设备读入该帧并向从设备返回一个确认帧来确认已经接收。</li></ul></li></ul><ol start="2"><li><p>流量控制与差错控制</p><ul><li>自动重复请求（ARQ）：数据帧在传输中出现错误，接收方就返回一个否定应答帧（NAK），出错的帧就会被发送方重新传送。这个过程叫做自动重复请求。</li><li>数据被重传的情况有三种：<strong>帧破坏、帧丢失和应答帧丢失</strong></li><li>流量控制和差错控制是结合在一起实现的。</li></ul></li><li><p><strong>停止等待协议</strong></p><ul><li><p>发送方每发送一帧后就等待应答。只有收到一个应答帧（ACK）后，才发送下一个帧。直到发送方发送一个传输结束帧（也就是线路上只有一帧）</p></li><li><p>完成一帧发送所需最短的时间</p><ul><li><p>一个窗口时间$WT$。$WT=t_1+2t_p+2t_{Proc}+t_S$。</p><p><em>其中，$t_I$是发送一个数据帧的时间，设一个数据帧的长度为$L_f$比特，发送数据速率为$C$bps，则$t_I=L_f/C$秒。</em></p><p><em>$t_s$是确认帧的发送时间，设一个确认帧的长度为$L_S$比特，发送数据速率为$C$bps，则$t_S=L_S/C$秒。</em></p><p>_$t_p$是电信号在物理链路上的传播延迟。_</p><p>$t_{Proc}$是收到一帧的处理时间和一个帧的形成时间。</p></li></ul></li></ul></li></ol><ol start="4"><li><strong>滑动窗口协议</strong><ul><li>流量控制：发送方在收到应答消息前可以发送多个帧。接收方使用一个确认（ACK）帧来对多个帧的接收进行确认。具体可以接受多少帧视窗口大小而定。<ul><li>回退n自动重复请求</li><li>选择拒绝自动重复请求：窗口尺寸小于等于$n/2$。</li></ul></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题(二) 7.28</title>
      <link href="/posts/6f31.html/"/>
      <url>/posts/6f31.html/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一题-7-28"><a href="#每日一题-7-28" class="headerlink" title="每日一题 7.28"></a>每日一题 7.28</h2><h4 id="给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。"><a href="#给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。" class="headerlink" title="给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。"></a>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ul><li>建立二叉树结构</li><li>建立二叉树，创造结点</li><li>递归求解二叉树深度</li><li>释放结点</li></ul><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">//二叉树结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> tree <span class="token comment" spellcheck="true">//结构体的名字为tree</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>    <span class="token keyword">struct</span> tree <span class="token operator">*</span>lchild<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向tree型变量的指针（指向自己结构体的指针）</span>    <span class="token keyword">struct</span> tree <span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">}</span>tree<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按先序建立二叉树</span>tree <span class="token operator">*</span><span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//创建树；</span><span class="token punctuation">{</span>    tree <span class="token operator">*</span>bt<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义节点的指针bt</span>    <span class="token keyword">char</span> str<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//屏幕输入的字符</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把屏幕输入字符赋予str</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token operator">==</span><span class="token string">'0'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        bt<span class="token operator">=</span><span class="token punctuation">(</span>tree <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为指针bt申请内存空间</span>        bt<span class="token operator">-></span>ch<span class="token operator">=</span>str<span class="token punctuation">;</span>        bt<span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bt<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//先定义两个变量，初始化为0 int ld=0，int rd=0；分别表示左子树和右子树的深度；</span><span class="token comment" spellcheck="true">//先判断二叉树bt是否为空，为空直接return返回；</span><span class="token comment" spellcheck="true">//不为空，进入左子树的递归调用，此时ld=1，一直到某个结点的左子树为空，if条件不成立，返回上一层递归调用；</span><span class="token comment" spellcheck="true">//之后进入右子树的递归调用，再进入这个结点的左子树一直到左子树为空，返回上一层递归调用，继续进入右子树的递归调用；</span><span class="token comment" spellcheck="true">//一直循环判断使用哪个递归调用；</span><span class="token comment" spellcheck="true">//一直到某个结点的左右子树为空，返回ld和rd的最大值，并将所带回的值+1，重新赋给ld或者rd；</span><span class="token comment" spellcheck="true">//重复上述过程，直到根结点，说明bt为空，无法继续返回，所以结束调用函数；</span><span class="token comment" spellcheck="true">//返回main函数带回一个整型的值；</span><span class="token comment" spellcheck="true">//求二叉树的深度,递归实现；</span><span class="token keyword">int</span> <span class="token function">DeepOrder</span><span class="token punctuation">(</span>tree <span class="token operator">*</span>bt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ld<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>rd<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//先找到最左边的左右孩子为空的结点，之后找到相对位置靠近第一个结点的结点，依次类推；</span>        ld<span class="token operator">=</span><span class="token function">DeepOrder</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        rd<span class="token operator">=</span><span class="token function">DeepOrder</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ld<span class="token operator">>=</span>rd<span class="token operator">?</span>ld<span class="token punctuation">:</span>rd<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//释放树的结点；</span><span class="token keyword">void</span> <span class="token function">DestroyTree</span><span class="token punctuation">(</span>tree <span class="token operator">*</span>bt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">DestroyTree</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DestroyTree</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tree <span class="token operator">*</span>bt<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请以先序输入二叉树(0表示该结点的子结点为空):\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bt<span class="token operator">=</span><span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bt为： %s"</span><span class="token punctuation">,</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> deep<span class="token operator">=</span><span class="token function">DeepOrder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n二叉树的深度为:  %d\n"</span><span class="token punctuation">,</span>deep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DestroyTree</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//释放树结点；</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题(一) 7.27</title>
      <link href="/posts/b23c.html/"/>
      <url>/posts/b23c.html/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一题-7-27"><a href="#每日一题-7-27" class="headerlink" title="每日一题 7.27"></a>每日一题 7.27</h2><h3 id="给定字符串-s-和-t-，判断-s-是否为-t-的子序列。"><a href="#给定字符串-s-和-t-，判断-s-是否为-t-的子序列。" class="headerlink" title="给定字符串 s 和 t ，判断 s 是否为 t 的子序列。"></a>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</h3><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p><strong>示例 1:</strong><br>s = “abc”, t = “ahbgdc”</p><p>返回 true.</p><p><strong>示例 2:</strong><br>s = “axc”, t = “ahbgdc”</p><p>返回 false.</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>​    我们初始化两个指针 i 和 j ，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。<br>​    最终如果 i 移动到 s的末尾，就说明 s 是 t 的子序列。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment" spellcheck="true">//字符串所需包</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token comment" spellcheck="true">//bool所需包</span>bool <span class="token function">isSubsequence</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义两个指针</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token operator">==</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//%d指十进制数字</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">isSubsequence</span><span class="token punctuation">(</span><span class="token string">"abcdc"</span><span class="token punctuation">,</span> <span class="token string">"asdabcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(1)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第三章 物理层</title>
      <link href="/posts/506b.html/"/>
      <url>/posts/506b.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-物理层"><a href="#第三章-物理层" class="headerlink" title="第三章 物理层"></a>第三章 物理层</h2><ol><li><p>有线传输介质：双绞线、同轴电缆和光纤</p></li><li><p>光纤传播模式</p><ul><li><p>多模传输：多束光线在芯材中通过不同路径传播</p><ul><li><p>多模阶跃：芯材的密度从中心到边缘是一致的。在边界上，填充材料密度降低（密度突变）</p></li><li><p>多模渐变：芯材的中心密度最大，并向外逐步变小，到边界是最小（密度渐变）</p></li></ul></li><li><p>单模传输</p></li></ul></li><li><p>物理连接</p><ul><li><p>DTE数据终端设备：是具有数据处理能力及发送和接收数据信息能力的设备</p></li><li><p>DCE数据电路终接设备：是能够通过网络发送和接收模拟或数字信号形式数据的设备（起到帮助的作用）</p></li><li><p>DTE一般不直接连接网络，它通过一台DCE通信。把DTE和DCE的连接成为DTE-DCE接口</p></li></ul></li><li><p><strong>媒介是消息传输的物理通路</strong></p></li><li><p>DTE是二进制数字数据源或宿</p></li><li><p><strong>HDLC中标志域控制了帧的开始和结束</strong></p></li><li><p>IEEE802标准讲数据链路层划分为一个上子层和一个下子层，分别为LLC和MAC</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第二章 数据基础通信</title>
      <link href="/posts/6b05.html/"/>
      <url>/posts/6b05.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-数据通信基础"><a href="#第二章-数据通信基础" class="headerlink" title="第二章　数据通信基础"></a>第二章　数据通信基础</h2><ol><li><p>数据通信系统的组成：[信源、发送设备]（源系统）、传输系统、[接收设备和信宿]（目的系统）</p></li><li><p>比特间隙：发送一比特所用时间</p></li><li><p>比特率：每秒发送的比特数（单位：bps），与比特间隙的关系为<strong>倒数关系</strong></p></li><li><p>数字编码</p><ul><li><p>单极性编码：高电平代表1，低电平代表0</p></li><li><p>极化编码</p><ul><li><p>非归零编码：高电平是1，低电平是0</p></li><li><p>非归零反向编码：电平翻转是1，电平不变是0</p></li><li><p>双相位编码</p><ul><li><p>曼彻斯特编码：负电平到正电平为1，正电平到负电平为0</p></li><li><p>差分曼彻斯特编码：每个比特的间隙，有跳变为0，没有跳变为1</p></li></ul></li></ul></li></ul></li></ol><ol start="5"><li><p>传输模式</p><ul><li>单工通信：通信是单向的，只有一个可以进行传输，另一个只能接收</li><li>半双工通信：每个站点都可以发送和接收数据，但是不能同时发送和接收数据</li><li>全双工通信：两个站点可以同时发送和接收数据</li></ul></li><li><p>并行和串行</p><ul><li>并行：可以同时发送多个比特，每个比特使用单独的一条线路，一次8位，价格贵，距离短</li><li>串行：一次一位传输，速度慢，价格便宜</li></ul></li><li><p>多路复用技术</p><ul><li><p>频分多路复用FDM：用于模拟信号</p></li><li><p>时分多路复用TDM：用于数字信号</p></li><li><p>波分多路复用WDM：光的频分多路复用，用于模拟信号</p></li><li><p><strong>码分多路复用CDM</strong>：也称码分多址复用CDMA</p><ul><li><p>每个比特被分为m个码片，每个站点被指定一个唯一指定的m位码片（码型）。当发送比特1时，就发送其码片。想发送0时，就发送码片的反码</p></li><li><p>所有码片是正交的</p></li><li><p>任何码片序列与自己的标乘积为1</p></li><li><p>多个站点同时传输，信号线性加强</p></li><li><p>要从信号还原站点比特流，通过计算站点码片和信息码片的内标识</p></li></ul></li></ul></li><li><p>数据交换技术</p><ul><li>电路交换：再两个设备之间创建一条临时的物理连接。步骤为电路建立、数据传输和电路拆除</li><li>报文交换：又称存储转发或消息交换。原理为在报文传输过程中，网络的中间节点先将报文暂时储存起来，检查正确性和完整性，然后再发往下一个结点。报文交换技术已被淘汰</li><li>分组交换：又称包交换，可以在中间节点存储，只要信息包到达后就可以转发，不用等到全部报文到达，缩短了信息传输过程的延时时间。<strong>可工作于广播和多播的方式</strong><ul><li>数据报：每个包都独立于其他包处理，任何一条链路可以同时为多对设备之间的通信服务。一次传输的数据报可能不是有次序的到达。重新排序的任务由传输层来完成</li><li>虚电路：路径在数据传输的开始之前就已经确定。仅在建立虚电路时需要目的地址，在数据传送时，每个包不需要携带完整的目的地址，仅需要一个虚电路的号码标志</li></ul></li></ul></li><li><p>错误检测和控制</p><ul><li>循环冗余校验码：在待发送信息后加上多项式最高阶个0，用这个数字除以多项式<strong>（同0异1）</strong>，最终余数为多项式最高阶数位，即为循环校验码</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
            <tag> 男男 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网第一章　概述</title>
      <link href="/posts/6c68.html/"/>
      <url>/posts/6c68.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-计算机网络概述"><a href="#第一章-计算机网络概述" class="headerlink" title="第一章　计算机网络概述"></a>第一章　计算机网络概述</h2><ol><li><p>不同程序同时在一台计算机内使用网络，可使用<strong>服务点地址</strong>来区别。</p></li><li><p>网络拓扑结构</p><ul><li>网状</li><li>星状：中央控制器是整个网络性能的瓶颈</li><li>树状</li><li>总线型</li><li>环形</li></ul></li><li><p>计算机网络的分类</p><ul><li>按作用范围分类：局域网（一般为私有的）、城域网和广域网</li><li>按通讯介质分类：有线网（同轴电缆、双绞线和光纤）和无线网</li><li>按通信传播方式分类：点对点传播网（星状、树状、环状和网状）和广播传播网（总线型网络和无线）</li><li>按通信速率分类：低速网、中速网和高速网</li><li>按使用范围分类：公用网和专用网</li><li>按网络控制方式分类：集中式网络和分布式网络（无处理中心，每个结点地位平等）</li><li>按网络环境分类：部门网、企业网和校园网</li></ul></li><li><p><strong>网络体系结构</strong>：计算机网络的各个层次及其协议的集合成为体系结构</p></li><li><p>ISO OSI参考模型</p><ul><li>计算机网络从逻辑功能上可分为两个子网：<strong>资源子网和通信子网</strong></li><li><strong>由下到上、由低到高为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong></li><li>物理层（中继器）：规定了机械、电气、功能和规程4个特性，单位是比特（bit）</li><li>数据链路层（网桥）：相邻结点的数据传输、帧同步、差错控制、流量控制、链路管理，单位是帧（frame）。提供<strong>可靠通信</strong></li><li>网络层（路由器）：任意节点的数据传输、路由选择、阻塞控制国际互联，单位是分组或包</li><li><strong>物理层、数据链路层和网络层</strong>三层组成<strong>通信子网</strong></li><li>传输层：<strong>端到端</strong>通信，流量控制、差错控制，单位是报文（message）</li><li>会话层：两个计算机上的进程间建立连接。提供同步点机制</li><li>表示层：解决用户信息的语法问题</li><li>应用层：处理用户的数据和信息</li></ul></li><li><p>Internet体系结构采用TCP/IP参考模型</p></li><li><p>TCP/IP体系结构：物理层、数据链路层、网络层、传输层和应用层</p><ul><li><p>物理层和数据链路层：这两层有时又称为网络接口层。数据链路层在TCP/IP协议中被认为是不可靠的。<strong>保证可靠地通讯是传输层的任务</strong></p></li><li><p>网络层：寻址、数据打包和路由选择，IP协议是一个<strong>无连接、不可靠</strong>的协议。包括地址解析协议ARP、反向地址解析协议RARP、Internet协议IP、Internet控制消息协议ICMP和Internet组管理协议IGMP</p></li><li><p>传输层</p><ul><li>TCP传输控制协议：可靠有链接</li><li>UDP用户数据报协议：不可靠无连接</li></ul></li><li><p>应用层：FTP交互式文件传输、SMTP邮件服务器间邮件传输、POP从邮件服务器上取回邮件、HTTP传输组成Web页面的文件、DNS解析域名成IP地址、SNMP简单网络管理协议</p></li></ul></li><li><p>物理层为第1层，应用层为第7层。<strong>下层为上面各层提供服务</strong>，相邻层传递的信息为服务数据单元SDU，对等层之间交换信息为协议数据单元PDU。<strong>N层的PDU由N层的SDU加上该层的PCI（协议控制信息）构成</strong></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第一讲总结</title>
      <link href="/posts/6214.html/"/>
      <url>/posts/6214.html/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-函数极限与连续"><a href="#第一章-函数极限与连续" class="headerlink" title="第一章　函数极限与连续"></a>第一章　函数极限与连续</h2><ul><li><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><ul><li>等式脱帽法</li></ul></li></ul><p>$$<br>  f(x)=A+ x ,其中\displaystyle \lim_{x \to }{x}=0<br>$$</p><ul><li>局部保号性：若Ａ大于０，则函数ｆ(x)也大于０</li></ul><ul><li><h3 id="极限的计算"><a href="#极限的计算" class="headerlink" title="极限的计算"></a>极限的计算</h3><ul><li><p>先化简</p></li><li><p>再变形</p><ul><li>换元、通分、因式分解</li></ul></li><li><p><strong>中值定理</strong></p><ul><li><p>拉格朗日中值定理：见到ｆ - ｆ、ｆ - ｆ的导数 </p></li><li><p>积分中值定理（见到函数和积分时使用）<br>$$<br>\int_a^b{f(x)}dx=f(\xi)(b-a)<br>$$</p></li><li><p>牛顿－莱布尼兹公式</p></li><li><p>泰勒公式（三阶及其以上使用）</p></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7月份学习计划</title>
      <link href="/posts/4cfa.html/"/>
      <url>/posts/4cfa.html/</url>
      
        <content type="html"><![CDATA[<center> <h2>7月份学习计划</h2><h2></h2></center><table><thead><tr><th><center>7月份</center></th><th><center>数学</center></th><th><center>专业课</center></th><th><center>英语</center></th><th><center>政治</center></th><th><center>完成度</center></th></tr></thead><tbody><tr><td>7.1</td><td>1.1000题高数第16讲BC <br>2.看第7章BC组讲解</td><td>1.2018年计专数据结构基础题</td><td>1.整理句子<br> 2.背单词</td><td>对立统一</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.2</td><td>1.1000题高数第17讲BC <br>2.看第8章BC组讲解</td><td>1.2017年计专数据结构基础题 <br>2.2018计算机学硕两道代码 <br>3.对照常青藤与课本复习计算机网络其余部分</td><td>1.恋恋有词Unit6 Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词</td><td>质量互变定律</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.3</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.4</td><td>1.1000题高数第18讲25道题<br>2.看第9章BC组讲解</td><td>1.2016年计专数据结构基础题 <br>2.2017计算机学硕两道代码 <br>3.冲刺讲义数据结构看完4.2和代码讲义链表代码 <br>4.2018学硕计网真题</td><td>1.恋恋有词Unit7 Lesson1 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词</td><td>否定之否定定律</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f626.png?v8">😦</span></center></td></tr><tr><td>7.5</td><td>1.1000题高数第18讲剩余题目<br>2.看第10章BC组讲解</td><td>1.2015年计专数据结构基础题 <br>2.2018学硕计网真题</td><td>1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td><td>否定之否定定律</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.6</td><td>1.1000题线代第1、2讲BC <br>2.看第11、12章BC组讲解</td><td>1.2014年计专数据结构基础题 <br>2.冲刺讲义数据结构看完4.2 <br>3.2017学硕计网真题</td><td>1.恋恋有词Unit7 Lesson2 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td><td>否定之否定定律</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.7</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.8</td><td>1.1000题线代第3-1讲 <br>2.看第13章讲解</td><td>1.2013年计专数据结构基础题 <br>2.学习2017学硕计网选择题知识点 <br>3.冲刺讲义数据结构看4.3</td><td>1.做真题2010.3并看李旭相应视频 <br>2.背所学课程单词</td><td>否定之否定定律</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.9</td><td>1.1000题线代第3-2讲 <br>2.看第14章讲解</td><td>1.2012年计专数据结构基础题 <br>2.2016学硕计网 <br>3.冲刺讲义数据结构看4.4</td><td>1.做真题2010.4并看李旭相应视频 <br>2.背所学课程单词</td><td>否定之否定定律</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.10</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.11</td><td>烧烤BBQ</td><td>烧烤BBQ</td><td>烧烤BBQ</td><td>烧烤BBQ</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.12</td><td>1.1000题线代第4讲 <br>2.看第15章讲解</td><td>1.2011年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5</td><td>1.做真题2011.1并看李旭相应视频 <br>2.背所学课程单词</td><td>认识论</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.13</td><td>1.1000题线代第5-1讲 <br>2.看第16章B组讲解</td><td>1.2010年计专数据结构基础题 <br>2.2015学硕计网 <br>3.冲刺讲义数据结构看4.5</td><td>1.做真题2011.2并看李旭相应视频 <br>2.背所学课程单词</td><td>认识的本质</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.14</td><td>1.1000题线代第5-2讲 <br>2.看第16章C组讲解</td><td>1.2018年软专数据结构基础题 <br>2.2012学硕计网 <br>3.冲刺讲义数据结构看4.5</td><td>1.做真题2011.3并看李旭相应视频 <br>2.背所学课程单词</td><td>认识的本质</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.15</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.16</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.17</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.18</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.19</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.20</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td>学习deepin-linux系统</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.21</td><td>1.1000题线代第6讲 <br>2.看第17章讲解 <br>3.看18讲第一章并blog总结相关知识点</td><td>1.2017年软专数据结构基础题 <br>2.2010学硕计网 <br>3.冲刺讲义数据结构看4.1 <br>4.冲刺讲义计网基础全部看完</td><td>1.做真题2011.4并看李旭相应视频 <br>２.背所学课程单词</td><td>认识的本质</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.22</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.23</td><td>1.1000题线代第7-1讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td><td>1.2015年软专数据结构基础题 <br>2.整理计网基础第二章blog <br>3.冲刺讲义数据结构看4.2</td><td>1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词</td><td>1.徐涛真理与价值 <br>2.做1000题第一、二章题</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.24</td><td>1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td><td>1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3</td><td>1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词</td><td>社会基本矛盾</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.25</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.26</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8">☺</span></center></td></tr><tr><td>7.27</td><td>1.1000题线代第7-2讲 <br>2.看第18章讲解 <br>3.看18讲第二章</td><td>1.2014年软专数据结构基础题 <br>2.整理计网基础第三章blog <br>3.冲刺讲义数据结构看4.3 <br>4.每日一题 栈</td><td>1.做真题2014.4并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会形态</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.28</td><td>1.1000题线代第8讲 <br>2.看线代第3章讲解 <br>3.看18讲第二章 <br>4.闭关修炼第一章</td><td>1.2013年软专数据结构基础题 <br>2.整理计网基础第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td><td>1.做真题2012.2并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会形态 <br>2.做1000剩余第二章单选</td><td><center><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">🌞</span></center></td></tr><tr><td>7.29</td><td>1.看线代第3章讲解 <br>2.闭关修炼第一章</td><td>1.2013年软专数据结构基础题 <br>2.整理计网基础剩余第四章blog <br>3.冲刺讲义数据结构看4.4 <br>4.每日一题 栈</td><td>1.做真题2012.3并看李旭相应视频 <br>２.背所学课程单词</td><td>1.社会形态 <br>2.做1000剩余第二章单选</td><td></td></tr><tr><td>7.30</td><td>1.1000题线概率第2讲</td><td>1.2011年软专数据结构基础题</td><td>1.做真题2012.1并看李旭相应视频 <br>２.背所学课程单词</td><td>商品的两因素</td><td></td></tr><tr><td>7.31</td><td>1.1000题线概率第3讲</td><td>1.2010年软专数据结构基础题</td><td></td><td>价值规律</td><td></td></tr><tr><td></td><td>1.1000题线概率第4讲</td><td></td><td></td><td>剩余价值生产</td><td></td></tr><tr><td></td><td>1.1000题线概率第5讲</td><td></td><td></td><td>剩余价值流转</td><td></td></tr><tr><td></td><td>1.1000题线概率第6-1讲</td><td></td><td></td><td>垄断资本主义</td><td></td></tr><tr><td></td><td>1.1000题线概率第6-2讲</td><td></td><td></td><td>社会主义</td><td></td></tr><tr><td></td><td>1.1000题线概率第6-3讲</td><td></td><td></td><td>人生的青春</td><td></td></tr><tr><td></td><td>1.1000题线概率第7讲</td><td></td><td></td><td>人生理想</td><td></td></tr><tr><td></td><td>1.1000题线概率第8讲</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1.1000题线概率第9-1讲</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1.1000题线概率第9-2讲</td><td></td><td></td><td></td><td></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 男男 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾宾浩斯背单词</title>
      <link href="/posts/9eeb.html/"/>
      <url>/posts/9eeb.html/</url>
      
        <content type="html"><![CDATA[<hr><center> <h2>英语单词复习计划表</h2><h2></h2></center><table><thead><tr><th>序号</th><th>学习日期</th><th>学   习     内   容</th><th>1天</th><th>2天</th><th>4天</th><th>7天</th><th>15天</th><th>1月</th><th>是否完成</th></tr></thead><tbody><tr><td>1</td><td>6月14日</td><td>恋恋有词第1章</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>2</td><td>6月15日</td><td>恋恋有词第2章</td><td>1</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>3</td><td>6月16日</td><td>恋恋有词第3章</td><td>2</td><td>1</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>4</td><td>6月17日</td><td>恋恋有词第4章</td><td>3</td><td>2</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>5</td><td>6月18日</td><td>恋恋有词第5章</td><td>4</td><td>3</td><td>1</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>6</td><td>6月19日</td><td>恋恋有词第6章</td><td>5</td><td>4</td><td>2</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>7</td><td>6月20日</td><td>恋恋有词第7章</td><td>6</td><td>5</td><td>3</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr><td>8</td><td>6月21日</td><td>恋恋有词第8章</td><td>7</td><td>6</td><td>4</td><td>1</td><td>-</td><td>-</td><td></td></tr><tr><td>9</td><td>6月22日</td><td>恋恋有词第9章</td><td>8</td><td>7</td><td>5</td><td>2</td><td>-</td><td>-</td><td></td></tr><tr><td>10</td><td>6月23日</td><td>恋恋有词第10章</td><td>9</td><td>8</td><td>6</td><td>3</td><td>-</td><td>-</td><td></td></tr><tr><td>11</td><td>6月24日</td><td>恋恋有词第11章</td><td>10</td><td>9</td><td>7</td><td>4</td><td>-</td><td>-</td><td></td></tr><tr><td>12</td><td>6月25日</td><td>恋恋有词第12章</td><td>11</td><td>10</td><td>8</td><td>5</td><td>-</td><td>-</td><td></td></tr><tr><td>13</td><td>6月26日</td><td>恋恋有词第13章</td><td>12</td><td>11</td><td>9</td><td>6</td><td>-</td><td>-</td><td></td></tr><tr><td>14</td><td>6月27日</td><td>恋恋有词第14章</td><td>13</td><td>12</td><td>10</td><td>7</td><td>-</td><td>-</td><td></td></tr><tr><td>15</td><td>6月28日</td><td>恋恋有词第15章</td><td>14</td><td>13</td><td>11</td><td>8</td><td>-</td><td>-</td><td></td></tr><tr><td>16</td><td>6月29日</td><td>恋恋有词第16章</td><td>15</td><td>14</td><td>12</td><td>9</td><td>1</td><td>-</td><td></td></tr><tr><td>17</td><td>6月30日</td><td>恋恋有词第17章</td><td>16</td><td>15</td><td>13</td><td>10</td><td>2</td><td>-</td><td></td></tr><tr><td>18</td><td>7月1日</td><td>恋恋有词第18章</td><td>17</td><td>16</td><td>14</td><td>11</td><td>3</td><td>-</td><td></td></tr><tr><td>19</td><td>7月2日</td><td>恋恋有词第19章</td><td>18</td><td>17</td><td>15</td><td>12</td><td>4</td><td>-</td><td></td></tr><tr><td>20</td><td>7月3日</td><td>恋恋有词第20章</td><td>19</td><td>18</td><td>16</td><td>13</td><td>5</td><td>-</td><td></td></tr><tr><td>21</td><td>7月4日</td><td>恋恋有词第21章</td><td>20</td><td>19</td><td>17</td><td>14</td><td>6</td><td>-</td><td></td></tr><tr><td>22</td><td>7月5日</td><td>恋恋有词第22章</td><td>21</td><td>20</td><td>18</td><td>15</td><td>7</td><td>-</td><td></td></tr><tr><td>23</td><td>7月6日</td><td>恋恋有词第23章</td><td>22</td><td>21</td><td>19</td><td>16</td><td>8</td><td>-</td><td></td></tr><tr><td>24</td><td>7月7日</td><td>恋恋有词第24章</td><td>23</td><td>22</td><td>20</td><td>17</td><td>9</td><td>-</td><td></td></tr><tr><td>25</td><td>7月8日</td><td>恋恋有词第25章</td><td>24</td><td>23</td><td>21</td><td>18</td><td>10</td><td>-</td><td></td></tr><tr><td>26</td><td>7月9日</td><td>恋恋有词第26章</td><td>25</td><td>24</td><td>22</td><td>19</td><td>11</td><td>-</td><td></td></tr><tr><td>27</td><td>7月10日</td><td>恋恋有词第27章</td><td>26</td><td>25</td><td>23</td><td>20</td><td>12</td><td>-</td><td></td></tr><tr><td>28</td><td>7月11日</td><td>恋恋有词第28章</td><td>27</td><td>26</td><td>24</td><td>21</td><td>13</td><td>-</td><td></td></tr><tr><td>29</td><td>7月12日</td><td>恋恋有词第29章</td><td>28</td><td>27</td><td>25</td><td>22</td><td>14</td><td>-</td><td></td></tr><tr><td>30</td><td>7月13日</td><td>恋恋有词第30章</td><td>29</td><td>28</td><td>26</td><td>23</td><td>15</td><td>-</td><td></td></tr><tr><td>31</td><td>7月14日</td><td></td><td>30</td><td>29</td><td>27</td><td>24</td><td>16</td><td>1</td><td></td></tr><tr><td>32</td><td>7月15日</td><td></td><td>31</td><td>30</td><td>28</td><td>25</td><td>17</td><td>2</td><td></td></tr><tr><td>33</td><td>7月16日</td><td></td><td>32</td><td>31</td><td>29</td><td>26</td><td>18</td><td>3</td><td></td></tr><tr><td>34</td><td>7月17日</td><td></td><td>33</td><td>32</td><td>30</td><td>27</td><td>19</td><td>4</td><td></td></tr><tr><td>35</td><td>7月18日</td><td></td><td>34</td><td>33</td><td>31</td><td>28</td><td>20</td><td>5</td><td></td></tr><tr><td>36</td><td>7月19日</td><td></td><td>35</td><td>34</td><td>32</td><td>29</td><td>21</td><td>6</td><td></td></tr><tr><td>37</td><td>7月20日</td><td></td><td>36</td><td>35</td><td>33</td><td>30</td><td>22</td><td>7</td><td></td></tr><tr><td>38</td><td>7月21日</td><td></td><td>37</td><td>36</td><td>34</td><td>31</td><td>23</td><td>8</td><td></td></tr><tr><td>39</td><td>7月22日</td><td></td><td>38</td><td>37</td><td>35</td><td>32</td><td>24</td><td>9</td><td></td></tr><tr><td>40</td><td>7月23日</td><td></td><td>39</td><td>38</td><td>36</td><td>33</td><td>25</td><td>10</td><td></td></tr><tr><td>41</td><td>7月24日</td><td></td><td>40</td><td>39</td><td>37</td><td>34</td><td>26</td><td>11</td><td></td></tr><tr><td>42</td><td>7月25日</td><td></td><td>41</td><td>40</td><td>38</td><td>35</td><td>27</td><td>12</td><td></td></tr><tr><td>43</td><td>7月26日</td><td></td><td>42</td><td>41</td><td>39</td><td>36</td><td>28</td><td>13</td><td></td></tr><tr><td>44</td><td>7月27日</td><td></td><td>43</td><td>42</td><td>40</td><td>37</td><td>29</td><td>14</td><td></td></tr><tr><td>45</td><td>7月28日</td><td></td><td>44</td><td>43</td><td>41</td><td>38</td><td>30</td><td>15</td><td></td></tr><tr><td>46</td><td>7月29日</td><td></td><td>45</td><td>44</td><td>42</td><td>39</td><td>31</td><td>16</td><td></td></tr><tr><td>47</td><td>7月30日</td><td></td><td>46</td><td>45</td><td>43</td><td>40</td><td>32</td><td>17</td><td></td></tr><tr><td>48</td><td>7月31日</td><td></td><td>47</td><td>46</td><td>44</td><td>41</td><td>33</td><td>18</td><td></td></tr><tr><td>49</td><td>8月1日</td><td></td><td>48</td><td>47</td><td>45</td><td>42</td><td>34</td><td>19</td><td></td></tr><tr><td>50</td><td>8月2日</td><td></td><td>49</td><td>48</td><td>46</td><td>43</td><td>35</td><td>20</td><td></td></tr><tr><td>51</td><td>8月3日</td><td></td><td>50</td><td>49</td><td>47</td><td>44</td><td>36</td><td>21</td><td></td></tr><tr><td>52</td><td>8月4日</td><td></td><td>51</td><td>50</td><td>48</td><td>45</td><td>37</td><td>22</td><td></td></tr><tr><td>53</td><td>8月5日</td><td></td><td>52</td><td>51</td><td>49</td><td>46</td><td>38</td><td>23</td><td></td></tr><tr><td>54</td><td>8月6日</td><td></td><td>53</td><td>52</td><td>50</td><td>47</td><td>39</td><td>24</td><td></td></tr><tr><td>55</td><td>8月7日</td><td></td><td>54</td><td>53</td><td>51</td><td>48</td><td>40</td><td>25</td><td></td></tr><tr><td>56</td><td>8月8日</td><td></td><td>55</td><td>54</td><td>52</td><td>49</td><td>41</td><td>26</td><td></td></tr><tr><td>57</td><td>8月9日</td><td></td><td>56</td><td>55</td><td>53</td><td>50</td><td>42</td><td>27</td><td></td></tr><tr><td>58</td><td>8月10日</td><td></td><td>57</td><td>56</td><td>54</td><td>51</td><td>43</td><td>28</td><td></td></tr><tr><td>59</td><td>8月11日</td><td></td><td>58</td><td>57</td><td>55</td><td>52</td><td>44</td><td>29</td><td></td></tr><tr><td>60</td><td>8月12日</td><td></td><td>59</td><td>58</td><td>56</td><td>53</td><td>45</td><td>30</td><td></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计划 </tag>
            
            <tag> 男男 </tag>
            
            <tag> 菁菁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6月份学习计划</title>
      <link href="/posts/b0c7.html/"/>
      <url>/posts/b0c7.html/</url>
      
        <content type="html"><![CDATA[<center> <h2>6月份学习计划</h2><h2></h2></center><table><thead><tr><th>6月份</th><th>数学</th><th>专业课</th><th>英语</th><th>政治</th><th>完成度</th></tr></thead><tbody><tr><td>6.9</td><td>1000题高数第8讲BC</td><td>1.2016年数据结构真题   <br>2.计算机网络王道第五章传输层</td><td>1.恋恋有词Unit5   Lesson2 <br>2.田静、长难句、特殊句式 <br>3.背所学课程单词</td><td>导论</td><td><strong>完成</strong></td></tr><tr><td>6.10</td><td>1000题高数第9讲BC</td><td>1.2015年数据结构真题</td><td>1.恋恋有词Unit5   Lesson3 <br>2.田静、长难句分析、标点与连接词 <br>3.背所学课程单词</td><td>唯物论</td><td><strong>数学未完成</strong></td></tr><tr><td>6.11</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td>休息一天</td><td><strong>休息一天</strong></td></tr><tr><td>6.12</td><td>剩余第9讲BC题</td><td>1.2014年数据结构真题</td><td>1.恋恋有词Unit5   Lesson4 <br>2.田静、长难句分析、分析主谓 <br>3.背所学课程单词</td><td>唯物论-物质观</td><td><strong>完成</strong></td></tr><tr><td>6.13</td><td>1000题高数第10讲BC</td><td>1.2013年数据结构真题      <br>2.计算机网络常青藤5、6章对照书复习</td><td>1.恋恋有词Unit5   Lesson5 <br>2.田静、长难句分析、简化长难句 <br>3.背恋恋有词Unit01单词表   <br>4.背所学课程单词</td><td>唯物论-意识观</td><td><strong>完成</strong></td></tr><tr><td>6.14</td><td>1000题高数第11、12讲BC</td><td>1.2012年数据结构真题      <br>2.重点对照常青藤和课本复习计算机网络第五章</td><td>1.恋恋有词Unit6   Lesson1 <br>2.田静、长难句分析、分裂结构 <br>3.背所学课程单词</td><td>辩证法两大特征</td><td><strong>完成</strong></td></tr><tr><td>6.15</td><td>1.1000题高数第13讲BC</td><td>1.2011年数据结构真题</td><td>1.恋恋有词Unit6   Lesson2 <br>2.田静、长难句分析、嵌套结构 <br>3.背所学课程单词</td><td>辩证法五对范畴1</td><td><strong>政治少看一课、恋恋有词未完成</strong></td></tr><tr><td>6.16</td><td>1.1000题高数剩余第13讲BC      <br>2.看第四章BC组讲解</td><td>1.2009年计学数据结构</td><td>1.恋恋有词Unit6   Lesson3 <br>2.田静、长难句分析、平行结构 <br>3.背所学课程单词</td><td>辩证法五对范畴2</td><td><strong>完成</strong></td></tr><tr><td>6.17</td><td>1.1000题高数第14讲BC      <br>2.看第五章BC组讲解</td><td>1.2008年计学数据结构      <br>2.2018计算机学硕两道代码      <br>3.对照常青藤复习计算机网络第七、八章</td><td>1.恋恋有词Unit6   Lesson4 <br>2.李旭、阅读基础、态度方向题 <br>3.背所学课程单词</td><td>对立统一</td><td></td></tr><tr><td>6.18</td><td>1.1000题高数第15讲BC</td><td>1.2018年软学数据结构</td><td>1.恋恋有词Unit7   Lesson1 <br>2.李旭、阅读基础、论点论据题 <br>3.背所学课程单词</td><td>质量互变定律</td><td></td></tr><tr><td>6.19</td><td>1.1000题高数第16讲BC</td><td>1.2017年软学数据结构</td><td>1.恋恋有词Unit7   Lesson2 <br>2.李旭、阅读基础、文章续写题 <br>3.背所学课程单词</td><td>否定之否定定律</td><td></td></tr><tr><td>6.20</td><td>1.1000题高数第17讲BC</td><td>1.2018年计专数据结构</td><td>1.恋恋有词Unit7   Lesson3 <br>2.李旭、阅读基础、总结点睛 <br>3.背所学课程单词</td><td>认识论</td><td></td></tr><tr><td>6.21</td><td>1.1000题线代第1、2讲BC</td><td>1.2017年计专数据结构</td><td>1.恋恋有词Unit7   Lesson4 <br>2.做真题2010.1并看李旭相应视频 <br>3.背所学课程单词</td><td>认识的本质</td><td></td></tr><tr><td>6.22</td><td>1000题线代第3讲BC</td><td>1.2016年计专数据结构</td><td>1.恋恋有词Unit7   Lesson5 <br>2.做真题2010.2并看李旭相应视频 <br>3.背所学课程单词</td><td>真理与价值</td><td></td></tr><tr><td>6.23</td><td>1000题线代第4讲BC</td><td>1.2015年计专数据结构</td><td>1.恋恋有词Unit8   Lesson1 <br>2.做真题2010.3并看李旭相应视频 <br>3.背所学课程单词</td><td>社会基本矛盾</td><td></td></tr><tr><td>6.24</td><td>1000题线代第5讲BC</td><td>1.2014年计专数据结构</td><td>1.恋恋有词Unit8   Lesson2 <br>2.做真题2010.4并看李旭相应视频 <br>3.背所学课程单词</td><td>社会形态</td><td></td></tr><tr><td>6.25</td><td>1000题线代第6讲BC</td><td>1.2013年计专数据结构</td><td>1.恋恋有词Unit8   Lesson3 <br>2.做真题2011.1并看李旭相应视频 <br>3.背所学课程单词</td><td>商品的两因素</td><td></td></tr><tr><td>6.26</td><td>1000题线代第7讲BC</td><td>1.2012年计专数据结构</td><td>1.恋恋有词Unit8   Lesson4 <br>2.做真题2011.2并看李旭相应视频 <br>3.背所学课程单词</td><td>价值规律</td><td></td></tr><tr><td>6.27</td><td>1000题线代第8讲BC</td><td>1.2011年计专数据结构</td><td>1.恋恋有词Unit9   Lesson1 <br>2.做真题2011.3并看李旭相应视频 <br>3.背所学课程单词</td><td>剩余价值生产</td><td></td></tr><tr><td>6.28</td><td>1000题线代第9讲BC</td><td>1.2018年软专数据结构</td><td>1.恋恋有词Unit9   Lesson2 <br>2.做真题2011.4并看李旭相应视频 <br>3.背所学课程单词</td><td>剩余价值流转</td><td></td></tr><tr><td>6.29</td><td>1000题概率第1讲BC</td><td>1.2017年软专数据结构</td><td>1.恋恋有词Unit9   Lesson3 <br>2.做真题2012.1并看李旭相应视频 <br>3.背所学课程单词</td><td>垄断资本主义</td><td></td></tr><tr><td>6.30</td><td>1000题概率第2讲BC</td><td>1.2016年软专数据结构</td><td>1.恋恋有词Unit9   Lesson4 <br>2.做真题2012.2并看李旭相应视频 <br>3.背所学课程单词</td><td>社会主义</td><td></td></tr><tr><td>6.31</td><td>1000题概率第3讲BC</td><td>2018-2007软专</td><td>1.恋恋有词Unit10   Lesson1 <br>2.做真题2012.3并看李旭相应视频 <br>3.背所学课程单词</td><td>人生的青春</td><td></td></tr><tr><td>7.1</td><td>1000题概率第4讲BC</td><td></td><td></td><td>人生理想</td><td></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 男男 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吉林大学2019年招生目录</title>
      <link href="/posts/2e9c.html/"/>
      <url>/posts/2e9c.html/</url>
      
        <content type="html"><![CDATA[<h2 id="吉林大学2019年全日制硕士研究生招生专业目录"><a href="#吉林大学2019年全日制硕士研究生招生专业目录" class="headerlink" title="- 吉林大学2019年全日制硕士研究生招生专业目录 -"></a>- 吉林大学2019年全日制硕士研究生招生专业目录 -</h2><h3 id="哲学社会学院"><a href="#哲学社会学院" class="headerlink" title="- 哲学社会学院 -"></a>- 哲学社会学院 -</h3><hr><h4 id="学硕"><a href="#学硕" class="headerlink" title="学硕"></a>学硕</h4><p><img src="%E5%AD%A6%E7%A1%95.png"></p><h4 id="专硕"><a href="#专硕" class="headerlink" title="专硕"></a>专硕</h4><p><img src="%E4%B8%93%E7%A1%95.png"></p><hr><h3 id="计算机科学与技术学院"><a href="#计算机科学与技术学院" class="headerlink" title="- 计算机科学与技术学院 -"></a>- 计算机科学与技术学院 -</h3><hr><h4 id="学硕-1"><a href="#学硕-1" class="headerlink" title="学硕"></a>学硕</h4><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A1%951.png"><br><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A1%952.png"></p><h4 id="专硕-1"><a href="#专硕-1" class="headerlink" title="专硕"></a>专硕</h4><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E7%A1%95.png"></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 吉林大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 心理学 </tag>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次测试</title>
      <link href="/posts/e047.html/"/>
      <url>/posts/e047.html/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="-搭建hexo博客-"></a>-搭建hexo博客-</h2><h2 id="初记录-smile"><a href="#初记录-smile" class="headerlink" title="初记录 :smile:"></a>初记录 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></h2><h3 id="捯饬了两天，终于把网站搭建好了，"><a href="#捯饬了两天，终于把网站搭建好了，" class="headerlink" title="捯饬了两天，终于把网站搭建好了，"></a>捯饬了两天，终于把网站搭建好了，</h3><p>使用matery主题<br>制作<br>本项目由<a href="https://www.lgn2018.com/" target="_blank" rel="noopener">冷的小站</a>支持,更多详细使用方法请在博客上查看<br><br><strong>本项目开源免费归档前长期维护，请勿用于任何商业用途，否则后果自负！<br></strong></p><h2 id="技术支持-Support"><a href="#技术支持-Support" class="headerlink" title="-技术支持 Support-"></a>-技术支持 Support-</h2><p>在使用过程中有任何问题可以<strong>提交Issue</strong>（邮件不再回复） ，但是<strong>在此之前</strong> ，请仔细阅读下方<strong>使用步骤</strong> ！<br></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="-使用步骤-"></a>-使用步骤-</h2><ul><li>登录前需要想好自己要选择哪一个座位</li><li>具体使用步骤请登录 <a href="https://www.lgn2018.com/" target="_blank" rel="noopener">https://www.lgn2018.com</a> 查看 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>  <br></li></ul><p>中心主题<br>    分支主题 1<br>    分支主题 2<br>    分支主题 3</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> first </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
